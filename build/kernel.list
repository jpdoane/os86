
build/kernel:     file format elf32-i386


Disassembly of section .text.boot:

00100000 <_start-0xc>:
  100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fb                   	sti    
  100009:	4f                   	dec    %edi
  10000a:	52                   	push   %edx
  10000b:	e4                   	.byte 0xe4

0010000c <_start>:
  10000c:	fa                   	cli    
  10000d:	3d 02 b0 ad 2b       	cmp    $0x2badb002,%eax
  100012:	0f 85 e4 00 00 00    	jne    1000fc <kpanic>
  100018:	8d 25 00 00 11 00    	lea    0x110000,%esp
  10001e:	53                   	push   %ebx
  10001f:	8d 3d 00 00 11 00    	lea    0x110000,%edi
  100025:	b8 83 00 00 00       	mov    $0x83,%eax
  10002a:	89 07                	mov    %eax,(%edi)
  10002c:	0f 20 e0             	mov    %cr4,%eax
  10002f:	83 c8 10             	or     $0x10,%eax
  100032:	0f 22 e0             	mov    %eax,%cr4

00100035 <.init_pagedir>:
  100035:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  10003b:	c1 e8 16             	shr    $0x16,%eax
  10003e:	bb 04 00 00 00       	mov    $0x4,%ebx
  100043:	f7 e3                	mul    %ebx
  100045:	8d 3d 00 00 11 00    	lea    0x110000,%edi
  10004b:	01 c7                	add    %eax,%edi
  10004d:	8d 05 00 10 11 00    	lea    0x111000,%eax
  100053:	83 c8 03             	or     $0x3,%eax
  100056:	b9 ff 00 00 00       	mov    $0xff,%ecx
  10005b:	fc                   	cld    

0010005c <.nextpde>:
  10005c:	ab                   	stos   %eax,%es:(%edi)
  10005d:	05 00 10 00 00       	add    $0x1000,%eax
  100062:	e2 f8                	loop   10005c <.nextpde>
  100064:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  10006a:	c1 e8 16             	shr    $0x16,%eax
  10006d:	bb 04 00 00 00       	mov    $0x4,%ebx
  100072:	f7 e3                	mul    %ebx
  100074:	8d 3d 00 00 11 00    	lea    0x110000,%edi
  10007a:	01 c7                	add    %eax,%edi
  10007c:	8d 1d 00 00 00 c0    	lea    0xc0000000,%ebx
  100082:	c1 eb 0c             	shr    $0xc,%ebx
  100085:	8d 0d 00 f0 10 c0    	lea    0xc010f000,%ecx
  10008b:	81 c1 ff 0f 00 00    	add    $0xfff,%ecx
  100091:	c1 e9 0c             	shr    $0xc,%ecx
  100094:	29 d9                	sub    %ebx,%ecx
  100096:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  10009c:	25 00 f0 3f 00       	and    $0x3ff000,%eax
  1000a1:	c1 e8 0c             	shr    $0xc,%eax
  1000a4:	bb 04 00 00 00       	mov    $0x4,%ebx
  1000a9:	f7 e3                	mul    %ebx
  1000ab:	8d 3d 00 10 11 00    	lea    0x111000,%edi
  1000b1:	01 c7                	add    %eax,%edi
  1000b3:	8d 05 00 10 10 00    	lea    0x101000,%eax
  1000b9:	83 c8 03             	or     $0x3,%eax

001000bc <.nextpte>:
  1000bc:	ab                   	stos   %eax,%es:(%edi)
  1000bd:	05 00 10 00 00       	add    $0x1000,%eax
  1000c2:	e2 f8                	loop   1000bc <.nextpte>
  1000c4:	8d 35 00 00 11 00    	lea    0x110000,%esi
  1000ca:	89 f7                	mov    %esi,%edi
  1000cc:	81 c7 fc 0f 00 00    	add    $0xffc,%edi
  1000d2:	83 ce 03             	or     $0x3,%esi
  1000d5:	89 37                	mov    %esi,(%edi)

001000d7 <_enable_paging>:
  1000d7:	5b                   	pop    %ebx
  1000d8:	8d 05 00 00 11 00    	lea    0x110000,%eax
  1000de:	0f 22 d8             	mov    %eax,%cr3
  1000e1:	0f 20 c0             	mov    %cr0,%eax
  1000e4:	0d 00 00 01 80       	or     $0x80010000,%eax
  1000e9:	0f 22 c0             	mov    %eax,%cr0
  1000ec:	8d 25 00 f0 00 c0    	lea    0xc000f000,%esp
  1000f2:	50                   	push   %eax
  1000f3:	50                   	push   %eax
  1000f4:	50                   	push   %eax
  1000f5:	53                   	push   %ebx
  1000f6:	e8 e3 35 f0 bf       	call   c00036de <kernel_main>
  1000fb:	fa                   	cli    

001000fc <kpanic>:
  1000fc:	f4                   	hlt    
  1000fd:	eb fd                	jmp    1000fc <kpanic>

001000ff <map_page_table>:
  1000ff:	25 00 f0 3f 00       	and    $0x3ff000,%eax
  100104:	c1 e8 0c             	shr    $0xc,%eax
  100107:	bb 04 00 00 00       	mov    $0x4,%ebx
  10010c:	f7 e3                	mul    %ebx
  10010e:	8d 3d 00 10 11 00    	lea    0x111000,%edi
  100114:	01 c7                	add    %eax,%edi
  100116:	83 c8 03             	or     $0x3,%eax

00100119 <.nextentry>:
  100119:	ab                   	stos   %eax,%es:(%edi)
  10011a:	05 00 10 00 00       	add    $0x1000,%eax
  10011f:	e2 f8                	loop   100119 <.nextentry>

Disassembly of section .text:

c0000000 <align_int>:
{
  __asm__ ("xchg %bx, %bx");
}

static inline size_t align_int(size_t len, size_t alignment)
{
c0000000:	55                   	push   %ebp
c0000001:	89 e5                	mov    %esp,%ebp
c0000003:	83 ec 10             	sub    $0x10,%esp
    size_t am = alignment - 1;
c0000006:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000009:	83 e8 01             	sub    $0x1,%eax
c000000c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (((size_t)len + am) & ~am);
c000000f:	8b 55 08             	mov    0x8(%ebp),%edx
c0000012:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0000015:	01 c2                	add    %eax,%edx
c0000017:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000001a:	f7 d0                	not    %eax
c000001c:	21 d0                	and    %edx,%eax
}
c000001e:	c9                   	leave  
c000001f:	c3                   	ret    

c0000020 <test_allocation>:


//allocate memory, return ptr
//check heap usage before and after for consistenty with expected allocation
int test_allocation(size_t sz, void** ptr)
{
c0000020:	55                   	push   %ebp
c0000021:	89 e5                	mov    %esp,%ebp
c0000023:	83 ec 28             	sub    $0x28,%esp
    size_t sz_used;
    size_t sz_free;
    // get initial size of heap
    if(kheap_size(&sz_used, &sz_free)) return -1;
c0000026:	83 ec 08             	sub    $0x8,%esp
c0000029:	8d 45 ec             	lea    -0x14(%ebp),%eax
c000002c:	50                   	push   %eax
c000002d:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0000030:	50                   	push   %eax
c0000031:	e8 60 35 00 00       	call   c0003596 <kheap_size>
c0000036:	83 c4 10             	add    $0x10,%esp
c0000039:	85 c0                	test   %eax,%eax
c000003b:	74 0a                	je     c0000047 <test_allocation+0x27>
c000003d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000042:	e9 b5 00 00 00       	jmp    c00000fc <test_allocation+0xdc>

    // allocate memory
    *ptr = kmalloc(sz);
c0000047:	83 ec 0c             	sub    $0xc,%esp
c000004a:	ff 75 08             	pushl  0x8(%ebp)
c000004d:	e8 c9 32 00 00       	call   c000331b <kmalloc>
c0000052:	83 c4 10             	add    $0x10,%esp
c0000055:	8b 55 0c             	mov    0xc(%ebp),%edx
c0000058:	89 02                	mov    %eax,(%edx)
    if(! *ptr) return -1;
c000005a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000005d:	8b 00                	mov    (%eax),%eax
c000005f:	85 c0                	test   %eax,%eax
c0000061:	75 0a                	jne    c000006d <test_allocation+0x4d>
c0000063:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000068:	e9 8f 00 00 00       	jmp    c00000fc <test_allocation+0xdc>

    // check heap size
    size_t sz_used_new;
    size_t sz_free_new;
    if(kheap_size(&sz_used_new, &sz_free_new)) return -1;
c000006d:	83 ec 08             	sub    $0x8,%esp
c0000070:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0000073:	50                   	push   %eax
c0000074:	8d 45 e8             	lea    -0x18(%ebp),%eax
c0000077:	50                   	push   %eax
c0000078:	e8 19 35 00 00       	call   c0003596 <kheap_size>
c000007d:	83 c4 10             	add    $0x10,%esp
c0000080:	85 c0                	test   %eax,%eax
c0000082:	74 07                	je     c000008b <test_allocation+0x6b>
c0000084:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000089:	eb 71                	jmp    c00000fc <test_allocation+0xdc>
    // memory is allocated in increments of HEAP_BLOCKSIZE_UNITS, with extra HEAP_BLOCKSIZE_UNITS for header
    size_t sz_alloc = HEAP_BLOCKSIZE_UNITS + align_int(sz, HEAP_BLOCKSIZE_UNITS);
c000008b:	83 ec 08             	sub    $0x8,%esp
c000008e:	6a 10                	push   $0x10
c0000090:	ff 75 08             	pushl  0x8(%ebp)
c0000093:	e8 68 ff ff ff       	call   c0000000 <align_int>
c0000098:	83 c4 10             	add    $0x10,%esp
c000009b:	83 c0 10             	add    $0x10,%eax
c000009e:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // allocated memory should have increased by sz_alloc
    if(sz_used_new != sz_used + sz_alloc)
c00000a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00000a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00000a7:	01 c2                	add    %eax,%edx
c00000a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00000ac:	39 c2                	cmp    %eax,%edx
c00000ae:	74 07                	je     c00000b7 <test_allocation+0x97>
        return -1;
c00000b0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00000b5:	eb 45                	jmp    c00000fc <test_allocation+0xdc>

    // total heap size (used + free) should not have decreased
    if(sz_used_new + sz_free_new < sz_used + sz_free)
c00000b7:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00000ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00000bd:	01 c2                	add    %eax,%edx
c00000bf:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c00000c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00000c5:	01 c8                	add    %ecx,%eax
c00000c7:	39 c2                	cmp    %eax,%edx
c00000c9:	73 07                	jae    c00000d2 <test_allocation+0xb2>
        return -1;
c00000cb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00000d0:	eb 2a                	jmp    c00000fc <test_allocation+0xdc>

    // if heap size (used + free) has changed, it must have increased in units of HEAP_INCREMENT 
    if( ( (sz_used_new + sz_free_new) - (sz_used + sz_free) ) % HEAP_INCREMENT != 0)
c00000d2:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00000d5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00000d8:	01 d0                	add    %edx,%eax
c00000da:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c00000dd:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00000e0:	01 ca                	add    %ecx,%edx
c00000e2:	29 d0                	sub    %edx,%eax
c00000e4:	25 ff 0f 00 00       	and    $0xfff,%eax
c00000e9:	c1 e0 02             	shl    $0x2,%eax
c00000ec:	85 c0                	test   %eax,%eax
c00000ee:	74 07                	je     c00000f7 <test_allocation+0xd7>
        return -1;
c00000f0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00000f5:	eb 05                	jmp    c00000fc <test_allocation+0xdc>

    return 0;
c00000f7:	b8 00 00 00 00       	mov    $0x0,%eax

}
c00000fc:	c9                   	leave  
c00000fd:	c3                   	ret    

c00000fe <test_free>:

// free memory and check heap for consistenty with expected free
int test_free(size_t sz, void* ptr)
{
c00000fe:	55                   	push   %ebp
c00000ff:	89 e5                	mov    %esp,%ebp
c0000101:	83 ec 28             	sub    $0x28,%esp
    size_t sz_used;
    size_t sz_free;
    // get initial size of heap
    if(kheap_size(&sz_used, &sz_free)) return -1;
c0000104:	83 ec 08             	sub    $0x8,%esp
c0000107:	8d 45 ec             	lea    -0x14(%ebp),%eax
c000010a:	50                   	push   %eax
c000010b:	8d 45 f0             	lea    -0x10(%ebp),%eax
c000010e:	50                   	push   %eax
c000010f:	e8 82 34 00 00       	call   c0003596 <kheap_size>
c0000114:	83 c4 10             	add    $0x10,%esp
c0000117:	85 c0                	test   %eax,%eax
c0000119:	74 07                	je     c0000122 <test_free+0x24>
c000011b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000120:	eb 7e                	jmp    c00001a0 <test_free+0xa2>

    // test free and make sure we have recovered all the memory
    if( kfree(ptr) ) return -1;
c0000122:	83 ec 0c             	sub    $0xc,%esp
c0000125:	ff 75 0c             	pushl  0xc(%ebp)
c0000128:	e8 14 34 00 00       	call   c0003541 <kfree>
c000012d:	83 c4 10             	add    $0x10,%esp
c0000130:	85 c0                	test   %eax,%eax
c0000132:	74 07                	je     c000013b <test_free+0x3d>
c0000134:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000139:	eb 65                	jmp    c00001a0 <test_free+0xa2>
    // memory is allocated in increments of HEAP_BLOCKSIZE_UNITS, with extra HEAP_BLOCKSIZE_UNITS for header
    size_t sz_alloc = HEAP_BLOCKSIZE_UNITS + align_int(sz, HEAP_BLOCKSIZE_UNITS);
c000013b:	83 ec 08             	sub    $0x8,%esp
c000013e:	6a 10                	push   $0x10
c0000140:	ff 75 08             	pushl  0x8(%ebp)
c0000143:	e8 b8 fe ff ff       	call   c0000000 <align_int>
c0000148:	83 c4 10             	add    $0x10,%esp
c000014b:	83 c0 10             	add    $0x10,%eax
c000014e:	89 45 f4             	mov    %eax,-0xc(%ebp)

    size_t sz_used_new;
    size_t sz_free_new;
    if(kheap_size(&sz_used_new, &sz_free_new)) return -1;
c0000151:	83 ec 08             	sub    $0x8,%esp
c0000154:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0000157:	50                   	push   %eax
c0000158:	8d 45 e8             	lea    -0x18(%ebp),%eax
c000015b:	50                   	push   %eax
c000015c:	e8 35 34 00 00       	call   c0003596 <kheap_size>
c0000161:	83 c4 10             	add    $0x10,%esp
c0000164:	85 c0                	test   %eax,%eax
c0000166:	74 07                	je     c000016f <test_free+0x71>
c0000168:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000016d:	eb 31                	jmp    c00001a0 <test_free+0xa2>

    if(sz_used_new != sz_used - sz_alloc)
c000016f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0000172:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0000175:	89 c2                	mov    %eax,%edx
c0000177:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000017a:	39 c2                	cmp    %eax,%edx
c000017c:	74 07                	je     c0000185 <test_free+0x87>
        return -1;
c000017e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000183:	eb 1b                	jmp    c00001a0 <test_free+0xa2>
    if(sz_free_new != sz_free + sz_alloc)
c0000185:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0000188:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000018b:	01 c2                	add    %eax,%edx
c000018d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0000190:	39 c2                	cmp    %eax,%edx
c0000192:	74 07                	je     c000019b <test_free+0x9d>
        return -1;
c0000194:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000199:	eb 05                	jmp    c00001a0 <test_free+0xa2>

    return 0;
c000019b:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00001a0:	c9                   	leave  
c00001a1:	c3                   	ret    

c00001a2 <test_kmalloc>:

int test_kmalloc()
{
c00001a2:	55                   	push   %ebp
c00001a3:	89 e5                	mov    %esp,%ebp
c00001a5:	83 ec 38             	sub    $0x38,%esp
    if(kmalloc_init()) return -1;
c00001a8:	e8 7b 2d 00 00       	call   c0002f28 <kmalloc_init>
c00001ad:	85 c0                	test   %eax,%eax
c00001af:	74 0a                	je     c00001bb <test_kmalloc+0x19>
c00001b1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00001b6:	e9 78 02 00 00       	jmp    c0000433 <test_kmalloc+0x291>

    //allocate uint32_t
    uint32_t* a;
    if(test_allocation(sizeof(uint32_t), (void**) &a)) return -1;
c00001bb:	83 ec 08             	sub    $0x8,%esp
c00001be:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c00001c1:	50                   	push   %eax
c00001c2:	6a 04                	push   $0x4
c00001c4:	e8 57 fe ff ff       	call   c0000020 <test_allocation>
c00001c9:	83 c4 10             	add    $0x10,%esp
c00001cc:	85 c0                	test   %eax,%eax
c00001ce:	74 0a                	je     c00001da <test_kmalloc+0x38>
c00001d0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00001d5:	e9 59 02 00 00       	jmp    c0000433 <test_kmalloc+0x291>

    // test assignment and read
    *a = 5;
c00001da:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00001dd:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    if(*a != 5) return -1;
c00001e3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00001e6:	8b 00                	mov    (%eax),%eax
c00001e8:	83 f8 05             	cmp    $0x5,%eax
c00001eb:	74 0a                	je     c00001f7 <test_kmalloc+0x55>
c00001ed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00001f2:	e9 3c 02 00 00       	jmp    c0000433 <test_kmalloc+0x291>

    if(test_free(sizeof(uint32_t), a)) return -1;
c00001f7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00001fa:	83 ec 08             	sub    $0x8,%esp
c00001fd:	50                   	push   %eax
c00001fe:	6a 04                	push   $0x4
c0000200:	e8 f9 fe ff ff       	call   c00000fe <test_free>
c0000205:	83 c4 10             	add    $0x10,%esp
c0000208:	85 c0                	test   %eax,%eax
c000020a:	74 0a                	je     c0000216 <test_kmalloc+0x74>
c000020c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000211:	e9 1d 02 00 00       	jmp    c0000433 <test_kmalloc+0x291>

    // try to free again, make sure this FAILS
    if( !kfree(a) ) return -1;
c0000216:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0000219:	83 ec 0c             	sub    $0xc,%esp
c000021c:	50                   	push   %eax
c000021d:	e8 1f 33 00 00       	call   c0003541 <kfree>
c0000222:	83 c4 10             	add    $0x10,%esp
c0000225:	85 c0                	test   %eax,%eax
c0000227:	75 0a                	jne    c0000233 <test_kmalloc+0x91>
c0000229:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000022e:	e9 00 02 00 00       	jmp    c0000433 <test_kmalloc+0x291>


    //allocate some larger arrays
    uint32_t *b, *c, *d;
    size_t NB = 1000;
c0000233:	c7 45 e4 e8 03 00 00 	movl   $0x3e8,-0x1c(%ebp)
    size_t NC = 16000;
c000023a:	c7 45 e0 80 3e 00 00 	movl   $0x3e80,-0x20(%ebp)
    size_t ND = 1000;
c0000241:	c7 45 dc e8 03 00 00 	movl   $0x3e8,-0x24(%ebp)
        
    if(test_allocation(sizeof(uint32_t)*NB, (void**)&b)) return -1;
c0000248:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000024b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0000252:	83 ec 08             	sub    $0x8,%esp
c0000255:	8d 45 d0             	lea    -0x30(%ebp),%eax
c0000258:	50                   	push   %eax
c0000259:	52                   	push   %edx
c000025a:	e8 c1 fd ff ff       	call   c0000020 <test_allocation>
c000025f:	83 c4 10             	add    $0x10,%esp
c0000262:	85 c0                	test   %eax,%eax
c0000264:	74 0a                	je     c0000270 <test_kmalloc+0xce>
c0000266:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000026b:	e9 c3 01 00 00       	jmp    c0000433 <test_kmalloc+0x291>
    if(test_allocation(sizeof(uint32_t)*NC, (void**)&c)) return -1;
c0000270:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0000273:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000027a:	83 ec 08             	sub    $0x8,%esp
c000027d:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0000280:	50                   	push   %eax
c0000281:	52                   	push   %edx
c0000282:	e8 99 fd ff ff       	call   c0000020 <test_allocation>
c0000287:	83 c4 10             	add    $0x10,%esp
c000028a:	85 c0                	test   %eax,%eax
c000028c:	74 0a                	je     c0000298 <test_kmalloc+0xf6>
c000028e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000293:	e9 9b 01 00 00       	jmp    c0000433 <test_kmalloc+0x291>
    if(test_allocation(sizeof(uint32_t)*ND, (void**)&d)) return -1;
c0000298:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000029b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c00002a2:	83 ec 08             	sub    $0x8,%esp
c00002a5:	8d 45 c8             	lea    -0x38(%ebp),%eax
c00002a8:	50                   	push   %eax
c00002a9:	52                   	push   %edx
c00002aa:	e8 71 fd ff ff       	call   c0000020 <test_allocation>
c00002af:	83 c4 10             	add    $0x10,%esp
c00002b2:	85 c0                	test   %eax,%eax
c00002b4:	74 0a                	je     c00002c0 <test_kmalloc+0x11e>
c00002b6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00002bb:	e9 73 01 00 00       	jmp    c0000433 <test_kmalloc+0x291>

    //test read and write
    for(size_t nn=0; nn<NB; nn++)
c00002c0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00002c7:	eb 14                	jmp    c00002dd <test_kmalloc+0x13b>
        b[nn] = (uint32_t) nn;
c00002c9:	8b 55 d0             	mov    -0x30(%ebp),%edx
c00002cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00002cf:	c1 e0 02             	shl    $0x2,%eax
c00002d2:	01 c2                	add    %eax,%edx
c00002d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00002d7:	89 02                	mov    %eax,(%edx)
    for(size_t nn=0; nn<NB; nn++)
c00002d9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00002dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00002e0:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c00002e3:	72 e4                	jb     c00002c9 <test_kmalloc+0x127>
    for(size_t nn=0; nn<ND; nn++)
c00002e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00002ec:	eb 14                	jmp    c0000302 <test_kmalloc+0x160>
        d[nn] = (uint32_t) nn;
c00002ee:	8b 55 c8             	mov    -0x38(%ebp),%edx
c00002f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00002f4:	c1 e0 02             	shl    $0x2,%eax
c00002f7:	01 c2                	add    %eax,%edx
c00002f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00002fc:	89 02                	mov    %eax,(%edx)
    for(size_t nn=0; nn<ND; nn++)
c00002fe:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0000302:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0000305:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c0000308:	72 e4                	jb     c00002ee <test_kmalloc+0x14c>
    for(size_t nn=0; nn<NB; nn++)
c000030a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0000311:	eb 20                	jmp    c0000333 <test_kmalloc+0x191>
        if(b[nn] != (uint32_t) nn) return -1;
c0000313:	8b 55 d0             	mov    -0x30(%ebp),%edx
c0000316:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0000319:	c1 e0 02             	shl    $0x2,%eax
c000031c:	01 d0                	add    %edx,%eax
c000031e:	8b 00                	mov    (%eax),%eax
c0000320:	39 45 ec             	cmp    %eax,-0x14(%ebp)
c0000323:	74 0a                	je     c000032f <test_kmalloc+0x18d>
c0000325:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000032a:	e9 04 01 00 00       	jmp    c0000433 <test_kmalloc+0x291>
    for(size_t nn=0; nn<NB; nn++)
c000032f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0000333:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0000336:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0000339:	72 d8                	jb     c0000313 <test_kmalloc+0x171>
    for(size_t nn=0; nn<ND; nn++)
c000033b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c0000342:	eb 20                	jmp    c0000364 <test_kmalloc+0x1c2>
        if(d[nn] != (uint32_t) nn) return -1;
c0000344:	8b 55 c8             	mov    -0x38(%ebp),%edx
c0000347:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000034a:	c1 e0 02             	shl    $0x2,%eax
c000034d:	01 d0                	add    %edx,%eax
c000034f:	8b 00                	mov    (%eax),%eax
c0000351:	39 45 e8             	cmp    %eax,-0x18(%ebp)
c0000354:	74 0a                	je     c0000360 <test_kmalloc+0x1be>
c0000356:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000035b:	e9 d3 00 00 00       	jmp    c0000433 <test_kmalloc+0x291>
    for(size_t nn=0; nn<ND; nn++)
c0000360:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c0000364:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000367:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c000036a:	72 d8                	jb     c0000344 <test_kmalloc+0x1a2>


    // test aligned allocation
    uint32_t* e = kmalloc_aligned(sizeof(uint32_t), 4096); // align to page
c000036c:	83 ec 08             	sub    $0x8,%esp
c000036f:	68 00 10 00 00       	push   $0x1000
c0000374:	6a 04                	push   $0x4
c0000376:	e8 6d 30 00 00       	call   c00033e8 <kmalloc_aligned>
c000037b:	83 c4 10             	add    $0x10,%esp
c000037e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if(!e) return -1;
c0000381:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c0000385:	75 0a                	jne    c0000391 <test_kmalloc+0x1ef>
c0000387:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000038c:	e9 a2 00 00 00       	jmp    c0000433 <test_kmalloc+0x291>
    if( (size_t) e % 4096 ) return -1;
c0000391:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0000394:	25 ff 0f 00 00       	and    $0xfff,%eax
c0000399:	85 c0                	test   %eax,%eax
c000039b:	74 0a                	je     c00003a7 <test_kmalloc+0x205>
c000039d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00003a2:	e9 8c 00 00 00       	jmp    c0000433 <test_kmalloc+0x291>
    if((*e = 128) != 128) return -1;
c00003a7:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00003aa:	c7 00 80 00 00 00    	movl   $0x80,(%eax)

    if(test_free(sizeof(uint32_t)*NB, b)) return -1;
c00003b0:	8b 45 d0             	mov    -0x30(%ebp),%eax
c00003b3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00003b6:	c1 e2 02             	shl    $0x2,%edx
c00003b9:	83 ec 08             	sub    $0x8,%esp
c00003bc:	50                   	push   %eax
c00003bd:	52                   	push   %edx
c00003be:	e8 3b fd ff ff       	call   c00000fe <test_free>
c00003c3:	83 c4 10             	add    $0x10,%esp
c00003c6:	85 c0                	test   %eax,%eax
c00003c8:	74 07                	je     c00003d1 <test_kmalloc+0x22f>
c00003ca:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00003cf:	eb 62                	jmp    c0000433 <test_kmalloc+0x291>
    if(test_free(sizeof(uint32_t)*NC, c)) return -1;
c00003d1:	8b 45 cc             	mov    -0x34(%ebp),%eax
c00003d4:	8b 55 e0             	mov    -0x20(%ebp),%edx
c00003d7:	c1 e2 02             	shl    $0x2,%edx
c00003da:	83 ec 08             	sub    $0x8,%esp
c00003dd:	50                   	push   %eax
c00003de:	52                   	push   %edx
c00003df:	e8 1a fd ff ff       	call   c00000fe <test_free>
c00003e4:	83 c4 10             	add    $0x10,%esp
c00003e7:	85 c0                	test   %eax,%eax
c00003e9:	74 07                	je     c00003f2 <test_kmalloc+0x250>
c00003eb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00003f0:	eb 41                	jmp    c0000433 <test_kmalloc+0x291>
    if(test_free(sizeof(uint32_t)*ND, d)) return -1;
c00003f2:	8b 45 c8             	mov    -0x38(%ebp),%eax
c00003f5:	8b 55 dc             	mov    -0x24(%ebp),%edx
c00003f8:	c1 e2 02             	shl    $0x2,%edx
c00003fb:	83 ec 08             	sub    $0x8,%esp
c00003fe:	50                   	push   %eax
c00003ff:	52                   	push   %edx
c0000400:	e8 f9 fc ff ff       	call   c00000fe <test_free>
c0000405:	83 c4 10             	add    $0x10,%esp
c0000408:	85 c0                	test   %eax,%eax
c000040a:	74 07                	je     c0000413 <test_kmalloc+0x271>
c000040c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000411:	eb 20                	jmp    c0000433 <test_kmalloc+0x291>
    if(test_free(sizeof(uint32_t), e)) return -1;
c0000413:	83 ec 08             	sub    $0x8,%esp
c0000416:	ff 75 d8             	pushl  -0x28(%ebp)
c0000419:	6a 04                	push   $0x4
c000041b:	e8 de fc ff ff       	call   c00000fe <test_free>
c0000420:	83 c4 10             	add    $0x10,%esp
c0000423:	85 c0                	test   %eax,%eax
c0000425:	74 07                	je     c000042e <test_kmalloc+0x28c>
c0000427:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000042c:	eb 05                	jmp    c0000433 <test_kmalloc+0x291>

    return 0;
c000042e:	b8 00 00 00 00       	mov    $0x0,%eax
c0000433:	c9                   	leave  
c0000434:	c3                   	ret    

c0000435 <syscall>:
#include "terminal.h"
#include "kprintf.h"

void syscall()
{
c0000435:	55                   	push   %ebp
c0000436:	89 e5                	mov    %esp,%ebp
}
c0000438:	90                   	nop
c0000439:	5d                   	pop    %ebp
c000043a:	c3                   	ret    

c000043b <vga_entry_color>:
	VGA_COLOR_LIGHT_BROWN = 14,
	VGA_COLOR_WHITE = 15,
};
 
static inline uint8_t vga_entry_color(enum vga_color fg, enum vga_color bg) 
{
c000043b:	55                   	push   %ebp
c000043c:	89 e5                	mov    %esp,%ebp
	return fg | bg << 4;
c000043e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000441:	c1 e0 04             	shl    $0x4,%eax
c0000444:	89 c2                	mov    %eax,%edx
c0000446:	8b 45 08             	mov    0x8(%ebp),%eax
c0000449:	09 d0                	or     %edx,%eax
}
c000044b:	5d                   	pop    %ebp
c000044c:	c3                   	ret    

c000044d <vga_entry>:
 
static inline uint16_t vga_entry(unsigned char uc, uint8_t color) 
{
c000044d:	55                   	push   %ebp
c000044e:	89 e5                	mov    %esp,%ebp
c0000450:	83 ec 08             	sub    $0x8,%esp
c0000453:	8b 55 08             	mov    0x8(%ebp),%edx
c0000456:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000459:	88 55 fc             	mov    %dl,-0x4(%ebp)
c000045c:	88 45 f8             	mov    %al,-0x8(%ebp)
	return (uint16_t) uc | (uint16_t) color << 8;
c000045f:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c0000463:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0000467:	c1 e0 08             	shl    $0x8,%eax
c000046a:	09 d0                	or     %edx,%eax
}
c000046c:	c9                   	leave  
c000046d:	c3                   	ret    

c000046e <outb>:
  return _v;
}

static inline void
outb (unsigned char __value, unsigned short int __port)
{
c000046e:	55                   	push   %ebp
c000046f:	89 e5                	mov    %esp,%ebp
c0000471:	83 ec 08             	sub    $0x8,%esp
c0000474:	8b 55 08             	mov    0x8(%ebp),%edx
c0000477:	8b 45 0c             	mov    0xc(%ebp),%eax
c000047a:	88 55 fc             	mov    %dl,-0x4(%ebp)
c000047d:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
c0000481:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0000485:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
c0000489:	ee                   	out    %al,(%dx)
}
c000048a:	90                   	nop
c000048b:	c9                   	leave  
c000048c:	c3                   	ret    

c000048d <terminal_init>:
#include "io.h"

struct terminal stdout;

void terminal_init(struct terminal* term) 
{
c000048d:	55                   	push   %ebp
c000048e:	89 e5                	mov    %esp,%ebp
c0000490:	53                   	push   %ebx
c0000491:	83 ec 10             	sub    $0x10,%esp
	term->row = 0;
c0000494:	8b 45 08             	mov    0x8(%ebp),%eax
c0000497:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	term->column = 0;
c000049d:	8b 45 08             	mov    0x8(%ebp),%eax
c00004a0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	term->color = vga_entry_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
c00004a7:	6a 00                	push   $0x0
c00004a9:	6a 07                	push   $0x7
c00004ab:	e8 8b ff ff ff       	call   c000043b <vga_entry_color>
c00004b0:	83 c4 08             	add    $0x8,%esp
c00004b3:	8b 55 08             	mov    0x8(%ebp),%edx
c00004b6:	88 42 08             	mov    %al,0x8(%edx)
	term->buffer = (uint16_t*) VGA_BUFFER;
c00004b9:	8b 45 08             	mov    0x8(%ebp),%eax
c00004bc:	c7 40 0c 00 00 b1 ff 	movl   $0xffb10000,0xc(%eax)
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
c00004c3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c00004ca:	eb 54                	jmp    c0000520 <terminal_init+0x93>
		for (size_t x = 0; x < VGA_WIDTH; x++) {
c00004cc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00004d3:	eb 41                	jmp    c0000516 <terminal_init+0x89>
			const size_t index = y * VGA_WIDTH + x;
c00004d5:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00004d8:	89 d0                	mov    %edx,%eax
c00004da:	c1 e0 02             	shl    $0x2,%eax
c00004dd:	01 d0                	add    %edx,%eax
c00004df:	c1 e0 04             	shl    $0x4,%eax
c00004e2:	89 c2                	mov    %eax,%edx
c00004e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00004e7:	01 d0                	add    %edx,%eax
c00004e9:	89 45 f0             	mov    %eax,-0x10(%ebp)
			term->buffer[index] = vga_entry(' ', term->color);
c00004ec:	8b 45 08             	mov    0x8(%ebp),%eax
c00004ef:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c00004f3:	0f b6 c0             	movzbl %al,%eax
c00004f6:	8b 55 08             	mov    0x8(%ebp),%edx
c00004f9:	8b 4a 0c             	mov    0xc(%edx),%ecx
c00004fc:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00004ff:	01 d2                	add    %edx,%edx
c0000501:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
c0000504:	50                   	push   %eax
c0000505:	6a 20                	push   $0x20
c0000507:	e8 41 ff ff ff       	call   c000044d <vga_entry>
c000050c:	83 c4 08             	add    $0x8,%esp
c000050f:	66 89 03             	mov    %ax,(%ebx)
		for (size_t x = 0; x < VGA_WIDTH; x++) {
c0000512:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0000516:	83 7d f4 4f          	cmpl   $0x4f,-0xc(%ebp)
c000051a:	76 b9                	jbe    c00004d5 <terminal_init+0x48>
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
c000051c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0000520:	83 7d f8 18          	cmpl   $0x18,-0x8(%ebp)
c0000524:	76 a6                	jbe    c00004cc <terminal_init+0x3f>
		}
	}

	//disable cursor
	outb(0x0A, 0x3D4);
c0000526:	68 d4 03 00 00       	push   $0x3d4
c000052b:	6a 0a                	push   $0xa
c000052d:	e8 3c ff ff ff       	call   c000046e <outb>
c0000532:	83 c4 08             	add    $0x8,%esp
	outb(0x20, 0x3D5);
c0000535:	68 d5 03 00 00       	push   $0x3d5
c000053a:	6a 20                	push   $0x20
c000053c:	e8 2d ff ff ff       	call   c000046e <outb>
c0000541:	83 c4 08             	add    $0x8,%esp
	// outb(0x0A, 0x3D4);
	// outb((inb(0x3D5) & 0xC0) | cursor_start, 0x3D5);
 
	// outb(0x0B, 0x3D4);
	// outb((inb(0x3D5) & 0xE0) | cursor_end, 0x3D5);
}
c0000544:	90                   	nop
c0000545:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0000548:	c9                   	leave  
c0000549:	c3                   	ret    

c000054a <terminal_setcolor>:
 
void terminal_setcolor(struct terminal* term, uint8_t color) 
{
c000054a:	55                   	push   %ebp
c000054b:	89 e5                	mov    %esp,%ebp
c000054d:	83 ec 04             	sub    $0x4,%esp
c0000550:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000553:	88 45 fc             	mov    %al,-0x4(%ebp)
	term->color = color;
c0000556:	8b 45 08             	mov    0x8(%ebp),%eax
c0000559:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c000055d:	88 50 08             	mov    %dl,0x8(%eax)
}
c0000560:	90                   	nop
c0000561:	c9                   	leave  
c0000562:	c3                   	ret    

c0000563 <terminal_putentryat>:
 
void terminal_putentryat(struct terminal* term, char c, uint8_t color, size_t x, size_t y) 
{
c0000563:	55                   	push   %ebp
c0000564:	89 e5                	mov    %esp,%ebp
c0000566:	53                   	push   %ebx
c0000567:	83 ec 18             	sub    $0x18,%esp
c000056a:	8b 55 0c             	mov    0xc(%ebp),%edx
c000056d:	8b 45 10             	mov    0x10(%ebp),%eax
c0000570:	88 55 e8             	mov    %dl,-0x18(%ebp)
c0000573:	88 45 e4             	mov    %al,-0x1c(%ebp)
	const size_t index = y * VGA_WIDTH + x;
c0000576:	8b 55 18             	mov    0x18(%ebp),%edx
c0000579:	89 d0                	mov    %edx,%eax
c000057b:	c1 e0 02             	shl    $0x2,%eax
c000057e:	01 d0                	add    %edx,%eax
c0000580:	c1 e0 04             	shl    $0x4,%eax
c0000583:	89 c2                	mov    %eax,%edx
c0000585:	8b 45 14             	mov    0x14(%ebp),%eax
c0000588:	01 d0                	add    %edx,%eax
c000058a:	89 45 f8             	mov    %eax,-0x8(%ebp)
	term->buffer[index] = vga_entry(c, color);
c000058d:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c0000591:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0000595:	0f b6 c0             	movzbl %al,%eax
c0000598:	8b 4d 08             	mov    0x8(%ebp),%ecx
c000059b:	8b 59 0c             	mov    0xc(%ecx),%ebx
c000059e:	8b 4d f8             	mov    -0x8(%ebp),%ecx
c00005a1:	01 c9                	add    %ecx,%ecx
c00005a3:	01 cb                	add    %ecx,%ebx
c00005a5:	52                   	push   %edx
c00005a6:	50                   	push   %eax
c00005a7:	e8 a1 fe ff ff       	call   c000044d <vga_entry>
c00005ac:	83 c4 08             	add    $0x8,%esp
c00005af:	66 89 03             	mov    %ax,(%ebx)
	// terminal_movecursor(term, x, y);
}
c00005b2:	90                   	nop
c00005b3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00005b6:	c9                   	leave  
c00005b7:	c3                   	ret    

c00005b8 <terminal_movecursor>:

void terminal_movecursor(struct terminal* term, size_t x, size_t y)
{
c00005b8:	55                   	push   %ebp
c00005b9:	89 e5                	mov    %esp,%ebp
c00005bb:	83 ec 10             	sub    $0x10,%esp
	(void) term; //we are directly manipulating curser, so were arean't using the term struct

	uint16_t pos = y * VGA_WIDTH + x;
c00005be:	8b 45 10             	mov    0x10(%ebp),%eax
c00005c1:	89 c2                	mov    %eax,%edx
c00005c3:	89 d0                	mov    %edx,%eax
c00005c5:	c1 e0 02             	shl    $0x2,%eax
c00005c8:	01 d0                	add    %edx,%eax
c00005ca:	c1 e0 04             	shl    $0x4,%eax
c00005cd:	89 c2                	mov    %eax,%edx
c00005cf:	8b 45 0c             	mov    0xc(%ebp),%eax
c00005d2:	01 d0                	add    %edx,%eax
c00005d4:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

	outb(0x0F, 0x3D4);
c00005d8:	68 d4 03 00 00       	push   $0x3d4
c00005dd:	6a 0f                	push   $0xf
c00005df:	e8 8a fe ff ff       	call   c000046e <outb>
c00005e4:	83 c4 08             	add    $0x8,%esp
	outb((uint8_t) (pos & 0xFF), 0x3D5);
c00005e7:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c00005eb:	0f b6 c0             	movzbl %al,%eax
c00005ee:	68 d5 03 00 00       	push   $0x3d5
c00005f3:	50                   	push   %eax
c00005f4:	e8 75 fe ff ff       	call   c000046e <outb>
c00005f9:	83 c4 08             	add    $0x8,%esp
	outb(0x0E, 0x3D4);
c00005fc:	68 d4 03 00 00       	push   $0x3d4
c0000601:	6a 0e                	push   $0xe
c0000603:	e8 66 fe ff ff       	call   c000046e <outb>
c0000608:	83 c4 08             	add    $0x8,%esp
	outb((uint8_t) ((pos >> 8) & 0xFF), 0x3D5);
c000060b:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c000060f:	66 c1 e8 08          	shr    $0x8,%ax
c0000613:	0f b6 c0             	movzbl %al,%eax
c0000616:	68 d5 03 00 00       	push   $0x3d5
c000061b:	50                   	push   %eax
c000061c:	e8 4d fe ff ff       	call   c000046e <outb>
c0000621:	83 c4 08             	add    $0x8,%esp
}
c0000624:	90                   	nop
c0000625:	c9                   	leave  
c0000626:	c3                   	ret    

c0000627 <terminal_putchar>:

 
void terminal_putchar(struct terminal* term, char c) 
{
c0000627:	55                   	push   %ebp
c0000628:	89 e5                	mov    %esp,%ebp
c000062a:	53                   	push   %ebx
c000062b:	83 ec 14             	sub    $0x14,%esp
c000062e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000631:	88 45 f4             	mov    %al,-0xc(%ebp)
	if(c == '\n')
c0000634:	80 7d f4 0a          	cmpb   $0xa,-0xc(%ebp)
c0000638:	75 10                	jne    c000064a <terminal_putchar+0x23>
	{
		terminal_newline(term);
c000063a:	83 ec 0c             	sub    $0xc,%esp
c000063d:	ff 75 08             	pushl  0x8(%ebp)
c0000640:	e8 95 00 00 00       	call   c00006da <terminal_newline>
c0000645:	83 c4 10             	add    $0x10,%esp
		return;
c0000648:	eb 53                	jmp    c000069d <terminal_putchar+0x76>
	}

	terminal_putentryat(term, c, term->color, term->column, term->row);
c000064a:	8b 45 08             	mov    0x8(%ebp),%eax
c000064d:	8b 18                	mov    (%eax),%ebx
c000064f:	8b 45 08             	mov    0x8(%ebp),%eax
c0000652:	8b 48 04             	mov    0x4(%eax),%ecx
c0000655:	8b 45 08             	mov    0x8(%ebp),%eax
c0000658:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c000065c:	0f b6 d0             	movzbl %al,%edx
c000065f:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c0000663:	83 ec 0c             	sub    $0xc,%esp
c0000666:	53                   	push   %ebx
c0000667:	51                   	push   %ecx
c0000668:	52                   	push   %edx
c0000669:	50                   	push   %eax
c000066a:	ff 75 08             	pushl  0x8(%ebp)
c000066d:	e8 f1 fe ff ff       	call   c0000563 <terminal_putentryat>
c0000672:	83 c4 20             	add    $0x20,%esp
	if (++term->column == VGA_WIDTH)
c0000675:	8b 45 08             	mov    0x8(%ebp),%eax
c0000678:	8b 40 04             	mov    0x4(%eax),%eax
c000067b:	8d 50 01             	lea    0x1(%eax),%edx
c000067e:	8b 45 08             	mov    0x8(%ebp),%eax
c0000681:	89 50 04             	mov    %edx,0x4(%eax)
c0000684:	8b 45 08             	mov    0x8(%ebp),%eax
c0000687:	8b 40 04             	mov    0x4(%eax),%eax
c000068a:	83 f8 50             	cmp    $0x50,%eax
c000068d:	75 0e                	jne    c000069d <terminal_putchar+0x76>
		terminal_newline(term);
c000068f:	83 ec 0c             	sub    $0xc,%esp
c0000692:	ff 75 08             	pushl  0x8(%ebp)
c0000695:	e8 40 00 00 00       	call   c00006da <terminal_newline>
c000069a:	83 c4 10             	add    $0x10,%esp
}
c000069d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00006a0:	c9                   	leave  
c00006a1:	c3                   	ret    

c00006a2 <terminal_putcharn>:

void terminal_putcharn(struct terminal* term, char c, size_t repeat) 
{
c00006a2:	55                   	push   %ebp
c00006a3:	89 e5                	mov    %esp,%ebp
c00006a5:	83 ec 28             	sub    $0x28,%esp
c00006a8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00006ab:	88 45 e4             	mov    %al,-0x1c(%ebp)
	for (size_t i = 0; i < repeat; i++)
c00006ae:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00006b5:	eb 17                	jmp    c00006ce <terminal_putcharn+0x2c>
		terminal_putchar(term, c);
c00006b7:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
c00006bb:	83 ec 08             	sub    $0x8,%esp
c00006be:	50                   	push   %eax
c00006bf:	ff 75 08             	pushl  0x8(%ebp)
c00006c2:	e8 60 ff ff ff       	call   c0000627 <terminal_putchar>
c00006c7:	83 c4 10             	add    $0x10,%esp
	for (size_t i = 0; i < repeat; i++)
c00006ca:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00006ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00006d1:	3b 45 10             	cmp    0x10(%ebp),%eax
c00006d4:	72 e1                	jb     c00006b7 <terminal_putcharn+0x15>
}
c00006d6:	90                   	nop
c00006d7:	90                   	nop
c00006d8:	c9                   	leave  
c00006d9:	c3                   	ret    

c00006da <terminal_newline>:

void terminal_newline(struct terminal* term)
{
c00006da:	55                   	push   %ebp
c00006db:	89 e5                	mov    %esp,%ebp
c00006dd:	83 ec 08             	sub    $0x8,%esp
    term->column = 0;
c00006e0:	8b 45 08             	mov    0x8(%ebp),%eax
c00006e3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if (++term->row == VGA_HEIGHT)
c00006ea:	8b 45 08             	mov    0x8(%ebp),%eax
c00006ed:	8b 00                	mov    (%eax),%eax
c00006ef:	8d 50 01             	lea    0x1(%eax),%edx
c00006f2:	8b 45 08             	mov    0x8(%ebp),%eax
c00006f5:	89 10                	mov    %edx,(%eax)
c00006f7:	8b 45 08             	mov    0x8(%ebp),%eax
c00006fa:	8b 00                	mov    (%eax),%eax
c00006fc:	83 f8 19             	cmp    $0x19,%eax
c00006ff:	75 0e                	jne    c000070f <terminal_newline+0x35>
        terminal_scrollline(term);
c0000701:	83 ec 0c             	sub    $0xc,%esp
c0000704:	ff 75 08             	pushl  0x8(%ebp)
c0000707:	e8 06 00 00 00       	call   c0000712 <terminal_scrollline>
c000070c:	83 c4 10             	add    $0x10,%esp
}
c000070f:	90                   	nop
c0000710:	c9                   	leave  
c0000711:	c3                   	ret    

c0000712 <terminal_scrollline>:

void terminal_scrollline(struct terminal* term)
{
c0000712:	55                   	push   %ebp
c0000713:	89 e5                	mov    %esp,%ebp
c0000715:	83 ec 08             	sub    $0x8,%esp
	// copy rows 2 though N to rows 1 through N-1
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c0000718:	8b 45 08             	mov    0x8(%ebp),%eax
c000071b:	8b 40 0c             	mov    0xc(%eax),%eax
c000071e:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c0000724:	8b 45 08             	mov    0x8(%ebp),%eax
c0000727:	8b 40 0c             	mov    0xc(%eax),%eax
c000072a:	83 ec 04             	sub    $0x4,%esp
c000072d:	68 00 0f 00 00       	push   $0xf00
c0000732:	52                   	push   %edx
c0000733:	50                   	push   %eax
c0000734:	e8 d5 0f 00 00       	call   c000170e <memcpy>
c0000739:	83 c4 10             	add    $0x10,%esp
	// clear last row
	term->row = VGA_HEIGHT-1;
c000073c:	8b 45 08             	mov    0x8(%ebp),%eax
c000073f:	c7 00 18 00 00 00    	movl   $0x18,(%eax)
	terminal_clearline(term);
c0000745:	83 ec 0c             	sub    $0xc,%esp
c0000748:	ff 75 08             	pushl  0x8(%ebp)
c000074b:	e8 06 00 00 00       	call   c0000756 <terminal_clearline>
c0000750:	83 c4 10             	add    $0x10,%esp
}
c0000753:	90                   	nop
c0000754:	c9                   	leave  
c0000755:	c3                   	ret    

c0000756 <terminal_clearline>:

void terminal_clearline(struct terminal* term)
{
c0000756:	55                   	push   %ebp
c0000757:	89 e5                	mov    %esp,%ebp
c0000759:	53                   	push   %ebx
c000075a:	83 ec 10             	sub    $0x10,%esp
	size_t row_start = term->row * VGA_WIDTH;
c000075d:	8b 45 08             	mov    0x8(%ebp),%eax
c0000760:	8b 10                	mov    (%eax),%edx
c0000762:	89 d0                	mov    %edx,%eax
c0000764:	c1 e0 02             	shl    $0x2,%eax
c0000767:	01 d0                	add    %edx,%eax
c0000769:	c1 e0 04             	shl    $0x4,%eax
c000076c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c000076f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0000776:	eb 2f                	jmp    c00007a7 <terminal_clearline+0x51>
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0000778:	8b 45 08             	mov    0x8(%ebp),%eax
c000077b:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c000077f:	0f b6 c0             	movzbl %al,%eax
c0000782:	8b 55 08             	mov    0x8(%ebp),%edx
c0000785:	8b 4a 0c             	mov    0xc(%edx),%ecx
c0000788:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c000078b:	8b 55 f8             	mov    -0x8(%ebp),%edx
c000078e:	01 da                	add    %ebx,%edx
c0000790:	01 d2                	add    %edx,%edx
c0000792:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
c0000795:	50                   	push   %eax
c0000796:	6a 20                	push   $0x20
c0000798:	e8 b0 fc ff ff       	call   c000044d <vga_entry>
c000079d:	83 c4 08             	add    $0x8,%esp
c00007a0:	66 89 03             	mov    %ax,(%ebx)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c00007a3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c00007a7:	83 7d f8 4f          	cmpl   $0x4f,-0x8(%ebp)
c00007ab:	76 cb                	jbe    c0000778 <terminal_clearline+0x22>

}
c00007ad:	90                   	nop
c00007ae:	90                   	nop
c00007af:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00007b2:	c9                   	leave  
c00007b3:	c3                   	ret    

c00007b4 <terminal_write>:


void terminal_write(struct terminal* term, const char* data, size_t size) 
{
c00007b4:	55                   	push   %ebp
c00007b5:	89 e5                	mov    %esp,%ebp
c00007b7:	83 ec 18             	sub    $0x18,%esp
	for (size_t i = 0; i < size; i++)
c00007ba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00007c1:	eb 21                	jmp    c00007e4 <terminal_write+0x30>
		terminal_putchar(term, data[i]);
c00007c3:	8b 55 0c             	mov    0xc(%ebp),%edx
c00007c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00007c9:	01 d0                	add    %edx,%eax
c00007cb:	0f b6 00             	movzbl (%eax),%eax
c00007ce:	0f be c0             	movsbl %al,%eax
c00007d1:	83 ec 08             	sub    $0x8,%esp
c00007d4:	50                   	push   %eax
c00007d5:	ff 75 08             	pushl  0x8(%ebp)
c00007d8:	e8 4a fe ff ff       	call   c0000627 <terminal_putchar>
c00007dd:	83 c4 10             	add    $0x10,%esp
	for (size_t i = 0; i < size; i++)
c00007e0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00007e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00007e7:	3b 45 10             	cmp    0x10(%ebp),%eax
c00007ea:	72 d7                	jb     c00007c3 <terminal_write+0xf>
}
c00007ec:	90                   	nop
c00007ed:	90                   	nop
c00007ee:	c9                   	leave  
c00007ef:	c3                   	ret    

c00007f0 <terminal_writestring>:
 
void terminal_writestring(struct terminal* term, const char* data) 
{
c00007f0:	55                   	push   %ebp
c00007f1:	89 e5                	mov    %esp,%ebp
c00007f3:	83 ec 08             	sub    $0x8,%esp
	terminal_write(term, data, strlen(data));
c00007f6:	83 ec 0c             	sub    $0xc,%esp
c00007f9:	ff 75 0c             	pushl  0xc(%ebp)
c00007fc:	e8 e6 0e 00 00       	call   c00016e7 <strlen>
c0000801:	83 c4 10             	add    $0x10,%esp
c0000804:	83 ec 04             	sub    $0x4,%esp
c0000807:	50                   	push   %eax
c0000808:	ff 75 0c             	pushl  0xc(%ebp)
c000080b:	ff 75 08             	pushl  0x8(%ebp)
c000080e:	e8 a1 ff ff ff       	call   c00007b4 <terminal_write>
c0000813:	83 c4 10             	add    $0x10,%esp
}
c0000816:	90                   	nop
c0000817:	c9                   	leave  
c0000818:	c3                   	ret    

c0000819 <kprint>:
unsigned int numdigits_uint(unsigned int value, unsigned int base);

int format_uint(unsigned int value, char* str, unsigned int base, int precision, int cap);

int kprint(const char* str)
{
c0000819:	55                   	push   %ebp
c000081a:	89 e5                	mov    %esp,%ebp
c000081c:	83 ec 08             	sub    $0x8,%esp
    terminal_writestring(&stdout, str);
c000081f:	83 ec 08             	sub    $0x8,%esp
c0000822:	ff 75 08             	pushl  0x8(%ebp)
c0000825:	68 00 60 00 c0       	push   $0xc0006000
c000082a:	e8 c1 ff ff ff       	call   c00007f0 <terminal_writestring>
c000082f:	83 c4 10             	add    $0x10,%esp
    return strlen(str);
c0000832:	83 ec 0c             	sub    $0xc,%esp
c0000835:	ff 75 08             	pushl  0x8(%ebp)
c0000838:	e8 aa 0e 00 00       	call   c00016e7 <strlen>
c000083d:	83 c4 10             	add    $0x10,%esp
}
c0000840:	c9                   	leave  
c0000841:	c3                   	ret    

c0000842 <kprintn>:

int kprintn(const char* str, size_t len)
{
c0000842:	55                   	push   %ebp
c0000843:	89 e5                	mov    %esp,%ebp
c0000845:	83 ec 08             	sub    $0x8,%esp
    terminal_write(&stdout, str, len);
c0000848:	83 ec 04             	sub    $0x4,%esp
c000084b:	ff 75 0c             	pushl  0xc(%ebp)
c000084e:	ff 75 08             	pushl  0x8(%ebp)
c0000851:	68 00 60 00 c0       	push   $0xc0006000
c0000856:	e8 59 ff ff ff       	call   c00007b4 <terminal_write>
c000085b:	83 c4 10             	add    $0x10,%esp
    return len;
c000085e:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c0000861:	c9                   	leave  
c0000862:	c3                   	ret    

c0000863 <kprint_char>:

int kprint_char(char c)
{
c0000863:	55                   	push   %ebp
c0000864:	89 e5                	mov    %esp,%ebp
c0000866:	83 ec 18             	sub    $0x18,%esp
c0000869:	8b 45 08             	mov    0x8(%ebp),%eax
c000086c:	88 45 f4             	mov    %al,-0xc(%ebp)
    terminal_putchar(&stdout, c); 
c000086f:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c0000873:	83 ec 08             	sub    $0x8,%esp
c0000876:	50                   	push   %eax
c0000877:	68 00 60 00 c0       	push   $0xc0006000
c000087c:	e8 a6 fd ff ff       	call   c0000627 <terminal_putchar>
c0000881:	83 c4 10             	add    $0x10,%esp
    return 1;
c0000884:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0000889:	c9                   	leave  
c000088a:	c3                   	ret    

c000088b <kprintn_char>:

int kprintn_char(char c, size_t rpt)
{
c000088b:	55                   	push   %ebp
c000088c:	89 e5                	mov    %esp,%ebp
c000088e:	83 ec 18             	sub    $0x18,%esp
c0000891:	8b 45 08             	mov    0x8(%ebp),%eax
c0000894:	88 45 f4             	mov    %al,-0xc(%ebp)
    terminal_putcharn(&stdout, c, rpt); 
c0000897:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c000089b:	83 ec 04             	sub    $0x4,%esp
c000089e:	ff 75 0c             	pushl  0xc(%ebp)
c00008a1:	50                   	push   %eax
c00008a2:	68 00 60 00 c0       	push   $0xc0006000
c00008a7:	e8 f6 fd ff ff       	call   c00006a2 <terminal_putcharn>
c00008ac:	83 c4 10             	add    $0x10,%esp
    return rpt;
c00008af:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c00008b2:	c9                   	leave  
c00008b3:	c3                   	ret    

c00008b4 <kprintf>:


int kprintf(const char* format, ...)
{
c00008b4:	55                   	push   %ebp
c00008b5:	89 e5                	mov    %esp,%ebp
c00008b7:	81 ec a8 02 00 00    	sub    $0x2a8,%esp
    /* initialize valist for num number of arguments */
    va_list valist;
    va_start(valist, format);
c00008bd:	8d 45 0c             	lea    0xc(%ebp),%eax
c00008c0:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)

    // parse format into str
    const char* f = format;
c00008c6:	8b 45 08             	mov    0x8(%ebp),%eax
c00008c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int nchar = 0;
c00008cc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    while(f[0] != 0)
c00008d3:	e9 9e 0a 00 00       	jmp    c0001376 <kprintf+0xac2>
    {
        if(f[0] == '\\' && f[1] == '%')
c00008d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00008db:	0f b6 00             	movzbl (%eax),%eax
c00008de:	3c 5c                	cmp    $0x5c,%al
c00008e0:	75 22                	jne    c0000904 <kprintf+0x50>
c00008e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00008e5:	83 c0 01             	add    $0x1,%eax
c00008e8:	0f b6 00             	movzbl (%eax),%eax
c00008eb:	3c 25                	cmp    $0x25,%al
c00008ed:	75 15                	jne    c0000904 <kprintf+0x50>
        {
            //write escaped "%%" as '%'
            kprint_char('%');
c00008ef:	83 ec 0c             	sub    $0xc,%esp
c00008f2:	6a 25                	push   $0x25
c00008f4:	e8 6a ff ff ff       	call   c0000863 <kprint_char>
c00008f9:	83 c4 10             	add    $0x10,%esp
            nchar++;
c00008fc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
            f += 2;
c0000900:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
        }

        if(f[0] == '%')
c0000904:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000907:	0f b6 00             	movzbl (%eax),%eax
c000090a:	3c 25                	cmp    $0x25,%al
c000090c:	0f 85 45 0a 00 00    	jne    c0001357 <kprintf+0xaa3>
        {
            // found new field

            // parse flags
            struct format_flags flags = {0};
c0000912:	c7 85 77 ff ff ff 00 	movl   $0x0,-0x89(%ebp)
c0000919:	00 00 00 
c000091c:	c6 85 7b ff ff ff 00 	movb   $0x0,-0x85(%ebp)
            int check_flags = 1;
c0000923:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
            while(check_flags)
c000092a:	e9 ee 00 00 00       	jmp    c0000a1d <kprintf+0x169>
            {
                switch(*(++f))
c000092f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0000933:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000936:	0f b6 00             	movzbl (%eax),%eax
c0000939:	0f be c0             	movsbl %al,%eax
c000093c:	85 c0                	test   %eax,%eax
c000093e:	0f 84 c8 00 00 00    	je     c0000a0c <kprintf+0x158>
c0000944:	85 c0                	test   %eax,%eax
c0000946:	0f 88 ca 00 00 00    	js     c0000a16 <kprintf+0x162>
c000094c:	83 f8 30             	cmp    $0x30,%eax
c000094f:	0f 8f c1 00 00 00    	jg     c0000a16 <kprintf+0x162>
c0000955:	83 f8 20             	cmp    $0x20,%eax
c0000958:	0f 8c b8 00 00 00    	jl     c0000a16 <kprintf+0x162>
c000095e:	83 e8 20             	sub    $0x20,%eax
c0000961:	83 f8 10             	cmp    $0x10,%eax
c0000964:	0f 87 ac 00 00 00    	ja     c0000a16 <kprintf+0x162>
c000096a:	8b 04 85 00 40 00 c0 	mov    -0x3fffc000(,%eax,4),%eax
c0000971:	ff e0                	jmp    *%eax
                {
                    case '#':
                        if(flags.alt) return 0;
c0000973:	0f b6 85 77 ff ff ff 	movzbl -0x89(%ebp),%eax
c000097a:	84 c0                	test   %al,%al
c000097c:	74 0a                	je     c0000988 <kprintf+0xd4>
c000097e:	b8 00 00 00 00       	mov    $0x0,%eax
c0000983:	e9 ff 09 00 00       	jmp    c0001387 <kprintf+0xad3>
                        flags.alt = 1;
c0000988:	c6 85 77 ff ff ff 01 	movb   $0x1,-0x89(%ebp)
                        break;
c000098f:	e9 89 00 00 00       	jmp    c0000a1d <kprintf+0x169>
                    case '0':
                        if(flags.zero) return 0;
c0000994:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c000099b:	84 c0                	test   %al,%al
c000099d:	74 0a                	je     c00009a9 <kprintf+0xf5>
c000099f:	b8 00 00 00 00       	mov    $0x0,%eax
c00009a4:	e9 de 09 00 00       	jmp    c0001387 <kprintf+0xad3>
                        flags.zero = 1;
c00009a9:	c6 85 78 ff ff ff 01 	movb   $0x1,-0x88(%ebp)
                        break;
c00009b0:	eb 6b                	jmp    c0000a1d <kprintf+0x169>
                    case '-':
                        if(flags.left) return 0;
c00009b2:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c00009b9:	84 c0                	test   %al,%al
c00009bb:	74 0a                	je     c00009c7 <kprintf+0x113>
c00009bd:	b8 00 00 00 00       	mov    $0x0,%eax
c00009c2:	e9 c0 09 00 00       	jmp    c0001387 <kprintf+0xad3>
                        flags.left = 1;
c00009c7:	c6 85 79 ff ff ff 01 	movb   $0x1,-0x87(%ebp)
                        break;
c00009ce:	eb 4d                	jmp    c0000a1d <kprintf+0x169>
                    case ' ':
                        if(flags.space) return 0;
c00009d0:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c00009d7:	84 c0                	test   %al,%al
c00009d9:	74 0a                	je     c00009e5 <kprintf+0x131>
c00009db:	b8 00 00 00 00       	mov    $0x0,%eax
c00009e0:	e9 a2 09 00 00       	jmp    c0001387 <kprintf+0xad3>
                        flags.space = 1;
c00009e5:	c6 85 7a ff ff ff 01 	movb   $0x1,-0x86(%ebp)
                        break;
c00009ec:	eb 2f                	jmp    c0000a1d <kprintf+0x169>
                    case '+':
                        if(flags.sign) return 0;
c00009ee:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c00009f5:	84 c0                	test   %al,%al
c00009f7:	74 0a                	je     c0000a03 <kprintf+0x14f>
c00009f9:	b8 00 00 00 00       	mov    $0x0,%eax
c00009fe:	e9 84 09 00 00       	jmp    c0001387 <kprintf+0xad3>
                        flags.sign = 1;
c0000a03:	c6 85 7b ff ff ff 01 	movb   $0x1,-0x85(%ebp)
                        break;
c0000a0a:	eb 11                	jmp    c0000a1d <kprintf+0x169>
                    case '\0':
                        //unexpected string termination
                        return -1;
c0000a0c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000a11:	e9 71 09 00 00       	jmp    c0001387 <kprintf+0xad3>
                        break;
                    default:
                        //no more flags
                        check_flags = 0;
c0000a16:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
            while(check_flags)
c0000a1d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0000a21:	0f 85 08 ff ff ff    	jne    c000092f <kprintf+0x7b>
                }
            }

            if(flags.left) flags.zero = 0; //If the 0 and - flags both appear, the 0 flag is ignored
c0000a27:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000a2e:	84 c0                	test   %al,%al
c0000a30:	74 07                	je     c0000a39 <kprintf+0x185>
c0000a32:	c6 85 78 ff ff ff 00 	movb   $0x0,-0x88(%ebp)

            // parse field width
            int field_width=0;
c0000a39:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
            int nn=0;
c0000a40:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
            while(f[nn] >= '0' && f[nn] <= '9')
c0000a47:	eb 04                	jmp    c0000a4d <kprintf+0x199>
                nn++;            
c0000a49:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
            while(f[nn] >= '0' && f[nn] <= '9')
c0000a4d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000a50:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000a53:	01 d0                	add    %edx,%eax
c0000a55:	0f b6 00             	movzbl (%eax),%eax
c0000a58:	3c 2f                	cmp    $0x2f,%al
c0000a5a:	7e 0f                	jle    c0000a6b <kprintf+0x1b7>
c0000a5c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000a5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000a62:	01 d0                	add    %edx,%eax
c0000a64:	0f b6 00             	movzbl (%eax),%eax
c0000a67:	3c 39                	cmp    $0x39,%al
c0000a69:	7e de                	jle    c0000a49 <kprintf+0x195>
            if(nn>0)
c0000a6b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0000a6f:	7e 17                	jle    c0000a88 <kprintf+0x1d4>
            {
                field_width = atoi(f);
c0000a71:	83 ec 0c             	sub    $0xc,%esp
c0000a74:	ff 75 f4             	pushl  -0xc(%ebp)
c0000a77:	e8 6a 0d 00 00       	call   c00017e6 <atoi>
c0000a7c:	83 c4 10             	add    $0x10,%esp
c0000a7f:	89 45 e8             	mov    %eax,-0x18(%ebp)
                f += nn;
c0000a82:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0000a85:	01 45 f4             	add    %eax,-0xc(%ebp)
            }

            // parse field precision
            int field_prec=-1; //default is -1
c0000a88:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
            if(f[0] == '.')
c0000a8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000a92:	0f b6 00             	movzbl (%eax),%eax
c0000a95:	3c 2e                	cmp    $0x2e,%al
c0000a97:	75 59                	jne    c0000af2 <kprintf+0x23e>
            {
                f++;
c0000a99:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                nn=0;
c0000a9d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
                while(f[nn] >= '0' && f[nn] <= '9')
c0000aa4:	eb 04                	jmp    c0000aaa <kprintf+0x1f6>
                    nn++;            
c0000aa6:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                while(f[nn] >= '0' && f[nn] <= '9')
c0000aaa:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000aad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000ab0:	01 d0                	add    %edx,%eax
c0000ab2:	0f b6 00             	movzbl (%eax),%eax
c0000ab5:	3c 2f                	cmp    $0x2f,%al
c0000ab7:	7e 0f                	jle    c0000ac8 <kprintf+0x214>
c0000ab9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000abc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000abf:	01 d0                	add    %edx,%eax
c0000ac1:	0f b6 00             	movzbl (%eax),%eax
c0000ac4:	3c 39                	cmp    $0x39,%al
c0000ac6:	7e de                	jle    c0000aa6 <kprintf+0x1f2>
                if(nn>0)
c0000ac8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0000acc:	7e 24                	jle    c0000af2 <kprintf+0x23e>
                {
                    field_prec = atoi(f);
c0000ace:	83 ec 0c             	sub    $0xc,%esp
c0000ad1:	ff 75 f4             	pushl  -0xc(%ebp)
c0000ad4:	e8 0d 0d 00 00       	call   c00017e6 <atoi>
c0000ad9:	83 c4 10             	add    $0x10,%esp
c0000adc:	89 45 e0             	mov    %eax,-0x20(%ebp)
                    if(field_prec<0) field_prec = 0;
c0000adf:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000ae3:	79 07                	jns    c0000aec <kprintf+0x238>
c0000ae5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
                    f += nn;
c0000aec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0000aef:	01 45 f4             	add    %eax,-0xc(%ebp)

            //parse type
            enum length_mod_t {DEFAULT, CHARINT, SHORTINT, LONGINT, LONGLONGINT,
                            LONGDOUBLE, INTMAX, SIZE, PTRDIFF} length_mod;

            switch(*(f++))
c0000af2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000af5:	8d 50 01             	lea    0x1(%eax),%edx
c0000af8:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0000afb:	0f b6 00             	movzbl (%eax),%eax
c0000afe:	0f be c0             	movsbl %al,%eax
c0000b01:	83 e8 4c             	sub    $0x4c,%eax
c0000b04:	83 f8 2e             	cmp    $0x2e,%eax
c0000b07:	77 6d                	ja     c0000b76 <kprintf+0x2c2>
c0000b09:	8b 04 85 44 40 00 c0 	mov    -0x3fffbfbc(,%eax,4),%eax
c0000b10:	ff e0                	jmp    *%eax
            {
                case 'h':
                    if(*f == 'h')
c0000b12:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000b15:	0f b6 00             	movzbl (%eax),%eax
c0000b18:	3c 68                	cmp    $0x68,%al
c0000b1a:	75 0d                	jne    c0000b29 <kprintf+0x275>
                    {
                        f++;
c0000b1c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                        length_mod = CHARINT;
c0000b20:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
                    }
                    else
                        length_mod = SHORTINT;
                    break;
c0000b27:	eb 58                	jmp    c0000b81 <kprintf+0x2cd>
                        length_mod = SHORTINT;
c0000b29:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
                    break;
c0000b30:	eb 4f                	jmp    c0000b81 <kprintf+0x2cd>
                case 'l':
                    if(*f == 'l')
c0000b32:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000b35:	0f b6 00             	movzbl (%eax),%eax
c0000b38:	3c 6c                	cmp    $0x6c,%al
c0000b3a:	75 0d                	jne    c0000b49 <kprintf+0x295>
                    {
                        f++;
c0000b3c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                        length_mod = LONGLONGINT;
c0000b40:	c7 45 dc 04 00 00 00 	movl   $0x4,-0x24(%ebp)
                    }
                    else
                        length_mod = LONGINT;
                    break;
c0000b47:	eb 38                	jmp    c0000b81 <kprintf+0x2cd>
                        length_mod = LONGINT;
c0000b49:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
                    break;
c0000b50:	eb 2f                	jmp    c0000b81 <kprintf+0x2cd>
                case 'q':
                case 'L':
                    length_mod = LONGDOUBLE;
c0000b52:	c7 45 dc 05 00 00 00 	movl   $0x5,-0x24(%ebp)
                    break;
c0000b59:	eb 26                	jmp    c0000b81 <kprintf+0x2cd>
                case 'j':
                    length_mod = INTMAX;
c0000b5b:	c7 45 dc 06 00 00 00 	movl   $0x6,-0x24(%ebp)
                    break;
c0000b62:	eb 1d                	jmp    c0000b81 <kprintf+0x2cd>
                case 'Z':
                case 'z':
                    length_mod = SIZE;
c0000b64:	c7 45 dc 07 00 00 00 	movl   $0x7,-0x24(%ebp)
                    break;
c0000b6b:	eb 14                	jmp    c0000b81 <kprintf+0x2cd>
                case 't':
                    length_mod = PTRDIFF;
c0000b6d:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
                    break;
c0000b74:	eb 0b                	jmp    c0000b81 <kprintf+0x2cd>
                default:
                    f--; //no length mod, back up a char...
c0000b76:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
                    length_mod = DEFAULT;
c0000b7a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
            }

            //parse field
            char val_buf[512]; //assuming here that numberical values cannot exceed 512 chars 
            if(field_width>511)
c0000b81:	81 7d e8 ff 01 00 00 	cmpl   $0x1ff,-0x18(%ebp)
c0000b88:	7e 0a                	jle    c0000b94 <kprintf+0x2e0>
                return -1;
c0000b8a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000b8f:	e9 f3 07 00 00       	jmp    c0001387 <kprintf+0xad3>

            switch(*f)
c0000b94:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000b97:	0f b6 00             	movzbl (%eax),%eax
c0000b9a:	0f be c0             	movsbl %al,%eax
c0000b9d:	83 e8 45             	sub    $0x45,%eax
c0000ba0:	83 f8 33             	cmp    $0x33,%eax
c0000ba3:	0f 87 97 07 00 00    	ja     c0001340 <kprintf+0xa8c>
c0000ba9:	8b 04 85 00 41 00 c0 	mov    -0x3fffbf00(,%eax,4),%eax
c0000bb0:	ff e0                	jmp    *%eax
c0000bb2:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000bb6:	0f 87 67 01 00 00    	ja     c0000d23 <kprintf+0x46f>
                        case(LONGINT):
                        case(LONGLONGINT):
                        case(DEFAULT):
                            {
                                int i_value;
                                if(length_mod == LONGLONGINT)
c0000bbc:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000bc0:	75 19                	jne    c0000bdb <kprintf+0x327>
                                    i_value = (int) va_arg(valist, long long int); //TODO: implement actual longlong handling
c0000bc2:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000bc8:	8d 50 08             	lea    0x8(%eax),%edx
c0000bcb:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000bd1:	8b 50 04             	mov    0x4(%eax),%edx
c0000bd4:	8b 00                	mov    (%eax),%eax
c0000bd6:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0000bd9:	eb 14                	jmp    c0000bef <kprintf+0x33b>
                                else
                                    i_value = va_arg(valist, int);
c0000bdb:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000be1:	8d 50 04             	lea    0x4(%eax),%edx
c0000be4:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000bea:	8b 00                	mov    (%eax),%eax
c0000bec:	89 45 d8             	mov    %eax,-0x28(%ebp)

                                char sign_char = 0; //sign character or 0 if none
c0000bef:	c6 45 d7 00          	movb   $0x0,-0x29(%ebp)
                                unsigned int ui_value; //unsigned value (abs value)
                                if(i_value<0)
c0000bf3:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c0000bf7:	79 0e                	jns    c0000c07 <kprintf+0x353>
                                {
                                    ui_value = -i_value;
c0000bf9:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0000bfc:	f7 d8                	neg    %eax
c0000bfe:	89 45 d0             	mov    %eax,-0x30(%ebp)
                                    sign_char = '-';
c0000c01:	c6 45 d7 2d          	movb   $0x2d,-0x29(%ebp)
c0000c05:	eb 26                	jmp    c0000c2d <kprintf+0x379>
                                }
                                else
                                {
                                    ui_value = i_value;
c0000c07:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0000c0a:	89 45 d0             	mov    %eax,-0x30(%ebp)
                                    if(flags.sign)
c0000c0d:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c0000c14:	84 c0                	test   %al,%al
c0000c16:	74 06                	je     c0000c1e <kprintf+0x36a>
                                        sign_char = '+';
c0000c18:	c6 45 d7 2b          	movb   $0x2b,-0x29(%ebp)
c0000c1c:	eb 0f                	jmp    c0000c2d <kprintf+0x379>
                                    else if(flags.space)
c0000c1e:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c0000c25:	84 c0                	test   %al,%al
c0000c27:	74 04                	je     c0000c2d <kprintf+0x379>
                                        sign_char = ' ';
c0000c29:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
                                    
                                    //else positive number has no sign character
                                }

                                //convert value into string
                                int len = format_uint(ui_value, val_buf, 10, field_prec, 0);
c0000c2d:	83 ec 0c             	sub    $0xc,%esp
c0000c30:	6a 00                	push   $0x0
c0000c32:	ff 75 e0             	pushl  -0x20(%ebp)
c0000c35:	6a 0a                	push   $0xa
c0000c37:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000c3d:	50                   	push   %eax
c0000c3e:	ff 75 d0             	pushl  -0x30(%ebp)
c0000c41:	e8 43 07 00 00       	call   c0001389 <format_uint>
c0000c46:	83 c4 20             	add    $0x20,%esp
c0000c49:	89 45 9c             	mov    %eax,-0x64(%ebp)
                                //amount of padding required to meet requested width
                                int lenpad = field_width - len; 
c0000c4c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000c4f:	2b 45 9c             	sub    -0x64(%ebp),%eax
c0000c52:	89 45 cc             	mov    %eax,-0x34(%ebp)

                                if(sign_char)
c0000c55:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
c0000c59:	74 22                	je     c0000c7d <kprintf+0x3c9>
                                {
                                    lenpad--; //remove one char of padding to account for sign
c0000c5b:	83 6d cc 01          	subl   $0x1,-0x34(%ebp)
                                    if(flags.zero)
c0000c5f:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000c66:	84 c0                	test   %al,%al
c0000c68:	74 13                	je     c0000c7d <kprintf+0x3c9>
                                        nchar += kprint_char(sign_char); //if zero padding, sign is at beginning
c0000c6a:	0f be 45 d7          	movsbl -0x29(%ebp),%eax
c0000c6e:	83 ec 0c             	sub    $0xc,%esp
c0000c71:	50                   	push   %eax
c0000c72:	e8 ec fb ff ff       	call   c0000863 <kprint_char>
c0000c77:	83 c4 10             	add    $0x10,%esp
c0000c7a:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                if(!flags.left && lenpad>0)
c0000c7d:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000c84:	84 c0                	test   %al,%al
c0000c86:	75 3b                	jne    c0000cc3 <kprintf+0x40f>
c0000c88:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
c0000c8c:	7e 35                	jle    c0000cc3 <kprintf+0x40f>
                                {
                                    if(flags.zero)
c0000c8e:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000c95:	84 c0                	test   %al,%al
c0000c97:	74 16                	je     c0000caf <kprintf+0x3fb>
                                        nchar += kprintn_char('0', lenpad);
c0000c99:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0000c9c:	83 ec 08             	sub    $0x8,%esp
c0000c9f:	50                   	push   %eax
c0000ca0:	6a 30                	push   $0x30
c0000ca2:	e8 e4 fb ff ff       	call   c000088b <kprintn_char>
c0000ca7:	83 c4 10             	add    $0x10,%esp
c0000caa:	01 45 f0             	add    %eax,-0x10(%ebp)
c0000cad:	eb 14                	jmp    c0000cc3 <kprintf+0x40f>
                                    else
                                        nchar += kprintn_char(' ', lenpad);
c0000caf:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0000cb2:	83 ec 08             	sub    $0x8,%esp
c0000cb5:	50                   	push   %eax
c0000cb6:	6a 20                	push   $0x20
c0000cb8:	e8 ce fb ff ff       	call   c000088b <kprintn_char>
c0000cbd:	83 c4 10             	add    $0x10,%esp
c0000cc0:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                if(!flags.zero && sign_char)
c0000cc3:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000cca:	84 c0                	test   %al,%al
c0000ccc:	75 19                	jne    c0000ce7 <kprintf+0x433>
c0000cce:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
c0000cd2:	74 13                	je     c0000ce7 <kprintf+0x433>
                                    nchar += kprint_char(sign_char); //if not zero padding, write sign here
c0000cd4:	0f be 45 d7          	movsbl -0x29(%ebp),%eax
c0000cd8:	83 ec 0c             	sub    $0xc,%esp
c0000cdb:	50                   	push   %eax
c0000cdc:	e8 82 fb ff ff       	call   c0000863 <kprint_char>
c0000ce1:	83 c4 10             	add    $0x10,%esp
c0000ce4:	01 45 f0             	add    %eax,-0x10(%ebp)

                                nchar += kprint(val_buf);
c0000ce7:	83 ec 0c             	sub    $0xc,%esp
c0000cea:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000cf0:	50                   	push   %eax
c0000cf1:	e8 23 fb ff ff       	call   c0000819 <kprint>
c0000cf6:	83 c4 10             	add    $0x10,%esp
c0000cf9:	01 45 f0             	add    %eax,-0x10(%ebp)

                                if(flags.left && lenpad>0)
c0000cfc:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000d03:	84 c0                	test   %al,%al
c0000d05:	74 26                	je     c0000d2d <kprintf+0x479>
c0000d07:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
c0000d0b:	7e 20                	jle    c0000d2d <kprintf+0x479>
                                    nchar += kprintn_char(' ', lenpad);
c0000d0d:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0000d10:	83 ec 08             	sub    $0x8,%esp
c0000d13:	50                   	push   %eax
c0000d14:	6a 20                	push   $0x20
c0000d16:	e8 70 fb ff ff       	call   c000088b <kprintn_char>
c0000d1b:	83 c4 10             	add    $0x10,%esp
c0000d1e:	01 45 f0             	add    %eax,-0x10(%ebp)


                            }
                            break;
c0000d21:	eb 0a                	jmp    c0000d2d <kprintf+0x479>
                        default:
                            return -1; //invalid length mod
c0000d23:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000d28:	e9 5a 06 00 00       	jmp    c0001387 <kprintf+0xad3>
                            break;
c0000d2d:	90                   	nop
                    }
                    break;
c0000d2e:	e9 1e 06 00 00       	jmp    c0001351 <kprintf+0xa9d>
c0000d33:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000d37:	0f 87 03 02 00 00    	ja     c0000f40 <kprintf+0x68c>
                        case(SHORTINT):
                        case(LONGINT):
                        case(LONGLONGINT):
                        case(DEFAULT):
                            {
                                unsigned int base = 10;
c0000d3d:	c7 45 c8 0a 00 00 00 	movl   $0xa,-0x38(%ebp)
                                unsigned int ui_value;
                                if(length_mod == LONGLONGINT)
c0000d44:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000d48:	75 19                	jne    c0000d63 <kprintf+0x4af>
                                    ui_value = (unsigned int) va_arg(valist, long long unsigned int); //TODO: implement actual longlong handling
c0000d4a:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000d50:	8d 50 08             	lea    0x8(%eax),%edx
c0000d53:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000d59:	8b 50 04             	mov    0x4(%eax),%edx
c0000d5c:	8b 00                	mov    (%eax),%eax
c0000d5e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
c0000d61:	eb 14                	jmp    c0000d77 <kprintf+0x4c3>
                                else
                                    ui_value = va_arg(valist, unsigned int);
c0000d63:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000d69:	8d 50 04             	lea    0x4(%eax),%edx
c0000d6c:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000d72:	8b 00                	mov    (%eax),%eax
c0000d74:	89 45 c4             	mov    %eax,-0x3c(%ebp)

                                if(*f == 'o')
c0000d77:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000d7a:	0f b6 00             	movzbl (%eax),%eax
c0000d7d:	3c 6f                	cmp    $0x6f,%al
c0000d7f:	75 09                	jne    c0000d8a <kprintf+0x4d6>
                                    base = 8;
c0000d81:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
c0000d88:	eb 3e                	jmp    c0000dc8 <kprintf+0x514>
                                else if(*f == 'x' || *f == 'X')
c0000d8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000d8d:	0f b6 00             	movzbl (%eax),%eax
c0000d90:	3c 78                	cmp    $0x78,%al
c0000d92:	74 0a                	je     c0000d9e <kprintf+0x4ea>
c0000d94:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000d97:	0f b6 00             	movzbl (%eax),%eax
c0000d9a:	3c 58                	cmp    $0x58,%al
c0000d9c:	75 09                	jne    c0000da7 <kprintf+0x4f3>
                                    base = 16;
c0000d9e:	c7 45 c8 10 00 00 00 	movl   $0x10,-0x38(%ebp)
c0000da5:	eb 21                	jmp    c0000dc8 <kprintf+0x514>
                                else if(*f == 'p')
c0000da7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000daa:	0f b6 00             	movzbl (%eax),%eax
c0000dad:	3c 70                	cmp    $0x70,%al
c0000daf:	75 10                	jne    c0000dc1 <kprintf+0x50d>
                                {
                                    //print as hex with 0x prefix
                                    base = 16;
c0000db1:	c7 45 c8 10 00 00 00 	movl   $0x10,-0x38(%ebp)
                                    flags.alt = 1; 
c0000db8:	c6 85 77 ff ff ff 01 	movb   $0x1,-0x89(%ebp)
c0000dbf:	eb 07                	jmp    c0000dc8 <kprintf+0x514>
                                }
                                else
                                    flags.alt = 0;
c0000dc1:	c6 85 77 ff ff ff 00 	movb   $0x0,-0x89(%ebp)
                                
                                int cap = (*f == 'X') ? 1 : 0;
c0000dc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000dcb:	0f b6 00             	movzbl (%eax),%eax
c0000dce:	3c 58                	cmp    $0x58,%al
c0000dd0:	0f 94 c0             	sete   %al
c0000dd3:	0f b6 c0             	movzbl %al,%eax
c0000dd6:	89 45 94             	mov    %eax,-0x6c(%ebp)

                                //convert value into string
                                int len = format_uint(ui_value, val_buf, base, field_prec, cap);
c0000dd9:	83 ec 0c             	sub    $0xc,%esp
c0000ddc:	ff 75 94             	pushl  -0x6c(%ebp)
c0000ddf:	ff 75 e0             	pushl  -0x20(%ebp)
c0000de2:	ff 75 c8             	pushl  -0x38(%ebp)
c0000de5:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000deb:	50                   	push   %eax
c0000dec:	ff 75 c4             	pushl  -0x3c(%ebp)
c0000def:	e8 95 05 00 00       	call   c0001389 <format_uint>
c0000df4:	83 c4 20             	add    $0x20,%esp
c0000df7:	89 45 90             	mov    %eax,-0x70(%ebp)
                                //amount of padding required to meet requested width
                                int lenpad = field_width - len; 
c0000dfa:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000dfd:	2b 45 90             	sub    -0x70(%ebp),%eax
c0000e00:	89 45 c0             	mov    %eax,-0x40(%ebp)


                                //format radix prefix for oct and hex with alt flag
                                char radix[3]="";
c0000e03:	66 c7 85 74 ff ff ff 	movw   $0x0,-0x8c(%ebp)
c0000e0a:	00 00 
c0000e0c:	c6 85 76 ff ff ff 00 	movb   $0x0,-0x8a(%ebp)
                                if(flags.alt)
c0000e13:	0f b6 85 77 ff ff ff 	movzbl -0x89(%ebp),%eax
c0000e1a:	84 c0                	test   %al,%al
c0000e1c:	74 75                	je     c0000e93 <kprintf+0x5df>
                                {
                                    if(base==16)
c0000e1e:	83 7d c8 10          	cmpl   $0x10,-0x38(%ebp)
c0000e22:	75 2c                	jne    c0000e50 <kprintf+0x59c>
                                    {
                                        lenpad -= 2;
c0000e24:	83 6d c0 02          	subl   $0x2,-0x40(%ebp)
                                        radix[0] = '0';
c0000e28:	c6 85 74 ff ff ff 30 	movb   $0x30,-0x8c(%ebp)
                                        radix[1] = cap ? 'X' : 'x';
c0000e2f:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
c0000e33:	74 07                	je     c0000e3c <kprintf+0x588>
c0000e35:	b8 58 00 00 00       	mov    $0x58,%eax
c0000e3a:	eb 05                	jmp    c0000e41 <kprintf+0x58d>
c0000e3c:	b8 78 00 00 00       	mov    $0x78,%eax
c0000e41:	88 85 75 ff ff ff    	mov    %al,-0x8b(%ebp)
                                        radix[2] = 0;
c0000e47:	c6 85 76 ff ff ff 00 	movb   $0x0,-0x8a(%ebp)
c0000e4e:	eb 23                	jmp    c0000e73 <kprintf+0x5bf>
                                    }
                                    else if(base==8 && val_buf[0] != '0')
c0000e50:	83 7d c8 08          	cmpl   $0x8,-0x38(%ebp)
c0000e54:	75 1d                	jne    c0000e73 <kprintf+0x5bf>
c0000e56:	0f b6 85 74 fd ff ff 	movzbl -0x28c(%ebp),%eax
c0000e5d:	3c 30                	cmp    $0x30,%al
c0000e5f:	74 12                	je     c0000e73 <kprintf+0x5bf>
                                    {
                                        lenpad -= 1;
c0000e61:	83 6d c0 01          	subl   $0x1,-0x40(%ebp)
                                        radix[0] = '0';
c0000e65:	c6 85 74 ff ff ff 30 	movb   $0x30,-0x8c(%ebp)
                                        radix[1] = 0;
c0000e6c:	c6 85 75 ff ff ff 00 	movb   $0x0,-0x8b(%ebp)
                                    }

                                    //if zero padding, radix is printed first
                                    if(flags.zero)
c0000e73:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000e7a:	84 c0                	test   %al,%al
c0000e7c:	74 15                	je     c0000e93 <kprintf+0x5df>
                                        nchar += kprint(radix);
c0000e7e:	83 ec 0c             	sub    $0xc,%esp
c0000e81:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
c0000e87:	50                   	push   %eax
c0000e88:	e8 8c f9 ff ff       	call   c0000819 <kprint>
c0000e8d:	83 c4 10             	add    $0x10,%esp
c0000e90:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }


                                //print leading padding, if any
                                if(!flags.left && lenpad>0)
c0000e93:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000e9a:	84 c0                	test   %al,%al
c0000e9c:	75 3b                	jne    c0000ed9 <kprintf+0x625>
c0000e9e:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
c0000ea2:	7e 35                	jle    c0000ed9 <kprintf+0x625>
                                {
                                    if(flags.zero)
c0000ea4:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000eab:	84 c0                	test   %al,%al
c0000ead:	74 16                	je     c0000ec5 <kprintf+0x611>
                                        nchar += kprintn_char('0', lenpad);
c0000eaf:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000eb2:	83 ec 08             	sub    $0x8,%esp
c0000eb5:	50                   	push   %eax
c0000eb6:	6a 30                	push   $0x30
c0000eb8:	e8 ce f9 ff ff       	call   c000088b <kprintn_char>
c0000ebd:	83 c4 10             	add    $0x10,%esp
c0000ec0:	01 45 f0             	add    %eax,-0x10(%ebp)
c0000ec3:	eb 14                	jmp    c0000ed9 <kprintf+0x625>
                                    else
                                        nchar += kprintn_char(' ', lenpad);
c0000ec5:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000ec8:	83 ec 08             	sub    $0x8,%esp
c0000ecb:	50                   	push   %eax
c0000ecc:	6a 20                	push   $0x20
c0000ece:	e8 b8 f9 ff ff       	call   c000088b <kprintn_char>
c0000ed3:	83 c4 10             	add    $0x10,%esp
c0000ed6:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                //print radix prefix if valid and not leading zeros
                                if(!flags.zero && radix[0])
c0000ed9:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000ee0:	84 c0                	test   %al,%al
c0000ee2:	75 20                	jne    c0000f04 <kprintf+0x650>
c0000ee4:	0f b6 85 74 ff ff ff 	movzbl -0x8c(%ebp),%eax
c0000eeb:	84 c0                	test   %al,%al
c0000eed:	74 15                	je     c0000f04 <kprintf+0x650>
                                    nchar += kprint(radix);
c0000eef:	83 ec 0c             	sub    $0xc,%esp
c0000ef2:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
c0000ef8:	50                   	push   %eax
c0000ef9:	e8 1b f9 ff ff       	call   c0000819 <kprint>
c0000efe:	83 c4 10             	add    $0x10,%esp
c0000f01:	01 45 f0             	add    %eax,-0x10(%ebp)

                                //print number itself
                                nchar += kprint(val_buf);
c0000f04:	83 ec 0c             	sub    $0xc,%esp
c0000f07:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000f0d:	50                   	push   %eax
c0000f0e:	e8 06 f9 ff ff       	call   c0000819 <kprint>
c0000f13:	83 c4 10             	add    $0x10,%esp
c0000f16:	01 45 f0             	add    %eax,-0x10(%ebp)

                                //print trailing padding if left justified
                                if(flags.left && lenpad>0)
c0000f19:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000f20:	84 c0                	test   %al,%al
c0000f22:	74 26                	je     c0000f4a <kprintf+0x696>
c0000f24:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
c0000f28:	7e 20                	jle    c0000f4a <kprintf+0x696>
                                    nchar += kprintn_char(' ', lenpad);
c0000f2a:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000f2d:	83 ec 08             	sub    $0x8,%esp
c0000f30:	50                   	push   %eax
c0000f31:	6a 20                	push   $0x20
c0000f33:	e8 53 f9 ff ff       	call   c000088b <kprintn_char>
c0000f38:	83 c4 10             	add    $0x10,%esp
c0000f3b:	01 45 f0             	add    %eax,-0x10(%ebp)

                            }
                            break;
c0000f3e:	eb 0a                	jmp    c0000f4a <kprintf+0x696>
                        default:
                            return -1; //invalid length mod
c0000f40:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000f45:	e9 3d 04 00 00       	jmp    c0001387 <kprintf+0xad3>
                            break;
c0000f4a:	90                   	nop
                    }

                    break;
c0000f4b:	e9 01 04 00 00       	jmp    c0001351 <kprintf+0xa9d>

                case 'f':
                case 'F':
                    {
                        float f_value = (float) va_arg(valist, double);
c0000f50:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000f56:	8d 50 08             	lea    0x8(%eax),%edx
c0000f59:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000f5f:	dd 00                	fldl   (%eax)
c0000f61:	d9 5d 8c             	fstps  -0x74(%ebp)

                        //When 0 is printed with an explicit precision 0, the output is empty.
                        if(f_value==0 && field_prec==0)
c0000f64:	d9 45 8c             	flds   -0x74(%ebp)
c0000f67:	d9 ee                	fldz   
c0000f69:	df e9                	fucomip %st(1),%st
c0000f6b:	dd d8                	fstp   %st(0)
c0000f6d:	7a 15                	jp     c0000f84 <kprintf+0x6d0>
c0000f6f:	d9 45 8c             	flds   -0x74(%ebp)
c0000f72:	d9 ee                	fldz   
c0000f74:	df e9                	fucomip %st(1),%st
c0000f76:	dd d8                	fstp   %st(0)
c0000f78:	75 0a                	jne    c0000f84 <kprintf+0x6d0>
c0000f7a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000f7e:	0f 84 c3 03 00 00    	je     c0001347 <kprintf+0xa93>
                            break;
                        if(field_prec<0) field_prec = 6;  //default is prec = 6
c0000f84:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000f88:	79 07                	jns    c0000f91 <kprintf+0x6dd>
c0000f8a:	c7 45 e0 06 00 00 00 	movl   $0x6,-0x20(%ebp)

                        unsigned int ui_part;
                        char sign_char = 0;
c0000f91:	c6 45 bb 00          	movb   $0x0,-0x45(%ebp)
                        if(f_value<0)
c0000f95:	d9 45 8c             	flds   -0x74(%ebp)
c0000f98:	d9 ee                	fldz   
c0000f9a:	df f1                	fcomip %st(1),%st
c0000f9c:	dd d8                	fstp   %st(0)
c0000f9e:	76 3d                	jbe    c0000fdd <kprintf+0x729>
                        {
                            ui_part = (unsigned int) -f_value;
c0000fa0:	d9 45 8c             	flds   -0x74(%ebp)
c0000fa3:	d9 e0                	fchs   
c0000fa5:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c0000fab:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c0000fb2:	80 cc 0c             	or     $0xc,%ah
c0000fb5:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c0000fbc:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c0000fc2:	df bd 58 fd ff ff    	fistpll -0x2a8(%ebp)
c0000fc8:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
c0000fce:	8b 85 58 fd ff ff    	mov    -0x2a8(%ebp),%eax
c0000fd4:	89 45 bc             	mov    %eax,-0x44(%ebp)
                            sign_char = '-';
c0000fd7:	c6 45 bb 2d          	movb   $0x2d,-0x45(%ebp)
c0000fdb:	eb 55                	jmp    c0001032 <kprintf+0x77e>
                        }
                        else
                        {
                            ui_part = (unsigned int) f_value;
c0000fdd:	d9 45 8c             	flds   -0x74(%ebp)
c0000fe0:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c0000fe6:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c0000fed:	80 cc 0c             	or     $0xc,%ah
c0000ff0:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c0000ff7:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c0000ffd:	df bd 58 fd ff ff    	fistpll -0x2a8(%ebp)
c0001003:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
c0001009:	8b 85 58 fd ff ff    	mov    -0x2a8(%ebp),%eax
c000100f:	89 45 bc             	mov    %eax,-0x44(%ebp)
                            if(flags.sign)
c0001012:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c0001019:	84 c0                	test   %al,%al
c000101b:	74 06                	je     c0001023 <kprintf+0x76f>
                                sign_char = '+';
c000101d:	c6 45 bb 2b          	movb   $0x2b,-0x45(%ebp)
c0001021:	eb 0f                	jmp    c0001032 <kprintf+0x77e>
                            else if(flags.space)
c0001023:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c000102a:	84 c0                	test   %al,%al
c000102c:	74 04                	je     c0001032 <kprintf+0x77e>
                                sign_char = ' ';
c000102e:	c6 45 bb 20          	movb   $0x20,-0x45(%ebp)
                            
                            //else positive number has no sign character
                        }

                        int int_len = format_uint(ui_part,val_buf,10,-1,0);
c0001032:	83 ec 0c             	sub    $0xc,%esp
c0001035:	6a 00                	push   $0x0
c0001037:	6a ff                	push   $0xffffffff
c0001039:	6a 0a                	push   $0xa
c000103b:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0001041:	50                   	push   %eax
c0001042:	ff 75 bc             	pushl  -0x44(%ebp)
c0001045:	e8 3f 03 00 00       	call   c0001389 <format_uint>
c000104a:	83 c4 20             	add    $0x20,%esp
c000104d:	89 45 88             	mov    %eax,-0x78(%ebp)

                        int f_len = int_len + 1 + field_prec;
c0001050:	8b 45 88             	mov    -0x78(%ebp),%eax
c0001053:	8d 50 01             	lea    0x1(%eax),%edx
c0001056:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001059:	01 d0                	add    %edx,%eax
c000105b:	89 45 84             	mov    %eax,-0x7c(%ebp)

                        //amount of padding required to meet requested width
                        int lenpad = field_width - f_len; 
c000105e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001061:	2b 45 84             	sub    -0x7c(%ebp),%eax
c0001064:	89 45 b4             	mov    %eax,-0x4c(%ebp)

                        if(sign_char)
c0001067:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
c000106b:	74 22                	je     c000108f <kprintf+0x7db>
                        {
                            lenpad--; //remove one char of padding to account for sign
c000106d:	83 6d b4 01          	subl   $0x1,-0x4c(%ebp)
                            if(flags.zero)
c0001071:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0001078:	84 c0                	test   %al,%al
c000107a:	74 13                	je     c000108f <kprintf+0x7db>
                                nchar += kprint_char(sign_char); //if zero padding, sign is at beginning
c000107c:	0f be 45 bb          	movsbl -0x45(%ebp),%eax
c0001080:	83 ec 0c             	sub    $0xc,%esp
c0001083:	50                   	push   %eax
c0001084:	e8 da f7 ff ff       	call   c0000863 <kprint_char>
c0001089:	83 c4 10             	add    $0x10,%esp
c000108c:	01 45 f0             	add    %eax,-0x10(%ebp)
                        }

                        if(!flags.left && lenpad>0)
c000108f:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0001096:	84 c0                	test   %al,%al
c0001098:	75 3b                	jne    c00010d5 <kprintf+0x821>
c000109a:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
c000109e:	7e 35                	jle    c00010d5 <kprintf+0x821>
                        {
                            if(flags.zero)
c00010a0:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c00010a7:	84 c0                	test   %al,%al
c00010a9:	74 16                	je     c00010c1 <kprintf+0x80d>
                                nchar += kprintn_char('0', lenpad);
c00010ab:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c00010ae:	83 ec 08             	sub    $0x8,%esp
c00010b1:	50                   	push   %eax
c00010b2:	6a 30                	push   $0x30
c00010b4:	e8 d2 f7 ff ff       	call   c000088b <kprintn_char>
c00010b9:	83 c4 10             	add    $0x10,%esp
c00010bc:	01 45 f0             	add    %eax,-0x10(%ebp)
c00010bf:	eb 14                	jmp    c00010d5 <kprintf+0x821>
                            else
                                nchar += kprintn_char(' ', lenpad);
c00010c1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c00010c4:	83 ec 08             	sub    $0x8,%esp
c00010c7:	50                   	push   %eax
c00010c8:	6a 20                	push   $0x20
c00010ca:	e8 bc f7 ff ff       	call   c000088b <kprintn_char>
c00010cf:	83 c4 10             	add    $0x10,%esp
c00010d2:	01 45 f0             	add    %eax,-0x10(%ebp)
                        }

                        if(!flags.zero && sign_char)
c00010d5:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c00010dc:	84 c0                	test   %al,%al
c00010de:	75 19                	jne    c00010f9 <kprintf+0x845>
c00010e0:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
c00010e4:	74 13                	je     c00010f9 <kprintf+0x845>
                            nchar += kprint_char(sign_char); //if not zero padding, write sign here
c00010e6:	0f be 45 bb          	movsbl -0x45(%ebp),%eax
c00010ea:	83 ec 0c             	sub    $0xc,%esp
c00010ed:	50                   	push   %eax
c00010ee:	e8 70 f7 ff ff       	call   c0000863 <kprint_char>
c00010f3:	83 c4 10             	add    $0x10,%esp
c00010f6:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprint(val_buf);
c00010f9:	83 ec 0c             	sub    $0xc,%esp
c00010fc:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0001102:	50                   	push   %eax
c0001103:	e8 11 f7 ff ff       	call   c0000819 <kprint>
c0001108:	83 c4 10             	add    $0x10,%esp
c000110b:	01 45 f0             	add    %eax,-0x10(%ebp)
                        nchar += kprint_char('.');
c000110e:	83 ec 0c             	sub    $0xc,%esp
c0001111:	6a 2e                	push   $0x2e
c0001113:	e8 4b f7 ff ff       	call   c0000863 <kprint_char>
c0001118:	83 c4 10             	add    $0x10,%esp
c000111b:	01 45 f0             	add    %eax,-0x10(%ebp)

                        //compute fractional digits.
                        float frac = f_value<0 ? -f_value - ui_part : f_value - ui_part;
c000111e:	d9 45 8c             	flds   -0x74(%ebp)
c0001121:	d9 ee                	fldz   
c0001123:	df f1                	fcomip %st(1),%st
c0001125:	dd d8                	fstp   %st(0)
c0001127:	76 23                	jbe    c000114c <kprintf+0x898>
c0001129:	d9 45 8c             	flds   -0x74(%ebp)
c000112c:	d9 e0                	fchs   
c000112e:	8b 45 bc             	mov    -0x44(%ebp),%eax
c0001131:	ba 00 00 00 00       	mov    $0x0,%edx
c0001136:	89 85 58 fd ff ff    	mov    %eax,-0x2a8(%ebp)
c000113c:	89 95 5c fd ff ff    	mov    %edx,-0x2a4(%ebp)
c0001142:	df ad 58 fd ff ff    	fildll -0x2a8(%ebp)
c0001148:	de e9                	fsubrp %st,%st(1)
c000114a:	eb 1f                	jmp    c000116b <kprintf+0x8b7>
c000114c:	8b 45 bc             	mov    -0x44(%ebp),%eax
c000114f:	ba 00 00 00 00       	mov    $0x0,%edx
c0001154:	89 85 58 fd ff ff    	mov    %eax,-0x2a8(%ebp)
c000115a:	89 95 5c fd ff ff    	mov    %edx,-0x2a4(%ebp)
c0001160:	df ad 58 fd ff ff    	fildll -0x2a8(%ebp)
c0001166:	d9 45 8c             	flds   -0x74(%ebp)
c0001169:	de e1                	fsubp  %st,%st(1)
c000116b:	d9 5d b0             	fstps  -0x50(%ebp)
                        int d;
                        for(int nn=0;nn<field_prec; nn++)
c000116e:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
c0001175:	eb 5e                	jmp    c00011d5 <kprintf+0x921>
                        {
                            frac *= 10.;
c0001177:	d9 45 b0             	flds   -0x50(%ebp)
c000117a:	d9 05 1c 44 00 c0    	flds   0xc000441c
c0001180:	de c9                	fmulp  %st,%st(1)
c0001182:	d9 5d b0             	fstps  -0x50(%ebp)
                            d = (int) frac;
c0001185:	d9 45 b0             	flds   -0x50(%ebp)
c0001188:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c000118e:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c0001195:	80 cc 0c             	or     $0xc,%ah
c0001198:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c000119f:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c00011a5:	db 5d 80             	fistpl -0x80(%ebp)
c00011a8:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
                            frac -= d;
c00011ae:	db 45 80             	fildl  -0x80(%ebp)
c00011b1:	d9 45 b0             	flds   -0x50(%ebp)
c00011b4:	de e1                	fsubp  %st,%st(1)
c00011b6:	d9 5d b0             	fstps  -0x50(%ebp)
                            nchar += kprint_char('0' + d);
c00011b9:	8b 45 80             	mov    -0x80(%ebp),%eax
c00011bc:	83 c0 30             	add    $0x30,%eax
c00011bf:	0f be c0             	movsbl %al,%eax
c00011c2:	83 ec 0c             	sub    $0xc,%esp
c00011c5:	50                   	push   %eax
c00011c6:	e8 98 f6 ff ff       	call   c0000863 <kprint_char>
c00011cb:	83 c4 10             	add    $0x10,%esp
c00011ce:	01 45 f0             	add    %eax,-0x10(%ebp)
                        for(int nn=0;nn<field_prec; nn++)
c00011d1:	83 45 ac 01          	addl   $0x1,-0x54(%ebp)
c00011d5:	8b 45 ac             	mov    -0x54(%ebp),%eax
c00011d8:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c00011db:	7c 9a                	jl     c0001177 <kprintf+0x8c3>
                        }

                        if(flags.left && lenpad>0)
c00011dd:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c00011e4:	84 c0                	test   %al,%al
c00011e6:	0f 84 5e 01 00 00    	je     c000134a <kprintf+0xa96>
c00011ec:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
c00011f0:	0f 8e 54 01 00 00    	jle    c000134a <kprintf+0xa96>
                            nchar += kprintn_char(' ', lenpad);
c00011f6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c00011f9:	83 ec 08             	sub    $0x8,%esp
c00011fc:	50                   	push   %eax
c00011fd:	6a 20                	push   $0x20
c00011ff:	e8 87 f6 ff ff       	call   c000088b <kprintn_char>
c0001204:	83 c4 10             	add    $0x10,%esp
c0001207:	01 45 f0             	add    %eax,-0x10(%ebp)

                    }
                    break;
c000120a:	e9 3b 01 00 00       	jmp    c000134a <kprintf+0xa96>
                case 'e':
                case 'E':
                case 'g':
                case 'G':
                    return -1; // not yet implemented
c000120f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0001214:	e9 6e 01 00 00       	jmp    c0001387 <kprintf+0xad3>
                case 'c':
                    {
                        char c = (char) va_arg(valist, int);
c0001219:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c000121f:	8d 50 04             	lea    0x4(%eax),%edx
c0001222:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0001228:	8b 00                	mov    (%eax),%eax
c000122a:	88 45 9b             	mov    %al,-0x65(%ebp)

                        if(field_width>1 && !flags.left)    
c000122d:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
c0001231:	7e 22                	jle    c0001255 <kprintf+0x9a1>
c0001233:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c000123a:	84 c0                	test   %al,%al
c000123c:	75 17                	jne    c0001255 <kprintf+0x9a1>
                            nchar += kprintn_char(' ', field_width-1);
c000123e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001241:	83 e8 01             	sub    $0x1,%eax
c0001244:	83 ec 08             	sub    $0x8,%esp
c0001247:	50                   	push   %eax
c0001248:	6a 20                	push   $0x20
c000124a:	e8 3c f6 ff ff       	call   c000088b <kprintn_char>
c000124f:	83 c4 10             	add    $0x10,%esp
c0001252:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprint_char(c);
c0001255:	0f be 45 9b          	movsbl -0x65(%ebp),%eax
c0001259:	83 ec 0c             	sub    $0xc,%esp
c000125c:	50                   	push   %eax
c000125d:	e8 01 f6 ff ff       	call   c0000863 <kprint_char>
c0001262:	83 c4 10             	add    $0x10,%esp
c0001265:	01 45 f0             	add    %eax,-0x10(%ebp)

                        if(field_width>1 && flags.left)    
c0001268:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
c000126c:	0f 8e db 00 00 00    	jle    c000134d <kprintf+0xa99>
c0001272:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0001279:	84 c0                	test   %al,%al
c000127b:	0f 84 cc 00 00 00    	je     c000134d <kprintf+0xa99>
                            nchar += kprintn_char(' ', field_width-1);
c0001281:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001284:	83 e8 01             	sub    $0x1,%eax
c0001287:	83 ec 08             	sub    $0x8,%esp
c000128a:	50                   	push   %eax
c000128b:	6a 20                	push   $0x20
c000128d:	e8 f9 f5 ff ff       	call   c000088b <kprintn_char>
c0001292:	83 c4 10             	add    $0x10,%esp
c0001295:	01 45 f0             	add    %eax,-0x10(%ebp)
                    }                    
                    break;
c0001298:	e9 b0 00 00 00       	jmp    c000134d <kprintf+0xa99>

                case 's':
                    {
                        char* str = va_arg(valist, char*);
c000129d:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c00012a3:	8d 50 04             	lea    0x4(%eax),%edx
c00012a6:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c00012ac:	8b 00                	mov    (%eax),%eax
c00012ae:	89 45 a4             	mov    %eax,-0x5c(%ebp)
                        int len = strlen(str);
c00012b1:	83 ec 0c             	sub    $0xc,%esp
c00012b4:	ff 75 a4             	pushl  -0x5c(%ebp)
c00012b7:	e8 2b 04 00 00       	call   c00016e7 <strlen>
c00012bc:	83 c4 10             	add    $0x10,%esp
c00012bf:	89 45 a8             	mov    %eax,-0x58(%ebp)
                        if(field_prec > 0 && field_prec < len)
c00012c2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c00012c6:	7e 0e                	jle    c00012d6 <kprintf+0xa22>
c00012c8:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00012cb:	3b 45 a8             	cmp    -0x58(%ebp),%eax
c00012ce:	7d 06                	jge    c00012d6 <kprintf+0xa22>
                            len = field_prec;
c00012d0:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00012d3:	89 45 a8             	mov    %eax,-0x58(%ebp)

                        int lenpad = field_width - len; 
c00012d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00012d9:	2b 45 a8             	sub    -0x58(%ebp),%eax
c00012dc:	89 45 a0             	mov    %eax,-0x60(%ebp)

                        if(lenpad>0 && !flags.left)    
c00012df:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
c00012e3:	7e 1f                	jle    c0001304 <kprintf+0xa50>
c00012e5:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c00012ec:	84 c0                	test   %al,%al
c00012ee:	75 14                	jne    c0001304 <kprintf+0xa50>
                            nchar += kprintn_char(' ', lenpad);
c00012f0:	8b 45 a0             	mov    -0x60(%ebp),%eax
c00012f3:	83 ec 08             	sub    $0x8,%esp
c00012f6:	50                   	push   %eax
c00012f7:	6a 20                	push   $0x20
c00012f9:	e8 8d f5 ff ff       	call   c000088b <kprintn_char>
c00012fe:	83 c4 10             	add    $0x10,%esp
c0001301:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprintn(str,len);
c0001304:	8b 45 a8             	mov    -0x58(%ebp),%eax
c0001307:	83 ec 08             	sub    $0x8,%esp
c000130a:	50                   	push   %eax
c000130b:	ff 75 a4             	pushl  -0x5c(%ebp)
c000130e:	e8 2f f5 ff ff       	call   c0000842 <kprintn>
c0001313:	83 c4 10             	add    $0x10,%esp
c0001316:	01 45 f0             	add    %eax,-0x10(%ebp)

                        if(lenpad>0 && flags.left)
c0001319:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
c000131d:	7e 31                	jle    c0001350 <kprintf+0xa9c>
c000131f:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0001326:	84 c0                	test   %al,%al
c0001328:	74 26                	je     c0001350 <kprintf+0xa9c>
                            nchar += kprintn_char(' ', lenpad);
c000132a:	8b 45 a0             	mov    -0x60(%ebp),%eax
c000132d:	83 ec 08             	sub    $0x8,%esp
c0001330:	50                   	push   %eax
c0001331:	6a 20                	push   $0x20
c0001333:	e8 53 f5 ff ff       	call   c000088b <kprintn_char>
c0001338:	83 c4 10             	add    $0x10,%esp
c000133b:	01 45 f0             	add    %eax,-0x10(%ebp)
                        
                    }
                    break;
c000133e:	eb 10                	jmp    c0001350 <kprintf+0xa9c>
                default:
                    //unsupported type
                    return -1;
c0001340:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0001345:	eb 40                	jmp    c0001387 <kprintf+0xad3>
                            break;
c0001347:	90                   	nop
c0001348:	eb 07                	jmp    c0001351 <kprintf+0xa9d>
                    break;
c000134a:	90                   	nop
c000134b:	eb 04                	jmp    c0001351 <kprintf+0xa9d>
                    break;
c000134d:	90                   	nop
c000134e:	eb 01                	jmp    c0001351 <kprintf+0xa9d>
                    break;
c0001350:	90                   	nop
                
            }
            f++;
c0001351:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0001355:	eb 1f                	jmp    c0001376 <kprintf+0xac2>
        }
        else
        {
            //this isnt part of a format code, just copy char to string and increment pointers
            kprint_char(*(f++));
c0001357:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000135a:	8d 50 01             	lea    0x1(%eax),%edx
c000135d:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0001360:	0f b6 00             	movzbl (%eax),%eax
c0001363:	0f be c0             	movsbl %al,%eax
c0001366:	83 ec 0c             	sub    $0xc,%esp
c0001369:	50                   	push   %eax
c000136a:	e8 f4 f4 ff ff       	call   c0000863 <kprint_char>
c000136f:	83 c4 10             	add    $0x10,%esp
            nchar++;
c0001372:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    while(f[0] != 0)
c0001376:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001379:	0f b6 00             	movzbl (%eax),%eax
c000137c:	84 c0                	test   %al,%al
c000137e:	0f 85 54 f5 ff ff    	jne    c00008d8 <kprintf+0x24>
    }

   /* clean memory reserved for valist */
   va_end(valist);

   return nchar; //number of characters copied to str
c0001384:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0001387:	c9                   	leave  
c0001388:	c3                   	ret    

c0001389 <format_uint>:
// base may be 2-32
// precision is per printf format, precision<0 represents default (unspecified) 
// cap = 0, alpha-numbers are capitalized [base>10 only]
// returns length of string (not counting null termination)
int format_uint(unsigned int value, char* str, unsigned int base, int precision, int cap)
{
c0001389:	55                   	push   %ebp
c000138a:	89 e5                	mov    %esp,%ebp
c000138c:	83 ec 18             	sub    $0x18,%esp
    if(base < 2 || base > 32)
c000138f:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c0001393:	76 06                	jbe    c000139b <format_uint+0x12>
c0001395:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
c0001399:	76 0a                	jbe    c00013a5 <format_uint+0x1c>
        return -1;
c000139b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00013a0:	e9 d1 00 00 00       	jmp    c0001476 <format_uint+0xed>

    //When 0 is printed with an explicit precision 0, the output is empty.
    if(value==0 && precision==0)
c00013a5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00013a9:	75 16                	jne    c00013c1 <format_uint+0x38>
c00013ab:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c00013af:	75 10                	jne    c00013c1 <format_uint+0x38>
    {
        str[0] = 0;
c00013b1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00013b4:	c6 00 00             	movb   $0x0,(%eax)
        return 0;
c00013b7:	b8 00 00 00 00       	mov    $0x0,%eax
c00013bc:	e9 b5 00 00 00       	jmp    c0001476 <format_uint+0xed>
    }

    // find number of digits
    int num_digits = numdigits_uint(value, base);
c00013c1:	83 ec 08             	sub    $0x8,%esp
c00013c4:	ff 75 10             	pushl  0x10(%ebp)
c00013c7:	ff 75 08             	pushl  0x8(%ebp)
c00013ca:	e8 a9 00 00 00       	call   c0001478 <numdigits_uint>
c00013cf:	83 c4 10             	add    $0x10,%esp
c00013d2:	89 45 ec             	mov    %eax,-0x14(%ebp)
    num_digits = num_digits>precision ? num_digits : precision;
c00013d5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00013d8:	39 45 14             	cmp    %eax,0x14(%ebp)
c00013db:	0f 4d 45 14          	cmovge 0x14(%ebp),%eax
c00013df:	89 45 ec             	mov    %eax,-0x14(%ebp)

    //write formatted number out in reverse order
    char* s = str + num_digits;
c00013e2:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00013e5:	8b 45 0c             	mov    0xc(%ebp),%eax
c00013e8:	01 d0                	add    %edx,%eax
c00013ea:	89 45 f4             	mov    %eax,-0xc(%ebp)

    *(s--) = '\0'; //null termination
c00013ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00013f0:	8d 50 ff             	lea    -0x1(%eax),%edx
c00013f3:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00013f6:	c6 00 00             	movb   $0x0,(%eax)

    //compute each digit from lowest to highest.
    unsigned int d;
    for(int nn=0;nn<num_digits; nn++)
c00013f9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0001400:	eb 69                	jmp    c000146b <format_uint+0xe2>
    {
        d = value % base;
c0001402:	8b 45 08             	mov    0x8(%ebp),%eax
c0001405:	ba 00 00 00 00       	mov    $0x0,%edx
c000140a:	f7 75 10             	divl   0x10(%ebp)
c000140d:	89 55 e8             	mov    %edx,-0x18(%ebp)
        value /= base;
c0001410:	8b 45 08             	mov    0x8(%ebp),%eax
c0001413:	ba 00 00 00 00       	mov    $0x0,%edx
c0001418:	f7 75 10             	divl   0x10(%ebp)
c000141b:	89 45 08             	mov    %eax,0x8(%ebp)

        //write digit into string and decrement pointer
        if(d < 10)
c000141e:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
c0001422:	77 15                	ja     c0001439 <format_uint+0xb0>
            *(s--) = d + '0';
c0001424:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001427:	8d 48 30             	lea    0x30(%eax),%ecx
c000142a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000142d:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001430:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0001433:	89 ca                	mov    %ecx,%edx
c0001435:	88 10                	mov    %dl,(%eax)
c0001437:	eb 2e                	jmp    c0001467 <format_uint+0xde>
        else if(cap == 0)
c0001439:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
c000143d:	75 15                	jne    c0001454 <format_uint+0xcb>
            *(s--) = d - 10 + 'a';
c000143f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001442:	8d 48 57             	lea    0x57(%eax),%ecx
c0001445:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001448:	8d 50 ff             	lea    -0x1(%eax),%edx
c000144b:	89 55 f4             	mov    %edx,-0xc(%ebp)
c000144e:	89 ca                	mov    %ecx,%edx
c0001450:	88 10                	mov    %dl,(%eax)
c0001452:	eb 13                	jmp    c0001467 <format_uint+0xde>
        else
            *(s--) = d - 10 + 'A';
c0001454:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001457:	8d 48 37             	lea    0x37(%eax),%ecx
c000145a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000145d:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001460:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0001463:	89 ca                	mov    %ecx,%edx
c0001465:	88 10                	mov    %dl,(%eax)
    for(int nn=0;nn<num_digits; nn++)
c0001467:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c000146b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000146e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0001471:	7c 8f                	jl     c0001402 <format_uint+0x79>
    }

    return num_digits;
c0001473:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c0001476:	c9                   	leave  
c0001477:	c3                   	ret    

c0001478 <numdigits_uint>:


//returns number of digits of unsigned int represented in given base
//num_digits is always >= 1
unsigned int numdigits_uint(unsigned int value, unsigned int base)
{
c0001478:	55                   	push   %ebp
c0001479:	89 e5                	mov    %esp,%ebp
c000147b:	83 ec 10             	sub    $0x10,%esp
    unsigned int num_digits = 1;
c000147e:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
    while(value >= base)
c0001485:	eb 12                	jmp    c0001499 <numdigits_uint+0x21>
    {
        num_digits++;
c0001487:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        value /= base;
c000148b:	8b 45 08             	mov    0x8(%ebp),%eax
c000148e:	ba 00 00 00 00       	mov    $0x0,%edx
c0001493:	f7 75 0c             	divl   0xc(%ebp)
c0001496:	89 45 08             	mov    %eax,0x8(%ebp)
    while(value >= base)
c0001499:	8b 45 08             	mov    0x8(%ebp),%eax
c000149c:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000149f:	73 e6                	jae    c0001487 <numdigits_uint+0xf>
    }
    return num_digits;
c00014a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00014a4:	c9                   	leave  
c00014a5:	c3                   	ret    

c00014a6 <kprintf_test>:



void kprintf_test()
{
c00014a6:	55                   	push   %ebp
c00014a7:	89 e5                	mov    %esp,%ebp
c00014a9:	83 ec 18             	sub    $0x18,%esp
    int num = 12345678;    
c00014ac:	c7 45 f4 4e 61 bc 00 	movl   $0xbc614e,-0xc(%ebp)
    kprintf("\nkprintf() tests...\n", num);
c00014b3:	83 ec 08             	sub    $0x8,%esp
c00014b6:	ff 75 f4             	pushl  -0xc(%ebp)
c00014b9:	68 d0 41 00 c0       	push   $0xc00041d0
c00014be:	e8 f1 f3 ff ff       	call   c00008b4 <kprintf>
c00014c3:	83 c4 10             	add    $0x10,%esp
    kprintf("Fixed width, right justify:\n");
c00014c6:	83 ec 0c             	sub    $0xc,%esp
c00014c9:	68 e5 41 00 c0       	push   $0xc00041e5
c00014ce:	e8 e1 f3 ff ff       	call   c00008b4 <kprintf>
c00014d3:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%15d]\n", num);
c00014d6:	83 ec 08             	sub    $0x8,%esp
c00014d9:	ff 75 f4             	pushl  -0xc(%ebp)
c00014dc:	68 02 42 00 c0       	push   $0xc0004202
c00014e1:	e8 ce f3 ff ff       	call   c00008b4 <kprintf>
c00014e6:	83 c4 10             	add    $0x10,%esp
    kprintf("Hex:     [%#15x]\n", num);
c00014e9:	83 ec 08             	sub    $0x8,%esp
c00014ec:	ff 75 f4             	pushl  -0xc(%ebp)
c00014ef:	68 13 42 00 c0       	push   $0xc0004213
c00014f4:	e8 bb f3 ff ff       	call   c00008b4 <kprintf>
c00014f9:	83 c4 10             	add    $0x10,%esp
    kprintf("Oct:     [%#15o]\n", num);
c00014fc:	83 ec 08             	sub    $0x8,%esp
c00014ff:	ff 75 f4             	pushl  -0xc(%ebp)
c0001502:	68 25 42 00 c0       	push   $0xc0004225
c0001507:	e8 a8 f3 ff ff       	call   c00008b4 <kprintf>
c000150c:	83 c4 10             	add    $0x10,%esp
    kprintf("String:  [%15s]\n", "Hello World!");
c000150f:	83 ec 08             	sub    $0x8,%esp
c0001512:	68 37 42 00 c0       	push   $0xc0004237
c0001517:	68 44 42 00 c0       	push   $0xc0004244
c000151c:	e8 93 f3 ff ff       	call   c00008b4 <kprintf>
c0001521:	83 c4 10             	add    $0x10,%esp
    kprintf("Char:    [%15c]\n", '!');
c0001524:	83 ec 08             	sub    $0x8,%esp
c0001527:	6a 21                	push   $0x21
c0001529:	68 55 42 00 c0       	push   $0xc0004255
c000152e:	e8 81 f3 ff ff       	call   c00008b4 <kprintf>
c0001533:	83 c4 10             	add    $0x10,%esp

    kprintf("\nFixed width, left justify:\n");
c0001536:	83 ec 0c             	sub    $0xc,%esp
c0001539:	68 66 42 00 c0       	push   $0xc0004266
c000153e:	e8 71 f3 ff ff       	call   c00008b4 <kprintf>
c0001543:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%-15d]\n", num);
c0001546:	83 ec 08             	sub    $0x8,%esp
c0001549:	ff 75 f4             	pushl  -0xc(%ebp)
c000154c:	68 83 42 00 c0       	push   $0xc0004283
c0001551:	e8 5e f3 ff ff       	call   c00008b4 <kprintf>
c0001556:	83 c4 10             	add    $0x10,%esp
    kprintf("Hex:     [%-#15x]\n", num);
c0001559:	83 ec 08             	sub    $0x8,%esp
c000155c:	ff 75 f4             	pushl  -0xc(%ebp)
c000155f:	68 95 42 00 c0       	push   $0xc0004295
c0001564:	e8 4b f3 ff ff       	call   c00008b4 <kprintf>
c0001569:	83 c4 10             	add    $0x10,%esp
    kprintf("String:  [%-15s]\n", "Hello World!");
c000156c:	83 ec 08             	sub    $0x8,%esp
c000156f:	68 37 42 00 c0       	push   $0xc0004237
c0001574:	68 a8 42 00 c0       	push   $0xc00042a8
c0001579:	e8 36 f3 ff ff       	call   c00008b4 <kprintf>
c000157e:	83 c4 10             	add    $0x10,%esp

    kprintf("\nFixed Precision:\n");
c0001581:	83 ec 0c             	sub    $0xc,%esp
c0001584:	68 ba 42 00 c0       	push   $0xc00042ba
c0001589:	e8 26 f3 ff ff       	call   c00008b4 <kprintf>
c000158e:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%15.10d]\nHex:     [%#15.10x]\nOct:     [%#15.10o]\nString:  [%15.10s]\n", 
c0001591:	83 ec 0c             	sub    $0xc,%esp
c0001594:	68 37 42 00 c0       	push   $0xc0004237
c0001599:	ff 75 f4             	pushl  -0xc(%ebp)
c000159c:	ff 75 f4             	pushl  -0xc(%ebp)
c000159f:	ff 75 f4             	pushl  -0xc(%ebp)
c00015a2:	68 d0 42 00 c0       	push   $0xc00042d0
c00015a7:	e8 08 f3 ff ff       	call   c00008b4 <kprintf>
c00015ac:	83 c4 20             	add    $0x20,%esp
        num, num, num, "Hello World!");

    kprintf("\nLeading Zeros:\n");
c00015af:	83 ec 0c             	sub    $0xc,%esp
c00015b2:	68 1f 43 00 c0       	push   $0xc000431f
c00015b7:	e8 f8 f2 ff ff       	call   c00008b4 <kprintf>
c00015bc:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%015.10d]\nHex:     [%#015.10x]\nOct:     [%#015.10o]\n",num, num, num);
c00015bf:	ff 75 f4             	pushl  -0xc(%ebp)
c00015c2:	ff 75 f4             	pushl  -0xc(%ebp)
c00015c5:	ff 75 f4             	pushl  -0xc(%ebp)
c00015c8:	68 30 43 00 c0       	push   $0xc0004330
c00015cd:	e8 e2 f2 ff ff       	call   c00008b4 <kprintf>
c00015d2:	83 c4 10             	add    $0x10,%esp

    kprintf("Signed (none):  [%d], [%d]\n",num, -num);
c00015d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00015d8:	f7 d8                	neg    %eax
c00015da:	83 ec 04             	sub    $0x4,%esp
c00015dd:	50                   	push   %eax
c00015de:	ff 75 f4             	pushl  -0xc(%ebp)
c00015e1:	68 6f 43 00 c0       	push   $0xc000436f
c00015e6:	e8 c9 f2 ff ff       	call   c00008b4 <kprintf>
c00015eb:	83 c4 10             	add    $0x10,%esp
    kprintf("Signed (space): [% d], [% d]\n",num, -num);
c00015ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00015f1:	f7 d8                	neg    %eax
c00015f3:	83 ec 04             	sub    $0x4,%esp
c00015f6:	50                   	push   %eax
c00015f7:	ff 75 f4             	pushl  -0xc(%ebp)
c00015fa:	68 8b 43 00 c0       	push   $0xc000438b
c00015ff:	e8 b0 f2 ff ff       	call   c00008b4 <kprintf>
c0001604:	83 c4 10             	add    $0x10,%esp
    kprintf("Signed (+):     [%+d], [%+d]\n",num, -num);
c0001607:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000160a:	f7 d8                	neg    %eax
c000160c:	83 ec 04             	sub    $0x4,%esp
c000160f:	50                   	push   %eax
c0001610:	ff 75 f4             	pushl  -0xc(%ebp)
c0001613:	68 a9 43 00 c0       	push   $0xc00043a9
c0001618:	e8 97 f2 ff ff       	call   c00008b4 <kprintf>
c000161d:	83 c4 10             	add    $0x10,%esp

    float f = 1.23456789;
c0001620:	d9 05 20 44 00 c0    	flds   0xc0004420
c0001626:	d9 5d f0             	fstps  -0x10(%ebp)
    kprintf("\nfloat:     [%15.f]\n",f);
c0001629:	d9 45 f0             	flds   -0x10(%ebp)
c000162c:	83 ec 04             	sub    $0x4,%esp
c000162f:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001633:	dd 1c 24             	fstpl  (%esp)
c0001636:	68 c7 43 00 c0       	push   $0xc00043c7
c000163b:	e8 74 f2 ff ff       	call   c00008b4 <kprintf>
c0001640:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.3f]\n",f);
c0001643:	d9 45 f0             	flds   -0x10(%ebp)
c0001646:	83 ec 04             	sub    $0x4,%esp
c0001649:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c000164d:	dd 1c 24             	fstpl  (%esp)
c0001650:	68 dc 43 00 c0       	push   $0xc00043dc
c0001655:	e8 5a f2 ff ff       	call   c00008b4 <kprintf>
c000165a:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.10f]\n",f);
c000165d:	d9 45 f0             	flds   -0x10(%ebp)
c0001660:	83 ec 04             	sub    $0x4,%esp
c0001663:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001667:	dd 1c 24             	fstpl  (%esp)
c000166a:	68 f1 43 00 c0       	push   $0xc00043f1
c000166f:	e8 40 f2 ff ff       	call   c00008b4 <kprintf>
c0001674:	83 c4 10             	add    $0x10,%esp

    f = -12345.6789;
c0001677:	d9 05 24 44 00 c0    	flds   0xc0004424
c000167d:	d9 5d f0             	fstps  -0x10(%ebp)
    kprintf("float:     [%15f]\n",f);
c0001680:	d9 45 f0             	flds   -0x10(%ebp)
c0001683:	83 ec 04             	sub    $0x4,%esp
c0001686:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c000168a:	dd 1c 24             	fstpl  (%esp)
c000168d:	68 07 44 00 c0       	push   $0xc0004407
c0001692:	e8 1d f2 ff ff       	call   c00008b4 <kprintf>
c0001697:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.3f]\n",f);
c000169a:	d9 45 f0             	flds   -0x10(%ebp)
c000169d:	83 ec 04             	sub    $0x4,%esp
c00016a0:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c00016a4:	dd 1c 24             	fstpl  (%esp)
c00016a7:	68 dc 43 00 c0       	push   $0xc00043dc
c00016ac:	e8 03 f2 ff ff       	call   c00008b4 <kprintf>
c00016b1:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.10f]\n",f);
c00016b4:	d9 45 f0             	flds   -0x10(%ebp)
c00016b7:	83 ec 04             	sub    $0x4,%esp
c00016ba:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c00016be:	dd 1c 24             	fstpl  (%esp)
c00016c1:	68 f1 43 00 c0       	push   $0xc00043f1
c00016c6:	e8 e9 f1 ff ff       	call   c00008b4 <kprintf>
c00016cb:	83 c4 10             	add    $0x10,%esp
}
c00016ce:	90                   	nop
c00016cf:	c9                   	leave  
c00016d0:	c3                   	ret    

c00016d1 <panic>:
#include "common.h"
#include "kprintf.h"

void panic(char* str)
{
c00016d1:	55                   	push   %ebp
c00016d2:	89 e5                	mov    %esp,%ebp
c00016d4:	83 ec 08             	sub    $0x8,%esp
    kprintf(str);
c00016d7:	83 ec 0c             	sub    $0xc,%esp
c00016da:	ff 75 08             	pushl  0x8(%ebp)
c00016dd:	e8 d2 f1 ff ff       	call   c00008b4 <kprintf>
c00016e2:	83 c4 10             	add    $0x10,%esp
    while(true);
c00016e5:	eb fe                	jmp    c00016e5 <panic+0x14>

c00016e7 <strlen>:
}

size_t strlen(const char* str) 
{
c00016e7:	55                   	push   %ebp
c00016e8:	89 e5                	mov    %esp,%ebp
c00016ea:	83 ec 10             	sub    $0x10,%esp
	size_t len = 0;
c00016ed:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while (str[len])
c00016f4:	eb 04                	jmp    c00016fa <strlen+0x13>
		len++;
c00016f6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
	while (str[len])
c00016fa:	8b 55 08             	mov    0x8(%ebp),%edx
c00016fd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001700:	01 d0                	add    %edx,%eax
c0001702:	0f b6 00             	movzbl (%eax),%eax
c0001705:	84 c0                	test   %al,%al
c0001707:	75 ed                	jne    c00016f6 <strlen+0xf>
	return len;
c0001709:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c000170c:	c9                   	leave  
c000170d:	c3                   	ret    

c000170e <memcpy>:

// copy n bytes from src to dest
void *memcpy(void *dest, const void *src, size_t n)
{
c000170e:	55                   	push   %ebp
c000170f:	89 e5                	mov    %esp,%ebp
c0001711:	83 ec 20             	sub    $0x20,%esp
    //system wordsize is equal to length of size_t
    size_t n_words = n/sizeof(size_t);
c0001714:	8b 45 10             	mov    0x10(%ebp),%eax
c0001717:	c1 e8 02             	shr    $0x2,%eax
c000171a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t* dest_word = (size_t *) dest;
c000171d:	8b 45 08             	mov    0x8(%ebp),%eax
c0001720:	89 45 f0             	mov    %eax,-0x10(%ebp)
    size_t* src_word = (size_t *) src;
c0001723:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001726:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for(size_t nn=0; nn<n_words; nn++)
c0001729:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0001730:	eb 26                	jmp    c0001758 <memcpy+0x4a>
        dest_word[nn]=src_word[nn];
c0001732:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001735:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000173c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000173f:	01 d0                	add    %edx,%eax
c0001741:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0001744:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
c000174b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000174e:	01 ca                	add    %ecx,%edx
c0001750:	8b 00                	mov    (%eax),%eax
c0001752:	89 02                	mov    %eax,(%edx)
    for(size_t nn=0; nn<n_words; nn++)
c0001754:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0001758:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000175b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c000175e:	72 d2                	jb     c0001732 <memcpy+0x24>
    
    //copy remaining bytes
    size_t n_bytes = n - n_words*sizeof(size_t);
c0001760:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001763:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000176a:	8b 45 10             	mov    0x10(%ebp),%eax
c000176d:	29 d0                	sub    %edx,%eax
c000176f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(n_bytes > 0)
c0001772:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0001776:	74 36                	je     c00017ae <memcpy+0xa0>
    {
        char* dest_byte = (char *) dest;
c0001778:	8b 45 08             	mov    0x8(%ebp),%eax
c000177b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        char* src_byte = (char *) src;
c000177e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001781:	89 45 e0             	mov    %eax,-0x20(%ebp)
        for(size_t nn=0; nn<n_bytes; nn++)
c0001784:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c000178b:	eb 19                	jmp    c00017a6 <memcpy+0x98>
            dest_byte[nn]=src_byte[nn];
c000178d:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0001790:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0001793:	01 d0                	add    %edx,%eax
c0001795:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c0001798:	8b 55 f8             	mov    -0x8(%ebp),%edx
c000179b:	01 ca                	add    %ecx,%edx
c000179d:	0f b6 00             	movzbl (%eax),%eax
c00017a0:	88 02                	mov    %al,(%edx)
        for(size_t nn=0; nn<n_bytes; nn++)
c00017a2:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c00017a6:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00017a9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c00017ac:	72 df                	jb     c000178d <memcpy+0x7f>
    }

    return dest;
c00017ae:	8b 45 08             	mov    0x8(%ebp),%eax
}
c00017b1:	c9                   	leave  
c00017b2:	c3                   	ret    

c00017b3 <memset>:

void* memset(void* addr, int val, size_t cnt)
{
c00017b3:	55                   	push   %ebp
c00017b4:	89 e5                	mov    %esp,%ebp
c00017b6:	83 ec 10             	sub    $0x10,%esp
    char* m = (char*) addr;
c00017b9:	8b 45 08             	mov    0x8(%ebp),%eax
c00017bc:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for(size_t nn=0;nn<cnt; nn++)
c00017bf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00017c6:	eb 11                	jmp    c00017d9 <memset+0x26>
        m[nn] = val;
c00017c8:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00017cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00017ce:	01 d0                	add    %edx,%eax
c00017d0:	8b 55 0c             	mov    0xc(%ebp),%edx
c00017d3:	88 10                	mov    %dl,(%eax)
    for(size_t nn=0;nn<cnt; nn++)
c00017d5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c00017d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00017dc:	3b 45 10             	cmp    0x10(%ebp),%eax
c00017df:	72 e7                	jb     c00017c8 <memset+0x15>

    return addr;
c00017e1:	8b 45 08             	mov    0x8(%ebp),%eax
}
c00017e4:	c9                   	leave  
c00017e5:	c3                   	ret    

c00017e6 <atoi>:


int atoi(const char* str)
{
c00017e6:	55                   	push   %ebp
c00017e7:	89 e5                	mov    %esp,%ebp
c00017e9:	83 ec 20             	sub    $0x20,%esp
    int p = 0;
c00017ec:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    int neg = 0;
c00017f3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    //find start of number string, ignore whitespace
    while(str[p] == '-' || str[p] == ' ' || (str[p] >= 9 && str[p] <= 13))
c00017fa:	eb 41                	jmp    c000183d <atoi+0x57>
    {
        if(str[p++] == '-')
c00017fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00017ff:	8d 50 01             	lea    0x1(%eax),%edx
c0001802:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001805:	89 c2                	mov    %eax,%edx
c0001807:	8b 45 08             	mov    0x8(%ebp),%eax
c000180a:	01 d0                	add    %edx,%eax
c000180c:	0f b6 00             	movzbl (%eax),%eax
c000180f:	3c 2d                	cmp    $0x2d,%al
c0001811:	75 09                	jne    c000181c <atoi+0x36>
        {
            neg=1;
c0001813:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
            break;
c000181a:	eb 5d                	jmp    c0001879 <atoi+0x93>
        }
        if(str[p++] == '\0')
c000181c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000181f:	8d 50 01             	lea    0x1(%eax),%edx
c0001822:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001825:	89 c2                	mov    %eax,%edx
c0001827:	8b 45 08             	mov    0x8(%ebp),%eax
c000182a:	01 d0                	add    %edx,%eax
c000182c:	0f b6 00             	movzbl (%eax),%eax
c000182f:	84 c0                	test   %al,%al
c0001831:	75 0a                	jne    c000183d <atoi+0x57>
            return 0; //invalid string (only whitespace found)
c0001833:	b8 00 00 00 00       	mov    $0x0,%eax
c0001838:	e9 ee 00 00 00       	jmp    c000192b <atoi+0x145>
    while(str[p] == '-' || str[p] == ' ' || (str[p] >= 9 && str[p] <= 13))
c000183d:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0001840:	8b 45 08             	mov    0x8(%ebp),%eax
c0001843:	01 d0                	add    %edx,%eax
c0001845:	0f b6 00             	movzbl (%eax),%eax
c0001848:	3c 2d                	cmp    $0x2d,%al
c000184a:	74 b0                	je     c00017fc <atoi+0x16>
c000184c:	8b 55 fc             	mov    -0x4(%ebp),%edx
c000184f:	8b 45 08             	mov    0x8(%ebp),%eax
c0001852:	01 d0                	add    %edx,%eax
c0001854:	0f b6 00             	movzbl (%eax),%eax
c0001857:	3c 20                	cmp    $0x20,%al
c0001859:	74 a1                	je     c00017fc <atoi+0x16>
c000185b:	8b 55 fc             	mov    -0x4(%ebp),%edx
c000185e:	8b 45 08             	mov    0x8(%ebp),%eax
c0001861:	01 d0                	add    %edx,%eax
c0001863:	0f b6 00             	movzbl (%eax),%eax
c0001866:	3c 08                	cmp    $0x8,%al
c0001868:	7e 0f                	jle    c0001879 <atoi+0x93>
c000186a:	8b 55 fc             	mov    -0x4(%ebp),%edx
c000186d:	8b 45 08             	mov    0x8(%ebp),%eax
c0001870:	01 d0                	add    %edx,%eax
c0001872:	0f b6 00             	movzbl (%eax),%eax
c0001875:	3c 0d                	cmp    $0xd,%al
c0001877:	7e 83                	jle    c00017fc <atoi+0x16>
    }

    int num_start = p;
c0001879:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000187c:	89 45 e8             	mov    %eax,-0x18(%ebp)

    //find end of integer string (ints only, no decimal point)
    while(str[p] >= '0' && str[p] <= '9')
c000187f:	eb 21                	jmp    c00018a2 <atoi+0xbc>
    {
        if(str[p++] == '\0')
c0001881:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001884:	8d 50 01             	lea    0x1(%eax),%edx
c0001887:	89 55 fc             	mov    %edx,-0x4(%ebp)
c000188a:	89 c2                	mov    %eax,%edx
c000188c:	8b 45 08             	mov    0x8(%ebp),%eax
c000188f:	01 d0                	add    %edx,%eax
c0001891:	0f b6 00             	movzbl (%eax),%eax
c0001894:	84 c0                	test   %al,%al
c0001896:	75 0a                	jne    c00018a2 <atoi+0xbc>
            return 0; //invalid string (only whitespace found)
c0001898:	b8 00 00 00 00       	mov    $0x0,%eax
c000189d:	e9 89 00 00 00       	jmp    c000192b <atoi+0x145>
    while(str[p] >= '0' && str[p] <= '9')
c00018a2:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00018a5:	8b 45 08             	mov    0x8(%ebp),%eax
c00018a8:	01 d0                	add    %edx,%eax
c00018aa:	0f b6 00             	movzbl (%eax),%eax
c00018ad:	3c 2f                	cmp    $0x2f,%al
c00018af:	7e 0f                	jle    c00018c0 <atoi+0xda>
c00018b1:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00018b4:	8b 45 08             	mov    0x8(%ebp),%eax
c00018b7:	01 d0                	add    %edx,%eax
c00018b9:	0f b6 00             	movzbl (%eax),%eax
c00018bc:	3c 39                	cmp    $0x39,%al
c00018be:	7e c1                	jle    c0001881 <atoi+0x9b>
    }

    if(num_start == p) return 0; //length 0 string
c00018c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00018c3:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c00018c6:	75 07                	jne    c00018cf <atoi+0xe9>
c00018c8:	b8 00 00 00 00       	mov    $0x0,%eax
c00018cd:	eb 5c                	jmp    c000192b <atoi+0x145>

    int number = 0;
c00018cf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    int place = 1;
c00018d6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    //iterate backwards through number to add each digit
    for(int digit = p-1; digit >= num_start; digit--)
c00018dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00018e0:	83 e8 01             	sub    $0x1,%eax
c00018e3:	89 45 ec             	mov    %eax,-0x14(%ebp)
c00018e6:	eb 2b                	jmp    c0001913 <atoi+0x12d>
    {
        number += (int) (str[digit] - '0') * place;
c00018e8:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00018eb:	8b 45 08             	mov    0x8(%ebp),%eax
c00018ee:	01 d0                	add    %edx,%eax
c00018f0:	0f b6 00             	movzbl (%eax),%eax
c00018f3:	0f be c0             	movsbl %al,%eax
c00018f6:	83 e8 30             	sub    $0x30,%eax
c00018f9:	0f af 45 f0          	imul   -0x10(%ebp),%eax
c00018fd:	01 45 f4             	add    %eax,-0xc(%ebp)
        place *= 10;
c0001900:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001903:	89 d0                	mov    %edx,%eax
c0001905:	c1 e0 02             	shl    $0x2,%eax
c0001908:	01 d0                	add    %edx,%eax
c000190a:	01 c0                	add    %eax,%eax
c000190c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for(int digit = p-1; digit >= num_start; digit--)
c000190f:	83 6d ec 01          	subl   $0x1,-0x14(%ebp)
c0001913:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001916:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0001919:	7d cd                	jge    c00018e8 <atoi+0x102>
    }

    if(neg)
c000191b:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c000191f:	74 07                	je     c0001928 <atoi+0x142>
        return -1*number;
c0001921:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001924:	f7 d8                	neg    %eax
c0001926:	eb 03                	jmp    c000192b <atoi+0x145>
    else
        return number;
c0001928:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c000192b:	c9                   	leave  
c000192c:	c3                   	ret    

c000192d <itoa>:

char* itoa( int value, char* str, int base)
{
c000192d:	55                   	push   %ebp
c000192e:	89 e5                	mov    %esp,%ebp
c0001930:	83 ec 20             	sub    $0x20,%esp
    if(base < 2 || base > 32)
c0001933:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c0001937:	7e 06                	jle    c000193f <itoa+0x12>
c0001939:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
c000193d:	7e 0a                	jle    c0001949 <itoa+0x1c>
        return NULL;
c000193f:	b8 00 00 00 00       	mov    $0x0,%eax
c0001944:	e9 df 00 00 00       	jmp    c0001a28 <itoa+0xfb>

    //handle zero as special case 
    if(value == 0)
c0001949:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c000194d:	75 17                	jne    c0001966 <itoa+0x39>
    {
        str[0] = '0';
c000194f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001952:	c6 00 30             	movb   $0x30,(%eax)
        str[1] = '\0';
c0001955:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001958:	83 c0 01             	add    $0x1,%eax
c000195b:	c6 00 00             	movb   $0x0,(%eax)
        return str;
c000195e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001961:	e9 c2 00 00 00       	jmp    c0001a28 <itoa+0xfb>
    }

    char* s = str;
c0001966:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001969:	89 45 fc             	mov    %eax,-0x4(%ebp)
    unsigned int residual; //holds the unsigned value still to be parsed
    if(base == 10 && value < 0)
c000196c:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
c0001970:	75 1c                	jne    c000198e <itoa+0x61>
c0001972:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0001976:	79 16                	jns    c000198e <itoa+0x61>
    {
        residual = -value;
c0001978:	8b 45 08             	mov    0x8(%ebp),%eax
c000197b:	f7 d8                	neg    %eax
c000197d:	89 45 f8             	mov    %eax,-0x8(%ebp)
        *(s++) = '-';
c0001980:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001983:	8d 50 01             	lea    0x1(%eax),%edx
c0001986:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001989:	c6 00 2d             	movb   $0x2d,(%eax)
c000198c:	eb 06                	jmp    c0001994 <itoa+0x67>
    }
    else
    {
        //all non-decimal numbers are treated as unsigned
        residual = (unsigned int) value;
c000198e:	8b 45 08             	mov    0x8(%ebp),%eax
c0001991:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    
    // find number of digits so that we can parse number
    // directly into string from lowest to highest digit    
    unsigned int num_digits = 0;
c0001994:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    unsigned int temp = residual;
c000199b:	8b 45 f8             	mov    -0x8(%ebp),%eax
c000199e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(temp>0)
c00019a1:	eb 14                	jmp    c00019b7 <itoa+0x8a>
    {
        num_digits++;
c00019a3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
        temp /= base;
c00019a7:	8b 4d 10             	mov    0x10(%ebp),%ecx
c00019aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00019ad:	ba 00 00 00 00       	mov    $0x0,%edx
c00019b2:	f7 f1                	div    %ecx
c00019b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(temp>0)
c00019b7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00019bb:	75 e6                	jne    c00019a3 <itoa+0x76>
    }

    //point at end of string
    s += num_digits;
c00019bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00019c0:	01 45 fc             	add    %eax,-0x4(%ebp)
    *(s--) = '\0'; //null termination
c00019c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00019c6:	8d 50 ff             	lea    -0x1(%eax),%edx
c00019c9:	89 55 fc             	mov    %edx,-0x4(%ebp)
c00019cc:	c6 00 00             	movb   $0x0,(%eax)

    //compute each digit from lowest to highest.
    unsigned int digit;
    while(residual>0)
c00019cf:	eb 4e                	jmp    c0001a1f <itoa+0xf2>
    {
        digit = residual % base;
c00019d1:	8b 4d 10             	mov    0x10(%ebp),%ecx
c00019d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00019d7:	ba 00 00 00 00       	mov    $0x0,%edx
c00019dc:	f7 f1                	div    %ecx
c00019de:	89 55 ec             	mov    %edx,-0x14(%ebp)
        residual /= base;
c00019e1:	8b 4d 10             	mov    0x10(%ebp),%ecx
c00019e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00019e7:	ba 00 00 00 00       	mov    $0x0,%edx
c00019ec:	f7 f1                	div    %ecx
c00019ee:	89 45 f8             	mov    %eax,-0x8(%ebp)

        //write digit into string and decrement pointer
        if(digit < 10)
c00019f1:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
c00019f5:	77 15                	ja     c0001a0c <itoa+0xdf>
            *(s--) = digit + '0';
c00019f7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00019fa:	8d 48 30             	lea    0x30(%eax),%ecx
c00019fd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001a00:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001a03:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001a06:	89 ca                	mov    %ecx,%edx
c0001a08:	88 10                	mov    %dl,(%eax)
c0001a0a:	eb 13                	jmp    c0001a1f <itoa+0xf2>
        else
            *(s--) = digit - 10 + 'A';        
c0001a0c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001a0f:	8d 48 37             	lea    0x37(%eax),%ecx
c0001a12:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001a15:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001a18:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001a1b:	89 ca                	mov    %ecx,%edx
c0001a1d:	88 10                	mov    %dl,(%eax)
    while(residual>0)
c0001a1f:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0001a23:	75 ac                	jne    c00019d1 <itoa+0xa4>
    }

    return str;
c0001a25:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c0001a28:	c9                   	leave  
c0001a29:	c3                   	ret    

c0001a2a <printregs>:
#include "regs.h"
#include "kprintf.h"

void printregs(const reg_t* regs)
{
c0001a2a:	55                   	push   %ebp
c0001a2b:	89 e5                	mov    %esp,%ebp
c0001a2d:	57                   	push   %edi
c0001a2e:	56                   	push   %esi
c0001a2f:	53                   	push   %ebx
c0001a30:	83 ec 0c             	sub    $0xc,%esp
    kprintf("Registers:\n");
c0001a33:	83 ec 0c             	sub    $0xc,%esp
c0001a36:	68 28 44 00 c0       	push   $0xc0004428
c0001a3b:	e8 74 ee ff ff       	call   c00008b4 <kprintf>
c0001a40:	83 c4 10             	add    $0x10,%esp
    kprintf("eax: 0x%x\n", regs->eax);
c0001a43:	8b 45 08             	mov    0x8(%ebp),%eax
c0001a46:	8b 00                	mov    (%eax),%eax
c0001a48:	83 ec 08             	sub    $0x8,%esp
c0001a4b:	50                   	push   %eax
c0001a4c:	68 34 44 00 c0       	push   $0xc0004434
c0001a51:	e8 5e ee ff ff       	call   c00008b4 <kprintf>
c0001a56:	83 c4 10             	add    $0x10,%esp
    kprintf("ebx: 0x%x\n", regs->ebx);
c0001a59:	8b 45 08             	mov    0x8(%ebp),%eax
c0001a5c:	8b 40 04             	mov    0x4(%eax),%eax
c0001a5f:	83 ec 08             	sub    $0x8,%esp
c0001a62:	50                   	push   %eax
c0001a63:	68 3f 44 00 c0       	push   $0xc000443f
c0001a68:	e8 47 ee ff ff       	call   c00008b4 <kprintf>
c0001a6d:	83 c4 10             	add    $0x10,%esp
    kprintf("ecx: 0x%x\n", regs->ecx);
c0001a70:	8b 45 08             	mov    0x8(%ebp),%eax
c0001a73:	8b 40 08             	mov    0x8(%eax),%eax
c0001a76:	83 ec 08             	sub    $0x8,%esp
c0001a79:	50                   	push   %eax
c0001a7a:	68 4a 44 00 c0       	push   $0xc000444a
c0001a7f:	e8 30 ee ff ff       	call   c00008b4 <kprintf>
c0001a84:	83 c4 10             	add    $0x10,%esp
    kprintf("edx: 0x%x\n", regs->edx);
c0001a87:	8b 45 08             	mov    0x8(%ebp),%eax
c0001a8a:	8b 40 0c             	mov    0xc(%eax),%eax
c0001a8d:	83 ec 08             	sub    $0x8,%esp
c0001a90:	50                   	push   %eax
c0001a91:	68 55 44 00 c0       	push   $0xc0004455
c0001a96:	e8 19 ee ff ff       	call   c00008b4 <kprintf>
c0001a9b:	83 c4 10             	add    $0x10,%esp
    kprintf("esi: 0x%x\n", regs->esi);
c0001a9e:	8b 45 08             	mov    0x8(%ebp),%eax
c0001aa1:	8b 40 10             	mov    0x10(%eax),%eax
c0001aa4:	83 ec 08             	sub    $0x8,%esp
c0001aa7:	50                   	push   %eax
c0001aa8:	68 60 44 00 c0       	push   $0xc0004460
c0001aad:	e8 02 ee ff ff       	call   c00008b4 <kprintf>
c0001ab2:	83 c4 10             	add    $0x10,%esp
    kprintf("edi: 0x%x\n", regs->edi);
c0001ab5:	8b 45 08             	mov    0x8(%ebp),%eax
c0001ab8:	8b 40 14             	mov    0x14(%eax),%eax
c0001abb:	83 ec 08             	sub    $0x8,%esp
c0001abe:	50                   	push   %eax
c0001abf:	68 6b 44 00 c0       	push   $0xc000446b
c0001ac4:	e8 eb ed ff ff       	call   c00008b4 <kprintf>
c0001ac9:	83 c4 10             	add    $0x10,%esp
    kprintf("ebp: 0x%x\n", regs->ebp);
c0001acc:	8b 45 08             	mov    0x8(%ebp),%eax
c0001acf:	8b 40 1c             	mov    0x1c(%eax),%eax
c0001ad2:	83 ec 08             	sub    $0x8,%esp
c0001ad5:	50                   	push   %eax
c0001ad6:	68 76 44 00 c0       	push   $0xc0004476
c0001adb:	e8 d4 ed ff ff       	call   c00008b4 <kprintf>
c0001ae0:	83 c4 10             	add    $0x10,%esp
    kprintf("esp: 0x%x\n", regs->esp);
c0001ae3:	8b 45 08             	mov    0x8(%ebp),%eax
c0001ae6:	8b 40 18             	mov    0x18(%eax),%eax
c0001ae9:	83 ec 08             	sub    $0x8,%esp
c0001aec:	50                   	push   %eax
c0001aed:	68 81 44 00 c0       	push   $0xc0004481
c0001af2:	e8 bd ed ff ff       	call   c00008b4 <kprintf>
c0001af7:	83 c4 10             	add    $0x10,%esp
    kprintf("eip: 0x%x\n", regs->eip);
c0001afa:	8b 45 08             	mov    0x8(%ebp),%eax
c0001afd:	8b 40 20             	mov    0x20(%eax),%eax
c0001b00:	83 ec 08             	sub    $0x8,%esp
c0001b03:	50                   	push   %eax
c0001b04:	68 8c 44 00 c0       	push   $0xc000448c
c0001b09:	e8 a6 ed ff ff       	call   c00008b4 <kprintf>
c0001b0e:	83 c4 10             	add    $0x10,%esp
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
                                                            (regs->eflags&EFLAGS_PF) == EFLAGS_PF,
                                                            (regs->eflags&EFLAGS_AF) == EFLAGS_AF,
                                                            (regs->eflags&EFLAGS_ZF) == EFLAGS_ZF,
                                                            (regs->eflags&EFLAGS_SF) == EFLAGS_SF,
                                                            (regs->eflags&EFLAGS_TF) == EFLAGS_TF);
c0001b11:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b14:	8b 40 24             	mov    0x24(%eax),%eax
c0001b17:	25 00 01 00 00       	and    $0x100,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c0001b1c:	85 c0                	test   %eax,%eax
c0001b1e:	0f 95 c0             	setne  %al
c0001b21:	0f b6 f8             	movzbl %al,%edi
                                                            (regs->eflags&EFLAGS_SF) == EFLAGS_SF,
c0001b24:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b27:	8b 40 24             	mov    0x24(%eax),%eax
c0001b2a:	25 80 00 00 00       	and    $0x80,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c0001b2f:	85 c0                	test   %eax,%eax
c0001b31:	0f 95 c0             	setne  %al
c0001b34:	0f b6 f0             	movzbl %al,%esi
                                                            (regs->eflags&EFLAGS_ZF) == EFLAGS_ZF,
c0001b37:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b3a:	8b 40 24             	mov    0x24(%eax),%eax
c0001b3d:	83 e0 40             	and    $0x40,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c0001b40:	85 c0                	test   %eax,%eax
c0001b42:	0f 95 c0             	setne  %al
c0001b45:	0f b6 d8             	movzbl %al,%ebx
                                                            (regs->eflags&EFLAGS_AF) == EFLAGS_AF,
c0001b48:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b4b:	8b 40 24             	mov    0x24(%eax),%eax
c0001b4e:	83 e0 10             	and    $0x10,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c0001b51:	85 c0                	test   %eax,%eax
c0001b53:	0f 95 c0             	setne  %al
c0001b56:	0f b6 c8             	movzbl %al,%ecx
                                                            (regs->eflags&EFLAGS_PF) == EFLAGS_PF,
c0001b59:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b5c:	8b 40 24             	mov    0x24(%eax),%eax
c0001b5f:	83 e0 04             	and    $0x4,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c0001b62:	85 c0                	test   %eax,%eax
c0001b64:	0f 95 c0             	setne  %al
c0001b67:	0f b6 d0             	movzbl %al,%edx
c0001b6a:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b6d:	8b 40 24             	mov    0x24(%eax),%eax
c0001b70:	83 e0 01             	and    $0x1,%eax
c0001b73:	85 c0                	test   %eax,%eax
c0001b75:	0f 95 c0             	setne  %al
c0001b78:	0f b6 c0             	movzbl %al,%eax
c0001b7b:	83 ec 04             	sub    $0x4,%esp
c0001b7e:	57                   	push   %edi
c0001b7f:	56                   	push   %esi
c0001b80:	53                   	push   %ebx
c0001b81:	51                   	push   %ecx
c0001b82:	52                   	push   %edx
c0001b83:	50                   	push   %eax
c0001b84:	68 98 44 00 c0       	push   $0xc0004498
c0001b89:	e8 26 ed ff ff       	call   c00008b4 <kprintf>
c0001b8e:	83 c4 20             	add    $0x20,%esp
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
                                                            (regs->eflags&EFLAGS_DF) == EFLAGS_DF,
                                                            (regs->eflags&EFLAGS_OF) == EFLAGS_OF,
                                                            (regs->eflags&EFLAGS_IOPL) >> 12,
                                                            (regs->eflags&EFLAGS_NT) == EFLAGS_NT,
                                                            (regs->eflags&EFLAGS_RF) == EFLAGS_RF);
c0001b91:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b94:	8b 40 24             	mov    0x24(%eax),%eax
c0001b97:	25 00 00 01 00       	and    $0x10000,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001b9c:	85 c0                	test   %eax,%eax
c0001b9e:	0f 95 c0             	setne  %al
c0001ba1:	0f b6 f0             	movzbl %al,%esi
                                                            (regs->eflags&EFLAGS_NT) == EFLAGS_NT,
c0001ba4:	8b 45 08             	mov    0x8(%ebp),%eax
c0001ba7:	8b 40 24             	mov    0x24(%eax),%eax
c0001baa:	25 00 40 00 00       	and    $0x4000,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001baf:	85 c0                	test   %eax,%eax
c0001bb1:	0f 95 c0             	setne  %al
c0001bb4:	0f b6 d8             	movzbl %al,%ebx
                                                            (regs->eflags&EFLAGS_IOPL) >> 12,
c0001bb7:	8b 45 08             	mov    0x8(%ebp),%eax
c0001bba:	8b 40 24             	mov    0x24(%eax),%eax
c0001bbd:	c1 e8 0c             	shr    $0xc,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001bc0:	83 e0 03             	and    $0x3,%eax
c0001bc3:	89 c7                	mov    %eax,%edi
                                                            (regs->eflags&EFLAGS_OF) == EFLAGS_OF,
c0001bc5:	8b 45 08             	mov    0x8(%ebp),%eax
c0001bc8:	8b 40 24             	mov    0x24(%eax),%eax
c0001bcb:	25 00 08 00 00       	and    $0x800,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001bd0:	85 c0                	test   %eax,%eax
c0001bd2:	0f 95 c0             	setne  %al
c0001bd5:	0f b6 c8             	movzbl %al,%ecx
                                                            (regs->eflags&EFLAGS_DF) == EFLAGS_DF,
c0001bd8:	8b 45 08             	mov    0x8(%ebp),%eax
c0001bdb:	8b 40 24             	mov    0x24(%eax),%eax
c0001bde:	25 00 04 00 00       	and    $0x400,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001be3:	85 c0                	test   %eax,%eax
c0001be5:	0f 95 c0             	setne  %al
c0001be8:	0f b6 d0             	movzbl %al,%edx
c0001beb:	8b 45 08             	mov    0x8(%ebp),%eax
c0001bee:	8b 40 24             	mov    0x24(%eax),%eax
c0001bf1:	25 00 02 00 00       	and    $0x200,%eax
c0001bf6:	85 c0                	test   %eax,%eax
c0001bf8:	0f 95 c0             	setne  %al
c0001bfb:	0f b6 c0             	movzbl %al,%eax
c0001bfe:	83 ec 04             	sub    $0x4,%esp
c0001c01:	56                   	push   %esi
c0001c02:	53                   	push   %ebx
c0001c03:	57                   	push   %edi
c0001c04:	51                   	push   %ecx
c0001c05:	52                   	push   %edx
c0001c06:	50                   	push   %eax
c0001c07:	68 c8 44 00 c0       	push   $0xc00044c8
c0001c0c:	e8 a3 ec ff ff       	call   c00008b4 <kprintf>
c0001c11:	83 c4 20             	add    $0x20,%esp
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
                                                            (regs->eflags&EFLAGS_AC) == EFLAGS_AC,
                                                            (regs->eflags&EFLAGS_VIF) == EFLAGS_VIF,
                                                            (regs->eflags&EFLAGS_VIP) == EFLAGS_VIP,
                                                            (regs->eflags&EFLAGS_ID) == EFLAGS_ID);
c0001c14:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c17:	8b 40 24             	mov    0x24(%eax),%eax
c0001c1a:	25 00 00 20 00       	and    $0x200000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c0001c1f:	85 c0                	test   %eax,%eax
c0001c21:	0f 95 c0             	setne  %al
c0001c24:	0f b6 f0             	movzbl %al,%esi
                                                            (regs->eflags&EFLAGS_VIP) == EFLAGS_VIP,
c0001c27:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c2a:	8b 40 24             	mov    0x24(%eax),%eax
c0001c2d:	25 00 00 10 00       	and    $0x100000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c0001c32:	85 c0                	test   %eax,%eax
c0001c34:	0f 95 c0             	setne  %al
c0001c37:	0f b6 d8             	movzbl %al,%ebx
                                                            (regs->eflags&EFLAGS_VIF) == EFLAGS_VIF,
c0001c3a:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c3d:	8b 40 24             	mov    0x24(%eax),%eax
c0001c40:	25 00 00 08 00       	and    $0x80000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c0001c45:	85 c0                	test   %eax,%eax
c0001c47:	0f 95 c0             	setne  %al
c0001c4a:	0f b6 c8             	movzbl %al,%ecx
                                                            (regs->eflags&EFLAGS_AC) == EFLAGS_AC,
c0001c4d:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c50:	8b 40 24             	mov    0x24(%eax),%eax
c0001c53:	25 00 00 04 00       	and    $0x40000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c0001c58:	85 c0                	test   %eax,%eax
c0001c5a:	0f 95 c0             	setne  %al
c0001c5d:	0f b6 d0             	movzbl %al,%edx
c0001c60:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c63:	8b 40 24             	mov    0x24(%eax),%eax
c0001c66:	25 00 00 02 00       	and    $0x20000,%eax
c0001c6b:	85 c0                	test   %eax,%eax
c0001c6d:	0f 95 c0             	setne  %al
c0001c70:	0f b6 c0             	movzbl %al,%eax
c0001c73:	83 ec 08             	sub    $0x8,%esp
c0001c76:	56                   	push   %esi
c0001c77:	53                   	push   %ebx
c0001c78:	51                   	push   %ecx
c0001c79:	52                   	push   %edx
c0001c7a:	50                   	push   %eax
c0001c7b:	68 f8 44 00 c0       	push   $0xc00044f8
c0001c80:	e8 2f ec ff ff       	call   c00008b4 <kprintf>
c0001c85:	83 c4 20             	add    $0x20,%esp
    kprintf("cr0: 0x%x\n", regs->cr0);
c0001c88:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c8b:	8b 40 28             	mov    0x28(%eax),%eax
c0001c8e:	83 ec 08             	sub    $0x8,%esp
c0001c91:	50                   	push   %eax
c0001c92:	68 21 45 00 c0       	push   $0xc0004521
c0001c97:	e8 18 ec ff ff       	call   c00008b4 <kprintf>
c0001c9c:	83 c4 10             	add    $0x10,%esp
    kprintf("cr2: 0x%x\n", regs->cr2);
c0001c9f:	8b 45 08             	mov    0x8(%ebp),%eax
c0001ca2:	8b 40 2c             	mov    0x2c(%eax),%eax
c0001ca5:	83 ec 08             	sub    $0x8,%esp
c0001ca8:	50                   	push   %eax
c0001ca9:	68 2c 45 00 c0       	push   $0xc000452c
c0001cae:	e8 01 ec ff ff       	call   c00008b4 <kprintf>
c0001cb3:	83 c4 10             	add    $0x10,%esp
    kprintf("cr3: 0x%x\n", regs->cr3);
c0001cb6:	8b 45 08             	mov    0x8(%ebp),%eax
c0001cb9:	8b 40 30             	mov    0x30(%eax),%eax
c0001cbc:	83 ec 08             	sub    $0x8,%esp
c0001cbf:	50                   	push   %eax
c0001cc0:	68 37 45 00 c0       	push   $0xc0004537
c0001cc5:	e8 ea eb ff ff       	call   c00008b4 <kprintf>
c0001cca:	83 c4 10             	add    $0x10,%esp
    kprintf("cr4: 0x%x\n", regs->cr4);
c0001ccd:	8b 45 08             	mov    0x8(%ebp),%eax
c0001cd0:	8b 40 34             	mov    0x34(%eax),%eax
c0001cd3:	83 ec 08             	sub    $0x8,%esp
c0001cd6:	50                   	push   %eax
c0001cd7:	68 42 45 00 c0       	push   $0xc0004542
c0001cdc:	e8 d3 eb ff ff       	call   c00008b4 <kprintf>
c0001ce1:	83 c4 10             	add    $0x10,%esp
}
c0001ce4:	90                   	nop
c0001ce5:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0001ce8:	5b                   	pop    %ebx
c0001ce9:	5e                   	pop    %esi
c0001cea:	5f                   	pop    %edi
c0001ceb:	5d                   	pop    %ebp
c0001cec:	c3                   	ret    

c0001ced <memory_table>:
#include "multiboot.h"
#include "kprintf.h"

size_t memory_table(multiboot_info_t* mbd)
{
c0001ced:	55                   	push   %ebp
c0001cee:	89 e5                	mov    %esp,%ebp
c0001cf0:	56                   	push   %esi
c0001cf1:	53                   	push   %ebx
c0001cf2:	83 ec 10             	sub    $0x10,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c0001cf5:	8b 45 08             	mov    0x8(%ebp),%eax
c0001cf8:	8b 40 30             	mov    0x30(%eax),%eax
c0001cfb:	89 45 ec             	mov    %eax,-0x14(%ebp)
    size_t available_mem = 0;
c0001cfe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001d05:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0001d0c:	e9 83 00 00 00       	jmp    c0001d94 <memory_table+0xa7>
	{
		if(mmap_table[nn].len>0 && mmap_table[nn].size>0)
c0001d11:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001d14:	89 d0                	mov    %edx,%eax
c0001d16:	01 c0                	add    %eax,%eax
c0001d18:	01 d0                	add    %edx,%eax
c0001d1a:	c1 e0 03             	shl    $0x3,%eax
c0001d1d:	89 c2                	mov    %eax,%edx
c0001d1f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001d22:	01 d0                	add    %edx,%eax
c0001d24:	8b 50 10             	mov    0x10(%eax),%edx
c0001d27:	8b 40 0c             	mov    0xc(%eax),%eax
c0001d2a:	89 c6                	mov    %eax,%esi
c0001d2c:	83 f6 00             	xor    $0x0,%esi
c0001d2f:	89 f1                	mov    %esi,%ecx
c0001d31:	89 d0                	mov    %edx,%eax
c0001d33:	80 f4 00             	xor    $0x0,%ah
c0001d36:	89 c3                	mov    %eax,%ebx
c0001d38:	89 d8                	mov    %ebx,%eax
c0001d3a:	09 c8                	or     %ecx,%eax
c0001d3c:	85 c0                	test   %eax,%eax
c0001d3e:	74 50                	je     c0001d90 <memory_table+0xa3>
c0001d40:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001d43:	89 d0                	mov    %edx,%eax
c0001d45:	01 c0                	add    %eax,%eax
c0001d47:	01 d0                	add    %edx,%eax
c0001d49:	c1 e0 03             	shl    $0x3,%eax
c0001d4c:	89 c2                	mov    %eax,%edx
c0001d4e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001d51:	01 d0                	add    %edx,%eax
c0001d53:	8b 00                	mov    (%eax),%eax
c0001d55:	85 c0                	test   %eax,%eax
c0001d57:	74 37                	je     c0001d90 <memory_table+0xa3>
        {
            if(mmap_table[nn].type == 1)
c0001d59:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001d5c:	89 d0                	mov    %edx,%eax
c0001d5e:	01 c0                	add    %eax,%eax
c0001d60:	01 d0                	add    %edx,%eax
c0001d62:	c1 e0 03             	shl    $0x3,%eax
c0001d65:	89 c2                	mov    %eax,%edx
c0001d67:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001d6a:	01 d0                	add    %edx,%eax
c0001d6c:	8b 40 14             	mov    0x14(%eax),%eax
c0001d6f:	83 f8 01             	cmp    $0x1,%eax
c0001d72:	75 1c                	jne    c0001d90 <memory_table+0xa3>
            available_mem += mmap_table[nn].len;
c0001d74:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001d77:	89 d0                	mov    %edx,%eax
c0001d79:	01 c0                	add    %eax,%eax
c0001d7b:	01 d0                	add    %edx,%eax
c0001d7d:	c1 e0 03             	shl    $0x3,%eax
c0001d80:	89 c2                	mov    %eax,%edx
c0001d82:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001d85:	01 d0                	add    %edx,%eax
c0001d87:	8b 50 10             	mov    0x10(%eax),%edx
c0001d8a:	8b 40 0c             	mov    0xc(%eax),%eax
c0001d8d:	01 45 f4             	add    %eax,-0xc(%ebp)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001d90:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0001d94:	8b 45 08             	mov    0x8(%ebp),%eax
c0001d97:	8b 40 2c             	mov    0x2c(%eax),%eax
c0001d9a:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0001d9d:	0f 82 6e ff ff ff    	jb     c0001d11 <memory_table+0x24>
        }
		
	}

    return available_mem;
c0001da3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0001da6:	83 c4 10             	add    $0x10,%esp
c0001da9:	5b                   	pop    %ebx
c0001daa:	5e                   	pop    %esi
c0001dab:	5d                   	pop    %ebp
c0001dac:	c3                   	ret    

c0001dad <print_memory_table>:

int print_memory_table(multiboot_info_t* mbd)
{
c0001dad:	55                   	push   %ebp
c0001dae:	89 e5                	mov    %esp,%ebp
c0001db0:	57                   	push   %edi
c0001db1:	56                   	push   %esi
c0001db2:	53                   	push   %ebx
c0001db3:	83 ec 2c             	sub    $0x2c,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c0001db6:	8b 45 08             	mov    0x8(%ebp),%eax
c0001db9:	8b 40 30             	mov    0x30(%eax),%eax
c0001dbc:	89 45 e0             	mov    %eax,-0x20(%ebp)
	kprintf("Memory Table:\n");
c0001dbf:	83 ec 0c             	sub    $0xc,%esp
c0001dc2:	68 50 45 00 c0       	push   $0xc0004550
c0001dc7:	e8 e8 ea ff ff       	call   c00008b4 <kprintf>
c0001dcc:	83 c4 10             	add    $0x10,%esp
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001dcf:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c0001dd6:	e9 a6 01 00 00       	jmp    c0001f81 <print_memory_table+0x1d4>
	{
        if(mmap_table[nn].size == 0)
c0001ddb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001dde:	89 d0                	mov    %edx,%eax
c0001de0:	01 c0                	add    %eax,%eax
c0001de2:	01 d0                	add    %edx,%eax
c0001de4:	c1 e0 03             	shl    $0x3,%eax
c0001de7:	89 c2                	mov    %eax,%edx
c0001de9:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001dec:	01 d0                	add    %edx,%eax
c0001dee:	8b 00                	mov    (%eax),%eax
c0001df0:	85 c0                	test   %eax,%eax
c0001df2:	0f 84 9a 01 00 00    	je     c0001f92 <print_memory_table+0x1e5>
            break;

		if(mmap_table[nn].len>0)
c0001df8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001dfb:	89 d0                	mov    %edx,%eax
c0001dfd:	01 c0                	add    %eax,%eax
c0001dff:	01 d0                	add    %edx,%eax
c0001e01:	c1 e0 03             	shl    $0x3,%eax
c0001e04:	89 c2                	mov    %eax,%edx
c0001e06:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001e09:	01 d0                	add    %edx,%eax
c0001e0b:	8b 50 10             	mov    0x10(%eax),%edx
c0001e0e:	8b 40 0c             	mov    0xc(%eax),%eax
c0001e11:	89 c7                	mov    %eax,%edi
c0001e13:	83 f7 00             	xor    $0x0,%edi
c0001e16:	89 7d d0             	mov    %edi,-0x30(%ebp)
c0001e19:	89 d0                	mov    %edx,%eax
c0001e1b:	80 f4 00             	xor    $0x0,%ah
c0001e1e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
c0001e21:	8b 5d d0             	mov    -0x30(%ebp),%ebx
c0001e24:	8b 75 d4             	mov    -0x2c(%ebp),%esi
c0001e27:	89 f0                	mov    %esi,%eax
c0001e29:	09 d8                	or     %ebx,%eax
c0001e2b:	85 c0                	test   %eax,%eax
c0001e2d:	0f 84 4a 01 00 00    	je     c0001f7d <print_memory_table+0x1d0>
		{
			if(mmap_table[nn].type == MULTIBOOT_MEMORY_AVAILABLE)
c0001e33:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001e36:	89 d0                	mov    %edx,%eax
c0001e38:	01 c0                	add    %eax,%eax
c0001e3a:	01 d0                	add    %edx,%eax
c0001e3c:	c1 e0 03             	shl    $0x3,%eax
c0001e3f:	89 c2                	mov    %eax,%edx
c0001e41:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001e44:	01 d0                	add    %edx,%eax
c0001e46:	8b 40 14             	mov    0x14(%eax),%eax
c0001e49:	83 f8 01             	cmp    $0x1,%eax
c0001e4c:	0f 85 98 00 00 00    	jne    c0001eea <print_memory_table+0x13d>
				kprintf("%.8llp - %.8llp [AVAILABLE] (%6llu kiB)\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c0001e52:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001e55:	89 d0                	mov    %edx,%eax
c0001e57:	01 c0                	add    %eax,%eax
c0001e59:	01 d0                	add    %edx,%eax
c0001e5b:	c1 e0 03             	shl    $0x3,%eax
c0001e5e:	89 c2                	mov    %eax,%edx
c0001e60:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001e63:	01 d0                	add    %edx,%eax
c0001e65:	8b 50 10             	mov    0x10(%eax),%edx
c0001e68:	8b 40 0c             	mov    0xc(%eax),%eax
c0001e6b:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c0001e6f:	c1 ea 0a             	shr    $0xa,%edx
c0001e72:	89 c6                	mov    %eax,%esi
c0001e74:	89 d7                	mov    %edx,%edi
c0001e76:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001e79:	89 d0                	mov    %edx,%eax
c0001e7b:	01 c0                	add    %eax,%eax
c0001e7d:	01 d0                	add    %edx,%eax
c0001e7f:	c1 e0 03             	shl    $0x3,%eax
c0001e82:	89 c2                	mov    %eax,%edx
c0001e84:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001e87:	01 d0                	add    %edx,%eax
c0001e89:	8b 48 04             	mov    0x4(%eax),%ecx
c0001e8c:	8b 58 08             	mov    0x8(%eax),%ebx
c0001e8f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001e92:	89 d0                	mov    %edx,%eax
c0001e94:	01 c0                	add    %eax,%eax
c0001e96:	01 d0                	add    %edx,%eax
c0001e98:	c1 e0 03             	shl    $0x3,%eax
c0001e9b:	89 c2                	mov    %eax,%edx
c0001e9d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001ea0:	01 d0                	add    %edx,%eax
c0001ea2:	8b 50 10             	mov    0x10(%eax),%edx
c0001ea5:	8b 40 0c             	mov    0xc(%eax),%eax
c0001ea8:	01 c8                	add    %ecx,%eax
c0001eaa:	11 da                	adc    %ebx,%edx
c0001eac:	83 c0 ff             	add    $0xffffffff,%eax
c0001eaf:	83 d2 ff             	adc    $0xffffffff,%edx
c0001eb2:	89 c1                	mov    %eax,%ecx
c0001eb4:	89 d3                	mov    %edx,%ebx
c0001eb6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001eb9:	89 d0                	mov    %edx,%eax
c0001ebb:	01 c0                	add    %eax,%eax
c0001ebd:	01 d0                	add    %edx,%eax
c0001ebf:	c1 e0 03             	shl    $0x3,%eax
c0001ec2:	89 c2                	mov    %eax,%edx
c0001ec4:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001ec7:	01 d0                	add    %edx,%eax
c0001ec9:	8b 50 08             	mov    0x8(%eax),%edx
c0001ecc:	8b 40 04             	mov    0x4(%eax),%eax
c0001ecf:	83 ec 04             	sub    $0x4,%esp
c0001ed2:	57                   	push   %edi
c0001ed3:	56                   	push   %esi
c0001ed4:	53                   	push   %ebx
c0001ed5:	51                   	push   %ecx
c0001ed6:	52                   	push   %edx
c0001ed7:	50                   	push   %eax
c0001ed8:	68 60 45 00 c0       	push   $0xc0004560
c0001edd:	e8 d2 e9 ff ff       	call   c00008b4 <kprintf>
c0001ee2:	83 c4 20             	add    $0x20,%esp
c0001ee5:	e9 93 00 00 00       	jmp    c0001f7d <print_memory_table+0x1d0>
			else
				kprintf("%.8llp - %.8llp [RESERVED]\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c0001eea:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001eed:	89 d0                	mov    %edx,%eax
c0001eef:	01 c0                	add    %eax,%eax
c0001ef1:	01 d0                	add    %edx,%eax
c0001ef3:	c1 e0 03             	shl    $0x3,%eax
c0001ef6:	89 c2                	mov    %eax,%edx
c0001ef8:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001efb:	01 d0                	add    %edx,%eax
c0001efd:	8b 50 10             	mov    0x10(%eax),%edx
c0001f00:	8b 40 0c             	mov    0xc(%eax),%eax
c0001f03:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c0001f07:	c1 ea 0a             	shr    $0xa,%edx
c0001f0a:	89 c6                	mov    %eax,%esi
c0001f0c:	89 d7                	mov    %edx,%edi
c0001f0e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001f11:	89 d0                	mov    %edx,%eax
c0001f13:	01 c0                	add    %eax,%eax
c0001f15:	01 d0                	add    %edx,%eax
c0001f17:	c1 e0 03             	shl    $0x3,%eax
c0001f1a:	89 c2                	mov    %eax,%edx
c0001f1c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001f1f:	01 d0                	add    %edx,%eax
c0001f21:	8b 48 04             	mov    0x4(%eax),%ecx
c0001f24:	8b 58 08             	mov    0x8(%eax),%ebx
c0001f27:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001f2a:	89 d0                	mov    %edx,%eax
c0001f2c:	01 c0                	add    %eax,%eax
c0001f2e:	01 d0                	add    %edx,%eax
c0001f30:	c1 e0 03             	shl    $0x3,%eax
c0001f33:	89 c2                	mov    %eax,%edx
c0001f35:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001f38:	01 d0                	add    %edx,%eax
c0001f3a:	8b 50 10             	mov    0x10(%eax),%edx
c0001f3d:	8b 40 0c             	mov    0xc(%eax),%eax
c0001f40:	01 c8                	add    %ecx,%eax
c0001f42:	11 da                	adc    %ebx,%edx
c0001f44:	83 c0 ff             	add    $0xffffffff,%eax
c0001f47:	83 d2 ff             	adc    $0xffffffff,%edx
c0001f4a:	89 c1                	mov    %eax,%ecx
c0001f4c:	89 d3                	mov    %edx,%ebx
c0001f4e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001f51:	89 d0                	mov    %edx,%eax
c0001f53:	01 c0                	add    %eax,%eax
c0001f55:	01 d0                	add    %edx,%eax
c0001f57:	c1 e0 03             	shl    $0x3,%eax
c0001f5a:	89 c2                	mov    %eax,%edx
c0001f5c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001f5f:	01 d0                	add    %edx,%eax
c0001f61:	8b 50 08             	mov    0x8(%eax),%edx
c0001f64:	8b 40 04             	mov    0x4(%eax),%eax
c0001f67:	83 ec 04             	sub    $0x4,%esp
c0001f6a:	57                   	push   %edi
c0001f6b:	56                   	push   %esi
c0001f6c:	53                   	push   %ebx
c0001f6d:	51                   	push   %ecx
c0001f6e:	52                   	push   %edx
c0001f6f:	50                   	push   %eax
c0001f70:	68 89 45 00 c0       	push   $0xc0004589
c0001f75:	e8 3a e9 ff ff       	call   c00008b4 <kprintf>
c0001f7a:	83 c4 20             	add    $0x20,%esp
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001f7d:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c0001f81:	8b 45 08             	mov    0x8(%ebp),%eax
c0001f84:	8b 40 2c             	mov    0x2c(%eax),%eax
c0001f87:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c0001f8a:	0f 82 4b fe ff ff    	jb     c0001ddb <print_memory_table+0x2e>
c0001f90:	eb 01                	jmp    c0001f93 <print_memory_table+0x1e6>
            break;
c0001f92:	90                   	nop
    //         kprintf("[%3u] %p (%#x)\n", nn, addr, flags);		
	// }

    // print_crs();

    return 0;
c0001f93:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0001f98:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0001f9b:	5b                   	pop    %ebx
c0001f9c:	5e                   	pop    %esi
c0001f9d:	5f                   	pop    %edi
c0001f9e:	5d                   	pop    %ebp
c0001f9f:	c3                   	ret    

c0001fa0 <inb>:
{
c0001fa0:	55                   	push   %ebp
c0001fa1:	89 e5                	mov    %esp,%ebp
c0001fa3:	83 ec 14             	sub    $0x14,%esp
c0001fa6:	8b 45 08             	mov    0x8(%ebp),%eax
c0001fa9:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  __asm__ __volatile__ ("inb %w1,%0":"=a" (_v):"Nd" (__port));
c0001fad:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0001fb1:	89 c2                	mov    %eax,%edx
c0001fb3:	ec                   	in     (%dx),%al
c0001fb4:	88 45 ff             	mov    %al,-0x1(%ebp)
  return _v;
c0001fb7:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0001fbb:	c9                   	leave  
c0001fbc:	c3                   	ret    

c0001fbd <outb>:
{
c0001fbd:	55                   	push   %ebp
c0001fbe:	89 e5                	mov    %esp,%ebp
c0001fc0:	83 ec 08             	sub    $0x8,%esp
c0001fc3:	8b 55 08             	mov    0x8(%ebp),%edx
c0001fc6:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001fc9:	88 55 fc             	mov    %dl,-0x4(%ebp)
c0001fcc:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
c0001fd0:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0001fd4:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
c0001fd8:	ee                   	out    %al,(%dx)
}
c0001fd9:	90                   	nop
c0001fda:	c9                   	leave  
c0001fdb:	c3                   	ret    

c0001fdc <init_interrupts>:

idt_entry_t __aligned idt[NUM_INTERRUPT_HANDLERS] = {0};
idt_descriptor_t __aligned idtd;

void init_interrupts()
{
c0001fdc:	55                   	push   %ebp
c0001fdd:	89 e5                	mov    %esp,%ebp
c0001fdf:	83 ec 08             	sub    $0x8,%esp
    /* init the PIC */
	outb(PIC_INIT, PIC1_CMD);  // init PIC 1
c0001fe2:	6a 20                	push   $0x20
c0001fe4:	6a 11                	push   $0x11
c0001fe6:	e8 d2 ff ff ff       	call   c0001fbd <outb>
c0001feb:	83 c4 08             	add    $0x8,%esp
    outb(PIC_INIT, PIC2_CMD);  // init PIC 2
c0001fee:	68 a0 00 00 00       	push   $0xa0
c0001ff3:	6a 11                	push   $0x11
c0001ff5:	e8 c3 ff ff ff       	call   c0001fbd <outb>
c0001ffa:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_OFFSET, PIC1_DATA); // map irq 0x0-0x7 to int 0x20-0x27
c0001ffd:	6a 21                	push   $0x21
c0001fff:	6a 20                	push   $0x20
c0002001:	e8 b7 ff ff ff       	call   c0001fbd <outb>
c0002006:	83 c4 08             	add    $0x8,%esp
    outb(PIC2_OFFSET, PIC2_DATA); // map irq 0x8-0xf to int 0x28-0x2f
c0002009:	68 a1 00 00 00       	push   $0xa1
c000200e:	6a 28                	push   $0x28
c0002010:	e8 a8 ff ff ff       	call   c0001fbd <outb>
c0002015:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_MS, PIC1_DATA);     // pic1 is master, with slave at irq 2
c0002018:	6a 21                	push   $0x21
c000201a:	6a 04                	push   $0x4
c000201c:	e8 9c ff ff ff       	call   c0001fbd <outb>
c0002021:	83 c4 08             	add    $0x8,%esp
    outb(PIC2_MS, PIC2_DATA);     // pic2 is slave with id 2
c0002024:	68 a1 00 00 00       	push   $0xa1
c0002029:	6a 02                	push   $0x2
c000202b:	e8 8d ff ff ff       	call   c0001fbd <outb>
c0002030:	83 c4 08             	add    $0x8,%esp
    outb(PIC_8086MODE, PIC1_DATA); //enable 8086 mode
c0002033:	6a 21                	push   $0x21
c0002035:	6a 01                	push   $0x1
c0002037:	e8 81 ff ff ff       	call   c0001fbd <outb>
c000203c:	83 c4 08             	add    $0x8,%esp
    outb(PIC_8086MODE, PIC2_DATA); //enable 8086 mode
c000203f:	68 a1 00 00 00       	push   $0xa1
c0002044:	6a 01                	push   $0x1
c0002046:	e8 72 ff ff ff       	call   c0001fbd <outb>
c000204b:	83 c4 08             	add    $0x8,%esp
    // interrupt mask
    outb( ~(1<<1) , PIC1_DATA); //enable irq1 (keyboard)
c000204e:	6a 21                	push   $0x21
c0002050:	68 fd 00 00 00       	push   $0xfd
c0002055:	e8 63 ff ff ff       	call   c0001fbd <outb>
c000205a:	83 c4 08             	add    $0x8,%esp
    outb(0xff, PIC2_DATA); //disable interrupts from slave
c000205d:	68 a1 00 00 00       	push   $0xa1
c0002062:	68 ff 00 00 00       	push   $0xff
c0002067:	e8 51 ff ff ff       	call   c0001fbd <outb>
c000206c:	83 c4 08             	add    $0x8,%esp


    // individual handler routines defined in interrupt.S
    // these call back to exception_handler() and irq_handler()
    set_interrupt_handler(0,except_0);
c000206f:	83 ec 08             	sub    $0x8,%esp
c0002072:	68 d0 39 00 c0       	push   $0xc00039d0
c0002077:	6a 00                	push   $0x0
c0002079:	e8 94 02 00 00       	call   c0002312 <set_interrupt_handler>
c000207e:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(1,except_1);
c0002081:	83 ec 08             	sub    $0x8,%esp
c0002084:	68 f0 39 00 c0       	push   $0xc00039f0
c0002089:	6a 01                	push   $0x1
c000208b:	e8 82 02 00 00       	call   c0002312 <set_interrupt_handler>
c0002090:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(2,except_2);
c0002093:	83 ec 08             	sub    $0x8,%esp
c0002096:	68 10 3a 00 c0       	push   $0xc0003a10
c000209b:	6a 02                	push   $0x2
c000209d:	e8 70 02 00 00       	call   c0002312 <set_interrupt_handler>
c00020a2:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(3,except_3);
c00020a5:	83 ec 08             	sub    $0x8,%esp
c00020a8:	68 30 3a 00 c0       	push   $0xc0003a30
c00020ad:	6a 03                	push   $0x3
c00020af:	e8 5e 02 00 00       	call   c0002312 <set_interrupt_handler>
c00020b4:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(4,except_4);
c00020b7:	83 ec 08             	sub    $0x8,%esp
c00020ba:	68 50 3a 00 c0       	push   $0xc0003a50
c00020bf:	6a 04                	push   $0x4
c00020c1:	e8 4c 02 00 00       	call   c0002312 <set_interrupt_handler>
c00020c6:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(5,except_5);
c00020c9:	83 ec 08             	sub    $0x8,%esp
c00020cc:	68 70 3a 00 c0       	push   $0xc0003a70
c00020d1:	6a 05                	push   $0x5
c00020d3:	e8 3a 02 00 00       	call   c0002312 <set_interrupt_handler>
c00020d8:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(6,except_6);
c00020db:	83 ec 08             	sub    $0x8,%esp
c00020de:	68 90 3a 00 c0       	push   $0xc0003a90
c00020e3:	6a 06                	push   $0x6
c00020e5:	e8 28 02 00 00       	call   c0002312 <set_interrupt_handler>
c00020ea:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(7,except_7);
c00020ed:	83 ec 08             	sub    $0x8,%esp
c00020f0:	68 b0 3a 00 c0       	push   $0xc0003ab0
c00020f5:	6a 07                	push   $0x7
c00020f7:	e8 16 02 00 00       	call   c0002312 <set_interrupt_handler>
c00020fc:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(8,except_8);
c00020ff:	83 ec 08             	sub    $0x8,%esp
c0002102:	68 d0 3a 00 c0       	push   $0xc0003ad0
c0002107:	6a 08                	push   $0x8
c0002109:	e8 04 02 00 00       	call   c0002312 <set_interrupt_handler>
c000210e:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(10,except_10);
c0002111:	83 ec 08             	sub    $0x8,%esp
c0002114:	68 f0 3a 00 c0       	push   $0xc0003af0
c0002119:	6a 0a                	push   $0xa
c000211b:	e8 f2 01 00 00       	call   c0002312 <set_interrupt_handler>
c0002120:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(11,except_11);
c0002123:	83 ec 08             	sub    $0x8,%esp
c0002126:	68 10 3b 00 c0       	push   $0xc0003b10
c000212b:	6a 0b                	push   $0xb
c000212d:	e8 e0 01 00 00       	call   c0002312 <set_interrupt_handler>
c0002132:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(12,except_12);
c0002135:	83 ec 08             	sub    $0x8,%esp
c0002138:	68 30 3b 00 c0       	push   $0xc0003b30
c000213d:	6a 0c                	push   $0xc
c000213f:	e8 ce 01 00 00       	call   c0002312 <set_interrupt_handler>
c0002144:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(13,except_13);
c0002147:	83 ec 08             	sub    $0x8,%esp
c000214a:	68 50 3b 00 c0       	push   $0xc0003b50
c000214f:	6a 0d                	push   $0xd
c0002151:	e8 bc 01 00 00       	call   c0002312 <set_interrupt_handler>
c0002156:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(14,except_14);
c0002159:	83 ec 08             	sub    $0x8,%esp
c000215c:	68 70 3b 00 c0       	push   $0xc0003b70
c0002161:	6a 0e                	push   $0xe
c0002163:	e8 aa 01 00 00       	call   c0002312 <set_interrupt_handler>
c0002168:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(16,except_16);
c000216b:	83 ec 08             	sub    $0x8,%esp
c000216e:	68 90 3b 00 c0       	push   $0xc0003b90
c0002173:	6a 10                	push   $0x10
c0002175:	e8 98 01 00 00       	call   c0002312 <set_interrupt_handler>
c000217a:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(17,except_17);
c000217d:	83 ec 08             	sub    $0x8,%esp
c0002180:	68 b0 3b 00 c0       	push   $0xc0003bb0
c0002185:	6a 11                	push   $0x11
c0002187:	e8 86 01 00 00       	call   c0002312 <set_interrupt_handler>
c000218c:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(18,except_18);
c000218f:	83 ec 08             	sub    $0x8,%esp
c0002192:	68 d0 3b 00 c0       	push   $0xc0003bd0
c0002197:	6a 12                	push   $0x12
c0002199:	e8 74 01 00 00       	call   c0002312 <set_interrupt_handler>
c000219e:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(19,except_19);
c00021a1:	83 ec 08             	sub    $0x8,%esp
c00021a4:	68 f0 3b 00 c0       	push   $0xc0003bf0
c00021a9:	6a 13                	push   $0x13
c00021ab:	e8 62 01 00 00       	call   c0002312 <set_interrupt_handler>
c00021b0:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(20,except_20);
c00021b3:	83 ec 08             	sub    $0x8,%esp
c00021b6:	68 10 3c 00 c0       	push   $0xc0003c10
c00021bb:	6a 14                	push   $0x14
c00021bd:	e8 50 01 00 00       	call   c0002312 <set_interrupt_handler>
c00021c2:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(30,except_30);
c00021c5:	83 ec 08             	sub    $0x8,%esp
c00021c8:	68 30 3c 00 c0       	push   $0xc0003c30
c00021cd:	6a 1e                	push   $0x1e
c00021cf:	e8 3e 01 00 00       	call   c0002312 <set_interrupt_handler>
c00021d4:	83 c4 10             	add    $0x10,%esp

    set_interrupt_handler(32,irq_0);
c00021d7:	83 ec 08             	sub    $0x8,%esp
c00021da:	68 50 3c 00 c0       	push   $0xc0003c50
c00021df:	6a 20                	push   $0x20
c00021e1:	e8 2c 01 00 00       	call   c0002312 <set_interrupt_handler>
c00021e6:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(33,irq_1);
c00021e9:	83 ec 08             	sub    $0x8,%esp
c00021ec:	68 64 3c 00 c0       	push   $0xc0003c64
c00021f1:	6a 21                	push   $0x21
c00021f3:	e8 1a 01 00 00       	call   c0002312 <set_interrupt_handler>
c00021f8:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(34,irq_2);
c00021fb:	83 ec 08             	sub    $0x8,%esp
c00021fe:	68 78 3c 00 c0       	push   $0xc0003c78
c0002203:	6a 22                	push   $0x22
c0002205:	e8 08 01 00 00       	call   c0002312 <set_interrupt_handler>
c000220a:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(35,irq_3);
c000220d:	83 ec 08             	sub    $0x8,%esp
c0002210:	68 8c 3c 00 c0       	push   $0xc0003c8c
c0002215:	6a 23                	push   $0x23
c0002217:	e8 f6 00 00 00       	call   c0002312 <set_interrupt_handler>
c000221c:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(36,irq_4);
c000221f:	83 ec 08             	sub    $0x8,%esp
c0002222:	68 a0 3c 00 c0       	push   $0xc0003ca0
c0002227:	6a 24                	push   $0x24
c0002229:	e8 e4 00 00 00       	call   c0002312 <set_interrupt_handler>
c000222e:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(37,irq_5);
c0002231:	83 ec 08             	sub    $0x8,%esp
c0002234:	68 b4 3c 00 c0       	push   $0xc0003cb4
c0002239:	6a 25                	push   $0x25
c000223b:	e8 d2 00 00 00       	call   c0002312 <set_interrupt_handler>
c0002240:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(38,irq_6);
c0002243:	83 ec 08             	sub    $0x8,%esp
c0002246:	68 c8 3c 00 c0       	push   $0xc0003cc8
c000224b:	6a 26                	push   $0x26
c000224d:	e8 c0 00 00 00       	call   c0002312 <set_interrupt_handler>
c0002252:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(39,irq_7);
c0002255:	83 ec 08             	sub    $0x8,%esp
c0002258:	68 dc 3c 00 c0       	push   $0xc0003cdc
c000225d:	6a 27                	push   $0x27
c000225f:	e8 ae 00 00 00       	call   c0002312 <set_interrupt_handler>
c0002264:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(40,irq_8);
c0002267:	83 ec 08             	sub    $0x8,%esp
c000226a:	68 f0 3c 00 c0       	push   $0xc0003cf0
c000226f:	6a 28                	push   $0x28
c0002271:	e8 9c 00 00 00       	call   c0002312 <set_interrupt_handler>
c0002276:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(41,irq_9);
c0002279:	83 ec 08             	sub    $0x8,%esp
c000227c:	68 04 3d 00 c0       	push   $0xc0003d04
c0002281:	6a 29                	push   $0x29
c0002283:	e8 8a 00 00 00       	call   c0002312 <set_interrupt_handler>
c0002288:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(42,irq_10);
c000228b:	83 ec 08             	sub    $0x8,%esp
c000228e:	68 18 3d 00 c0       	push   $0xc0003d18
c0002293:	6a 2a                	push   $0x2a
c0002295:	e8 78 00 00 00       	call   c0002312 <set_interrupt_handler>
c000229a:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(43,irq_11);
c000229d:	83 ec 08             	sub    $0x8,%esp
c00022a0:	68 2c 3d 00 c0       	push   $0xc0003d2c
c00022a5:	6a 2b                	push   $0x2b
c00022a7:	e8 66 00 00 00       	call   c0002312 <set_interrupt_handler>
c00022ac:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(44,irq_12);
c00022af:	83 ec 08             	sub    $0x8,%esp
c00022b2:	68 40 3d 00 c0       	push   $0xc0003d40
c00022b7:	6a 2c                	push   $0x2c
c00022b9:	e8 54 00 00 00       	call   c0002312 <set_interrupt_handler>
c00022be:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(45,irq_13);
c00022c1:	83 ec 08             	sub    $0x8,%esp
c00022c4:	68 54 3d 00 c0       	push   $0xc0003d54
c00022c9:	6a 2d                	push   $0x2d
c00022cb:	e8 42 00 00 00       	call   c0002312 <set_interrupt_handler>
c00022d0:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(46,irq_14);
c00022d3:	83 ec 08             	sub    $0x8,%esp
c00022d6:	68 68 3d 00 c0       	push   $0xc0003d68
c00022db:	6a 2e                	push   $0x2e
c00022dd:	e8 30 00 00 00       	call   c0002312 <set_interrupt_handler>
c00022e2:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(47,irq_15);
c00022e5:	83 ec 08             	sub    $0x8,%esp
c00022e8:	68 7c 3d 00 c0       	push   $0xc0003d7c
c00022ed:	6a 2f                	push   $0x2f
c00022ef:	e8 1e 00 00 00       	call   c0002312 <set_interrupt_handler>
c00022f4:	83 c4 10             	add    $0x10,%esp



    idtd.base = (uint32_t) idt;
c00022f7:	b8 20 60 00 c0       	mov    $0xc0006020,%eax
c00022fc:	a3 22 68 00 c0       	mov    %eax,0xc0006822
    idtd.limit = sizeof(idt_entry_t) * NUM_INTERRUPT_HANDLERS - 1;
c0002301:	66 c7 05 20 68 00 c0 	movw   $0x7ff,0xc0006820
c0002308:	ff 07 
    load_idt();
c000230a:	e8 b1 16 00 00       	call   c00039c0 <load_idt>
}
c000230f:	90                   	nop
c0002310:	c9                   	leave  
c0002311:	c3                   	ret    

c0002312 <set_interrupt_handler>:

void set_interrupt_handler(int int_num, void* handler)
{
c0002312:	55                   	push   %ebp
c0002313:	89 e5                	mov    %esp,%ebp
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c0002315:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002318:	89 c2                	mov    %eax,%edx
c000231a:	8b 45 08             	mov    0x8(%ebp),%eax
c000231d:	66 89 14 c5 20 60 00 	mov    %dx,-0x3fff9fe0(,%eax,8)
c0002324:	c0 
	idt[int_num].segment = KERNEL_CODE_SEGMENT;
c0002325:	8b 45 08             	mov    0x8(%ebp),%eax
c0002328:	66 c7 04 c5 22 60 00 	movw   $0x8,-0x3fff9fde(,%eax,8)
c000232f:	c0 08 00 
	idt[int_num].zero = 0;
c0002332:	8b 45 08             	mov    0x8(%ebp),%eax
c0002335:	c6 04 c5 24 60 00 c0 	movb   $0x0,-0x3fff9fdc(,%eax,8)
c000233c:	00 
	idt[int_num].type = 0x8e; /* INTERRUPT_GATE */
c000233d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002340:	c6 04 c5 25 60 00 c0 	movb   $0x8e,-0x3fff9fdb(,%eax,8)
c0002347:	8e 
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c0002348:	8b 45 0c             	mov    0xc(%ebp),%eax
c000234b:	c1 e8 10             	shr    $0x10,%eax
c000234e:	89 c2                	mov    %eax,%edx
c0002350:	8b 45 08             	mov    0x8(%ebp),%eax
c0002353:	66 89 14 c5 26 60 00 	mov    %dx,-0x3fff9fda(,%eax,8)
c000235a:	c0 
}
c000235b:	90                   	nop
c000235c:	5d                   	pop    %ebp
c000235d:	c3                   	ret    

c000235e <page_fault_handler>:

void page_fault_handler(uint32_t code, void* fault_ip)
{
c000235e:	55                   	push   %ebp
c000235f:	89 e5                	mov    %esp,%ebp
c0002361:	83 ec 08             	sub    $0x8,%esp

    if(code & PF_CODE_WRITE)
c0002364:	8b 45 08             	mov    0x8(%ebp),%eax
c0002367:	83 e0 02             	and    $0x2,%eax
c000236a:	85 c0                	test   %eax,%eax
c000236c:	74 1b                	je     c0002389 <page_fault_handler+0x2b>
        kprintf("\n\nPage Fault writing to 0x%x (instruction 0x%x)\n", pf_addr(), fault_ip);
c000236e:	e8 59 16 00 00       	call   c00039cc <pf_addr>
c0002373:	83 ec 04             	sub    $0x4,%esp
c0002376:	ff 75 0c             	pushl  0xc(%ebp)
c0002379:	50                   	push   %eax
c000237a:	68 a8 45 00 c0       	push   $0xc00045a8
c000237f:	e8 30 e5 ff ff       	call   c00008b4 <kprintf>
c0002384:	83 c4 10             	add    $0x10,%esp
c0002387:	eb 19                	jmp    c00023a2 <page_fault_handler+0x44>
    else        
        kprintf("\n\nPage Fault reading from 0x%x (instruction 0x%x)\n", pf_addr(), fault_ip);
c0002389:	e8 3e 16 00 00       	call   c00039cc <pf_addr>
c000238e:	83 ec 04             	sub    $0x4,%esp
c0002391:	ff 75 0c             	pushl  0xc(%ebp)
c0002394:	50                   	push   %eax
c0002395:	68 dc 45 00 c0       	push   $0xc00045dc
c000239a:	e8 15 e5 ff ff       	call   c00008b4 <kprintf>
c000239f:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_PGPROT)
c00023a2:	8b 45 08             	mov    0x8(%ebp),%eax
c00023a5:	83 e0 01             	and    $0x1,%eax
c00023a8:	85 c0                	test   %eax,%eax
c00023aa:	74 12                	je     c00023be <page_fault_handler+0x60>
        kprintf("Page protection violation\n");
c00023ac:	83 ec 0c             	sub    $0xc,%esp
c00023af:	68 0f 46 00 c0       	push   $0xc000460f
c00023b4:	e8 fb e4 ff ff       	call   c00008b4 <kprintf>
c00023b9:	83 c4 10             	add    $0x10,%esp
c00023bc:	eb 10                	jmp    c00023ce <page_fault_handler+0x70>
    else
        kprintf("Page not present\n");
c00023be:	83 ec 0c             	sub    $0xc,%esp
c00023c1:	68 2a 46 00 c0       	push   $0xc000462a
c00023c6:	e8 e9 e4 ff ff       	call   c00008b4 <kprintf>
c00023cb:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_USER)
c00023ce:	8b 45 08             	mov    0x8(%ebp),%eax
c00023d1:	83 e0 04             	and    $0x4,%eax
c00023d4:	85 c0                	test   %eax,%eax
c00023d6:	74 10                	je     c00023e8 <page_fault_handler+0x8a>
        kprintf("\n\nFault caused by user code\n");
c00023d8:	83 ec 0c             	sub    $0xc,%esp
c00023db:	68 3c 46 00 c0       	push   $0xc000463c
c00023e0:	e8 cf e4 ff ff       	call   c00008b4 <kprintf>
c00023e5:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_RES)
c00023e8:	8b 45 08             	mov    0x8(%ebp),%eax
c00023eb:	83 e0 08             	and    $0x8,%eax
c00023ee:	85 c0                	test   %eax,%eax
c00023f0:	74 10                	je     c0002402 <page_fault_handler+0xa4>
        kprintf("Page reserved bit set\n");
c00023f2:	83 ec 0c             	sub    $0xc,%esp
c00023f5:	68 59 46 00 c0       	push   $0xc0004659
c00023fa:	e8 b5 e4 ff ff       	call   c00008b4 <kprintf>
c00023ff:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_IF)
c0002402:	8b 45 08             	mov    0x8(%ebp),%eax
c0002405:	83 e0 10             	and    $0x10,%eax
c0002408:	85 c0                	test   %eax,%eax
c000240a:	74 10                	je     c000241c <page_fault_handler+0xbe>
        kprintf("Fault caused by instruction fetch\n");
c000240c:	83 ec 0c             	sub    $0xc,%esp
c000240f:	68 70 46 00 c0       	push   $0xc0004670
c0002414:	e8 9b e4 ff ff       	call   c00008b4 <kprintf>
c0002419:	83 c4 10             	add    $0x10,%esp

    while(1);
c000241c:	eb fe                	jmp    c000241c <page_fault_handler+0xbe>

c000241e <exception_handler>:
}


void exception_handler(uint32_t exception_num, uint32_t code, void* fault_ip)
{
c000241e:	55                   	push   %ebp
c000241f:	89 e5                	mov    %esp,%ebp
c0002421:	83 ec 08             	sub    $0x8,%esp
    if(exception_num==14)
c0002424:	83 7d 08 0e          	cmpl   $0xe,0x8(%ebp)
c0002428:	75 13                	jne    c000243d <exception_handler+0x1f>
        page_fault_handler(code, fault_ip);
c000242a:	83 ec 08             	sub    $0x8,%esp
c000242d:	ff 75 10             	pushl  0x10(%ebp)
c0002430:	ff 75 0c             	pushl  0xc(%ebp)
c0002433:	e8 26 ff ff ff       	call   c000235e <page_fault_handler>
c0002438:	83 c4 10             	add    $0x10,%esp
c000243b:	eb 16                	jmp    c0002453 <exception_handler+0x35>
    else
        kprintf("\n\nException %u with code 0x%x at instruction 0x%x\n", exception_num, code, fault_ip);
c000243d:	ff 75 10             	pushl  0x10(%ebp)
c0002440:	ff 75 0c             	pushl  0xc(%ebp)
c0002443:	ff 75 08             	pushl  0x8(%ebp)
c0002446:	68 94 46 00 c0       	push   $0xc0004694
c000244b:	e8 64 e4 ff ff       	call   c00008b4 <kprintf>
c0002450:	83 c4 10             	add    $0x10,%esp
    while(1);
c0002453:	eb fe                	jmp    c0002453 <exception_handler+0x35>

c0002455 <irq_handler>:
}

void irq_handler(uint32_t irq_num)
{
c0002455:	55                   	push   %ebp
c0002456:	89 e5                	mov    %esp,%ebp
c0002458:	83 ec 18             	sub    $0x18,%esp
    if(irq_num == 1)
c000245b:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c000245f:	75 36                	jne    c0002497 <irq_handler+0x42>
    {
        unsigned char scan_code = inb(0x60);
c0002461:	6a 60                	push   $0x60
c0002463:	e8 38 fb ff ff       	call   c0001fa0 <inb>
c0002468:	83 c4 04             	add    $0x4,%esp
c000246b:	88 45 f7             	mov    %al,-0x9(%ebp)
        char key_ascii = scancode_to_ascii(scan_code);
c000246e:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0002472:	83 ec 0c             	sub    $0xc,%esp
c0002475:	50                   	push   %eax
c0002476:	e8 cf 11 00 00       	call   c000364a <scancode_to_ascii>
c000247b:	83 c4 10             	add    $0x10,%esp
c000247e:	88 45 f6             	mov    %al,-0xa(%ebp)
        // kprintf("code: 0x%x, ascii:%c\n", scan_code, key_ascii);
        if(key_ascii>0)
c0002481:	80 7d f6 00          	cmpb   $0x0,-0xa(%ebp)
c0002485:	7e 10                	jle    c0002497 <irq_handler+0x42>
            kprint_char(key_ascii);
c0002487:	0f be 45 f6          	movsbl -0xa(%ebp),%eax
c000248b:	83 ec 0c             	sub    $0xc,%esp
c000248e:	50                   	push   %eax
c000248f:	e8 cf e3 ff ff       	call   c0000863 <kprint_char>
c0002494:	83 c4 10             	add    $0x10,%esp
    
    }

    // notify PIC that interrupt handling is complete
    if(irq_num >= 8)
c0002497:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
c000249b:	76 12                	jbe    c00024af <irq_handler+0x5a>
        outb(PIC_EOI, PIC2_CMD);
c000249d:	83 ec 08             	sub    $0x8,%esp
c00024a0:	68 a0 00 00 00       	push   $0xa0
c00024a5:	6a 20                	push   $0x20
c00024a7:	e8 11 fb ff ff       	call   c0001fbd <outb>
c00024ac:	83 c4 10             	add    $0x10,%esp

    outb(PIC_EOI, PIC1_CMD);
c00024af:	83 ec 08             	sub    $0x8,%esp
c00024b2:	6a 20                	push   $0x20
c00024b4:	6a 20                	push   $0x20
c00024b6:	e8 02 fb ff ff       	call   c0001fbd <outb>
c00024bb:	83 c4 10             	add    $0x10,%esp

    return;
c00024be:	90                   	nop
}
c00024bf:	c9                   	leave  
c00024c0:	c3                   	ret    

c00024c1 <initialize_multitasking>:
task_control_block_t kernel_main_task;

uint32_t pid_counter;

void initialize_multitasking()
{    
c00024c1:	55                   	push   %ebp
c00024c2:	89 e5                	mov    %esp,%ebp
c00024c4:	83 ec 08             	sub    $0x8,%esp
    // initialize current task as initial task
    kernel_main_task.pid = pid_counter = 0;
c00024c7:	c7 05 80 68 00 c0 00 	movl   $0x0,0xc0006880
c00024ce:	00 00 00 
c00024d1:	a1 80 68 00 c0       	mov    0xc0006880,%eax
c00024d6:	a3 60 68 00 c0       	mov    %eax,0xc0006860
    kernel_main_task.state = RUNNING;
c00024db:	c7 05 64 68 00 c0 00 	movl   $0x0,0xc0006864
c00024e2:	00 00 00 
    kernel_main_task.esp = NULL; //this is initialized only on task switch
c00024e5:	c7 05 68 68 00 c0 00 	movl   $0x0,0xc0006868
c00024ec:	00 00 00 
    kernel_main_task.pd = get_page_dir();
c00024ef:	e8 1c 19 00 00       	call   c0003e10 <get_page_dir>
c00024f4:	a3 70 68 00 c0       	mov    %eax,0xc0006870

    // this is the only task so far
    //as we add tasks this becomes circular linked list
    kernel_main_task.next_task = &kernel_main_task;
c00024f9:	c7 05 74 68 00 c0 60 	movl   $0xc0006860,0xc0006874
c0002500:	68 00 c0 
    current_task = &kernel_main_task;
c0002503:	c7 05 40 68 00 c0 60 	movl   $0xc0006860,0xc0006840
c000250a:	68 00 c0 
}
c000250d:	90                   	nop
c000250e:	c9                   	leave  
c000250f:	c3                   	ret    

c0002510 <new_kernel_task>:

task_control_block_t* new_kernel_task(int32_t (*task_entry) (void))
{
c0002510:	55                   	push   %ebp
c0002511:	89 e5                	mov    %esp,%ebp
c0002513:	83 ec 18             	sub    $0x18,%esp
    task_control_block_t* new_task = kmalloc(sizeof(task_control_block_t));
c0002516:	83 ec 0c             	sub    $0xc,%esp
c0002519:	6a 20                	push   $0x20
c000251b:	e8 fb 0d 00 00       	call   c000331b <kmalloc>
c0002520:	83 c4 10             	add    $0x10,%esp
c0002523:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void* new_stack = kmalloc(KERNEL_STACK_SIZE);
c0002526:	83 ec 0c             	sub    $0xc,%esp
c0002529:	68 00 80 00 00       	push   $0x8000
c000252e:	e8 e8 0d 00 00       	call   c000331b <kmalloc>
c0002533:	83 c4 10             	add    $0x10,%esp
c0002536:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint32_t* esp0 = (uint32_t*) (new_stack + KERNEL_STACK_SIZE);
c0002539:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000253c:	05 00 80 00 00       	add    $0x8000,%eax
c0002541:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // init new stack with valid context to launch new task
    *(--esp0) = (uint32_t) new_task; //argument to launch_task
c0002544:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c0002548:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000254b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000254e:	89 10                	mov    %edx,(%eax)
    *(--esp0) = (uint32_t) terminate_task; // launch_task() returns to here, to close out task
c0002550:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c0002554:	ba c5 3d 00 c0       	mov    $0xc0003dc5,%edx
c0002559:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000255c:	89 10                	mov    %edx,(%eax)
    *(--esp0) = (uint32_t) launch_task; //common entry function for new tasks
c000255e:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c0002562:	ba cd 26 00 c0       	mov    $0xc00026cd,%edx
c0002567:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000256a:	89 10                	mov    %edx,(%eax)
    *(--esp0) = 0; //push ebx
c000256c:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c0002570:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002573:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp0) = 0; //push esi
c0002579:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c000257d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002580:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp0) = 0; //push edi
c0002586:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c000258a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000258d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp0) = 0; //push ebp
c0002593:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c0002597:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000259a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    update_kstack(esp0); //update tss with esp0
c00025a0:	83 ec 0c             	sub    $0xc,%esp
c00025a3:	ff 75 ec             	pushl  -0x14(%ebp)
c00025a6:	e8 7d 13 00 00       	call   c0003928 <update_kstack>
c00025ab:	83 c4 10             	add    $0x10,%esp

    //create copy of kernel page_dir
    void* new_pd = kmalloc_aligned(PAGE_SIZE, PAGE_SIZE);
c00025ae:	83 ec 08             	sub    $0x8,%esp
c00025b1:	68 00 10 00 00       	push   $0x1000
c00025b6:	68 00 10 00 00       	push   $0x1000
c00025bb:	e8 28 0e 00 00       	call   c00033e8 <kmalloc_aligned>
c00025c0:	83 c4 10             	add    $0x10,%esp
c00025c3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    memcpy(new_pd, (void*) &pd->dir,PAGE_SIZE);
c00025c6:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c00025cb:	05 00 f0 3f 00       	add    $0x3ff000,%eax
c00025d0:	83 ec 04             	sub    $0x4,%esp
c00025d3:	68 00 10 00 00       	push   $0x1000
c00025d8:	50                   	push   %eax
c00025d9:	ff 75 e8             	pushl  -0x18(%ebp)
c00025dc:	e8 2d f1 ff ff       	call   c000170e <memcpy>
c00025e1:	83 c4 10             	add    $0x10,%esp
    new_task->pd = get_physaddr(new_pd); //page dir is physical address.
c00025e4:	83 ec 0c             	sub    $0xc,%esp
c00025e7:	ff 75 e8             	pushl  -0x18(%ebp)
c00025ea:	e8 0a 02 00 00       	call   c00027f9 <get_physaddr>
c00025ef:	83 c4 10             	add    $0x10,%esp
c00025f2:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00025f5:	89 42 10             	mov    %eax,0x10(%edx)


    new_task->pid = ++pid_counter;
c00025f8:	a1 80 68 00 c0       	mov    0xc0006880,%eax
c00025fd:	83 c0 01             	add    $0x1,%eax
c0002600:	a3 80 68 00 c0       	mov    %eax,0xc0006880
c0002605:	8b 15 80 68 00 c0    	mov    0xc0006880,%edx
c000260b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000260e:	89 10                	mov    %edx,(%eax)
    new_task->state = WAITING;
c0002610:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002613:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
    new_task->esp = esp0;
c000261a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000261d:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0002620:	89 50 08             	mov    %edx,0x8(%eax)
    new_task->task_entry = task_entry;
c0002623:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002626:	8b 55 08             	mov    0x8(%ebp),%edx
c0002629:	89 50 18             	mov    %edx,0x18(%eax)
    new_task->return_val = -1;
c000262c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000262f:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%eax)

    //insert task into the ll
    new_task->next_task = current_task->next_task;
c0002636:	a1 40 68 00 c0       	mov    0xc0006840,%eax
c000263b:	8b 50 14             	mov    0x14(%eax),%edx
c000263e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002641:	89 50 14             	mov    %edx,0x14(%eax)
    current_task->next_task = new_task;
c0002644:	a1 40 68 00 c0       	mov    0xc0006840,%eax
c0002649:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000264c:	89 50 14             	mov    %edx,0x14(%eax)

    return new_task;
c000264f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0002652:	c9                   	leave  
c0002653:	c3                   	ret    

c0002654 <yield>:

void yield(void)
{
c0002654:	55                   	push   %ebp
c0002655:	89 e5                	mov    %esp,%ebp
c0002657:	83 ec 08             	sub    $0x8,%esp
    current_task->state = WAITING;
c000265a:	a1 40 68 00 c0       	mov    0xc0006840,%eax
c000265f:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
    current_task->next_task->state = RUNNING;    
c0002666:	a1 40 68 00 c0       	mov    0xc0006840,%eax
c000266b:	8b 40 14             	mov    0x14(%eax),%eax
c000266e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    switch_to_task(current_task->next_task);
c0002675:	a1 40 68 00 c0       	mov    0xc0006840,%eax
c000267a:	8b 40 14             	mov    0x14(%eax),%eax
c000267d:	83 ec 0c             	sub    $0xc,%esp
c0002680:	50                   	push   %eax
c0002681:	e8 0a 17 00 00       	call   c0003d90 <switch_to_task>
c0002686:	83 c4 10             	add    $0x10,%esp
}
c0002689:	90                   	nop
c000268a:	c9                   	leave  
c000268b:	c3                   	ret    

c000268c <join>:

int32_t join(task_control_block_t* task)
{
c000268c:	55                   	push   %ebp
c000268d:	89 e5                	mov    %esp,%ebp
c000268f:	83 ec 08             	sub    $0x8,%esp
    // make sure we are not trying to join the current task or the main kernel task
    if(task == current_task || task == &kernel_main_task)
c0002692:	a1 40 68 00 c0       	mov    0xc0006840,%eax
c0002697:	39 45 08             	cmp    %eax,0x8(%ebp)
c000269a:	74 09                	je     c00026a5 <join+0x19>
c000269c:	81 7d 08 60 68 00 c0 	cmpl   $0xc0006860,0x8(%ebp)
c00026a3:	75 0c                	jne    c00026b1 <join+0x25>
        return -1; 
c00026a5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00026aa:	eb 1f                	jmp    c00026cb <join+0x3f>

    while(task->state == WAITING || task->state == RUNNING)
        yield();
c00026ac:	e8 a3 ff ff ff       	call   c0002654 <yield>
    while(task->state == WAITING || task->state == RUNNING)
c00026b1:	8b 45 08             	mov    0x8(%ebp),%eax
c00026b4:	8b 40 04             	mov    0x4(%eax),%eax
c00026b7:	83 f8 02             	cmp    $0x2,%eax
c00026ba:	74 f0                	je     c00026ac <join+0x20>
c00026bc:	8b 45 08             	mov    0x8(%ebp),%eax
c00026bf:	8b 40 04             	mov    0x4(%eax),%eax
c00026c2:	85 c0                	test   %eax,%eax
c00026c4:	74 e6                	je     c00026ac <join+0x20>
    // free task memory: stack, heap and paging structures
    // free tcb? << what should lifetime be?  Want to interrogate after process completes, but dont want it to live forever...

//    kfree(task);

    return 0;
c00026c6:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00026cb:	c9                   	leave  
c00026cc:	c3                   	ret    

c00026cd <launch_task>:


void launch_task(task_control_block_t* task)
{
c00026cd:	55                   	push   %ebp
c00026ce:	89 e5                	mov    %esp,%ebp
c00026d0:	83 ec 18             	sub    $0x18,%esp
    task->state = RUNNING;
c00026d3:	8b 45 08             	mov    0x8(%ebp),%eax
c00026d6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

   // call task main function
    task->return_val = (*task->task_entry)();
c00026dd:	8b 45 08             	mov    0x8(%ebp),%eax
c00026e0:	8b 40 18             	mov    0x18(%eax),%eax
c00026e3:	ff d0                	call   *%eax
c00026e5:	8b 55 08             	mov    0x8(%ebp),%edx
c00026e8:	89 42 1c             	mov    %eax,0x1c(%edx)

    //remove this task from active task list
    task_control_block_t* t = task->next_task;
c00026eb:	8b 45 08             	mov    0x8(%ebp),%eax
c00026ee:	8b 40 14             	mov    0x14(%eax),%eax
c00026f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while( t->next_task != task)
c00026f4:	eb 09                	jmp    c00026ff <launch_task+0x32>
        t = t->next_task;
c00026f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00026f9:	8b 40 14             	mov    0x14(%eax),%eax
c00026fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while( t->next_task != task)
c00026ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002702:	8b 40 14             	mov    0x14(%eax),%eax
c0002705:	39 45 08             	cmp    %eax,0x8(%ebp)
c0002708:	75 ec                	jne    c00026f6 <launch_task+0x29>
    t->next_task = t->next_task->next_task;
c000270a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000270d:	8b 40 14             	mov    0x14(%eax),%eax
c0002710:	8b 50 14             	mov    0x14(%eax),%edx
c0002713:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002716:	89 50 14             	mov    %edx,0x14(%eax)

    task->state = COMPLETE;
c0002719:	8b 45 08             	mov    0x8(%ebp),%eax
c000271c:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)

    // this will "return" to terminite_task 
}
c0002723:	90                   	nop
c0002724:	c9                   	leave  
c0002725:	c3                   	ret    

c0002726 <num_tasks>:

int num_tasks()
{
c0002726:	55                   	push   %ebp
c0002727:	89 e5                	mov    %esp,%ebp
c0002729:	83 ec 10             	sub    $0x10,%esp
    task_control_block_t* t = current_task;
c000272c:	a1 40 68 00 c0       	mov    0xc0006840,%eax
c0002731:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int nn = 1;
c0002734:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    while( t->next_task != current_task)
c000273b:	eb 0d                	jmp    c000274a <num_tasks+0x24>
    {
        t = t->next_task;
c000273d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002740:	8b 40 14             	mov    0x14(%eax),%eax
c0002743:	89 45 fc             	mov    %eax,-0x4(%ebp)
        nn++;
c0002746:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while( t->next_task != current_task)
c000274a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000274d:	8b 50 14             	mov    0x14(%eax),%edx
c0002750:	a1 40 68 00 c0       	mov    0xc0006840,%eax
c0002755:	39 c2                	cmp    %eax,%edx
c0002757:	75 e4                	jne    c000273d <num_tasks+0x17>
    }
    return nn;
c0002759:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c000275c:	c9                   	leave  
c000275d:	c3                   	ret    

c000275e <user_test>:
int user_test()
{
c000275e:	55                   	push   %ebp
c000275f:	89 e5                	mov    %esp,%ebp
c0002761:	83 ec 10             	sub    $0x10,%esp
    int a = 1;
c0002764:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
    int b = 2;
c000276b:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
    int c = b/a;
c0002772:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0002775:	99                   	cltd   
c0002776:	f7 7d fc             	idivl  -0x4(%ebp)
c0002779:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return c;
c000277c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000277f:	c9                   	leave  
c0002780:	c3                   	ret    

c0002781 <get_ptindex>:
    page_table_t tables[PAGING_NUM_PDE-1];
    page_directory_t dir;
} page_directory_virt_t;


//global pointer to page directory
c0002781:	55                   	push   %ebp
c0002782:	89 e5                	mov    %esp,%ebp
extern page_directory_virt_t* pd;
c0002784:	8b 45 08             	mov    0x8(%ebp),%eax
c0002787:	c1 e8 0c             	shr    $0xc,%eax
c000278a:	25 ff 03 00 00       	and    $0x3ff,%eax

c000278f:	5d                   	pop    %ebp
c0002790:	c3                   	ret    

c0002791 <get_pdindex>:
// return page table index for virtual address
static inline uint32_t get_ptindex(void* addr)
{
    return (((uint32_t) addr) & PAGE_PTE_MASK ) >> 12;
c0002791:	55                   	push   %ebp
c0002792:	89 e5                	mov    %esp,%ebp
}
c0002794:	8b 45 08             	mov    0x8(%ebp),%eax
c0002797:	c1 e8 16             	shr    $0x16,%eax

c000279a:	5d                   	pop    %ebp
c000279b:	c3                   	ret    

c000279c <get_page_offset>:
// return page directory index for virtual address
static inline uint32_t get_pdindex(void* addr)
{
    return ((uint32_t) addr) >> 22;
c000279c:	55                   	push   %ebp
c000279d:	89 e5                	mov    %esp,%ebp
}
c000279f:	8b 45 08             	mov    0x8(%ebp),%eax
c00027a2:	25 ff 0f 00 00       	and    $0xfff,%eax

c00027a7:	5d                   	pop    %ebp
c00027a8:	c3                   	ret    

c00027a9 <get_table>:

page_directory_virt_t* pd = (page_directory_virt_t*) PD_ADDR;

// return page directory index for virtual address
page_table_t* get_table(void* addr)
{
c00027a9:	55                   	push   %ebp
c00027aa:	89 e5                	mov    %esp,%ebp
c00027ac:	53                   	push   %ebx
c00027ad:	83 ec 10             	sub    $0x10,%esp
    uint32_t idx = get_pdindex(addr);
c00027b0:	ff 75 08             	pushl  0x8(%ebp)
c00027b3:	e8 d9 ff ff ff       	call   c0002791 <get_pdindex>
c00027b8:	83 c4 04             	add    $0x4,%esp
c00027bb:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(pd->dir.pde[idx] & PAGE_FLAG_PRESENT)
c00027be:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c00027c3:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00027c6:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c00027cc:	8b 04 90             	mov    (%eax,%edx,4),%eax
c00027cf:	83 e0 01             	and    $0x1,%eax
c00027d2:	85 c0                	test   %eax,%eax
c00027d4:	74 19                	je     c00027ef <get_table+0x46>
        return pd->tables + get_pdindex(addr);
c00027d6:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c00027db:	89 c3                	mov    %eax,%ebx
c00027dd:	ff 75 08             	pushl  0x8(%ebp)
c00027e0:	e8 ac ff ff ff       	call   c0002791 <get_pdindex>
c00027e5:	83 c4 04             	add    $0x4,%esp
c00027e8:	c1 e0 0c             	shl    $0xc,%eax
c00027eb:	01 d8                	add    %ebx,%eax
c00027ed:	eb 05                	jmp    c00027f4 <get_table+0x4b>
    else 
        return NULL;
c00027ef:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00027f4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00027f7:	c9                   	leave  
c00027f8:	c3                   	ret    

c00027f9 <get_physaddr>:

// return physical addr from virt addr
void* get_physaddr(void* addr)
{
c00027f9:	55                   	push   %ebp
c00027fa:	89 e5                	mov    %esp,%ebp
c00027fc:	53                   	push   %ebx
c00027fd:	83 ec 10             	sub    $0x10,%esp
    //check pd entry is present
    uint32_t pdi = get_pdindex(addr);
c0002800:	ff 75 08             	pushl  0x8(%ebp)
c0002803:	e8 89 ff ff ff       	call   c0002791 <get_pdindex>
c0002808:	83 c4 04             	add    $0x4,%esp
c000280b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(! pd->dir.pde[pdi] & PAGE_FLAG_PRESENT)
c000280e:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c0002813:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0002816:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c000281c:	8b 04 90             	mov    (%eax,%edx,4),%eax
c000281f:	85 c0                	test   %eax,%eax
c0002821:	75 07                	jne    c000282a <get_physaddr+0x31>
        return NULL;
c0002823:	b8 00 00 00 00       	mov    $0x0,%eax
c0002828:	eb 45                	jmp    c000286f <get_physaddr+0x76>

    //check pt entry is present
    uint32_t pte = pd->tables[pdi].pte[get_ptindex(addr)];
c000282a:	8b 1d 00 50 00 c0    	mov    0xc0005000,%ebx
c0002830:	ff 75 08             	pushl  0x8(%ebp)
c0002833:	e8 49 ff ff ff       	call   c0002781 <get_ptindex>
c0002838:	83 c4 04             	add    $0x4,%esp
c000283b:	89 c2                	mov    %eax,%edx
c000283d:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0002840:	c1 e0 0a             	shl    $0xa,%eax
c0002843:	01 d0                	add    %edx,%eax
c0002845:	8b 04 83             	mov    (%ebx,%eax,4),%eax
c0002848:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(! pte & PAGE_FLAG_PRESENT)
c000284b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c000284f:	75 07                	jne    c0002858 <get_physaddr+0x5f>
        return NULL;
c0002851:	b8 00 00 00 00       	mov    $0x0,%eax
c0002856:	eb 17                	jmp    c000286f <get_physaddr+0x76>

    return (void*) ((pte & PAGE_ADDRMASK) +  get_page_offset(addr) );
c0002858:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000285b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002860:	89 c3                	mov    %eax,%ebx
c0002862:	ff 75 08             	pushl  0x8(%ebp)
c0002865:	e8 32 ff ff ff       	call   c000279c <get_page_offset>
c000286a:	83 c4 04             	add    $0x4,%esp
c000286d:	01 d8                	add    %ebx,%eax
}
c000286f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0002872:	c9                   	leave  
c0002873:	c3                   	ret    

c0002874 <get_ptindex>:
{
c0002874:	55                   	push   %ebp
c0002875:	89 e5                	mov    %esp,%ebp
    return (((uint32_t) addr) & PAGE_PTE_MASK ) >> 12;
c0002877:	8b 45 08             	mov    0x8(%ebp),%eax
c000287a:	c1 e8 0c             	shr    $0xc,%eax
c000287d:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c0002882:	5d                   	pop    %ebp
c0002883:	c3                   	ret    

c0002884 <get_pdindex>:
{
c0002884:	55                   	push   %ebp
c0002885:	89 e5                	mov    %esp,%ebp
    return ((uint32_t) addr) >> 22;
c0002887:	8b 45 08             	mov    0x8(%ebp),%eax
c000288a:	c1 e8 16             	shr    $0x16,%eax
}
c000288d:	5d                   	pop    %ebp
c000288e:	c3                   	ret    

c000288f <align_int>:
{
c000288f:	55                   	push   %ebp
c0002890:	89 e5                	mov    %esp,%ebp
c0002892:	83 ec 10             	sub    $0x10,%esp
    size_t am = alignment - 1;
c0002895:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002898:	83 e8 01             	sub    $0x1,%eax
c000289b:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (((size_t)len + am) & ~am);
c000289e:	8b 55 08             	mov    0x8(%ebp),%edx
c00028a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00028a4:	01 c2                	add    %eax,%edx
c00028a6:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00028a9:	f7 d0                	not    %eax
c00028ab:	21 d0                	and    %edx,%eax
}
c00028ad:	c9                   	leave  
c00028ae:	c3                   	ret    

c00028af <align_ptr>:

static inline void* align_ptr(void* addr, size_t alignment)
{
c00028af:	55                   	push   %ebp
c00028b0:	89 e5                	mov    %esp,%ebp
    // alignment must be increment of 4
    if(alignment % sizeof(void*) != 0 ) return NULL;
c00028b2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00028b5:	83 e0 03             	and    $0x3,%eax
c00028b8:	85 c0                	test   %eax,%eax
c00028ba:	74 07                	je     c00028c3 <align_ptr+0x14>
c00028bc:	b8 00 00 00 00       	mov    $0x0,%eax
c00028c1:	eb 0f                	jmp    c00028d2 <align_ptr+0x23>
    return (void*) align_int((size_t) addr, alignment);
c00028c3:	8b 45 08             	mov    0x8(%ebp),%eax
c00028c6:	ff 75 0c             	pushl  0xc(%ebp)
c00028c9:	50                   	push   %eax
c00028ca:	e8 c0 ff ff ff       	call   c000288f <align_int>
c00028cf:	83 c4 08             	add    $0x8,%esp
}
c00028d2:	c9                   	leave  
c00028d3:	c3                   	ret    

c00028d4 <pop_free_frame>:
// 0xffc00000-0xffffffff:                   page tables


// allocate a physical page from the stack
page_t* pop_free_frame()
{
c00028d4:	55                   	push   %ebp
c00028d5:	89 e5                	mov    %esp,%ebp
c00028d7:	83 ec 10             	sub    $0x10,%esp
    page_t* free_frame = *(frame_stack_top++);
c00028da:	a1 98 68 00 c0       	mov    0xc0006898,%eax
c00028df:	8d 50 04             	lea    0x4(%eax),%edx
c00028e2:	89 15 98 68 00 c0    	mov    %edx,0xc0006898
c00028e8:	8b 00                	mov    (%eax),%eax
c00028ea:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(frame_stack_top<frame_stack_base)
c00028ed:	8b 15 98 68 00 c0    	mov    0xc0006898,%edx
c00028f3:	a1 9c 68 00 c0       	mov    0xc000689c,%eax
c00028f8:	39 c2                	cmp    %eax,%edx
c00028fa:	73 05                	jae    c0002901 <pop_free_frame+0x2d>
        return free_frame;
c00028fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00028ff:	eb 05                	jmp    c0002906 <pop_free_frame+0x32>
    else
        return NULL; //out of memory!    
c0002901:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002906:	c9                   	leave  
c0002907:	c3                   	ret    

c0002908 <push_free_frame>:

// free a physical page back to the stack
int push_free_frame(page_t* free_frame)
{
c0002908:	55                   	push   %ebp
c0002909:	89 e5                	mov    %esp,%ebp
    if(frame_stack_top<=frame_stack_start)
c000290b:	8b 15 98 68 00 c0    	mov    0xc0006898,%edx
c0002911:	a1 94 68 00 c0       	mov    0xc0006894,%eax
c0002916:	39 c2                	cmp    %eax,%edx
c0002918:	77 07                	ja     c0002921 <push_free_frame+0x19>
        return -1;
c000291a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000291f:	eb 18                	jmp    c0002939 <push_free_frame+0x31>

    *(frame_stack_top--) = free_frame;
c0002921:	a1 98 68 00 c0       	mov    0xc0006898,%eax
c0002926:	8d 50 fc             	lea    -0x4(%eax),%edx
c0002929:	89 15 98 68 00 c0    	mov    %edx,0xc0006898
c000292f:	8b 55 08             	mov    0x8(%ebp),%edx
c0002932:	89 10                	mov    %edx,(%eax)
    return 0;
c0002934:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002939:	5d                   	pop    %ebp
c000293a:	c3                   	ret    

c000293b <init_frame_stack>:

// set up a stack will all free pages of physical memory
void init_frame_stack(multiboot_info_t* mbd)
{
c000293b:	55                   	push   %ebp
c000293c:	89 e5                	mov    %esp,%ebp
c000293e:	57                   	push   %edi
c000293f:	56                   	push   %esi
c0002940:	83 ec 30             	sub    $0x30,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c0002943:	8b 45 08             	mov    0x8(%ebp),%eax
c0002946:	8b 40 30             	mov    0x30(%eax),%eax
c0002949:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // We will start looking for free physical memory just above the kernel
    page_t* first_free_frame = align_ptr( &_kernel_end_phys, PAGE_SIZE); //physical address of first free page after the kernel
c000294c:	68 00 10 00 00       	push   $0x1000
c0002951:	68 00 00 21 00       	push   $0x210000
c0002956:	e8 54 ff ff ff       	call   c00028af <align_ptr>
c000295b:	83 c4 08             	add    $0x8,%esp
c000295e:	89 45 e8             	mov    %eax,-0x18(%ebp)

    // Map the stack just past the end of the kernel in virtual mem

    // stack_break points to the end of the allocated region for the stack  
    frame_stack_brk = align_ptr( &_kernel_end, PAGE_SIZE);
c0002961:	68 00 10 00 00       	push   $0x1000
c0002966:	68 00 f0 10 c0       	push   $0xc010f000
c000296b:	e8 3f ff ff ff       	call   c00028af <align_ptr>
c0002970:	83 c4 08             	add    $0x8,%esp
c0002973:	a3 a0 68 00 c0       	mov    %eax,0xc00068a0

    // initialize stack pointers
    // we will initialize the stack by adding new pages to the base
    // first pages (in low mem) will be at top of the stack
    frame_stack_start = (page_t**) frame_stack_brk;
c0002978:	a1 a0 68 00 c0       	mov    0xc00068a0,%eax
c000297d:	a3 94 68 00 c0       	mov    %eax,0xc0006894
    frame_stack_top = frame_stack_start;
c0002982:	a1 94 68 00 c0       	mov    0xc0006894,%eax
c0002987:	a3 98 68 00 c0       	mov    %eax,0xc0006898
    frame_stack_base = frame_stack_top;
c000298c:	a1 98 68 00 c0       	mov    0xc0006898,%eax
c0002991:	a3 9c 68 00 c0       	mov    %eax,0xc000689c

    // allocate one page for the stack, incrementing the stack_break and first_free_frame pointers
    // We will allocate more pages for the stack as we go as needed
    if(!map_page_at(frame_stack_brk++, first_free_frame++, PAGE_FLAG_WRITE))
c0002996:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0002999:	8d 82 00 10 00 00    	lea    0x1000(%edx),%eax
c000299f:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00029a2:	a1 a0 68 00 c0       	mov    0xc00068a0,%eax
c00029a7:	8d 88 00 10 00 00    	lea    0x1000(%eax),%ecx
c00029ad:	89 0d a0 68 00 c0    	mov    %ecx,0xc00068a0
c00029b3:	83 ec 04             	sub    $0x4,%esp
c00029b6:	6a 02                	push   $0x2
c00029b8:	52                   	push   %edx
c00029b9:	50                   	push   %eax
c00029ba:	e8 98 03 00 00       	call   c0002d57 <map_page_at>
c00029bf:	83 c4 10             	add    $0x10,%esp
c00029c2:	85 c0                	test   %eax,%eax
c00029c4:	75 10                	jne    c00029d6 <init_frame_stack+0x9b>
        panic("Error reserving memory for physical page allocation!");
c00029c6:	83 ec 0c             	sub    $0xc,%esp
c00029c9:	68 c8 46 00 c0       	push   $0xc00046c8
c00029ce:	e8 fe ec ff ff       	call   c00016d1 <panic>
c00029d3:	83 c4 10             	add    $0x10,%esp

    // loop through each block of memory defined in the multiboot record
    // for each block of memory, add free pages to stack
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c00029d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00029dd:	e9 50 01 00 00       	jmp    c0002b32 <init_frame_stack+0x1f7>
	{
        if(mmap_table[nn].size == 0) // end of table
c00029e2:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00029e5:	89 d0                	mov    %edx,%eax
c00029e7:	01 c0                	add    %eax,%eax
c00029e9:	01 d0                	add    %edx,%eax
c00029eb:	c1 e0 03             	shl    $0x3,%eax
c00029ee:	89 c2                	mov    %eax,%edx
c00029f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00029f3:	01 d0                	add    %edx,%eax
c00029f5:	8b 00                	mov    (%eax),%eax
c00029f7:	85 c0                	test   %eax,%eax
c00029f9:	0f 84 44 01 00 00    	je     c0002b43 <init_frame_stack+0x208>
            break;

        if(mmap_table[nn].addr >> 32) // ignore anything above 32bits
c00029ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002a02:	89 d0                	mov    %edx,%eax
c0002a04:	01 c0                	add    %eax,%eax
c0002a06:	01 d0                	add    %edx,%eax
c0002a08:	c1 e0 03             	shl    $0x3,%eax
c0002a0b:	89 c2                	mov    %eax,%edx
c0002a0d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002a10:	01 d0                	add    %edx,%eax
c0002a12:	8b 50 08             	mov    0x8(%eax),%edx
c0002a15:	8b 40 04             	mov    0x4(%eax),%eax
c0002a18:	89 d0                	mov    %edx,%eax
c0002a1a:	31 d2                	xor    %edx,%edx
c0002a1c:	89 c1                	mov    %eax,%ecx
c0002a1e:	80 f5 00             	xor    $0x0,%ch
c0002a21:	89 ce                	mov    %ecx,%esi
c0002a23:	89 d0                	mov    %edx,%eax
c0002a25:	80 f4 00             	xor    $0x0,%ah
c0002a28:	89 c7                	mov    %eax,%edi
c0002a2a:	89 f8                	mov    %edi,%eax
c0002a2c:	09 f0                	or     %esi,%eax
c0002a2e:	85 c0                	test   %eax,%eax
c0002a30:	0f 85 f7 00 00 00    	jne    c0002b2d <init_frame_stack+0x1f2>
            continue;

		if(mmap_table[nn].type == MULTIBOOT_MEMORY_AVAILABLE)
c0002a36:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002a39:	89 d0                	mov    %edx,%eax
c0002a3b:	01 c0                	add    %eax,%eax
c0002a3d:	01 d0                	add    %edx,%eax
c0002a3f:	c1 e0 03             	shl    $0x3,%eax
c0002a42:	89 c2                	mov    %eax,%edx
c0002a44:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002a47:	01 d0                	add    %edx,%eax
c0002a49:	8b 40 14             	mov    0x14(%eax),%eax
c0002a4c:	83 f8 01             	cmp    $0x1,%eax
c0002a4f:	0f 85 d9 00 00 00    	jne    c0002b2e <init_frame_stack+0x1f3>
        {
            //pointers to the first and last page in this memory block 
            size_t block_addr = mmap_table[nn].addr;
c0002a55:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002a58:	89 d0                	mov    %edx,%eax
c0002a5a:	01 c0                	add    %eax,%eax
c0002a5c:	01 d0                	add    %edx,%eax
c0002a5e:	c1 e0 03             	shl    $0x3,%eax
c0002a61:	89 c2                	mov    %eax,%edx
c0002a63:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002a66:	01 d0                	add    %edx,%eax
c0002a68:	8b 50 08             	mov    0x8(%eax),%edx
c0002a6b:	8b 40 04             	mov    0x4(%eax),%eax
c0002a6e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            size_t block_len = mmap_table[nn].len;
c0002a71:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002a74:	89 d0                	mov    %edx,%eax
c0002a76:	01 c0                	add    %eax,%eax
c0002a78:	01 d0                	add    %edx,%eax
c0002a7a:	c1 e0 03             	shl    $0x3,%eax
c0002a7d:	89 c2                	mov    %eax,%edx
c0002a7f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002a82:	01 d0                	add    %edx,%eax
c0002a84:	8b 50 10             	mov    0x10(%eax),%edx
c0002a87:	8b 40 0c             	mov    0xc(%eax),%eax
c0002a8a:	89 45 e0             	mov    %eax,-0x20(%ebp)
            page_t* pg = align_ptr( (char*) block_addr, PAGE_SIZE); // first whole page in block
c0002a8d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0002a90:	83 ec 08             	sub    $0x8,%esp
c0002a93:	68 00 10 00 00       	push   $0x1000
c0002a98:	50                   	push   %eax
c0002a99:	e8 11 fe ff ff       	call   c00028af <align_ptr>
c0002a9e:	83 c4 10             	add    $0x10,%esp
c0002aa1:	89 45 f0             	mov    %eax,-0x10(%ebp)
            page_t* pg_end = (page_t*) ((block_addr+block_len) & PAGE_ADDRMASK); // first page *after* last whole page in block
c0002aa4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0002aa7:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0002aaa:	01 d0                	add    %edx,%eax
c0002aac:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002ab1:	89 45 dc             	mov    %eax,-0x24(%ebp)

            //don't map any memory before end of the kernel
            pg = pg<first_free_frame ? first_free_frame : pg; 
c0002ab4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002ab7:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0002aba:	0f 43 45 f0          	cmovae -0x10(%ebp),%eax
c0002abe:	89 45 f0             	mov    %eax,-0x10(%ebp)

            //fill stack with pointers to each page in the block
            for(; pg<pg_end; pg++)
c0002ac1:	eb 60                	jmp    c0002b23 <init_frame_stack+0x1e8>
            {
                // extend end of stack and make sure we have allocated enough memory
                if( (void*) ++frame_stack_base >= (void*) frame_stack_brk)
c0002ac3:	a1 9c 68 00 c0       	mov    0xc000689c,%eax
c0002ac8:	83 c0 04             	add    $0x4,%eax
c0002acb:	a3 9c 68 00 c0       	mov    %eax,0xc000689c
c0002ad0:	8b 15 9c 68 00 c0    	mov    0xc000689c,%edx
c0002ad6:	a1 a0 68 00 c0       	mov    0xc00068a0,%eax
c0002adb:	39 c2                	cmp    %eax,%edx
c0002add:	72 33                	jb     c0002b12 <init_frame_stack+0x1d7>
                {
                    // map a new page at the end of the stack
                    // note that this will pop a free page off the top of the stack
                    if(!map_page(frame_stack_brk++, PAGE_FLAG_WRITE))
c0002adf:	a1 a0 68 00 c0       	mov    0xc00068a0,%eax
c0002ae4:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c0002aea:	89 15 a0 68 00 c0    	mov    %edx,0xc00068a0
c0002af0:	83 ec 08             	sub    $0x8,%esp
c0002af3:	6a 02                	push   $0x2
c0002af5:	50                   	push   %eax
c0002af6:	e8 e8 02 00 00       	call   c0002de3 <map_page>
c0002afb:	83 c4 10             	add    $0x10,%esp
c0002afe:	85 c0                	test   %eax,%eax
c0002b00:	75 10                	jne    c0002b12 <init_frame_stack+0x1d7>
                        panic("Error reserving memory for physical page allocation!");
c0002b02:	83 ec 0c             	sub    $0xc,%esp
c0002b05:	68 c8 46 00 c0       	push   $0xc00046c8
c0002b0a:	e8 c2 eb ff ff       	call   c00016d1 <panic>
c0002b0f:	83 c4 10             	add    $0x10,%esp
                }

                //record physical page at end stack
                *frame_stack_base = pg;
c0002b12:	a1 9c 68 00 c0       	mov    0xc000689c,%eax
c0002b17:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0002b1a:	89 10                	mov    %edx,(%eax)
            for(; pg<pg_end; pg++)
c0002b1c:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
c0002b23:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002b26:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c0002b29:	72 98                	jb     c0002ac3 <init_frame_stack+0x188>
c0002b2b:	eb 01                	jmp    c0002b2e <init_frame_stack+0x1f3>
            continue;
c0002b2d:	90                   	nop
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0002b2e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0002b32:	8b 45 08             	mov    0x8(%ebp),%eax
c0002b35:	8b 40 2c             	mov    0x2c(%eax),%eax
c0002b38:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0002b3b:	0f 82 a1 fe ff ff    	jb     c00029e2 <init_frame_stack+0xa7>
c0002b41:	eb 01                	jmp    c0002b44 <init_frame_stack+0x209>
            break;
c0002b43:	90                   	nop
            }
        }
	}

    size_t free_frames = frame_stack_base-frame_stack_top;
c0002b44:	a1 9c 68 00 c0       	mov    0xc000689c,%eax
c0002b49:	8b 15 98 68 00 c0    	mov    0xc0006898,%edx
c0002b4f:	29 d0                	sub    %edx,%eax
c0002b51:	c1 f8 02             	sar    $0x2,%eax
c0002b54:	89 45 d8             	mov    %eax,-0x28(%ebp)
	kprintf("\nFound %d frames of RAM (%f MB)\n", free_frames, free_frames*PAGE_SIZE/1e6);
c0002b57:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0002b5a:	c1 e0 0c             	shl    $0xc,%eax
c0002b5d:	89 45 d0             	mov    %eax,-0x30(%ebp)
c0002b60:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
c0002b67:	df 6d d0             	fildll -0x30(%ebp)
c0002b6a:	dd 05 40 47 00 c0    	fldl   0xc0004740
c0002b70:	de f9                	fdivrp %st,%st(1)
c0002b72:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0002b76:	dd 1c 24             	fstpl  (%esp)
c0002b79:	ff 75 d8             	pushl  -0x28(%ebp)
c0002b7c:	68 00 47 00 c0       	push   $0xc0004700
c0002b81:	e8 2e dd ff ff       	call   c00008b4 <kprintf>
c0002b86:	83 c4 10             	add    $0x10,%esp

}
c0002b89:	90                   	nop
c0002b8a:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0002b8d:	5e                   	pop    %esi
c0002b8e:	5f                   	pop    %edi
c0002b8f:	5d                   	pop    %ebp
c0002b90:	c3                   	ret    

c0002b91 <ksbrk>:



// increment heap size, return pointer to *old* break (beginning of newly allocated memory)
void* ksbrk(size_t increment)
{
c0002b91:	55                   	push   %ebp
c0002b92:	89 e5                	mov    %esp,%ebp
c0002b94:	83 ec 18             	sub    $0x18,%esp
    if(increment == 0) return kheap_brk;
c0002b97:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002b9b:	75 07                	jne    c0002ba4 <ksbrk+0x13>
c0002b9d:	a1 8c 68 00 c0       	mov    0xc000688c,%eax
c0002ba2:	eb 2d                	jmp    c0002bd1 <ksbrk+0x40>

    page_t* old_brk = kheap_brk;
c0002ba4:	a1 8c 68 00 c0       	mov    0xc000688c,%eax
c0002ba9:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(kbrk(((char*)kheap_brk) + increment)) return NULL;
c0002bac:	8b 15 8c 68 00 c0    	mov    0xc000688c,%edx
c0002bb2:	8b 45 08             	mov    0x8(%ebp),%eax
c0002bb5:	01 d0                	add    %edx,%eax
c0002bb7:	83 ec 0c             	sub    $0xc,%esp
c0002bba:	50                   	push   %eax
c0002bbb:	e8 13 00 00 00       	call   c0002bd3 <kbrk>
c0002bc0:	83 c4 10             	add    $0x10,%esp
c0002bc3:	85 c0                	test   %eax,%eax
c0002bc5:	74 07                	je     c0002bce <ksbrk+0x3d>
c0002bc7:	b8 00 00 00 00       	mov    $0x0,%eax
c0002bcc:	eb 03                	jmp    c0002bd1 <ksbrk+0x40>

    return old_brk;
c0002bce:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0002bd1:	c9                   	leave  
c0002bd2:	c3                   	ret    

c0002bd3 <kbrk>:

// set kheap break to addr, growing or shrinking heap accordingly
// returns 0 on success
int kbrk(void* addr)
{
c0002bd3:	55                   	push   %ebp
c0002bd4:	89 e5                	mov    %esp,%ebp
c0002bd6:	83 ec 18             	sub    $0x18,%esp
    //make sure this is a valid break (not before heap begins or into stack)
    if(addr < (void*) kheap_base || addr >= (void*) kstack_brk)
c0002bd9:	a1 90 68 00 c0       	mov    0xc0006890,%eax
c0002bde:	39 45 08             	cmp    %eax,0x8(%ebp)
c0002be1:	72 0a                	jb     c0002bed <kbrk+0x1a>
c0002be3:	a1 88 68 00 c0       	mov    0xc0006888,%eax
c0002be8:	39 45 08             	cmp    %eax,0x8(%ebp)
c0002beb:	72 0a                	jb     c0002bf7 <kbrk+0x24>
        return -1; 
c0002bed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002bf2:	e9 8f 00 00 00       	jmp    c0002c86 <kbrk+0xb3>

    page_t* pg_addr = align_ptr(addr, PAGE_SIZE); // align addr to a page
c0002bf7:	68 00 10 00 00       	push   $0x1000
c0002bfc:	ff 75 08             	pushl  0x8(%ebp)
c0002bff:	e8 ab fc ff ff       	call   c00028af <align_ptr>
c0002c04:	83 c4 08             	add    $0x8,%esp
c0002c07:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(pg_addr > kheap_brk)
c0002c0a:	a1 8c 68 00 c0       	mov    0xc000688c,%eax
c0002c0f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0002c12:	76 63                	jbe    c0002c77 <kbrk+0xa4>
    {
        // we are increasing size of the heap
        while(pg_addr > kheap_brk)
c0002c14:	eb 2a                	jmp    c0002c40 <kbrk+0x6d>
        {
            // allocate a new page and map to end of heap
            if(!map_page(kheap_brk++, PAGE_FLAG_WRITE))
c0002c16:	a1 8c 68 00 c0       	mov    0xc000688c,%eax
c0002c1b:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c0002c21:	89 15 8c 68 00 c0    	mov    %edx,0xc000688c
c0002c27:	83 ec 08             	sub    $0x8,%esp
c0002c2a:	6a 02                	push   $0x2
c0002c2c:	50                   	push   %eax
c0002c2d:	e8 b1 01 00 00       	call   c0002de3 <map_page>
c0002c32:	83 c4 10             	add    $0x10,%esp
c0002c35:	85 c0                	test   %eax,%eax
c0002c37:	75 07                	jne    c0002c40 <kbrk+0x6d>
                return -1; // out of physical memory
c0002c39:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002c3e:	eb 46                	jmp    c0002c86 <kbrk+0xb3>
        while(pg_addr > kheap_brk)
c0002c40:	a1 8c 68 00 c0       	mov    0xc000688c,%eax
c0002c45:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0002c48:	77 cc                	ja     c0002c16 <kbrk+0x43>
c0002c4a:	eb 35                	jmp    c0002c81 <kbrk+0xae>
    {
        // we are decreasing size of the heap
        while(pg_addr < kheap_brk)
        {
            //free page from end of heap
            if(unmap_page(--kheap_brk))
c0002c4c:	a1 8c 68 00 c0       	mov    0xc000688c,%eax
c0002c51:	2d 00 10 00 00       	sub    $0x1000,%eax
c0002c56:	a3 8c 68 00 c0       	mov    %eax,0xc000688c
c0002c5b:	a1 8c 68 00 c0       	mov    0xc000688c,%eax
c0002c60:	83 ec 0c             	sub    $0xc,%esp
c0002c63:	50                   	push   %eax
c0002c64:	e8 99 01 00 00       	call   c0002e02 <unmap_page>
c0002c69:	83 c4 10             	add    $0x10,%esp
c0002c6c:	85 c0                	test   %eax,%eax
c0002c6e:	74 07                	je     c0002c77 <kbrk+0xa4>
                return -1; // error!
c0002c70:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002c75:	eb 0f                	jmp    c0002c86 <kbrk+0xb3>
        while(pg_addr < kheap_brk)
c0002c77:	a1 8c 68 00 c0       	mov    0xc000688c,%eax
c0002c7c:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0002c7f:	72 cb                	jb     c0002c4c <kbrk+0x79>
        }
    }

	// kprintf("Setting kernel heap break to 0x%x\n", kheap_brk);
    
    return 0;
c0002c81:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002c86:	c9                   	leave  
c0002c87:	c3                   	ret    

c0002c88 <global_memory_init>:


int global_memory_init(multiboot_info_t* mbd)
{
c0002c88:	55                   	push   %ebp
c0002c89:	89 e5                	mov    %esp,%ebp
c0002c8b:	83 ec 08             	sub    $0x8,%esp
    init_frame_stack(mbd);
c0002c8e:	83 ec 0c             	sub    $0xc,%esp
c0002c91:	ff 75 08             	pushl  0x8(%ebp)
c0002c94:	e8 a2 fc ff ff       	call   c000293b <init_frame_stack>
c0002c99:	83 c4 10             	add    $0x10,%esp

    // define some dummy pointers for where we will put the stack
    // TODO: actually set up a stack here
    kstack_base = (page_t*) 0xffb00000;
c0002c9c:	c7 05 84 68 00 c0 00 	movl   $0xffb00000,0xc0006884
c0002ca3:	00 b0 ff 
    kstack_brk = (page_t*)  0xf0000000;
c0002ca6:	c7 05 88 68 00 c0 00 	movl   $0xf0000000,0xc0006888
c0002cad:	00 00 f0 

    kheap_base = frame_stack_brk; //start heap after the page stack allocator
c0002cb0:	a1 a0 68 00 c0       	mov    0xc00068a0,%eax
c0002cb5:	a3 90 68 00 c0       	mov    %eax,0xc0006890
    kheap_brk = kheap_base;     // heap starts empty - increase with ksbrk
c0002cba:	a1 90 68 00 c0       	mov    0xc0006890,%eax
c0002cbf:	a3 8c 68 00 c0       	mov    %eax,0xc000688c

    // we don't need the 1st MB anymore so unmap it
	if( unmap_lowmem() )
c0002cc4:	e8 12 00 00 00       	call   c0002cdb <unmap_lowmem>
c0002cc9:	85 c0                	test   %eax,%eax
c0002ccb:	74 07                	je     c0002cd4 <global_memory_init+0x4c>
        return -1;
c0002ccd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002cd2:	eb 05                	jmp    c0002cd9 <global_memory_init+0x51>

    // except for VGA memory - still need that..
	// if(! map_vga() )
    //     return -1;

    return 0;
c0002cd4:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002cd9:	c9                   	leave  
c0002cda:	c3                   	ret    

c0002cdb <unmap_lowmem>:
//     return 0;
// }


int unmap_lowmem()
{
c0002cdb:	55                   	push   %ebp
c0002cdc:	89 e5                	mov    %esp,%ebp
c0002cde:	83 ec 08             	sub    $0x8,%esp
    pd->dir.pde[0] = PAGE_FLAG_EMPTY;
c0002ce1:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c0002ce6:	c7 80 00 f0 3f 00 00 	movl   $0x0,0x3ff000(%eax)
c0002ced:	00 00 00 
    refresh_tlb();
c0002cf0:	e8 1f 11 00 00       	call   c0003e14 <refresh_tlb>
    return 0;
c0002cf5:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002cfa:	c9                   	leave  
c0002cfb:	c3                   	ret    

c0002cfc <init_vga_buffer>:
// }


//map vga buffer memory
void init_vga_buffer()
{
c0002cfc:	55                   	push   %ebp
c0002cfd:	89 e5                	mov    %esp,%ebp
c0002cff:	83 ec 18             	sub    $0x18,%esp
    page_t* vga_buf = (page_t*) VGA_BUFFER;
c0002d02:	c7 45 f4 00 00 b1 ff 	movl   $0xffb10000,-0xc(%ebp)
    page_t* vga_buf_phys = (page_t*) VGA_BUFFER_PHYS;
c0002d09:	c7 45 f0 00 80 0b 00 	movl   $0xb8000,-0x10(%ebp)

    size_t Npages = VGA_BUFFER_SIZE >> 12;
c0002d10:	c7 45 e8 07 00 00 00 	movl   $0x7,-0x18(%ebp)
    for(size_t nn = 0; nn < Npages; nn++)
c0002d17:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0002d1e:	eb 2b                	jmp    c0002d4b <init_vga_buffer+0x4f>
        map_page_at(vga_buf++,vga_buf_phys++, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c0002d20:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0002d23:	8d 82 00 10 00 00    	lea    0x1000(%edx),%eax
c0002d29:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0002d2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002d2f:	8d 88 00 10 00 00    	lea    0x1000(%eax),%ecx
c0002d35:	89 4d f4             	mov    %ecx,-0xc(%ebp)
c0002d38:	83 ec 04             	sub    $0x4,%esp
c0002d3b:	6a 06                	push   $0x6
c0002d3d:	52                   	push   %edx
c0002d3e:	50                   	push   %eax
c0002d3f:	e8 13 00 00 00       	call   c0002d57 <map_page_at>
c0002d44:	83 c4 10             	add    $0x10,%esp
    for(size_t nn = 0; nn < Npages; nn++)
c0002d47:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0002d4b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002d4e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0002d51:	72 cd                	jb     c0002d20 <init_vga_buffer+0x24>
}
c0002d53:	90                   	nop
c0002d54:	90                   	nop
c0002d55:	c9                   	leave  
c0002d56:	c3                   	ret    

c0002d57 <map_page_at>:

page_t* map_page_at(page_t* page, page_t* frame, uint32_t flags)
{
c0002d57:	55                   	push   %ebp
c0002d58:	89 e5                	mov    %esp,%ebp
c0002d5a:	53                   	push   %ebx
c0002d5b:	83 ec 14             	sub    $0x14,%esp
    page_table_t* pt = get_table(page);
c0002d5e:	83 ec 0c             	sub    $0xc,%esp
c0002d61:	ff 75 08             	pushl  0x8(%ebp)
c0002d64:	e8 40 fa ff ff       	call   c00027a9 <get_table>
c0002d69:	83 c4 10             	add    $0x10,%esp
c0002d6c:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(!pt)
c0002d6f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002d73:	75 10                	jne    c0002d85 <map_page_at+0x2e>
    {
        panic("Kernel page table missing!");
c0002d75:	83 ec 0c             	sub    $0xc,%esp
c0002d78:	68 21 47 00 c0       	push   $0xc0004721
c0002d7d:	e8 4f e9 ff ff       	call   c00016d1 <panic>
c0002d82:	83 c4 10             	add    $0x10,%esp
        // pt = new_page_table(page, flags); // page table is not present, allocate a new one
    }
    
    if(pt->pte[get_ptindex(page)] & PAGE_FLAG_PRESENT)
c0002d85:	83 ec 0c             	sub    $0xc,%esp
c0002d88:	ff 75 08             	pushl  0x8(%ebp)
c0002d8b:	e8 e4 fa ff ff       	call   c0002874 <get_ptindex>
c0002d90:	83 c4 10             	add    $0x10,%esp
c0002d93:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002d96:	8b 04 82             	mov    (%edx,%eax,4),%eax
c0002d99:	83 e0 01             	and    $0x1,%eax
c0002d9c:	85 c0                	test   %eax,%eax
c0002d9e:	74 07                	je     c0002da7 <map_page_at+0x50>
        return NULL; //page already mapped
c0002da0:	b8 00 00 00 00       	mov    $0x0,%eax
c0002da5:	eb 37                	jmp    c0002dde <map_page_at+0x87>

    // map page
    pt->pte[get_ptindex(page)] = (((uint32_t) frame) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0002da7:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002daa:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002daf:	0b 45 10             	or     0x10(%ebp),%eax
c0002db2:	89 c3                	mov    %eax,%ebx
c0002db4:	83 ec 0c             	sub    $0xc,%esp
c0002db7:	ff 75 08             	pushl  0x8(%ebp)
c0002dba:	e8 b5 fa ff ff       	call   c0002874 <get_ptindex>
c0002dbf:	83 c4 10             	add    $0x10,%esp
c0002dc2:	89 d9                	mov    %ebx,%ecx
c0002dc4:	83 c9 01             	or     $0x1,%ecx
c0002dc7:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002dca:	89 0c 82             	mov    %ecx,(%edx,%eax,4)

    refresh_page(page);
c0002dcd:	83 ec 0c             	sub    $0xc,%esp
c0002dd0:	ff 75 08             	pushl  0x8(%ebp)
c0002dd3:	e8 44 10 00 00       	call   c0003e1c <refresh_page>
c0002dd8:	83 c4 10             	add    $0x10,%esp
    return page;
c0002ddb:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0002dde:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0002de1:	c9                   	leave  
c0002de2:	c3                   	ret    

c0002de3 <map_page>:

page_t* map_page(page_t* page, uint32_t flags)
{
c0002de3:	55                   	push   %ebp
c0002de4:	89 e5                	mov    %esp,%ebp
c0002de6:	83 ec 08             	sub    $0x8,%esp
    return map_page_at(page, pop_free_frame(), flags);
c0002de9:	e8 e6 fa ff ff       	call   c00028d4 <pop_free_frame>
c0002dee:	83 ec 04             	sub    $0x4,%esp
c0002df1:	ff 75 0c             	pushl  0xc(%ebp)
c0002df4:	50                   	push   %eax
c0002df5:	ff 75 08             	pushl  0x8(%ebp)
c0002df8:	e8 5a ff ff ff       	call   c0002d57 <map_page_at>
c0002dfd:	83 c4 10             	add    $0x10,%esp
}
c0002e00:	c9                   	leave  
c0002e01:	c3                   	ret    

c0002e02 <unmap_page>:

int unmap_page(page_t* page)
{
c0002e02:	55                   	push   %ebp
c0002e03:	89 e5                	mov    %esp,%ebp
c0002e05:	83 ec 08             	sub    $0x8,%esp
    return push_free_frame(get_physaddr(page));
c0002e08:	83 ec 0c             	sub    $0xc,%esp
c0002e0b:	ff 75 08             	pushl  0x8(%ebp)
c0002e0e:	e8 e6 f9 ff ff       	call   c00027f9 <get_physaddr>
c0002e13:	83 c4 10             	add    $0x10,%esp
c0002e16:	83 ec 0c             	sub    $0xc,%esp
c0002e19:	50                   	push   %eax
c0002e1a:	e8 e9 fa ff ff       	call   c0002908 <push_free_frame>
c0002e1f:	83 c4 10             	add    $0x10,%esp
}
c0002e22:	c9                   	leave  
c0002e23:	c3                   	ret    

c0002e24 <new_page_table>:

page_table_t* new_page_table(void* addr, uint32_t flags)
{
c0002e24:	55                   	push   %ebp
c0002e25:	89 e5                	mov    %esp,%ebp
c0002e27:	83 ec 18             	sub    $0x18,%esp
    uint32_t pdindex = get_pdindex(addr);      // index into page dir (which table does this address point to)
c0002e2a:	ff 75 08             	pushl  0x8(%ebp)
c0002e2d:	e8 52 fa ff ff       	call   c0002884 <get_pdindex>
c0002e32:	83 c4 04             	add    $0x4,%esp
c0002e35:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // is this table already mapped?
    if(pd->dir.pde[pdindex] & PAGE_FLAG_PRESENT)
c0002e38:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c0002e3d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002e40:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c0002e46:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0002e49:	83 e0 01             	and    $0x1,%eax
c0002e4c:	85 c0                	test   %eax,%eax
c0002e4e:	74 07                	je     c0002e57 <new_page_table+0x33>
        return NULL;
c0002e50:	b8 00 00 00 00       	mov    $0x0,%eax
c0002e55:	eb 70                	jmp    c0002ec7 <new_page_table+0xa3>

    page_t* pp = pop_free_frame();         // find a free page in physical mem for page table
c0002e57:	e8 78 fa ff ff       	call   c00028d4 <pop_free_frame>
c0002e5c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!pp) return NULL; // OOM
c0002e5f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0002e63:	75 07                	jne    c0002e6c <new_page_table+0x48>
c0002e65:	b8 00 00 00 00       	mov    $0x0,%eax
c0002e6a:	eb 5b                	jmp    c0002ec7 <new_page_table+0xa3>

    // we don't need to allocate virtual memory space, since table lives in our paging structure
    page_table_t* pv = pd->tables + pdindex;        // pointer to table (virtual)
c0002e6c:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c0002e71:	89 c2                	mov    %eax,%edx
c0002e73:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002e76:	c1 e0 0c             	shl    $0xc,%eax
c0002e79:	01 d0                	add    %edx,%eax
c0002e7b:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // map table: point the pd entry at the physical page we just reserved, and set flags
    pd->dir.pde[pdindex] = (((uint32_t) pp) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0002e7e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002e81:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002e86:	0b 45 0c             	or     0xc(%ebp),%eax
c0002e89:	89 c2                	mov    %eax,%edx
c0002e8b:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c0002e90:	89 d1                	mov    %edx,%ecx
c0002e92:	83 c9 01             	or     $0x1,%ecx
c0002e95:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002e98:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c0002e9e:	89 0c 90             	mov    %ecx,(%eax,%edx,4)

    // flush the tlb
    refresh_page(pv);
c0002ea1:	83 ec 0c             	sub    $0xc,%esp
c0002ea4:	ff 75 ec             	pushl  -0x14(%ebp)
c0002ea7:	e8 70 0f 00 00       	call   c0003e1c <refresh_page>
c0002eac:	83 c4 10             	add    $0x10,%esp

    //clear table
    memset((char*) pv, 0, PAGE_SIZE);     
c0002eaf:	83 ec 04             	sub    $0x4,%esp
c0002eb2:	68 00 10 00 00       	push   $0x1000
c0002eb7:	6a 00                	push   $0x0
c0002eb9:	ff 75 ec             	pushl  -0x14(%ebp)
c0002ebc:	e8 f2 e8 ff ff       	call   c00017b3 <memset>
c0002ec1:	83 c4 10             	add    $0x10,%esp

    // return pointer to table (virtual)
    return pv;
c0002ec4:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c0002ec7:	c9                   	leave  
c0002ec8:	c3                   	ret    

c0002ec9 <kheap_validate_block>:
int kheap_size(size_t* allocated, size_t* free);


// check magic number
static inline int kheap_validate_block(heap_block_t* b)
{
c0002ec9:	55                   	push   %ebp
c0002eca:	89 e5                	mov    %esp,%ebp
    return b->magic != HEAP_BLOCK_MAGIC;
c0002ecc:	8b 45 08             	mov    0x8(%ebp),%eax
c0002ecf:	8b 00                	mov    (%eax),%eax
c0002ed1:	25 ff ff ff 0f       	and    $0xfffffff,%eax
c0002ed6:	3d ef be 23 01       	cmp    $0x123beef,%eax
c0002edb:	0f 95 c0             	setne  %al
c0002ede:	0f b6 c0             	movzbl %al,%eax
}
c0002ee1:	5d                   	pop    %ebp
c0002ee2:	c3                   	ret    

c0002ee3 <align_int>:
{
c0002ee3:	55                   	push   %ebp
c0002ee4:	89 e5                	mov    %esp,%ebp
c0002ee6:	83 ec 10             	sub    $0x10,%esp
    size_t am = alignment - 1;
c0002ee9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002eec:	83 e8 01             	sub    $0x1,%eax
c0002eef:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (((size_t)len + am) & ~am);
c0002ef2:	8b 55 08             	mov    0x8(%ebp),%edx
c0002ef5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002ef8:	01 c2                	add    %eax,%edx
c0002efa:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002efd:	f7 d0                	not    %eax
c0002eff:	21 d0                	and    %edx,%eax
}
c0002f01:	c9                   	leave  
c0002f02:	c3                   	ret    

c0002f03 <align_ptr>:
{
c0002f03:	55                   	push   %ebp
c0002f04:	89 e5                	mov    %esp,%ebp
    if(alignment % sizeof(void*) != 0 ) return NULL;
c0002f06:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002f09:	83 e0 03             	and    $0x3,%eax
c0002f0c:	85 c0                	test   %eax,%eax
c0002f0e:	74 07                	je     c0002f17 <align_ptr+0x14>
c0002f10:	b8 00 00 00 00       	mov    $0x0,%eax
c0002f15:	eb 0f                	jmp    c0002f26 <align_ptr+0x23>
    return (void*) align_int((size_t) addr, alignment);
c0002f17:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f1a:	ff 75 0c             	pushl  0xc(%ebp)
c0002f1d:	50                   	push   %eax
c0002f1e:	e8 c0 ff ff ff       	call   c0002ee3 <align_int>
c0002f23:	83 c4 08             	add    $0x8,%esp
}
c0002f26:	c9                   	leave  
c0002f27:	c3                   	ret    

c0002f28 <kmalloc_init>:
#include "common.h"

heap_block_t* kheap_head = NULL;

int kmalloc_init()
{
c0002f28:	55                   	push   %ebp
c0002f29:	89 e5                	mov    %esp,%ebp
c0002f2b:	83 ec 08             	sub    $0x8,%esp
    kheap_head = ksbrk(HEAP_INCREMENT);
c0002f2e:	83 ec 0c             	sub    $0xc,%esp
c0002f31:	68 00 40 00 00       	push   $0x4000
c0002f36:	e8 56 fc ff ff       	call   c0002b91 <ksbrk>
c0002f3b:	83 c4 10             	add    $0x10,%esp
c0002f3e:	a3 a4 68 00 c0       	mov    %eax,0xc00068a4
   
    if(!kheap_head)
c0002f43:	a1 a4 68 00 c0       	mov    0xc00068a4,%eax
c0002f48:	85 c0                	test   %eax,%eax
c0002f4a:	75 0a                	jne    c0002f56 <kmalloc_init+0x2e>
        return -1;
c0002f4c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002f51:	e9 95 00 00 00       	jmp    c0002feb <kmalloc_init+0xc3>

    kheap_head = align_ptr(kheap_head,HEAP_BLOCKSIZE_UNITS);
c0002f56:	a1 a4 68 00 c0       	mov    0xc00068a4,%eax
c0002f5b:	83 ec 08             	sub    $0x8,%esp
c0002f5e:	6a 10                	push   $0x10
c0002f60:	50                   	push   %eax
c0002f61:	e8 9d ff ff ff       	call   c0002f03 <align_ptr>
c0002f66:	83 c4 10             	add    $0x10,%esp
c0002f69:	a3 a4 68 00 c0       	mov    %eax,0xc00068a4

    kheap_head->magic = HEAP_BLOCK_MAGIC;
c0002f6e:	a1 a4 68 00 c0       	mov    0xc00068a4,%eax
c0002f73:	8b 10                	mov    (%eax),%edx
c0002f75:	81 e2 00 00 00 f0    	and    $0xf0000000,%edx
c0002f7b:	81 ca ef be 23 01    	or     $0x123beef,%edx
c0002f81:	89 10                	mov    %edx,(%eax)
    kheap_head->status = HEAP_BLOCK_FREE;
c0002f83:	a1 a4 68 00 c0       	mov    0xc00068a4,%eax
c0002f88:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c0002f8c:	83 e2 0f             	and    $0xf,%edx
c0002f8f:	88 50 03             	mov    %dl,0x3(%eax)
    kheap_head->prev = kheap_head;
c0002f92:	a1 a4 68 00 c0       	mov    0xc00068a4,%eax
c0002f97:	8b 15 a4 68 00 c0    	mov    0xc00068a4,%edx
c0002f9d:	89 50 04             	mov    %edx,0x4(%eax)
    kheap_head->next = kheap_head;
c0002fa0:	a1 a4 68 00 c0       	mov    0xc00068a4,%eax
c0002fa5:	8b 15 a4 68 00 c0    	mov    0xc00068a4,%edx
c0002fab:	89 50 08             	mov    %edx,0x8(%eax)

    kheap_head->size = ((heap_block_t*) ksbrk(0)) - kheap_head;
c0002fae:	83 ec 0c             	sub    $0xc,%esp
c0002fb1:	6a 00                	push   $0x0
c0002fb3:	e8 d9 fb ff ff       	call   c0002b91 <ksbrk>
c0002fb8:	83 c4 10             	add    $0x10,%esp
c0002fbb:	8b 15 a4 68 00 c0    	mov    0xc00068a4,%edx
c0002fc1:	29 d0                	sub    %edx,%eax
c0002fc3:	c1 f8 04             	sar    $0x4,%eax
c0002fc6:	89 c2                	mov    %eax,%edx
c0002fc8:	a1 a4 68 00 c0       	mov    0xc00068a4,%eax
c0002fcd:	89 50 0c             	mov    %edx,0xc(%eax)

    if(kheap_head->size < HEAP_INCREMENT/HEAP_BLOCKSIZE_UNITS)
c0002fd0:	a1 a4 68 00 c0       	mov    0xc00068a4,%eax
c0002fd5:	8b 40 0c             	mov    0xc(%eax),%eax
c0002fd8:	3d ff 03 00 00       	cmp    $0x3ff,%eax
c0002fdd:	77 07                	ja     c0002fe6 <kmalloc_init+0xbe>
        return -1;    
c0002fdf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002fe4:	eb 05                	jmp    c0002feb <kmalloc_init+0xc3>

    return 0;    
c0002fe6:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002feb:	c9                   	leave  
c0002fec:	c3                   	ret    

c0002fed <kheap_insert_block>:

// insert new_block into LL between b and b->next
// return 0 on success 
int kheap_insert_block(heap_block_t* b, heap_block_t* new_block)
{
c0002fed:	55                   	push   %ebp
c0002fee:	89 e5                	mov    %esp,%ebp
c0002ff0:	83 ec 08             	sub    $0x8,%esp
    
    if(kheap_validate_block(b) || kheap_validate_block(new_block))
c0002ff3:	ff 75 08             	pushl  0x8(%ebp)
c0002ff6:	e8 ce fe ff ff       	call   c0002ec9 <kheap_validate_block>
c0002ffb:	83 c4 04             	add    $0x4,%esp
c0002ffe:	85 c0                	test   %eax,%eax
c0003000:	75 0f                	jne    c0003011 <kheap_insert_block+0x24>
c0003002:	ff 75 0c             	pushl  0xc(%ebp)
c0003005:	e8 bf fe ff ff       	call   c0002ec9 <kheap_validate_block>
c000300a:	83 c4 04             	add    $0x4,%esp
c000300d:	85 c0                	test   %eax,%eax
c000300f:	74 17                	je     c0003028 <kheap_insert_block+0x3b>
    {
        panic("kernel heap corrupted");
c0003011:	83 ec 0c             	sub    $0xc,%esp
c0003014:	68 48 47 00 c0       	push   $0xc0004748
c0003019:	e8 b3 e6 ff ff       	call   c00016d1 <panic>
c000301e:	83 c4 10             	add    $0x10,%esp
        return -1;
c0003021:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003026:	eb 2f                	jmp    c0003057 <kheap_insert_block+0x6a>
    }

    new_block->prev = b;
c0003028:	8b 45 0c             	mov    0xc(%ebp),%eax
c000302b:	8b 55 08             	mov    0x8(%ebp),%edx
c000302e:	89 50 04             	mov    %edx,0x4(%eax)
    new_block->next = b->next;            
c0003031:	8b 45 08             	mov    0x8(%ebp),%eax
c0003034:	8b 50 08             	mov    0x8(%eax),%edx
c0003037:	8b 45 0c             	mov    0xc(%ebp),%eax
c000303a:	89 50 08             	mov    %edx,0x8(%eax)
    b->next->prev = new_block;
c000303d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003040:	8b 40 08             	mov    0x8(%eax),%eax
c0003043:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003046:	89 50 04             	mov    %edx,0x4(%eax)
    b->next = new_block;
c0003049:	8b 45 08             	mov    0x8(%ebp),%eax
c000304c:	8b 55 0c             	mov    0xc(%ebp),%edx
c000304f:	89 50 08             	mov    %edx,0x8(%eax)

    return 0;
c0003052:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0003057:	c9                   	leave  
c0003058:	c3                   	ret    

c0003059 <kheap_delete_block>:


// remove block b from LL
// return pointer to previous block, NULL on error
heap_block_t* kheap_delete_block(heap_block_t* b)
{
c0003059:	55                   	push   %ebp
c000305a:	89 e5                	mov    %esp,%ebp
c000305c:	83 ec 08             	sub    $0x8,%esp
    if(kheap_validate_block(b->prev) || kheap_validate_block(b->next))
c000305f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003062:	8b 40 04             	mov    0x4(%eax),%eax
c0003065:	50                   	push   %eax
c0003066:	e8 5e fe ff ff       	call   c0002ec9 <kheap_validate_block>
c000306b:	83 c4 04             	add    $0x4,%esp
c000306e:	85 c0                	test   %eax,%eax
c0003070:	75 13                	jne    c0003085 <kheap_delete_block+0x2c>
c0003072:	8b 45 08             	mov    0x8(%ebp),%eax
c0003075:	8b 40 08             	mov    0x8(%eax),%eax
c0003078:	50                   	push   %eax
c0003079:	e8 4b fe ff ff       	call   c0002ec9 <kheap_validate_block>
c000307e:	83 c4 04             	add    $0x4,%esp
c0003081:	85 c0                	test   %eax,%eax
c0003083:	74 17                	je     c000309c <kheap_delete_block+0x43>
    {
        panic("kernel heap corrupted");
c0003085:	83 ec 0c             	sub    $0xc,%esp
c0003088:	68 48 47 00 c0       	push   $0xc0004748
c000308d:	e8 3f e6 ff ff       	call   c00016d1 <panic>
c0003092:	83 c4 10             	add    $0x10,%esp
        return NULL;
c0003095:	b8 00 00 00 00       	mov    $0x0,%eax
c000309a:	eb 24                	jmp    c00030c0 <kheap_delete_block+0x67>
    }

    b->prev->next = b->next;
c000309c:	8b 45 08             	mov    0x8(%ebp),%eax
c000309f:	8b 40 04             	mov    0x4(%eax),%eax
c00030a2:	8b 55 08             	mov    0x8(%ebp),%edx
c00030a5:	8b 52 08             	mov    0x8(%edx),%edx
c00030a8:	89 50 08             	mov    %edx,0x8(%eax)
    b->next->prev = b->prev;
c00030ab:	8b 45 08             	mov    0x8(%ebp),%eax
c00030ae:	8b 40 08             	mov    0x8(%eax),%eax
c00030b1:	8b 55 08             	mov    0x8(%ebp),%edx
c00030b4:	8b 52 04             	mov    0x4(%edx),%edx
c00030b7:	89 50 04             	mov    %edx,0x4(%eax)

    return b->prev;
c00030ba:	8b 45 08             	mov    0x8(%ebp),%eax
c00030bd:	8b 40 04             	mov    0x4(%eax),%eax
}
c00030c0:	c9                   	leave  
c00030c1:	c3                   	ret    

c00030c2 <kheap_free_block>:

// free block and merge with free neighbors
// return ptr to new free block
heap_block_t* kheap_free_block(heap_block_t* b)
{
c00030c2:	55                   	push   %ebp
c00030c3:	89 e5                	mov    %esp,%ebp
c00030c5:	83 ec 08             	sub    $0x8,%esp
    //check magic numbers to make sure theres no overrun
    if(kheap_validate_block(b))
c00030c8:	ff 75 08             	pushl  0x8(%ebp)
c00030cb:	e8 f9 fd ff ff       	call   c0002ec9 <kheap_validate_block>
c00030d0:	83 c4 04             	add    $0x4,%esp
c00030d3:	85 c0                	test   %eax,%eax
c00030d5:	74 1a                	je     c00030f1 <kheap_free_block+0x2f>
    {
        panic("kernel heap corrupted");
c00030d7:	83 ec 0c             	sub    $0xc,%esp
c00030da:	68 48 47 00 c0       	push   $0xc0004748
c00030df:	e8 ed e5 ff ff       	call   c00016d1 <panic>
c00030e4:	83 c4 10             	add    $0x10,%esp
        return NULL;
c00030e7:	b8 00 00 00 00       	mov    $0x0,%eax
c00030ec:	e9 b4 00 00 00       	jmp    c00031a5 <kheap_free_block+0xe3>
    }

    // make sure this block isnt already free allocated
    if(b->status == HEAP_BLOCK_FREE)
c00030f1:	8b 45 08             	mov    0x8(%ebp),%eax
c00030f4:	0f b6 40 03          	movzbl 0x3(%eax),%eax
c00030f8:	83 e0 f0             	and    $0xfffffff0,%eax
c00030fb:	84 c0                	test   %al,%al
c00030fd:	75 0a                	jne    c0003109 <kheap_free_block+0x47>
        return NULL;
c00030ff:	b8 00 00 00 00       	mov    $0x0,%eax
c0003104:	e9 9c 00 00 00       	jmp    c00031a5 <kheap_free_block+0xe3>

    b->status = HEAP_BLOCK_FREE;
c0003109:	8b 45 08             	mov    0x8(%ebp),%eax
c000310c:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c0003110:	83 e2 0f             	and    $0xf,%edx
c0003113:	88 50 03             	mov    %dl,0x3(%eax)

    //merge with next block if free
    if(b->next == HEAP_BLOCK_FREE && b->next != kheap_head)
c0003116:	8b 45 08             	mov    0x8(%ebp),%eax
c0003119:	8b 40 08             	mov    0x8(%eax),%eax
c000311c:	85 c0                	test   %eax,%eax
c000311e:	75 43                	jne    c0003163 <kheap_free_block+0xa1>
c0003120:	8b 45 08             	mov    0x8(%ebp),%eax
c0003123:	8b 50 08             	mov    0x8(%eax),%edx
c0003126:	a1 a4 68 00 c0       	mov    0xc00068a4,%eax
c000312b:	39 c2                	cmp    %eax,%edx
c000312d:	74 34                	je     c0003163 <kheap_free_block+0xa1>
    {
        b->size += b->next->size;
c000312f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003132:	8b 50 0c             	mov    0xc(%eax),%edx
c0003135:	8b 45 08             	mov    0x8(%ebp),%eax
c0003138:	8b 40 08             	mov    0x8(%eax),%eax
c000313b:	8b 40 0c             	mov    0xc(%eax),%eax
c000313e:	01 c2                	add    %eax,%edx
c0003140:	8b 45 08             	mov    0x8(%ebp),%eax
c0003143:	89 50 0c             	mov    %edx,0xc(%eax)
        if(!kheap_delete_block(b->next)) return NULL;
c0003146:	8b 45 08             	mov    0x8(%ebp),%eax
c0003149:	8b 40 08             	mov    0x8(%eax),%eax
c000314c:	83 ec 0c             	sub    $0xc,%esp
c000314f:	50                   	push   %eax
c0003150:	e8 04 ff ff ff       	call   c0003059 <kheap_delete_block>
c0003155:	83 c4 10             	add    $0x10,%esp
c0003158:	85 c0                	test   %eax,%eax
c000315a:	75 07                	jne    c0003163 <kheap_free_block+0xa1>
c000315c:	b8 00 00 00 00       	mov    $0x0,%eax
c0003161:	eb 42                	jmp    c00031a5 <kheap_free_block+0xe3>
    }

    //merge with previous block if free, and set b = b->prev
    if(b->prev == HEAP_BLOCK_FREE && b != kheap_head)
c0003163:	8b 45 08             	mov    0x8(%ebp),%eax
c0003166:	8b 40 04             	mov    0x4(%eax),%eax
c0003169:	85 c0                	test   %eax,%eax
c000316b:	75 35                	jne    c00031a2 <kheap_free_block+0xe0>
c000316d:	a1 a4 68 00 c0       	mov    0xc00068a4,%eax
c0003172:	39 45 08             	cmp    %eax,0x8(%ebp)
c0003175:	74 2b                	je     c00031a2 <kheap_free_block+0xe0>
    {
        b->prev->size += b->size;
c0003177:	8b 45 08             	mov    0x8(%ebp),%eax
c000317a:	8b 40 04             	mov    0x4(%eax),%eax
c000317d:	8b 48 0c             	mov    0xc(%eax),%ecx
c0003180:	8b 45 08             	mov    0x8(%ebp),%eax
c0003183:	8b 50 0c             	mov    0xc(%eax),%edx
c0003186:	8b 45 08             	mov    0x8(%ebp),%eax
c0003189:	8b 40 04             	mov    0x4(%eax),%eax
c000318c:	01 ca                	add    %ecx,%edx
c000318e:	89 50 0c             	mov    %edx,0xc(%eax)
        b = kheap_delete_block(b);
c0003191:	83 ec 0c             	sub    $0xc,%esp
c0003194:	ff 75 08             	pushl  0x8(%ebp)
c0003197:	e8 bd fe ff ff       	call   c0003059 <kheap_delete_block>
c000319c:	83 c4 10             	add    $0x10,%esp
c000319f:	89 45 08             	mov    %eax,0x8(%ebp)
    }

    return b;
c00031a2:	8b 45 08             	mov    0x8(%ebp),%eax
}
c00031a5:	c9                   	leave  
c00031a6:	c3                   	ret    

c00031a7 <kheap_split_block>:
// if there is enough extra room, split b into two
// return new size of block on successful split (in HEAP_BLOCKSIZE_UNITS)
// return 0 on insufficinet size for splitting into new block (b->size < size+1)
// return <0 on error
int kheap_split_block(heap_block_t* b, size_t size)
{
c00031a7:	55                   	push   %ebp
c00031a8:	89 e5                	mov    %esp,%ebp
c00031aa:	83 ec 18             	sub    $0x18,%esp
    //check magic numbers to make sure theres no overrun
    if(kheap_validate_block(b))
c00031ad:	ff 75 08             	pushl  0x8(%ebp)
c00031b0:	e8 14 fd ff ff       	call   c0002ec9 <kheap_validate_block>
c00031b5:	83 c4 04             	add    $0x4,%esp
c00031b8:	85 c0                	test   %eax,%eax
c00031ba:	74 1a                	je     c00031d6 <kheap_split_block+0x2f>
    {
        panic("kernel heap corrupted");
c00031bc:	83 ec 0c             	sub    $0xc,%esp
c00031bf:	68 48 47 00 c0       	push   $0xc0004748
c00031c4:	e8 08 e5 ff ff       	call   c00016d1 <panic>
c00031c9:	83 c4 10             	add    $0x10,%esp
        return -1;
c00031cc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00031d1:	e9 83 00 00 00       	jmp    c0003259 <kheap_split_block+0xb2>
    }

    if(b->size < size + 1 ) return 0;
c00031d6:	8b 45 08             	mov    0x8(%ebp),%eax
c00031d9:	8b 40 0c             	mov    0xc(%eax),%eax
c00031dc:	8b 55 0c             	mov    0xc(%ebp),%edx
c00031df:	83 c2 01             	add    $0x1,%edx
c00031e2:	39 d0                	cmp    %edx,%eax
c00031e4:	73 07                	jae    c00031ed <kheap_split_block+0x46>
c00031e6:	b8 00 00 00 00       	mov    $0x0,%eax
c00031eb:	eb 6c                	jmp    c0003259 <kheap_split_block+0xb2>

    // create new empty block
    heap_block_t* new_block = b + size;
c00031ed:	8b 45 0c             	mov    0xc(%ebp),%eax
c00031f0:	c1 e0 04             	shl    $0x4,%eax
c00031f3:	89 c2                	mov    %eax,%edx
c00031f5:	8b 45 08             	mov    0x8(%ebp),%eax
c00031f8:	01 d0                	add    %edx,%eax
c00031fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
    new_block->magic = HEAP_BLOCK_MAGIC;
c00031fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003200:	8b 10                	mov    (%eax),%edx
c0003202:	81 e2 00 00 00 f0    	and    $0xf0000000,%edx
c0003208:	81 ca ef be 23 01    	or     $0x123beef,%edx
c000320e:	89 10                	mov    %edx,(%eax)
    new_block->status = HEAP_BLOCK_FREE;
c0003210:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003213:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c0003217:	83 e2 0f             	and    $0xf,%edx
c000321a:	88 50 03             	mov    %dl,0x3(%eax)
    new_block->size = b->size - size;
c000321d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003220:	8b 40 0c             	mov    0xc(%eax),%eax
c0003223:	2b 45 0c             	sub    0xc(%ebp),%eax
c0003226:	89 c2                	mov    %eax,%edx
c0003228:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000322b:	89 50 0c             	mov    %edx,0xc(%eax)

    // insert new block to into LL after b
    if(kheap_insert_block(b,new_block)) return -1;
c000322e:	83 ec 08             	sub    $0x8,%esp
c0003231:	ff 75 f4             	pushl  -0xc(%ebp)
c0003234:	ff 75 08             	pushl  0x8(%ebp)
c0003237:	e8 b1 fd ff ff       	call   c0002fed <kheap_insert_block>
c000323c:	83 c4 10             	add    $0x10,%esp
c000323f:	85 c0                	test   %eax,%eax
c0003241:	74 07                	je     c000324a <kheap_split_block+0xa3>
c0003243:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003248:	eb 0f                	jmp    c0003259 <kheap_split_block+0xb2>

    // shrink b and return new size
    return b->size = size;
c000324a:	8b 45 08             	mov    0x8(%ebp),%eax
c000324d:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003250:	89 50 0c             	mov    %edx,0xc(%eax)
c0003253:	8b 45 08             	mov    0x8(%ebp),%eax
c0003256:	8b 40 0c             	mov    0xc(%eax),%eax
}
c0003259:	c9                   	leave  
c000325a:	c3                   	ret    

c000325b <grow_kheap>:

// grow the kernel heap by at least minimum_block_size*HEAP_BLOCKSIZE_UNITS bytes
// and return new tail block that is guaranteeed to be at least minimum_block_size
// return NULL on error or OOM
heap_block_t* grow_kheap(size_t minimum_block_size)
{
c000325b:	55                   	push   %ebp
c000325c:	89 e5                	mov    %esp,%ebp
c000325e:	83 ec 18             	sub    $0x18,%esp
    size_t grow_size = minimum_block_size*HEAP_BLOCKSIZE_UNITS > HEAP_INCREMENT ? minimum_block_size*HEAP_BLOCKSIZE_UNITS : HEAP_INCREMENT;
c0003261:	8b 45 08             	mov    0x8(%ebp),%eax
c0003264:	c1 e0 04             	shl    $0x4,%eax
c0003267:	ba 00 40 00 00       	mov    $0x4000,%edx
c000326c:	3d 00 40 00 00       	cmp    $0x4000,%eax
c0003271:	0f 42 c2             	cmovb  %edx,%eax
c0003274:	89 45 f4             	mov    %eax,-0xc(%ebp)
    heap_block_t* new_block = ksbrk(grow_size);
c0003277:	83 ec 0c             	sub    $0xc,%esp
c000327a:	ff 75 f4             	pushl  -0xc(%ebp)
c000327d:	e8 0f f9 ff ff       	call   c0002b91 <ksbrk>
c0003282:	83 c4 10             	add    $0x10,%esp
c0003285:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!new_block)
c0003288:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000328c:	75 0a                	jne    c0003298 <grow_kheap+0x3d>
        return NULL; // error in ksbrk, e.g. out of memory
c000328e:	b8 00 00 00 00       	mov    $0x0,%eax
c0003293:	e9 81 00 00 00       	jmp    c0003319 <grow_kheap+0xbe>

    //ksbrk doesnt guarantee properly aligned blocks, so make sure we are aligned
    new_block = align_ptr(new_block,HEAP_BLOCKSIZE_UNITS);
c0003298:	83 ec 08             	sub    $0x8,%esp
c000329b:	6a 10                	push   $0x10
c000329d:	ff 75 f0             	pushl  -0x10(%ebp)
c00032a0:	e8 5e fc ff ff       	call   c0002f03 <align_ptr>
c00032a5:	83 c4 10             	add    $0x10,%esp
c00032a8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    
    new_block->magic = HEAP_BLOCK_MAGIC;
c00032ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00032ae:	8b 10                	mov    (%eax),%edx
c00032b0:	81 e2 00 00 00 f0    	and    $0xf0000000,%edx
c00032b6:	81 ca ef be 23 01    	or     $0x123beef,%edx
c00032bc:	89 10                	mov    %edx,(%eax)
    new_block->status = HEAP_BLOCK_FREE;
c00032be:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00032c1:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c00032c5:	83 e2 0f             	and    $0xf,%edx
c00032c8:	88 50 03             	mov    %dl,0x3(%eax)

    // get end of block from ksbrk(0), and again make sure it is aligned.
    // this time align with a mask so that aligned address is <= ksbrk(0)
    new_block->size = new_block - (heap_block_t*) ( (uint32_t) ksbrk(0) & HEAP_BLOCKSIZE_MASK);
c00032cb:	83 ec 0c             	sub    $0xc,%esp
c00032ce:	6a 00                	push   $0x0
c00032d0:	e8 bc f8 ff ff       	call   c0002b91 <ksbrk>
c00032d5:	83 c4 10             	add    $0x10,%esp
c00032d8:	83 e0 f0             	and    $0xfffffff0,%eax
c00032db:	89 c2                	mov    %eax,%edx
c00032dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00032e0:	29 d0                	sub    %edx,%eax
c00032e2:	c1 f8 04             	sar    $0x4,%eax
c00032e5:	89 c2                	mov    %eax,%edx
c00032e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00032ea:	89 50 0c             	mov    %edx,0xc(%eax)

    //doublecheck that new block is large enough
    if(new_block->size < minimum_block_size) return NULL;
c00032ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00032f0:	8b 40 0c             	mov    0xc(%eax),%eax
c00032f3:	39 45 08             	cmp    %eax,0x8(%ebp)
c00032f6:	76 07                	jbe    c00032ff <grow_kheap+0xa4>
c00032f8:	b8 00 00 00 00       	mov    $0x0,%eax
c00032fd:	eb 1a                	jmp    c0003319 <grow_kheap+0xbe>

    kheap_insert_block(kheap_head->prev, new_block); //add new block to tail
c00032ff:	a1 a4 68 00 c0       	mov    0xc00068a4,%eax
c0003304:	8b 40 04             	mov    0x4(%eax),%eax
c0003307:	83 ec 08             	sub    $0x8,%esp
c000330a:	ff 75 f0             	pushl  -0x10(%ebp)
c000330d:	50                   	push   %eax
c000330e:	e8 da fc ff ff       	call   c0002fed <kheap_insert_block>
c0003313:	83 c4 10             	add    $0x10,%esp
    return new_block;
c0003316:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0003319:	c9                   	leave  
c000331a:	c3                   	ret    

c000331b <kmalloc>:

void* kmalloc(size_t sz)
{
c000331b:	55                   	push   %ebp
c000331c:	89 e5                	mov    %esp,%ebp
c000331e:	83 ec 18             	sub    $0x18,%esp
    //convert to HEAP_BLOCKSIZE_UNITS, rounding up, and add one for header
    size_t block_size = 1 + (sz+ HEAP_BLOCKSIZE_UNITS -1)/HEAP_BLOCKSIZE_UNITS;
c0003321:	8b 45 08             	mov    0x8(%ebp),%eax
c0003324:	83 c0 0f             	add    $0xf,%eax
c0003327:	c1 e8 04             	shr    $0x4,%eax
c000332a:	83 c0 01             	add    $0x1,%eax
c000332d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    
    if(!kheap_head)
c0003330:	a1 a4 68 00 c0       	mov    0xc00068a4,%eax
c0003335:	85 c0                	test   %eax,%eax
c0003337:	75 19                	jne    c0003352 <kmalloc+0x37>
    {
        //initialize the heap with some space
        if(kmalloc_init())
c0003339:	e8 ea fb ff ff       	call   c0002f28 <kmalloc_init>
c000333e:	85 c0                	test   %eax,%eax
c0003340:	74 10                	je     c0003352 <kmalloc+0x37>
            panic("Error initializing kernel heap");
c0003342:	83 ec 0c             	sub    $0xc,%esp
c0003345:	68 60 47 00 c0       	push   $0xc0004760
c000334a:	e8 82 e3 ff ff       	call   c00016d1 <panic>
c000334f:	83 c4 10             	add    $0x10,%esp
    }

    heap_block_t* block = kheap_head;
c0003352:	a1 a4 68 00 c0       	mov    0xc00068a4,%eax
c0003357:	89 45 f4             	mov    %eax,-0xc(%ebp)

    while(block->status != HEAP_BLOCK_FREE || block->size < block_size)
c000335a:	eb 36                	jmp    c0003392 <kmalloc+0x77>
    {
        //if we've returned to the head, we have run through the entire list without finding a free block
        if(block->next == kheap_head)
c000335c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000335f:	8b 50 08             	mov    0x8(%eax),%edx
c0003362:	a1 a4 68 00 c0       	mov    0xc00068a4,%eax
c0003367:	39 c2                	cmp    %eax,%edx
c0003369:	75 1e                	jne    c0003389 <kmalloc+0x6e>
        {
            //we've reached the end of the heap, so add a new block at the end
            block = grow_kheap(block_size);
c000336b:	83 ec 0c             	sub    $0xc,%esp
c000336e:	ff 75 f0             	pushl  -0x10(%ebp)
c0003371:	e8 e5 fe ff ff       	call   c000325b <grow_kheap>
c0003376:	83 c4 10             	add    $0x10,%esp
c0003379:	89 45 f4             	mov    %eax,-0xc(%ebp)
            if(!block) return NULL; //grow_kheap() failed, e.g. OOM 
c000337c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0003380:	75 10                	jne    c0003392 <kmalloc+0x77>
c0003382:	b8 00 00 00 00       	mov    $0x0,%eax
c0003387:	eb 5d                	jmp    c00033e6 <kmalloc+0xcb>
        }
        else
        {
            block = block->next;
c0003389:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000338c:	8b 40 08             	mov    0x8(%eax),%eax
c000338f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(block->status != HEAP_BLOCK_FREE || block->size < block_size)
c0003392:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003395:	0f b6 40 03          	movzbl 0x3(%eax),%eax
c0003399:	83 e0 f0             	and    $0xfffffff0,%eax
c000339c:	84 c0                	test   %al,%al
c000339e:	75 bc                	jne    c000335c <kmalloc+0x41>
c00033a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00033a3:	8b 40 0c             	mov    0xc(%eax),%eax
c00033a6:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c00033a9:	77 b1                	ja     c000335c <kmalloc+0x41>
    }

    // block is a free block that is large enough for this allocation

    //split block if its big enough
    if(kheap_split_block(block, block_size)<0)
c00033ab:	83 ec 08             	sub    $0x8,%esp
c00033ae:	ff 75 f0             	pushl  -0x10(%ebp)
c00033b1:	ff 75 f4             	pushl  -0xc(%ebp)
c00033b4:	e8 ee fd ff ff       	call   c00031a7 <kheap_split_block>
c00033b9:	83 c4 10             	add    $0x10,%esp
c00033bc:	85 c0                	test   %eax,%eax
c00033be:	79 10                	jns    c00033d0 <kmalloc+0xb5>
        panic("Critical error in malloc()");
c00033c0:	83 ec 0c             	sub    $0xc,%esp
c00033c3:	68 7f 47 00 c0       	push   $0xc000477f
c00033c8:	e8 04 e3 ff ff       	call   c00016d1 <panic>
c00033cd:	83 c4 10             	add    $0x10,%esp

    block->status = HEAP_BLOCK_USED;
c00033d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00033d3:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c00033d7:	83 e2 0f             	and    $0xf,%edx
c00033da:	83 ca 10             	or     $0x10,%edx
c00033dd:	88 50 03             	mov    %dl,0x3(%eax)
    return block+1; // return pointer after header
c00033e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00033e3:	83 c0 10             	add    $0x10,%eax
}
c00033e6:	c9                   	leave  
c00033e7:	c3                   	ret    

c00033e8 <kmalloc_aligned>:

void* kmalloc_aligned(size_t sz, size_t alignment)
{
c00033e8:	55                   	push   %ebp
c00033e9:	89 e5                	mov    %esp,%ebp
c00033eb:	83 ec 28             	sub    $0x28,%esp
    //alignement must be multiple of HEAP_BLOCKSIZE_UNITS
    if(alignment % HEAP_BLOCKSIZE_UNITS) return NULL;
c00033ee:	8b 45 0c             	mov    0xc(%ebp),%eax
c00033f1:	83 e0 0f             	and    $0xf,%eax
c00033f4:	85 c0                	test   %eax,%eax
c00033f6:	74 0a                	je     c0003402 <kmalloc_aligned+0x1a>
c00033f8:	b8 00 00 00 00       	mov    $0x0,%eax
c00033fd:	e9 3d 01 00 00       	jmp    c000353f <kmalloc_aligned+0x157>

    //convert alignment to HEAP_BLOCKSIZE_UNITS
    size_t block_alignment = alignment/HEAP_BLOCKSIZE_UNITS;
c0003402:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003405:	c1 e8 04             	shr    $0x4,%eax
c0003408:	89 45 f0             	mov    %eax,-0x10(%ebp)

    //convert sz to HEAP_BLOCKSIZE_UNITS, rounding up, and add one for header
    size_t block_size = 1 + (sz+ HEAP_BLOCKSIZE_UNITS -1)/HEAP_BLOCKSIZE_UNITS;
c000340b:	8b 45 08             	mov    0x8(%ebp),%eax
c000340e:	83 c0 0f             	add    $0xf,%eax
c0003411:	c1 e8 04             	shr    $0x4,%eax
c0003414:	83 c0 01             	add    $0x1,%eax
c0003417:	89 45 ec             	mov    %eax,-0x14(%ebp)

    
    if(!kheap_head)
c000341a:	a1 a4 68 00 c0       	mov    0xc00068a4,%eax
c000341f:	85 c0                	test   %eax,%eax
c0003421:	75 19                	jne    c000343c <kmalloc_aligned+0x54>
    {
        //initialize the heap with some space
        if(!kmalloc_init())
c0003423:	e8 00 fb ff ff       	call   c0002f28 <kmalloc_init>
c0003428:	85 c0                	test   %eax,%eax
c000342a:	75 10                	jne    c000343c <kmalloc_aligned+0x54>
            panic("Error initializing kernel heap");
c000342c:	83 ec 0c             	sub    $0xc,%esp
c000342f:	68 60 47 00 c0       	push   $0xc0004760
c0003434:	e8 98 e2 ff ff       	call   c00016d1 <panic>
c0003439:	83 c4 10             	add    $0x10,%esp
    }

    heap_block_t* block = kheap_head;
c000343c:	a1 a4 68 00 c0       	mov    0xc00068a4,%eax
c0003441:	89 45 f4             	mov    %eax,-0xc(%ebp)
    //how many additional units are needed to align this block?
    size_t alignment_space;

    while(true)
    {
        if(block->status == HEAP_BLOCK_FREE)
c0003444:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003447:	0f b6 40 03          	movzbl 0x3(%eax),%eax
c000344b:	83 e0 f0             	and    $0xfffffff0,%eax
c000344e:	84 c0                	test   %al,%al
c0003450:	75 42                	jne    c0003494 <kmalloc_aligned+0xac>
        {
            // where would aligned data start in this block?
            size_t block_data = (size_t)block/HEAP_BLOCKSIZE_UNITS + 1;  //(unaligned) data starts after header
c0003452:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003455:	c1 e8 04             	shr    $0x4,%eax
c0003458:	83 c0 01             	add    $0x1,%eax
c000345b:	89 45 e8             	mov    %eax,-0x18(%ebp)
            size_t am = block_alignment - 1;
c000345e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003461:	83 e8 01             	sub    $0x1,%eax
c0003464:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            size_t block_data_aligned = ((block_data + am) & ~am); //align data
c0003467:	8b 55 e8             	mov    -0x18(%ebp),%edx
c000346a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000346d:	01 c2                	add    %eax,%edx
c000346f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0003472:	f7 d0                	not    %eax
c0003474:	21 d0                	and    %edx,%eax
c0003476:	89 45 e0             	mov    %eax,-0x20(%ebp)

            alignment_space = block_data_aligned-block_data; 
c0003479:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000347c:	2b 45 e8             	sub    -0x18(%ebp),%eax
c000347f:	89 45 dc             	mov    %eax,-0x24(%ebp)

            if(block->size >= block_size + alignment_space)
c0003482:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003485:	8b 40 0c             	mov    0xc(%eax),%eax
c0003488:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c000348b:	8b 55 dc             	mov    -0x24(%ebp),%edx
c000348e:	01 ca                	add    %ecx,%edx
c0003490:	39 d0                	cmp    %edx,%eax
c0003492:	73 3b                	jae    c00034cf <kmalloc_aligned+0xe7>
                break;

        }

        //if we've returned to the head, we have run through the entire list without finding a free block
        if(block->next == kheap_head)
c0003494:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003497:	8b 50 08             	mov    0x8(%eax),%edx
c000349a:	a1 a4 68 00 c0       	mov    0xc00068a4,%eax
c000349f:	39 c2                	cmp    %eax,%edx
c00034a1:	75 1e                	jne    c00034c1 <kmalloc_aligned+0xd9>
        {
            //we've reached the end of the heap, so add a new block at the end
            block = grow_kheap(block_size);
c00034a3:	83 ec 0c             	sub    $0xc,%esp
c00034a6:	ff 75 ec             	pushl  -0x14(%ebp)
c00034a9:	e8 ad fd ff ff       	call   c000325b <grow_kheap>
c00034ae:	83 c4 10             	add    $0x10,%esp
c00034b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
            if(!block) return NULL; //grow_kheap() failed, e.g. OOM 
c00034b4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00034b8:	75 8a                	jne    c0003444 <kmalloc_aligned+0x5c>
c00034ba:	b8 00 00 00 00       	mov    $0x0,%eax
c00034bf:	eb 7e                	jmp    c000353f <kmalloc_aligned+0x157>
        }
        else
        {
            block = block->next;
c00034c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00034c4:	8b 40 08             	mov    0x8(%eax),%eax
c00034c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(block->status == HEAP_BLOCK_FREE)
c00034ca:	e9 75 ff ff ff       	jmp    c0003444 <kmalloc_aligned+0x5c>
                break;
c00034cf:	90                   	nop
    }

    // block is a free block that is large enough for this allocation

    //if we need to realign, split off the first part of the block
    if(alignment_space>0)
c00034d0:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c00034d4:	74 2e                	je     c0003504 <kmalloc_aligned+0x11c>
    {
        if(kheap_split_block(block, alignment_space)<0)
c00034d6:	83 ec 08             	sub    $0x8,%esp
c00034d9:	ff 75 dc             	pushl  -0x24(%ebp)
c00034dc:	ff 75 f4             	pushl  -0xc(%ebp)
c00034df:	e8 c3 fc ff ff       	call   c00031a7 <kheap_split_block>
c00034e4:	83 c4 10             	add    $0x10,%esp
c00034e7:	85 c0                	test   %eax,%eax
c00034e9:	79 10                	jns    c00034fb <kmalloc_aligned+0x113>
            panic("Critical error in malloc()");
c00034eb:	83 ec 0c             	sub    $0xc,%esp
c00034ee:	68 7f 47 00 c0       	push   $0xc000477f
c00034f3:	e8 d9 e1 ff ff       	call   c00016d1 <panic>
c00034f8:	83 c4 10             	add    $0x10,%esp
        block = block->next;
c00034fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00034fe:	8b 40 08             	mov    0x8(%eax),%eax
c0003501:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    
    //split end of block off its big enough
    if(kheap_split_block(block, block_size)<0)
c0003504:	83 ec 08             	sub    $0x8,%esp
c0003507:	ff 75 ec             	pushl  -0x14(%ebp)
c000350a:	ff 75 f4             	pushl  -0xc(%ebp)
c000350d:	e8 95 fc ff ff       	call   c00031a7 <kheap_split_block>
c0003512:	83 c4 10             	add    $0x10,%esp
c0003515:	85 c0                	test   %eax,%eax
c0003517:	79 10                	jns    c0003529 <kmalloc_aligned+0x141>
        panic("Critical error in malloc()");
c0003519:	83 ec 0c             	sub    $0xc,%esp
c000351c:	68 7f 47 00 c0       	push   $0xc000477f
c0003521:	e8 ab e1 ff ff       	call   c00016d1 <panic>
c0003526:	83 c4 10             	add    $0x10,%esp

    block->status = HEAP_BLOCK_USED;
c0003529:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000352c:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c0003530:	83 e2 0f             	and    $0xf,%edx
c0003533:	83 ca 10             	or     $0x10,%edx
c0003536:	88 50 03             	mov    %dl,0x3(%eax)
    return block+1; // return pointer after header
c0003539:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000353c:	83 c0 10             	add    $0x10,%eax
}
c000353f:	c9                   	leave  
c0003540:	c3                   	ret    

c0003541 <kfree>:

// free memory previously allocated with kmalloc
// return 0 on success.
// return -1 on fail (e.g. if p was not allocated with malloc, or memory corruption detected)
int kfree(void* p)
{
c0003541:	55                   	push   %ebp
c0003542:	89 e5                	mov    %esp,%ebp
c0003544:	83 ec 18             	sub    $0x18,%esp
    //get pointer to block header
    heap_block_t* b = ((heap_block_t*) p) - 1;
c0003547:	8b 45 08             	mov    0x8(%ebp),%eax
c000354a:	83 e8 10             	sub    $0x10,%eax
c000354d:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(kheap_validate_block(b))
c0003550:	ff 75 f4             	pushl  -0xc(%ebp)
c0003553:	e8 71 f9 ff ff       	call   c0002ec9 <kheap_validate_block>
c0003558:	83 c4 04             	add    $0x4,%esp
c000355b:	85 c0                	test   %eax,%eax
c000355d:	74 17                	je     c0003576 <kfree+0x35>
    {
        panic("kernel heap corrupted");
c000355f:	83 ec 0c             	sub    $0xc,%esp
c0003562:	68 48 47 00 c0       	push   $0xc0004748
c0003567:	e8 65 e1 ff ff       	call   c00016d1 <panic>
c000356c:	83 c4 10             	add    $0x10,%esp
        return -1;
c000356f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003574:	eb 1e                	jmp    c0003594 <kfree+0x53>
    }

    if(kheap_free_block(b)) return 0;
c0003576:	83 ec 0c             	sub    $0xc,%esp
c0003579:	ff 75 f4             	pushl  -0xc(%ebp)
c000357c:	e8 41 fb ff ff       	call   c00030c2 <kheap_free_block>
c0003581:	83 c4 10             	add    $0x10,%esp
c0003584:	85 c0                	test   %eax,%eax
c0003586:	74 07                	je     c000358f <kfree+0x4e>
c0003588:	b8 00 00 00 00       	mov    $0x0,%eax
c000358d:	eb 05                	jmp    c0003594 <kfree+0x53>

    return -1;
c000358f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0003594:	c9                   	leave  
c0003595:	c3                   	ret    

c0003596 <kheap_size>:


// size of allocated and free mem in heap
// returns 0 on success
int kheap_size(size_t* allocated, size_t* free)
{
c0003596:	55                   	push   %ebp
c0003597:	89 e5                	mov    %esp,%ebp
c0003599:	83 ec 10             	sub    $0x10,%esp
    *allocated = 0;
c000359c:	8b 45 08             	mov    0x8(%ebp),%eax
c000359f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *free = 0;
c00035a5:	8b 45 0c             	mov    0xc(%ebp),%eax
c00035a8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    // make sure heap is initilialized
    if(!kheap_head)
c00035ae:	a1 a4 68 00 c0       	mov    0xc00068a4,%eax
c00035b3:	85 c0                	test   %eax,%eax
c00035b5:	75 0a                	jne    c00035c1 <kheap_size+0x2b>
        return -1;
c00035b7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00035bc:	e9 87 00 00 00       	jmp    c0003648 <kheap_size+0xb2>

    heap_block_t* block = kheap_head;
c00035c1:	a1 a4 68 00 c0       	mov    0xc00068a4,%eax
c00035c6:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while(true)
    {        
        if(kheap_validate_block(block))
c00035c9:	ff 75 fc             	pushl  -0x4(%ebp)
c00035cc:	e8 f8 f8 ff ff       	call   c0002ec9 <kheap_validate_block>
c00035d1:	83 c4 04             	add    $0x4,%esp
c00035d4:	85 c0                	test   %eax,%eax
c00035d6:	74 07                	je     c00035df <kheap_size+0x49>
            return -1;        
c00035d8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00035dd:	eb 69                	jmp    c0003648 <kheap_size+0xb2>

        if(block->status == HEAP_BLOCK_FREE)
c00035df:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00035e2:	0f b6 40 03          	movzbl 0x3(%eax),%eax
c00035e6:	83 e0 f0             	and    $0xfffffff0,%eax
c00035e9:	84 c0                	test   %al,%al
c00035eb:	75 17                	jne    c0003604 <kheap_size+0x6e>
            *free += block->size*HEAP_BLOCKSIZE_UNITS;
c00035ed:	8b 45 0c             	mov    0xc(%ebp),%eax
c00035f0:	8b 10                	mov    (%eax),%edx
c00035f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00035f5:	8b 40 0c             	mov    0xc(%eax),%eax
c00035f8:	c1 e0 04             	shl    $0x4,%eax
c00035fb:	01 c2                	add    %eax,%edx
c00035fd:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003600:	89 10                	mov    %edx,(%eax)
c0003602:	eb 2c                	jmp    c0003630 <kheap_size+0x9a>
        else if(block->status == HEAP_BLOCK_USED)
c0003604:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003607:	0f b6 40 03          	movzbl 0x3(%eax),%eax
c000360b:	83 e0 f0             	and    $0xfffffff0,%eax
c000360e:	3c 10                	cmp    $0x10,%al
c0003610:	75 17                	jne    c0003629 <kheap_size+0x93>
            *allocated += block->size*HEAP_BLOCKSIZE_UNITS;
c0003612:	8b 45 08             	mov    0x8(%ebp),%eax
c0003615:	8b 10                	mov    (%eax),%edx
c0003617:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000361a:	8b 40 0c             	mov    0xc(%eax),%eax
c000361d:	c1 e0 04             	shl    $0x4,%eax
c0003620:	01 c2                	add    %eax,%edx
c0003622:	8b 45 08             	mov    0x8(%ebp),%eax
c0003625:	89 10                	mov    %edx,(%eax)
c0003627:	eb 07                	jmp    c0003630 <kheap_size+0x9a>
        else
            return -1;        
c0003629:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000362e:	eb 18                	jmp    c0003648 <kheap_size+0xb2>

        block = block->next;
c0003630:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003633:	8b 40 08             	mov    0x8(%eax),%eax
c0003636:	89 45 fc             	mov    %eax,-0x4(%ebp)
        if(block == kheap_head)
c0003639:	a1 a4 68 00 c0       	mov    0xc00068a4,%eax
c000363e:	39 45 fc             	cmp    %eax,-0x4(%ebp)
c0003641:	75 86                	jne    c00035c9 <kheap_size+0x33>
            return 0;
c0003643:	b8 00 00 00 00       	mov    $0x0,%eax
    }

}
c0003648:	c9                   	leave  
c0003649:	c3                   	ret    

c000364a <scancode_to_ascii>:
    0,  /* F12 Key */
    0,  /* All other keys are undefined */
};

char scancode_to_ascii(uint8_t scancode)
{
c000364a:	55                   	push   %ebp
c000364b:	89 e5                	mov    %esp,%ebp
c000364d:	83 ec 04             	sub    $0x4,%esp
c0003650:	8b 45 08             	mov    0x8(%ebp),%eax
c0003653:	88 45 fc             	mov    %al,-0x4(%ebp)
    return kbd_US[scancode];
c0003656:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c000365a:	0f b6 80 20 50 00 c0 	movzbl -0x3fffafe0(%eax),%eax
}
c0003661:	c9                   	leave  
c0003662:	c3                   	ret    

c0003663 <test_multitasking2>:
#include "test.h"
#include "kprintf.h"
#include "task.h"

int32_t test_multitasking2()
{
c0003663:	55                   	push   %ebp
c0003664:	89 e5                	mov    %esp,%ebp
c0003666:	83 ec 18             	sub    $0x18,%esp
	int nn;
	for(nn=0;nn<5;nn++)
c0003669:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0003670:	eb 09                	jmp    c000367b <test_multitasking2+0x18>
		yield();
c0003672:	e8 dd ef ff ff       	call   c0002654 <yield>
	for(nn=0;nn<5;nn++)
c0003677:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c000367b:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
c000367f:	7e f1                	jle    c0003672 <test_multitasking2+0xf>
	return nn;
c0003681:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0003684:	c9                   	leave  
c0003685:	c3                   	ret    

c0003686 <test_multitasking>:

int test_multitasking()
{
c0003686:	55                   	push   %ebp
c0003687:	89 e5                	mov    %esp,%ebp
c0003689:	83 ec 18             	sub    $0x18,%esp
	task_control_block_t* task2 = new_kernel_task( &test_multitasking2 );
c000368c:	83 ec 0c             	sub    $0xc,%esp
c000368f:	68 63 36 00 c0       	push   $0xc0003663
c0003694:	e8 77 ee ff ff       	call   c0002510 <new_kernel_task>
c0003699:	83 c4 10             	add    $0x10,%esp
c000369c:	89 45 f0             	mov    %eax,-0x10(%ebp)

	int nn;
	for(nn=0;nn<10;nn++)
c000369f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00036a6:	eb 09                	jmp    c00036b1 <test_multitasking+0x2b>
		yield();
c00036a8:	e8 a7 ef ff ff       	call   c0002654 <yield>
	for(nn=0;nn<10;nn++)
c00036ad:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00036b1:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c00036b5:	7e f1                	jle    c00036a8 <test_multitasking+0x22>

	join(task2);
c00036b7:	83 ec 0c             	sub    $0xc,%esp
c00036ba:	ff 75 f0             	pushl  -0x10(%ebp)
c00036bd:	e8 ca ef ff ff       	call   c000268c <join>
c00036c2:	83 c4 10             	add    $0x10,%esp

    if(task2->return_val == 5) return 0;
c00036c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00036c8:	8b 40 1c             	mov    0x1c(%eax),%eax
c00036cb:	83 f8 05             	cmp    $0x5,%eax
c00036ce:	75 07                	jne    c00036d7 <test_multitasking+0x51>
c00036d0:	b8 00 00 00 00       	mov    $0x0,%eax
c00036d5:	eb 05                	jmp    c00036dc <test_multitasking+0x56>

    return -1;
c00036d7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c00036dc:	c9                   	leave  
c00036dd:	c3                   	ret    

c00036de <kernel_main>:
#if defined(__linux__)  || !defined(__i386__)
#error "This kernel requires ix86-elf cross compiler"
#endif

void kernel_main(multiboot_info_t* mbd)
{
c00036de:	55                   	push   %ebp
c00036df:	89 e5                	mov    %esp,%ebp
c00036e1:	83 ec 08             	sub    $0x8,%esp
	init_vga_buffer(); //do this first so we have a working screen buffer
c00036e4:	e8 13 f6 ff ff       	call   c0002cfc <init_vga_buffer>
	init_gdt();
c00036e9:	e8 7f 01 00 00       	call   c000386d <init_gdt>
	init_interrupts();
c00036ee:	e8 e9 e8 ff ff       	call   c0001fdc <init_interrupts>

	terminal_init(&stdout);
c00036f3:	83 ec 0c             	sub    $0xc,%esp
c00036f6:	68 00 60 00 c0       	push   $0xc0006000
c00036fb:	e8 8d cd ff ff       	call   c000048d <terminal_init>
c0003700:	83 c4 10             	add    $0x10,%esp
    // terminal_setcolor(&stdout, VGA_COLOR_WHITE);
	kprintf("Let's learn about Operating Systems!\n");
c0003703:	83 ec 0c             	sub    $0xc,%esp
c0003706:	68 9c 47 00 c0       	push   $0xc000479c
c000370b:	e8 a4 d1 ff ff       	call   c00008b4 <kprintf>
c0003710:	83 c4 10             	add    $0x10,%esp
	kprintf("Jon Doane, 2020\n\n");
c0003713:	83 ec 0c             	sub    $0xc,%esp
c0003716:	68 c2 47 00 c0       	push   $0xc00047c2
c000371b:	e8 94 d1 ff ff       	call   c00008b4 <kprintf>
c0003720:	83 c4 10             	add    $0x10,%esp
	
	print_memory_table(mbd);
c0003723:	83 ec 0c             	sub    $0xc,%esp
c0003726:	ff 75 08             	pushl  0x8(%ebp)
c0003729:	e8 7f e6 ff ff       	call   c0001dad <print_memory_table>
c000372e:	83 c4 10             	add    $0x10,%esp
	global_memory_init(mbd);	//after this the multiboot structure is unmapped
c0003731:	83 ec 0c             	sub    $0xc,%esp
c0003734:	ff 75 08             	pushl  0x8(%ebp)
c0003737:	e8 4c f5 ff ff       	call   c0002c88 <global_memory_init>
c000373c:	83 c4 10             	add    $0x10,%esp
	initialize_multitasking();
c000373f:	e8 7d ed ff ff       	call   c00024c1 <initialize_multitasking>

	if(test_kmalloc())
c0003744:	e8 59 ca ff ff       	call   c00001a2 <test_kmalloc>
c0003749:	85 c0                	test   %eax,%eax
c000374b:	74 12                	je     c000375f <kernel_main+0x81>
		kprintf("Malloc tests FAILED!\n");
c000374d:	83 ec 0c             	sub    $0xc,%esp
c0003750:	68 d4 47 00 c0       	push   $0xc00047d4
c0003755:	e8 5a d1 ff ff       	call   c00008b4 <kprintf>
c000375a:	83 c4 10             	add    $0x10,%esp
c000375d:	eb 10                	jmp    c000376f <kernel_main+0x91>
	else
		kprintf("Malloc tests PASSED!\n");
c000375f:	83 ec 0c             	sub    $0xc,%esp
c0003762:	68 ea 47 00 c0       	push   $0xc00047ea
c0003767:	e8 48 d1 ff ff       	call   c00008b4 <kprintf>
c000376c:	83 c4 10             	add    $0x10,%esp

	if(test_multitasking())
c000376f:	e8 12 ff ff ff       	call   c0003686 <test_multitasking>
c0003774:	85 c0                	test   %eax,%eax
c0003776:	74 12                	je     c000378a <kernel_main+0xac>
		kprintf("Multitasking tests FAILED!\n");
c0003778:	83 ec 0c             	sub    $0xc,%esp
c000377b:	68 00 48 00 c0       	push   $0xc0004800
c0003780:	e8 2f d1 ff ff       	call   c00008b4 <kprintf>
c0003785:	83 c4 10             	add    $0x10,%esp
c0003788:	eb 10                	jmp    c000379a <kernel_main+0xbc>
	else
		kprintf("Multitasking tests PASSED!\n");
c000378a:	83 ec 0c             	sub    $0xc,%esp
c000378d:	68 1c 48 00 c0       	push   $0xc000481c
c0003792:	e8 1d d1 ff ff       	call   c00008b4 <kprintf>
c0003797:	83 c4 10             	add    $0x10,%esp

	while(1);
c000379a:	eb fe                	jmp    c000379a <kernel_main+0xbc>

c000379c <populate_gdt_entry>:
   uint16_t iomap_base;
} tss_entry_t;


static inline void populate_gdt_entry(gdt_entry_t* sd, uint32_t base, uint32_t limit, uint8_t access, uint8_t flags)
{
c000379c:	55                   	push   %ebp
c000379d:	89 e5                	mov    %esp,%ebp
c000379f:	53                   	push   %ebx
c00037a0:	83 ec 08             	sub    $0x8,%esp
c00037a3:	8b 55 14             	mov    0x14(%ebp),%edx
c00037a6:	8b 45 18             	mov    0x18(%ebp),%eax
c00037a9:	88 55 f8             	mov    %dl,-0x8(%ebp)
c00037ac:	88 45 f4             	mov    %al,-0xc(%ebp)
    sd->limit_low = limit & SEGMENT_LIMIT_LOW_MASK;
c00037af:	8b 45 10             	mov    0x10(%ebp),%eax
c00037b2:	89 c2                	mov    %eax,%edx
c00037b4:	8b 45 08             	mov    0x8(%ebp),%eax
c00037b7:	0f b7 ca             	movzwl %dx,%ecx
c00037ba:	0f b6 d9             	movzbl %cl,%ebx
c00037bd:	0f b6 08             	movzbl (%eax),%ecx
c00037c0:	83 e1 00             	and    $0x0,%ecx
c00037c3:	09 d9                	or     %ebx,%ecx
c00037c5:	88 08                	mov    %cl,(%eax)
c00037c7:	66 c1 ea 08          	shr    $0x8,%dx
c00037cb:	0f b7 ca             	movzwl %dx,%ecx
c00037ce:	0f b6 50 01          	movzbl 0x1(%eax),%edx
c00037d2:	83 e2 00             	and    $0x0,%edx
c00037d5:	09 ca                	or     %ecx,%edx
c00037d7:	88 50 01             	mov    %dl,0x1(%eax)
    sd->limit_high = (limit & SEGMENT_LIMIT_HIGH_MASK) >> 16;
c00037da:	8b 45 10             	mov    0x10(%ebp),%eax
c00037dd:	c1 e8 10             	shr    $0x10,%eax
c00037e0:	83 e0 0f             	and    $0xf,%eax
c00037e3:	8b 55 08             	mov    0x8(%ebp),%edx
c00037e6:	83 e0 0f             	and    $0xf,%eax
c00037e9:	89 c1                	mov    %eax,%ecx
c00037eb:	0f b6 42 06          	movzbl 0x6(%edx),%eax
c00037ef:	83 e0 f0             	and    $0xfffffff0,%eax
c00037f2:	09 c8                	or     %ecx,%eax
c00037f4:	88 42 06             	mov    %al,0x6(%edx)
    sd->base_low = base & SEGMENT_BASE_LOW_MASK;
c00037f7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00037fa:	89 c2                	mov    %eax,%edx
c00037fc:	8b 45 08             	mov    0x8(%ebp),%eax
c00037ff:	0f b7 ca             	movzwl %dx,%ecx
c0003802:	0f b6 d9             	movzbl %cl,%ebx
c0003805:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
c0003809:	83 e1 00             	and    $0x0,%ecx
c000380c:	09 d9                	or     %ebx,%ecx
c000380e:	88 48 02             	mov    %cl,0x2(%eax)
c0003811:	66 c1 ea 08          	shr    $0x8,%dx
c0003815:	0f b7 ca             	movzwl %dx,%ecx
c0003818:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c000381c:	83 e2 00             	and    $0x0,%edx
c000381f:	09 ca                	or     %ecx,%edx
c0003821:	88 50 03             	mov    %dl,0x3(%eax)
    sd->base_mid = (base & SEGMENT_BASE_MID_MASK) >> 16;
c0003824:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003827:	c1 e8 10             	shr    $0x10,%eax
c000382a:	89 c2                	mov    %eax,%edx
c000382c:	8b 45 08             	mov    0x8(%ebp),%eax
c000382f:	88 50 04             	mov    %dl,0x4(%eax)
    sd->base_high = (base & SEGMENT_BASE_HIGH_MASK) >> 24;
c0003832:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003835:	c1 e8 18             	shr    $0x18,%eax
c0003838:	89 c2                	mov    %eax,%edx
c000383a:	8b 45 08             	mov    0x8(%ebp),%eax
c000383d:	88 50 07             	mov    %dl,0x7(%eax)
    sd->access = access;
c0003840:	8b 45 08             	mov    0x8(%ebp),%eax
c0003843:	0f b6 55 f8          	movzbl -0x8(%ebp),%edx
c0003847:	88 50 05             	mov    %dl,0x5(%eax)
    sd->flags = flags;
c000384a:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c000384e:	83 e0 0f             	and    $0xf,%eax
c0003851:	89 c2                	mov    %eax,%edx
c0003853:	8b 45 08             	mov    0x8(%ebp),%eax
c0003856:	89 d1                	mov    %edx,%ecx
c0003858:	c1 e1 04             	shl    $0x4,%ecx
c000385b:	0f b6 50 06          	movzbl 0x6(%eax),%edx
c000385f:	83 e2 0f             	and    $0xf,%edx
c0003862:	09 ca                	or     %ecx,%edx
c0003864:	88 50 06             	mov    %dl,0x6(%eax)
}
c0003867:	90                   	nop
c0003868:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000386b:	c9                   	leave  
c000386c:	c3                   	ret    

c000386d <init_gdt>:
gdt_description_t __aligned  gdtd;

tss_entry_t tss = {0};

void init_gdt()
{
c000386d:	55                   	push   %ebp
c000386e:	89 e5                	mov    %esp,%ebp
c0003870:	83 ec 08             	sub    $0x8,%esp
    // gdt[0] unused
    populate_gdt_entry(&gdt[1], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(0) | SEG_DESCTYPE(1) | SEG_CODE_EXRD, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // priv code, seg 0x008
c0003873:	6a 0c                	push   $0xc
c0003875:	68 9a 00 00 00       	push   $0x9a
c000387a:	6a ff                	push   $0xffffffff
c000387c:	6a 00                	push   $0x0
c000387e:	68 c8 68 00 c0       	push   $0xc00068c8
c0003883:	e8 14 ff ff ff       	call   c000379c <populate_gdt_entry>
c0003888:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[2], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(0) | SEG_DESCTYPE(1) | SEG_DATA_RDWR, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // priv data, seg 0x010
c000388b:	6a 0c                	push   $0xc
c000388d:	68 92 00 00 00       	push   $0x92
c0003892:	6a ff                	push   $0xffffffff
c0003894:	6a 00                	push   $0x0
c0003896:	68 d0 68 00 c0       	push   $0xc00068d0
c000389b:	e8 fc fe ff ff       	call   c000379c <populate_gdt_entry>
c00038a0:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[3], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(3) | SEG_DESCTYPE(1) | SEG_CODE_EXRD, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // user code, seg 0x018
c00038a3:	6a 0c                	push   $0xc
c00038a5:	68 fa 00 00 00       	push   $0xfa
c00038aa:	6a ff                	push   $0xffffffff
c00038ac:	6a 00                	push   $0x0
c00038ae:	68 d8 68 00 c0       	push   $0xc00068d8
c00038b3:	e8 e4 fe ff ff       	call   c000379c <populate_gdt_entry>
c00038b8:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[4], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(3) | SEG_DESCTYPE(1) | SEG_DATA_RDWR, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // user data  seg 0x020
c00038bb:	6a 0c                	push   $0xc
c00038bd:	68 f2 00 00 00       	push   $0xf2
c00038c2:	6a ff                	push   $0xffffffff
c00038c4:	6a 00                	push   $0x0
c00038c6:	68 e0 68 00 c0       	push   $0xc00068e0
c00038cb:	e8 cc fe ff ff       	call   c000379c <populate_gdt_entry>
c00038d0:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[5], (uint32_t) &tss, sizeof(tss_entry_t), SEG_TSS, SEG_FLAG_TSS); // tss, seg 0x028
c00038d3:	b8 20 69 00 c0       	mov    $0xc0006920,%eax
c00038d8:	6a 04                	push   $0x4
c00038da:	68 89 00 00 00       	push   $0x89
c00038df:	6a 68                	push   $0x68
c00038e1:	50                   	push   %eax
c00038e2:	68 e8 68 00 c0       	push   $0xc00068e8
c00038e7:	e8 b0 fe ff ff       	call   c000379c <populate_gdt_entry>
c00038ec:	83 c4 14             	add    $0x14,%esp

    //tss.esp0 = XXXXX
    tss.ss0 = KERNEL_DATA_SEGMENT; //kernel data segment    
c00038ef:	c7 05 28 69 00 c0 10 	movl   $0x10,0xc0006928
c00038f6:	00 00 00 
    tss.iomap_base = sizeof(tss_entry_t);
c00038f9:	66 c7 05 86 69 00 c0 	movw   $0x68,0xc0006986
c0003900:	68 00 
    // before we can actually switch tasks, we must first set the kernel stack pointer, with update_tss()

    gdtd.addr = (uint32_t) gdt;
c0003902:	b8 c0 68 00 c0       	mov    $0xc00068c0,%eax
c0003907:	a3 02 69 00 c0       	mov    %eax,0xc0006902
    gdtd.size = sizeof(gdt);    
c000390c:	66 c7 05 00 69 00 c0 	movw   $0x30,0xc0006900
c0003913:	30 00 
    load_gdt(&gdtd);
c0003915:	83 ec 0c             	sub    $0xc,%esp
c0003918:	68 00 69 00 c0       	push   $0xc0006900
c000391d:	e8 1e 00 00 00       	call   c0003940 <load_gdt>
c0003922:	83 c4 10             	add    $0x10,%esp
}
c0003925:	90                   	nop
c0003926:	c9                   	leave  
c0003927:	c3                   	ret    

c0003928 <update_kstack>:

void update_kstack(void* kernel_stack_ptr)
{
c0003928:	55                   	push   %ebp
c0003929:	89 e5                	mov    %esp,%ebp
c000392b:	83 ec 08             	sub    $0x8,%esp
    tss.esp0 = (uint32_t) kernel_stack_ptr; //kernel stack ptr
c000392e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003931:	a3 24 69 00 c0       	mov    %eax,0xc0006924
    load_tss();
c0003936:	e8 25 00 00 00       	call   c0003960 <load_tss>
}
c000393b:	90                   	nop
c000393c:	c9                   	leave  
c000393d:	c3                   	ret    
c000393e:	66 90                	xchg   %ax,%ax

c0003940 <load_gdt>:
c0003940:	0f 01 15 00 69 00 c0 	lgdtl  0xc0006900
c0003947:	ea 4e 39 00 c0 08 00 	ljmp   $0x8,$0xc000394e

c000394e <complete_flush>:
c000394e:	66 b8 10 00          	mov    $0x10,%ax
c0003952:	8e d8                	mov    %eax,%ds
c0003954:	8e c0                	mov    %eax,%es
c0003956:	8e e0                	mov    %eax,%fs
c0003958:	8e e8                	mov    %eax,%gs
c000395a:	8e d0                	mov    %eax,%ss
c000395c:	c3                   	ret    
c000395d:	8d 76 00             	lea    0x0(%esi),%esi

c0003960 <load_tss>:
c0003960:	66 b8 28 00          	mov    $0x28,%ax
c0003964:	66 83 c8 03          	or     $0x3,%ax
c0003968:	0f 00 d8             	ltr    %ax
c000396b:	c3                   	ret    

c000396c <getregs>:
c000396c:	55                   	push   %ebp
c000396d:	89 e5                	mov    %esp,%ebp
c000396f:	53                   	push   %ebx
c0003970:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0003973:	89 03                	mov    %eax,(%ebx)
c0003975:	8b 04 24             	mov    (%esp),%eax
c0003978:	89 43 04             	mov    %eax,0x4(%ebx)
c000397b:	89 4b 08             	mov    %ecx,0x8(%ebx)
c000397e:	89 53 0c             	mov    %edx,0xc(%ebx)
c0003981:	89 73 10             	mov    %esi,0x10(%ebx)
c0003984:	89 7b 14             	mov    %edi,0x14(%ebx)
c0003987:	89 e8                	mov    %ebp,%eax
c0003989:	83 c0 0c             	add    $0xc,%eax
c000398c:	89 43 18             	mov    %eax,0x18(%ebx)
c000398f:	8b 45 00             	mov    0x0(%ebp),%eax
c0003992:	89 43 1c             	mov    %eax,0x1c(%ebx)
c0003995:	8b 45 04             	mov    0x4(%ebp),%eax
c0003998:	89 43 20             	mov    %eax,0x20(%ebx)
c000399b:	b8 00 00 00 00       	mov    $0x0,%eax
c00039a0:	9f                   	lahf   
c00039a1:	89 43 24             	mov    %eax,0x24(%ebx)
c00039a4:	0f 20 c0             	mov    %cr0,%eax
c00039a7:	89 43 28             	mov    %eax,0x28(%ebx)
c00039aa:	0f 20 d0             	mov    %cr2,%eax
c00039ad:	89 43 2c             	mov    %eax,0x2c(%ebx)
c00039b0:	0f 20 d8             	mov    %cr3,%eax
c00039b3:	89 43 30             	mov    %eax,0x30(%ebx)
c00039b6:	0f 20 e0             	mov    %cr4,%eax
c00039b9:	89 43 34             	mov    %eax,0x34(%ebx)
c00039bc:	5b                   	pop    %ebx
c00039bd:	5d                   	pop    %ebp
c00039be:	c3                   	ret    
c00039bf:	90                   	nop

c00039c0 <load_idt>:
c00039c0:	0f 01 1d 20 68 00 c0 	lidtl  0xc0006820
c00039c7:	fb                   	sti    
c00039c8:	c3                   	ret    
c00039c9:	8d 76 00             	lea    0x0(%esi),%esi

c00039cc <pf_addr>:
c00039cc:	0f 20 d0             	mov    %cr2,%eax
c00039cf:	c3                   	ret    

c00039d0 <except_0>:
c00039d0:	55                   	push   %ebp
c00039d1:	89 e5                	mov    %esp,%ebp
c00039d3:	60                   	pusha  
c00039d4:	8b 45 04             	mov    0x4(%ebp),%eax
c00039d7:	50                   	push   %eax
c00039d8:	b8 00 00 00 00       	mov    $0x0,%eax
c00039dd:	50                   	push   %eax
c00039de:	b8 00 00 00 00       	mov    $0x0,%eax
c00039e3:	50                   	push   %eax
c00039e4:	e8 35 ea ff ff       	call   c000241e <exception_handler>
c00039e9:	83 c4 0c             	add    $0xc,%esp
c00039ec:	61                   	popa   
c00039ed:	5d                   	pop    %ebp
c00039ee:	cf                   	iret   
c00039ef:	90                   	nop

c00039f0 <except_1>:
c00039f0:	55                   	push   %ebp
c00039f1:	89 e5                	mov    %esp,%ebp
c00039f3:	60                   	pusha  
c00039f4:	8b 45 04             	mov    0x4(%ebp),%eax
c00039f7:	50                   	push   %eax
c00039f8:	b8 00 00 00 00       	mov    $0x0,%eax
c00039fd:	50                   	push   %eax
c00039fe:	b8 01 00 00 00       	mov    $0x1,%eax
c0003a03:	50                   	push   %eax
c0003a04:	e8 15 ea ff ff       	call   c000241e <exception_handler>
c0003a09:	83 c4 0c             	add    $0xc,%esp
c0003a0c:	61                   	popa   
c0003a0d:	5d                   	pop    %ebp
c0003a0e:	cf                   	iret   
c0003a0f:	90                   	nop

c0003a10 <except_2>:
c0003a10:	55                   	push   %ebp
c0003a11:	89 e5                	mov    %esp,%ebp
c0003a13:	60                   	pusha  
c0003a14:	8b 45 04             	mov    0x4(%ebp),%eax
c0003a17:	50                   	push   %eax
c0003a18:	b8 00 00 00 00       	mov    $0x0,%eax
c0003a1d:	50                   	push   %eax
c0003a1e:	b8 02 00 00 00       	mov    $0x2,%eax
c0003a23:	50                   	push   %eax
c0003a24:	e8 f5 e9 ff ff       	call   c000241e <exception_handler>
c0003a29:	83 c4 0c             	add    $0xc,%esp
c0003a2c:	61                   	popa   
c0003a2d:	5d                   	pop    %ebp
c0003a2e:	cf                   	iret   
c0003a2f:	90                   	nop

c0003a30 <except_3>:
c0003a30:	55                   	push   %ebp
c0003a31:	89 e5                	mov    %esp,%ebp
c0003a33:	60                   	pusha  
c0003a34:	8b 45 04             	mov    0x4(%ebp),%eax
c0003a37:	50                   	push   %eax
c0003a38:	b8 00 00 00 00       	mov    $0x0,%eax
c0003a3d:	50                   	push   %eax
c0003a3e:	b8 03 00 00 00       	mov    $0x3,%eax
c0003a43:	50                   	push   %eax
c0003a44:	e8 d5 e9 ff ff       	call   c000241e <exception_handler>
c0003a49:	83 c4 0c             	add    $0xc,%esp
c0003a4c:	61                   	popa   
c0003a4d:	5d                   	pop    %ebp
c0003a4e:	cf                   	iret   
c0003a4f:	90                   	nop

c0003a50 <except_4>:
c0003a50:	55                   	push   %ebp
c0003a51:	89 e5                	mov    %esp,%ebp
c0003a53:	60                   	pusha  
c0003a54:	8b 45 04             	mov    0x4(%ebp),%eax
c0003a57:	50                   	push   %eax
c0003a58:	b8 00 00 00 00       	mov    $0x0,%eax
c0003a5d:	50                   	push   %eax
c0003a5e:	b8 04 00 00 00       	mov    $0x4,%eax
c0003a63:	50                   	push   %eax
c0003a64:	e8 b5 e9 ff ff       	call   c000241e <exception_handler>
c0003a69:	83 c4 0c             	add    $0xc,%esp
c0003a6c:	61                   	popa   
c0003a6d:	5d                   	pop    %ebp
c0003a6e:	cf                   	iret   
c0003a6f:	90                   	nop

c0003a70 <except_5>:
c0003a70:	55                   	push   %ebp
c0003a71:	89 e5                	mov    %esp,%ebp
c0003a73:	60                   	pusha  
c0003a74:	8b 45 04             	mov    0x4(%ebp),%eax
c0003a77:	50                   	push   %eax
c0003a78:	b8 00 00 00 00       	mov    $0x0,%eax
c0003a7d:	50                   	push   %eax
c0003a7e:	b8 05 00 00 00       	mov    $0x5,%eax
c0003a83:	50                   	push   %eax
c0003a84:	e8 95 e9 ff ff       	call   c000241e <exception_handler>
c0003a89:	83 c4 0c             	add    $0xc,%esp
c0003a8c:	61                   	popa   
c0003a8d:	5d                   	pop    %ebp
c0003a8e:	cf                   	iret   
c0003a8f:	90                   	nop

c0003a90 <except_6>:
c0003a90:	55                   	push   %ebp
c0003a91:	89 e5                	mov    %esp,%ebp
c0003a93:	60                   	pusha  
c0003a94:	8b 45 04             	mov    0x4(%ebp),%eax
c0003a97:	50                   	push   %eax
c0003a98:	b8 00 00 00 00       	mov    $0x0,%eax
c0003a9d:	50                   	push   %eax
c0003a9e:	b8 06 00 00 00       	mov    $0x6,%eax
c0003aa3:	50                   	push   %eax
c0003aa4:	e8 75 e9 ff ff       	call   c000241e <exception_handler>
c0003aa9:	83 c4 0c             	add    $0xc,%esp
c0003aac:	61                   	popa   
c0003aad:	5d                   	pop    %ebp
c0003aae:	cf                   	iret   
c0003aaf:	90                   	nop

c0003ab0 <except_7>:
c0003ab0:	55                   	push   %ebp
c0003ab1:	89 e5                	mov    %esp,%ebp
c0003ab3:	60                   	pusha  
c0003ab4:	8b 45 04             	mov    0x4(%ebp),%eax
c0003ab7:	50                   	push   %eax
c0003ab8:	b8 00 00 00 00       	mov    $0x0,%eax
c0003abd:	50                   	push   %eax
c0003abe:	b8 07 00 00 00       	mov    $0x7,%eax
c0003ac3:	50                   	push   %eax
c0003ac4:	e8 55 e9 ff ff       	call   c000241e <exception_handler>
c0003ac9:	83 c4 0c             	add    $0xc,%esp
c0003acc:	61                   	popa   
c0003acd:	5d                   	pop    %ebp
c0003ace:	cf                   	iret   
c0003acf:	90                   	nop

c0003ad0 <except_8>:
c0003ad0:	55                   	push   %ebp
c0003ad1:	89 e5                	mov    %esp,%ebp
c0003ad3:	60                   	pusha  
c0003ad4:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ad7:	50                   	push   %eax
c0003ad8:	8b 45 04             	mov    0x4(%ebp),%eax
c0003adb:	50                   	push   %eax
c0003adc:	b8 08 00 00 00       	mov    $0x8,%eax
c0003ae1:	50                   	push   %eax
c0003ae2:	e8 37 e9 ff ff       	call   c000241e <exception_handler>
c0003ae7:	83 c4 0c             	add    $0xc,%esp
c0003aea:	61                   	popa   
c0003aeb:	5d                   	pop    %ebp
c0003aec:	83 c4 04             	add    $0x4,%esp
c0003aef:	cf                   	iret   

c0003af0 <except_10>:
c0003af0:	55                   	push   %ebp
c0003af1:	89 e5                	mov    %esp,%ebp
c0003af3:	60                   	pusha  
c0003af4:	8b 45 08             	mov    0x8(%ebp),%eax
c0003af7:	50                   	push   %eax
c0003af8:	8b 45 04             	mov    0x4(%ebp),%eax
c0003afb:	50                   	push   %eax
c0003afc:	b8 0a 00 00 00       	mov    $0xa,%eax
c0003b01:	50                   	push   %eax
c0003b02:	e8 17 e9 ff ff       	call   c000241e <exception_handler>
c0003b07:	83 c4 0c             	add    $0xc,%esp
c0003b0a:	61                   	popa   
c0003b0b:	5d                   	pop    %ebp
c0003b0c:	83 c4 04             	add    $0x4,%esp
c0003b0f:	cf                   	iret   

c0003b10 <except_11>:
c0003b10:	55                   	push   %ebp
c0003b11:	89 e5                	mov    %esp,%ebp
c0003b13:	60                   	pusha  
c0003b14:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b17:	50                   	push   %eax
c0003b18:	8b 45 04             	mov    0x4(%ebp),%eax
c0003b1b:	50                   	push   %eax
c0003b1c:	b8 0b 00 00 00       	mov    $0xb,%eax
c0003b21:	50                   	push   %eax
c0003b22:	e8 f7 e8 ff ff       	call   c000241e <exception_handler>
c0003b27:	83 c4 0c             	add    $0xc,%esp
c0003b2a:	61                   	popa   
c0003b2b:	5d                   	pop    %ebp
c0003b2c:	83 c4 04             	add    $0x4,%esp
c0003b2f:	cf                   	iret   

c0003b30 <except_12>:
c0003b30:	55                   	push   %ebp
c0003b31:	89 e5                	mov    %esp,%ebp
c0003b33:	60                   	pusha  
c0003b34:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b37:	50                   	push   %eax
c0003b38:	8b 45 04             	mov    0x4(%ebp),%eax
c0003b3b:	50                   	push   %eax
c0003b3c:	b8 0c 00 00 00       	mov    $0xc,%eax
c0003b41:	50                   	push   %eax
c0003b42:	e8 d7 e8 ff ff       	call   c000241e <exception_handler>
c0003b47:	83 c4 0c             	add    $0xc,%esp
c0003b4a:	61                   	popa   
c0003b4b:	5d                   	pop    %ebp
c0003b4c:	83 c4 04             	add    $0x4,%esp
c0003b4f:	cf                   	iret   

c0003b50 <except_13>:
c0003b50:	55                   	push   %ebp
c0003b51:	89 e5                	mov    %esp,%ebp
c0003b53:	60                   	pusha  
c0003b54:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b57:	50                   	push   %eax
c0003b58:	8b 45 04             	mov    0x4(%ebp),%eax
c0003b5b:	50                   	push   %eax
c0003b5c:	b8 0d 00 00 00       	mov    $0xd,%eax
c0003b61:	50                   	push   %eax
c0003b62:	e8 b7 e8 ff ff       	call   c000241e <exception_handler>
c0003b67:	83 c4 0c             	add    $0xc,%esp
c0003b6a:	61                   	popa   
c0003b6b:	5d                   	pop    %ebp
c0003b6c:	83 c4 04             	add    $0x4,%esp
c0003b6f:	cf                   	iret   

c0003b70 <except_14>:
c0003b70:	55                   	push   %ebp
c0003b71:	89 e5                	mov    %esp,%ebp
c0003b73:	60                   	pusha  
c0003b74:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b77:	50                   	push   %eax
c0003b78:	8b 45 04             	mov    0x4(%ebp),%eax
c0003b7b:	50                   	push   %eax
c0003b7c:	b8 0e 00 00 00       	mov    $0xe,%eax
c0003b81:	50                   	push   %eax
c0003b82:	e8 97 e8 ff ff       	call   c000241e <exception_handler>
c0003b87:	83 c4 0c             	add    $0xc,%esp
c0003b8a:	61                   	popa   
c0003b8b:	5d                   	pop    %ebp
c0003b8c:	83 c4 04             	add    $0x4,%esp
c0003b8f:	cf                   	iret   

c0003b90 <except_16>:
c0003b90:	55                   	push   %ebp
c0003b91:	89 e5                	mov    %esp,%ebp
c0003b93:	60                   	pusha  
c0003b94:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b97:	50                   	push   %eax
c0003b98:	8b 45 04             	mov    0x4(%ebp),%eax
c0003b9b:	50                   	push   %eax
c0003b9c:	b8 10 00 00 00       	mov    $0x10,%eax
c0003ba1:	50                   	push   %eax
c0003ba2:	e8 77 e8 ff ff       	call   c000241e <exception_handler>
c0003ba7:	83 c4 0c             	add    $0xc,%esp
c0003baa:	61                   	popa   
c0003bab:	5d                   	pop    %ebp
c0003bac:	83 c4 04             	add    $0x4,%esp
c0003baf:	cf                   	iret   

c0003bb0 <except_17>:
c0003bb0:	55                   	push   %ebp
c0003bb1:	89 e5                	mov    %esp,%ebp
c0003bb3:	60                   	pusha  
c0003bb4:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bb7:	50                   	push   %eax
c0003bb8:	8b 45 04             	mov    0x4(%ebp),%eax
c0003bbb:	50                   	push   %eax
c0003bbc:	b8 11 00 00 00       	mov    $0x11,%eax
c0003bc1:	50                   	push   %eax
c0003bc2:	e8 57 e8 ff ff       	call   c000241e <exception_handler>
c0003bc7:	83 c4 0c             	add    $0xc,%esp
c0003bca:	61                   	popa   
c0003bcb:	5d                   	pop    %ebp
c0003bcc:	83 c4 04             	add    $0x4,%esp
c0003bcf:	cf                   	iret   

c0003bd0 <except_18>:
c0003bd0:	55                   	push   %ebp
c0003bd1:	89 e5                	mov    %esp,%ebp
c0003bd3:	60                   	pusha  
c0003bd4:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bd7:	50                   	push   %eax
c0003bd8:	8b 45 04             	mov    0x4(%ebp),%eax
c0003bdb:	50                   	push   %eax
c0003bdc:	b8 12 00 00 00       	mov    $0x12,%eax
c0003be1:	50                   	push   %eax
c0003be2:	e8 37 e8 ff ff       	call   c000241e <exception_handler>
c0003be7:	83 c4 0c             	add    $0xc,%esp
c0003bea:	61                   	popa   
c0003beb:	5d                   	pop    %ebp
c0003bec:	83 c4 04             	add    $0x4,%esp
c0003bef:	cf                   	iret   

c0003bf0 <except_19>:
c0003bf0:	55                   	push   %ebp
c0003bf1:	89 e5                	mov    %esp,%ebp
c0003bf3:	60                   	pusha  
c0003bf4:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bf7:	50                   	push   %eax
c0003bf8:	8b 45 04             	mov    0x4(%ebp),%eax
c0003bfb:	50                   	push   %eax
c0003bfc:	b8 13 00 00 00       	mov    $0x13,%eax
c0003c01:	50                   	push   %eax
c0003c02:	e8 17 e8 ff ff       	call   c000241e <exception_handler>
c0003c07:	83 c4 0c             	add    $0xc,%esp
c0003c0a:	61                   	popa   
c0003c0b:	5d                   	pop    %ebp
c0003c0c:	83 c4 04             	add    $0x4,%esp
c0003c0f:	cf                   	iret   

c0003c10 <except_20>:
c0003c10:	55                   	push   %ebp
c0003c11:	89 e5                	mov    %esp,%ebp
c0003c13:	60                   	pusha  
c0003c14:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c17:	50                   	push   %eax
c0003c18:	8b 45 04             	mov    0x4(%ebp),%eax
c0003c1b:	50                   	push   %eax
c0003c1c:	b8 14 00 00 00       	mov    $0x14,%eax
c0003c21:	50                   	push   %eax
c0003c22:	e8 f7 e7 ff ff       	call   c000241e <exception_handler>
c0003c27:	83 c4 0c             	add    $0xc,%esp
c0003c2a:	61                   	popa   
c0003c2b:	5d                   	pop    %ebp
c0003c2c:	83 c4 04             	add    $0x4,%esp
c0003c2f:	cf                   	iret   

c0003c30 <except_30>:
c0003c30:	55                   	push   %ebp
c0003c31:	89 e5                	mov    %esp,%ebp
c0003c33:	60                   	pusha  
c0003c34:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c37:	50                   	push   %eax
c0003c38:	8b 45 04             	mov    0x4(%ebp),%eax
c0003c3b:	50                   	push   %eax
c0003c3c:	b8 1e 00 00 00       	mov    $0x1e,%eax
c0003c41:	50                   	push   %eax
c0003c42:	e8 d7 e7 ff ff       	call   c000241e <exception_handler>
c0003c47:	83 c4 0c             	add    $0xc,%esp
c0003c4a:	61                   	popa   
c0003c4b:	5d                   	pop    %ebp
c0003c4c:	83 c4 04             	add    $0x4,%esp
c0003c4f:	cf                   	iret   

c0003c50 <irq_0>:
c0003c50:	60                   	pusha  
c0003c51:	b8 00 00 00 00       	mov    $0x0,%eax
c0003c56:	50                   	push   %eax
c0003c57:	e8 f9 e7 ff ff       	call   c0002455 <irq_handler>
c0003c5c:	83 c4 04             	add    $0x4,%esp
c0003c5f:	61                   	popa   
c0003c60:	cf                   	iret   
c0003c61:	8d 76 00             	lea    0x0(%esi),%esi

c0003c64 <irq_1>:
c0003c64:	60                   	pusha  
c0003c65:	b8 01 00 00 00       	mov    $0x1,%eax
c0003c6a:	50                   	push   %eax
c0003c6b:	e8 e5 e7 ff ff       	call   c0002455 <irq_handler>
c0003c70:	83 c4 04             	add    $0x4,%esp
c0003c73:	61                   	popa   
c0003c74:	cf                   	iret   
c0003c75:	8d 76 00             	lea    0x0(%esi),%esi

c0003c78 <irq_2>:
c0003c78:	60                   	pusha  
c0003c79:	b8 02 00 00 00       	mov    $0x2,%eax
c0003c7e:	50                   	push   %eax
c0003c7f:	e8 d1 e7 ff ff       	call   c0002455 <irq_handler>
c0003c84:	83 c4 04             	add    $0x4,%esp
c0003c87:	61                   	popa   
c0003c88:	cf                   	iret   
c0003c89:	8d 76 00             	lea    0x0(%esi),%esi

c0003c8c <irq_3>:
c0003c8c:	60                   	pusha  
c0003c8d:	b8 03 00 00 00       	mov    $0x3,%eax
c0003c92:	50                   	push   %eax
c0003c93:	e8 bd e7 ff ff       	call   c0002455 <irq_handler>
c0003c98:	83 c4 04             	add    $0x4,%esp
c0003c9b:	61                   	popa   
c0003c9c:	cf                   	iret   
c0003c9d:	8d 76 00             	lea    0x0(%esi),%esi

c0003ca0 <irq_4>:
c0003ca0:	60                   	pusha  
c0003ca1:	b8 04 00 00 00       	mov    $0x4,%eax
c0003ca6:	50                   	push   %eax
c0003ca7:	e8 a9 e7 ff ff       	call   c0002455 <irq_handler>
c0003cac:	83 c4 04             	add    $0x4,%esp
c0003caf:	61                   	popa   
c0003cb0:	cf                   	iret   
c0003cb1:	8d 76 00             	lea    0x0(%esi),%esi

c0003cb4 <irq_5>:
c0003cb4:	60                   	pusha  
c0003cb5:	b8 05 00 00 00       	mov    $0x5,%eax
c0003cba:	50                   	push   %eax
c0003cbb:	e8 95 e7 ff ff       	call   c0002455 <irq_handler>
c0003cc0:	83 c4 04             	add    $0x4,%esp
c0003cc3:	61                   	popa   
c0003cc4:	cf                   	iret   
c0003cc5:	8d 76 00             	lea    0x0(%esi),%esi

c0003cc8 <irq_6>:
c0003cc8:	60                   	pusha  
c0003cc9:	b8 06 00 00 00       	mov    $0x6,%eax
c0003cce:	50                   	push   %eax
c0003ccf:	e8 81 e7 ff ff       	call   c0002455 <irq_handler>
c0003cd4:	83 c4 04             	add    $0x4,%esp
c0003cd7:	61                   	popa   
c0003cd8:	cf                   	iret   
c0003cd9:	8d 76 00             	lea    0x0(%esi),%esi

c0003cdc <irq_7>:
c0003cdc:	60                   	pusha  
c0003cdd:	b8 07 00 00 00       	mov    $0x7,%eax
c0003ce2:	50                   	push   %eax
c0003ce3:	e8 6d e7 ff ff       	call   c0002455 <irq_handler>
c0003ce8:	83 c4 04             	add    $0x4,%esp
c0003ceb:	61                   	popa   
c0003cec:	cf                   	iret   
c0003ced:	8d 76 00             	lea    0x0(%esi),%esi

c0003cf0 <irq_8>:
c0003cf0:	60                   	pusha  
c0003cf1:	b8 08 00 00 00       	mov    $0x8,%eax
c0003cf6:	50                   	push   %eax
c0003cf7:	e8 59 e7 ff ff       	call   c0002455 <irq_handler>
c0003cfc:	83 c4 04             	add    $0x4,%esp
c0003cff:	61                   	popa   
c0003d00:	cf                   	iret   
c0003d01:	8d 76 00             	lea    0x0(%esi),%esi

c0003d04 <irq_9>:
c0003d04:	60                   	pusha  
c0003d05:	b8 09 00 00 00       	mov    $0x9,%eax
c0003d0a:	50                   	push   %eax
c0003d0b:	e8 45 e7 ff ff       	call   c0002455 <irq_handler>
c0003d10:	83 c4 04             	add    $0x4,%esp
c0003d13:	61                   	popa   
c0003d14:	cf                   	iret   
c0003d15:	8d 76 00             	lea    0x0(%esi),%esi

c0003d18 <irq_10>:
c0003d18:	60                   	pusha  
c0003d19:	b8 0a 00 00 00       	mov    $0xa,%eax
c0003d1e:	50                   	push   %eax
c0003d1f:	e8 31 e7 ff ff       	call   c0002455 <irq_handler>
c0003d24:	83 c4 04             	add    $0x4,%esp
c0003d27:	61                   	popa   
c0003d28:	cf                   	iret   
c0003d29:	8d 76 00             	lea    0x0(%esi),%esi

c0003d2c <irq_11>:
c0003d2c:	60                   	pusha  
c0003d2d:	b8 0b 00 00 00       	mov    $0xb,%eax
c0003d32:	50                   	push   %eax
c0003d33:	e8 1d e7 ff ff       	call   c0002455 <irq_handler>
c0003d38:	83 c4 04             	add    $0x4,%esp
c0003d3b:	61                   	popa   
c0003d3c:	cf                   	iret   
c0003d3d:	8d 76 00             	lea    0x0(%esi),%esi

c0003d40 <irq_12>:
c0003d40:	60                   	pusha  
c0003d41:	b8 0c 00 00 00       	mov    $0xc,%eax
c0003d46:	50                   	push   %eax
c0003d47:	e8 09 e7 ff ff       	call   c0002455 <irq_handler>
c0003d4c:	83 c4 04             	add    $0x4,%esp
c0003d4f:	61                   	popa   
c0003d50:	cf                   	iret   
c0003d51:	8d 76 00             	lea    0x0(%esi),%esi

c0003d54 <irq_13>:
c0003d54:	60                   	pusha  
c0003d55:	b8 0d 00 00 00       	mov    $0xd,%eax
c0003d5a:	50                   	push   %eax
c0003d5b:	e8 f5 e6 ff ff       	call   c0002455 <irq_handler>
c0003d60:	83 c4 04             	add    $0x4,%esp
c0003d63:	61                   	popa   
c0003d64:	cf                   	iret   
c0003d65:	8d 76 00             	lea    0x0(%esi),%esi

c0003d68 <irq_14>:
c0003d68:	60                   	pusha  
c0003d69:	b8 0e 00 00 00       	mov    $0xe,%eax
c0003d6e:	50                   	push   %eax
c0003d6f:	e8 e1 e6 ff ff       	call   c0002455 <irq_handler>
c0003d74:	83 c4 04             	add    $0x4,%esp
c0003d77:	61                   	popa   
c0003d78:	cf                   	iret   
c0003d79:	8d 76 00             	lea    0x0(%esi),%esi

c0003d7c <irq_15>:
c0003d7c:	60                   	pusha  
c0003d7d:	b8 0f 00 00 00       	mov    $0xf,%eax
c0003d82:	50                   	push   %eax
c0003d83:	e8 cd e6 ff ff       	call   c0002455 <irq_handler>
c0003d88:	83 c4 04             	add    $0x4,%esp
c0003d8b:	61                   	popa   
c0003d8c:	cf                   	iret   
c0003d8d:	66 90                	xchg   %ax,%ax
c0003d8f:	90                   	nop

c0003d90 <switch_to_task>:
c0003d90:	53                   	push   %ebx
c0003d91:	56                   	push   %esi
c0003d92:	57                   	push   %edi
c0003d93:	55                   	push   %ebp
c0003d94:	8b 3d 40 68 00 c0    	mov    0xc0006840,%edi
c0003d9a:	89 67 08             	mov    %esp,0x8(%edi)
c0003d9d:	8b 74 24 14          	mov    0x14(%esp),%esi
c0003da1:	89 35 40 68 00 c0    	mov    %esi,0xc0006840
c0003da7:	8b 66 08             	mov    0x8(%esi),%esp
c0003daa:	8b 5e 0c             	mov    0xc(%esi),%ebx
c0003dad:	8b 46 10             	mov    0x10(%esi),%eax
c0003db0:	89 1d 24 69 00 c0    	mov    %ebx,0xc0006924
c0003db6:	0f 20 d9             	mov    %cr3,%ecx
c0003db9:	39 c8                	cmp    %ecx,%eax
c0003dbb:	74 03                	je     c0003dc0 <.done>
c0003dbd:	0f 22 d8             	mov    %eax,%cr3

c0003dc0 <.done>:
c0003dc0:	5d                   	pop    %ebp
c0003dc1:	5f                   	pop    %edi
c0003dc2:	5e                   	pop    %esi
c0003dc3:	5b                   	pop    %ebx
c0003dc4:	c3                   	ret    

c0003dc5 <terminate_task>:
c0003dc5:	8d 35 60 68 00 c0    	lea    0xc0006860,%esi
c0003dcb:	89 35 40 68 00 c0    	mov    %esi,0xc0006840
c0003dd1:	8b 66 08             	mov    0x8(%esi),%esp
c0003dd4:	8b 5e 0c             	mov    0xc(%esi),%ebx
c0003dd7:	8b 46 10             	mov    0x10(%esi),%eax
c0003dda:	89 1d 24 69 00 c0    	mov    %ebx,0xc0006924
c0003de0:	0f 20 d9             	mov    %cr3,%ecx
c0003de3:	39 c8                	cmp    %ecx,%eax
c0003de5:	74 d9                	je     c0003dc0 <.done>
c0003de7:	0f 22 d8             	mov    %eax,%cr3

c0003dea <.done2>:
c0003dea:	5d                   	pop    %ebp
c0003deb:	5f                   	pop    %edi
c0003dec:	5e                   	pop    %esi
c0003ded:	5b                   	pop    %ebx
c0003dee:	c3                   	ret    
c0003def:	90                   	nop

c0003df0 <enable_paging>:
c0003df0:	55                   	push   %ebp
c0003df1:	89 e5                	mov    %esp,%ebp
c0003df3:	8b 45 08             	mov    0x8(%ebp),%eax
c0003df6:	0f 22 d8             	mov    %eax,%cr3
c0003df9:	0f 20 c0             	mov    %cr0,%eax
c0003dfc:	0d 01 00 00 80       	or     $0x80000001,%eax
c0003e01:	0f 22 c0             	mov    %eax,%cr0
c0003e04:	89 ec                	mov    %ebp,%esp
c0003e06:	5d                   	pop    %ebp
c0003e07:	c3                   	ret    

c0003e08 <set_page_dir>:
c0003e08:	8b 44 24 04          	mov    0x4(%esp),%eax
c0003e0c:	0f 22 d8             	mov    %eax,%cr3
c0003e0f:	c3                   	ret    

c0003e10 <get_page_dir>:
c0003e10:	0f 20 d8             	mov    %cr3,%eax
c0003e13:	c3                   	ret    

c0003e14 <refresh_tlb>:
c0003e14:	0f 20 d8             	mov    %cr3,%eax
c0003e17:	0f 22 d8             	mov    %eax,%cr3
c0003e1a:	c3                   	ret    
c0003e1b:	90                   	nop

c0003e1c <refresh_page>:
c0003e1c:	8b 44 24 04          	mov    0x4(%esp),%eax
c0003e20:	0f 01 38             	invlpg (%eax)
c0003e23:	c3                   	ret    
