
build/kernel:     file format elf32-i386


Disassembly of section .text.boot:

00100000 <_start-0xc>:
  100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fb                   	sti    
  100009:	4f                   	dec    %edi
  10000a:	52                   	push   %edx
  10000b:	e4                   	.byte 0xe4

0010000c <_start>:
  10000c:	fa                   	cli    
  10000d:	3d 02 b0 ad 2b       	cmp    $0x2badb002,%eax
  100012:	0f 85 c1 00 00 00    	jne    1000d9 <kpanic>
  100018:	8d 25 00 f0 10 00    	lea    0x10f000,%esp
  10001e:	53                   	push   %ebx
  10001f:	8d 3d 00 f0 10 00    	lea    0x10f000,%edi
  100025:	b8 83 00 00 00       	mov    $0x83,%eax
  10002a:	89 07                	mov    %eax,(%edi)
  10002c:	0f 20 e0             	mov    %cr4,%eax
  10002f:	83 c8 10             	or     $0x10,%eax
  100032:	0f 22 e0             	mov    %eax,%cr4
  100035:	8d 35 00 00 11 00    	lea    0x110000,%esi
  10003b:	83 ce 03             	or     $0x3,%esi
  10003e:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  100044:	c1 e8 16             	shr    $0x16,%eax
  100047:	bb 04 00 00 00       	mov    $0x4,%ebx
  10004c:	f7 e3                	mul    %ebx
  10004e:	8d 3d 00 f0 10 00    	lea    0x10f000,%edi
  100054:	01 c7                	add    %eax,%edi
  100056:	89 37                	mov    %esi,(%edi)
  100058:	8d 1d 00 00 00 c0    	lea    0xc0000000,%ebx
  10005e:	c1 eb 0c             	shr    $0xc,%ebx
  100061:	8d 0d 88 09 01 c0    	lea    0xc0010988,%ecx
  100067:	81 c1 ff 0f 00 00    	add    $0xfff,%ecx
  10006d:	c1 e9 0c             	shr    $0xc,%ecx
  100070:	29 d9                	sub    %ebx,%ecx
  100072:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  100078:	25 00 f0 3f 00       	and    $0x3ff000,%eax
  10007d:	c1 e8 0c             	shr    $0xc,%eax
  100080:	bb 04 00 00 00       	mov    $0x4,%ebx
  100085:	f7 e3                	mul    %ebx
  100087:	8d 3d 00 00 11 00    	lea    0x110000,%edi
  10008d:	01 c7                	add    %eax,%edi
  10008f:	8d 05 00 10 10 00    	lea    0x101000,%eax
  100095:	83 c8 03             	or     $0x3,%eax
  100098:	fc                   	cld    

00100099 <.nextpte>:
  100099:	ab                   	stos   %eax,%es:(%edi)
  10009a:	05 00 10 00 00       	add    $0x1000,%eax
  10009f:	e2 f8                	loop   100099 <.nextpte>
  1000a1:	8d 35 00 f0 10 00    	lea    0x10f000,%esi
  1000a7:	89 f7                	mov    %esi,%edi
  1000a9:	81 c7 fc 0f 00 00    	add    $0xffc,%edi
  1000af:	83 ce 03             	or     $0x3,%esi
  1000b2:	89 37                	mov    %esi,(%edi)
  1000b4:	5b                   	pop    %ebx

001000b5 <_enable_paging>:
  1000b5:	8d 05 00 f0 10 00    	lea    0x10f000,%eax
  1000bb:	0f 22 d8             	mov    %eax,%cr3
  1000be:	0f 20 c0             	mov    %cr0,%eax
  1000c1:	0d 00 00 01 80       	or     $0x80010000,%eax
  1000c6:	0f 22 c0             	mov    %eax,%cr0
  1000c9:	8d 25 00 e0 00 c0    	lea    0xc000e000,%esp
  1000cf:	50                   	push   %eax
  1000d0:	50                   	push   %eax
  1000d1:	50                   	push   %eax
  1000d2:	53                   	push   %ebx
  1000d3:	e8 2f 33 f0 bf       	call   c0003407 <kernel_main>
  1000d8:	fa                   	cli    

001000d9 <kpanic>:
  1000d9:	f4                   	hlt    
  1000da:	eb fd                	jmp    1000d9 <kpanic>

Disassembly of section .text:

c0000000 <test_kmalloc>:
#include "test.h"
#include "kmalloc.h"
#include "kprintf.h"

int test_kmalloc()
{
c0000000:	55                   	push   %ebp
c0000001:	89 e5                	mov    %esp,%ebp
c0000003:	83 ec 38             	sub    $0x38,%esp
    uint32_t* a = kmalloc(sizeof(uint32_t));
c0000006:	83 ec 0c             	sub    $0xc,%esp
c0000009:	6a 04                	push   $0x4
c000000b:	e8 f8 30 00 00       	call   c0003108 <kmalloc>
c0000010:	83 c4 10             	add    $0x10,%esp
c0000013:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(!a) return -1;
c0000016:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c000001a:	75 0a                	jne    c0000026 <test_kmalloc+0x26>
c000001c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000021:	e9 b2 01 00 00       	jmp    c00001d8 <test_kmalloc+0x1d8>
    *a = 5;
c0000026:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000029:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    if(*a != 5) return -1;
c000002f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000032:	8b 00                	mov    (%eax),%eax
c0000034:	83 f8 05             	cmp    $0x5,%eax
c0000037:	74 0a                	je     c0000043 <test_kmalloc+0x43>
c0000039:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000003e:	e9 95 01 00 00       	jmp    c00001d8 <test_kmalloc+0x1d8>

    int NB = 10000;
c0000043:	c7 45 e4 10 27 00 00 	movl   $0x2710,-0x1c(%ebp)
    uint32_t* b = kmalloc(sizeof(uint32_t)*NB);
c000004a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000004d:	c1 e0 02             	shl    $0x2,%eax
c0000050:	83 ec 0c             	sub    $0xc,%esp
c0000053:	50                   	push   %eax
c0000054:	e8 af 30 00 00       	call   c0003108 <kmalloc>
c0000059:	83 c4 10             	add    $0x10,%esp
c000005c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!b) return -1;
c000005f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000063:	75 0a                	jne    c000006f <test_kmalloc+0x6f>
c0000065:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000006a:	e9 69 01 00 00       	jmp    c00001d8 <test_kmalloc+0x1d8>
    for(int nn=0; nn<NB; nn++)
c000006f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0000076:	eb 18                	jmp    c0000090 <test_kmalloc+0x90>
        b[nn] = (uint32_t) nn;
c0000078:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000007b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0000082:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0000085:	01 c2                	add    %eax,%edx
c0000087:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000008a:	89 02                	mov    %eax,(%edx)
    for(int nn=0; nn<NB; nn++)
c000008c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0000090:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000093:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0000096:	7c e0                	jl     c0000078 <test_kmalloc+0x78>
    for(int nn=0; nn<NB; nn++)
c0000098:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c000009f:	eb 26                	jmp    c00000c7 <test_kmalloc+0xc7>
        if(b[nn] != (uint32_t) nn) return -1;
c00000a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00000a4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c00000ab:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00000ae:	01 d0                	add    %edx,%eax
c00000b0:	8b 10                	mov    (%eax),%edx
c00000b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00000b5:	39 c2                	cmp    %eax,%edx
c00000b7:	74 0a                	je     c00000c3 <test_kmalloc+0xc3>
c00000b9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00000be:	e9 15 01 00 00       	jmp    c00001d8 <test_kmalloc+0x1d8>
    for(int nn=0; nn<NB; nn++)
c00000c3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c00000c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00000ca:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c00000cd:	7c d2                	jl     c00000a1 <test_kmalloc+0xa1>

    uint32_t* c = kmalloc_aligned(sizeof(uint32_t), 4096); // align to page
c00000cf:	83 ec 08             	sub    $0x8,%esp
c00000d2:	68 00 10 00 00       	push   $0x1000
c00000d7:	6a 04                	push   $0x4
c00000d9:	e8 e7 30 00 00       	call   c00031c5 <kmalloc_aligned>
c00000de:	83 c4 10             	add    $0x10,%esp
c00000e1:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(!c) return -1;
c00000e4:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c00000e8:	75 0a                	jne    c00000f4 <test_kmalloc+0xf4>
c00000ea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00000ef:	e9 e4 00 00 00       	jmp    c00001d8 <test_kmalloc+0x1d8>
    if( (size_t) c % 4096 ) return -1;
c00000f4:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00000f7:	25 ff 0f 00 00       	and    $0xfff,%eax
c00000fc:	85 c0                	test   %eax,%eax
c00000fe:	74 0a                	je     c000010a <test_kmalloc+0x10a>
c0000100:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000105:	e9 ce 00 00 00       	jmp    c00001d8 <test_kmalloc+0x1d8>

    if( kfree(a) ) return -1;
c000010a:	83 ec 0c             	sub    $0xc,%esp
c000010d:	ff 75 e8             	pushl  -0x18(%ebp)
c0000110:	e8 09 32 00 00       	call   c000331e <kfree>
c0000115:	83 c4 10             	add    $0x10,%esp
c0000118:	85 c0                	test   %eax,%eax
c000011a:	74 0a                	je     c0000126 <test_kmalloc+0x126>
c000011c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000121:	e9 b2 00 00 00       	jmp    c00001d8 <test_kmalloc+0x1d8>
    if( kfree(b) ) return -1;
c0000126:	83 ec 0c             	sub    $0xc,%esp
c0000129:	ff 75 e0             	pushl  -0x20(%ebp)
c000012c:	e8 ed 31 00 00       	call   c000331e <kfree>
c0000131:	83 c4 10             	add    $0x10,%esp
c0000134:	85 c0                	test   %eax,%eax
c0000136:	74 0a                	je     c0000142 <test_kmalloc+0x142>
c0000138:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000013d:	e9 96 00 00 00       	jmp    c00001d8 <test_kmalloc+0x1d8>

    int ND = 100;
c0000142:	c7 45 d8 64 00 00 00 	movl   $0x64,-0x28(%ebp)
    uint32_t* d;
    for(int nn=0; nn<100; nn++)
c0000149:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0000150:	eb 62                	jmp    c00001b4 <test_kmalloc+0x1b4>
    {
        d = kmalloc(sizeof(uint32_t)*ND);
c0000152:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0000155:	c1 e0 02             	shl    $0x2,%eax
c0000158:	83 ec 0c             	sub    $0xc,%esp
c000015b:	50                   	push   %eax
c000015c:	e8 a7 2f 00 00       	call   c0003108 <kmalloc>
c0000161:	83 c4 10             	add    $0x10,%esp
c0000164:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        if(!d) return -1;
c0000167:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c000016b:	75 07                	jne    c0000174 <test_kmalloc+0x174>
c000016d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000172:	eb 64                	jmp    c00001d8 <test_kmalloc+0x1d8>
        d[0] = 1;
c0000174:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0000177:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        d[ND-1] = 1;
c000017d:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0000180:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
c0000185:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000018c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000018f:	01 d0                	add    %edx,%eax
c0000191:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        if( kfree(d) ) return -1;
c0000197:	83 ec 0c             	sub    $0xc,%esp
c000019a:	ff 75 d4             	pushl  -0x2c(%ebp)
c000019d:	e8 7c 31 00 00       	call   c000331e <kfree>
c00001a2:	83 c4 10             	add    $0x10,%esp
c00001a5:	85 c0                	test   %eax,%eax
c00001a7:	74 07                	je     c00001b0 <test_kmalloc+0x1b0>
c00001a9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00001ae:	eb 28                	jmp    c00001d8 <test_kmalloc+0x1d8>
    for(int nn=0; nn<100; nn++)
c00001b0:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c00001b4:	83 7d ec 63          	cmpl   $0x63,-0x14(%ebp)
c00001b8:	7e 98                	jle    c0000152 <test_kmalloc+0x152>
    }

    if( kfree(c) ) return -1;
c00001ba:	83 ec 0c             	sub    $0xc,%esp
c00001bd:	ff 75 dc             	pushl  -0x24(%ebp)
c00001c0:	e8 59 31 00 00       	call   c000331e <kfree>
c00001c5:	83 c4 10             	add    $0x10,%esp
c00001c8:	85 c0                	test   %eax,%eax
c00001ca:	74 07                	je     c00001d3 <test_kmalloc+0x1d3>
c00001cc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00001d1:	eb 05                	jmp    c00001d8 <test_kmalloc+0x1d8>

    return 0;
c00001d3:	b8 00 00 00 00       	mov    $0x0,%eax
c00001d8:	c9                   	leave  
c00001d9:	c3                   	ret    

c00001da <syscall>:
#include "terminal.h"
#include "kprintf.h"

void syscall()
{
c00001da:	55                   	push   %ebp
c00001db:	89 e5                	mov    %esp,%ebp
}
c00001dd:	90                   	nop
c00001de:	5d                   	pop    %ebp
c00001df:	c3                   	ret    

c00001e0 <vga_entry_color>:
	VGA_COLOR_LIGHT_BROWN = 14,
	VGA_COLOR_WHITE = 15,
};
 
static inline uint8_t vga_entry_color(enum vga_color fg, enum vga_color bg) 
{
c00001e0:	55                   	push   %ebp
c00001e1:	89 e5                	mov    %esp,%ebp
	return fg | bg << 4;
c00001e3:	8b 45 0c             	mov    0xc(%ebp),%eax
c00001e6:	c1 e0 04             	shl    $0x4,%eax
c00001e9:	89 c2                	mov    %eax,%edx
c00001eb:	8b 45 08             	mov    0x8(%ebp),%eax
c00001ee:	09 d0                	or     %edx,%eax
}
c00001f0:	5d                   	pop    %ebp
c00001f1:	c3                   	ret    

c00001f2 <vga_entry>:
 
static inline uint16_t vga_entry(unsigned char uc, uint8_t color) 
{
c00001f2:	55                   	push   %ebp
c00001f3:	89 e5                	mov    %esp,%ebp
c00001f5:	83 ec 08             	sub    $0x8,%esp
c00001f8:	8b 55 08             	mov    0x8(%ebp),%edx
c00001fb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00001fe:	88 55 fc             	mov    %dl,-0x4(%ebp)
c0000201:	88 45 f8             	mov    %al,-0x8(%ebp)
	return (uint16_t) uc | (uint16_t) color << 8;
c0000204:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c0000208:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c000020c:	c1 e0 08             	shl    $0x8,%eax
c000020f:	09 d0                	or     %edx,%eax
}
c0000211:	c9                   	leave  
c0000212:	c3                   	ret    

c0000213 <outb>:
  return _v;
}

static inline void
outb (unsigned char __value, unsigned short int __port)
{
c0000213:	55                   	push   %ebp
c0000214:	89 e5                	mov    %esp,%ebp
c0000216:	83 ec 08             	sub    $0x8,%esp
c0000219:	8b 55 08             	mov    0x8(%ebp),%edx
c000021c:	8b 45 0c             	mov    0xc(%ebp),%eax
c000021f:	88 55 fc             	mov    %dl,-0x4(%ebp)
c0000222:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
c0000226:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c000022a:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
c000022e:	ee                   	out    %al,(%dx)
}
c000022f:	90                   	nop
c0000230:	c9                   	leave  
c0000231:	c3                   	ret    

c0000232 <terminal_init>:
#include "io.h"

struct terminal stdout;

void terminal_init(struct terminal* term) 
{
c0000232:	55                   	push   %ebp
c0000233:	89 e5                	mov    %esp,%ebp
c0000235:	53                   	push   %ebx
c0000236:	83 ec 10             	sub    $0x10,%esp
	term->row = 0;
c0000239:	8b 45 08             	mov    0x8(%ebp),%eax
c000023c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	term->column = 0;
c0000242:	8b 45 08             	mov    0x8(%ebp),%eax
c0000245:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	term->color = vga_entry_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
c000024c:	6a 00                	push   $0x0
c000024e:	6a 07                	push   $0x7
c0000250:	e8 8b ff ff ff       	call   c00001e0 <vga_entry_color>
c0000255:	83 c4 08             	add    $0x8,%esp
c0000258:	8b 55 08             	mov    0x8(%ebp),%edx
c000025b:	88 42 08             	mov    %al,0x8(%edx)
	term->buffer = (uint16_t*) VGA_BUFFER;
c000025e:	8b 45 08             	mov    0x8(%ebp),%eax
c0000261:	c7 40 0c 00 80 0b 00 	movl   $0xb8000,0xc(%eax)
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
c0000268:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c000026f:	eb 54                	jmp    c00002c5 <terminal_init+0x93>
		for (size_t x = 0; x < VGA_WIDTH; x++) {
c0000271:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0000278:	eb 41                	jmp    c00002bb <terminal_init+0x89>
			const size_t index = y * VGA_WIDTH + x;
c000027a:	8b 55 f8             	mov    -0x8(%ebp),%edx
c000027d:	89 d0                	mov    %edx,%eax
c000027f:	c1 e0 02             	shl    $0x2,%eax
c0000282:	01 d0                	add    %edx,%eax
c0000284:	c1 e0 04             	shl    $0x4,%eax
c0000287:	89 c2                	mov    %eax,%edx
c0000289:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000028c:	01 d0                	add    %edx,%eax
c000028e:	89 45 f0             	mov    %eax,-0x10(%ebp)
			term->buffer[index] = vga_entry(' ', term->color);
c0000291:	8b 45 08             	mov    0x8(%ebp),%eax
c0000294:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c0000298:	0f b6 c0             	movzbl %al,%eax
c000029b:	8b 55 08             	mov    0x8(%ebp),%edx
c000029e:	8b 4a 0c             	mov    0xc(%edx),%ecx
c00002a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00002a4:	01 d2                	add    %edx,%edx
c00002a6:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
c00002a9:	50                   	push   %eax
c00002aa:	6a 20                	push   $0x20
c00002ac:	e8 41 ff ff ff       	call   c00001f2 <vga_entry>
c00002b1:	83 c4 08             	add    $0x8,%esp
c00002b4:	66 89 03             	mov    %ax,(%ebx)
		for (size_t x = 0; x < VGA_WIDTH; x++) {
c00002b7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00002bb:	83 7d f4 4f          	cmpl   $0x4f,-0xc(%ebp)
c00002bf:	76 b9                	jbe    c000027a <terminal_init+0x48>
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
c00002c1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c00002c5:	83 7d f8 18          	cmpl   $0x18,-0x8(%ebp)
c00002c9:	76 a6                	jbe    c0000271 <terminal_init+0x3f>
		}
	}

	//disable cursor
	outb(0x0A, 0x3D4);
c00002cb:	68 d4 03 00 00       	push   $0x3d4
c00002d0:	6a 0a                	push   $0xa
c00002d2:	e8 3c ff ff ff       	call   c0000213 <outb>
c00002d7:	83 c4 08             	add    $0x8,%esp
	outb(0x20, 0x3D5);
c00002da:	68 d5 03 00 00       	push   $0x3d5
c00002df:	6a 20                	push   $0x20
c00002e1:	e8 2d ff ff ff       	call   c0000213 <outb>
c00002e6:	83 c4 08             	add    $0x8,%esp
	// outb(0x0A, 0x3D4);
	// outb((inb(0x3D5) & 0xC0) | cursor_start, 0x3D5);
 
	// outb(0x0B, 0x3D4);
	// outb((inb(0x3D5) & 0xE0) | cursor_end, 0x3D5);
}
c00002e9:	90                   	nop
c00002ea:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00002ed:	c9                   	leave  
c00002ee:	c3                   	ret    

c00002ef <terminal_setcolor>:
 
void terminal_setcolor(struct terminal* term, uint8_t color) 
{
c00002ef:	55                   	push   %ebp
c00002f0:	89 e5                	mov    %esp,%ebp
c00002f2:	83 ec 04             	sub    $0x4,%esp
c00002f5:	8b 45 0c             	mov    0xc(%ebp),%eax
c00002f8:	88 45 fc             	mov    %al,-0x4(%ebp)
	term->color = color;
c00002fb:	8b 45 08             	mov    0x8(%ebp),%eax
c00002fe:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c0000302:	88 50 08             	mov    %dl,0x8(%eax)
}
c0000305:	90                   	nop
c0000306:	c9                   	leave  
c0000307:	c3                   	ret    

c0000308 <terminal_putentryat>:
 
void terminal_putentryat(struct terminal* term, char c, uint8_t color, size_t x, size_t y) 
{
c0000308:	55                   	push   %ebp
c0000309:	89 e5                	mov    %esp,%ebp
c000030b:	53                   	push   %ebx
c000030c:	83 ec 18             	sub    $0x18,%esp
c000030f:	8b 55 0c             	mov    0xc(%ebp),%edx
c0000312:	8b 45 10             	mov    0x10(%ebp),%eax
c0000315:	88 55 e8             	mov    %dl,-0x18(%ebp)
c0000318:	88 45 e4             	mov    %al,-0x1c(%ebp)
	const size_t index = y * VGA_WIDTH + x;
c000031b:	8b 55 18             	mov    0x18(%ebp),%edx
c000031e:	89 d0                	mov    %edx,%eax
c0000320:	c1 e0 02             	shl    $0x2,%eax
c0000323:	01 d0                	add    %edx,%eax
c0000325:	c1 e0 04             	shl    $0x4,%eax
c0000328:	89 c2                	mov    %eax,%edx
c000032a:	8b 45 14             	mov    0x14(%ebp),%eax
c000032d:	01 d0                	add    %edx,%eax
c000032f:	89 45 f8             	mov    %eax,-0x8(%ebp)
	term->buffer[index] = vga_entry(c, color);
c0000332:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c0000336:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c000033a:	0f b6 c0             	movzbl %al,%eax
c000033d:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0000340:	8b 59 0c             	mov    0xc(%ecx),%ebx
c0000343:	8b 4d f8             	mov    -0x8(%ebp),%ecx
c0000346:	01 c9                	add    %ecx,%ecx
c0000348:	01 cb                	add    %ecx,%ebx
c000034a:	52                   	push   %edx
c000034b:	50                   	push   %eax
c000034c:	e8 a1 fe ff ff       	call   c00001f2 <vga_entry>
c0000351:	83 c4 08             	add    $0x8,%esp
c0000354:	66 89 03             	mov    %ax,(%ebx)
	// terminal_movecursor(term, x, y);
}
c0000357:	90                   	nop
c0000358:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000035b:	c9                   	leave  
c000035c:	c3                   	ret    

c000035d <terminal_movecursor>:

void terminal_movecursor(struct terminal* term, size_t x, size_t y)
{
c000035d:	55                   	push   %ebp
c000035e:	89 e5                	mov    %esp,%ebp
c0000360:	83 ec 10             	sub    $0x10,%esp
	(void) term; //we are directly manipulating curser, so were arean't using the term struct

	uint16_t pos = y * VGA_WIDTH + x;
c0000363:	8b 45 10             	mov    0x10(%ebp),%eax
c0000366:	89 c2                	mov    %eax,%edx
c0000368:	89 d0                	mov    %edx,%eax
c000036a:	c1 e0 02             	shl    $0x2,%eax
c000036d:	01 d0                	add    %edx,%eax
c000036f:	c1 e0 04             	shl    $0x4,%eax
c0000372:	89 c2                	mov    %eax,%edx
c0000374:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000377:	01 d0                	add    %edx,%eax
c0000379:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

	outb(0x0F, 0x3D4);
c000037d:	68 d4 03 00 00       	push   $0x3d4
c0000382:	6a 0f                	push   $0xf
c0000384:	e8 8a fe ff ff       	call   c0000213 <outb>
c0000389:	83 c4 08             	add    $0x8,%esp
	outb((uint8_t) (pos & 0xFF), 0x3D5);
c000038c:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c0000390:	0f b6 c0             	movzbl %al,%eax
c0000393:	68 d5 03 00 00       	push   $0x3d5
c0000398:	50                   	push   %eax
c0000399:	e8 75 fe ff ff       	call   c0000213 <outb>
c000039e:	83 c4 08             	add    $0x8,%esp
	outb(0x0E, 0x3D4);
c00003a1:	68 d4 03 00 00       	push   $0x3d4
c00003a6:	6a 0e                	push   $0xe
c00003a8:	e8 66 fe ff ff       	call   c0000213 <outb>
c00003ad:	83 c4 08             	add    $0x8,%esp
	outb((uint8_t) ((pos >> 8) & 0xFF), 0x3D5);
c00003b0:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c00003b4:	66 c1 e8 08          	shr    $0x8,%ax
c00003b8:	0f b6 c0             	movzbl %al,%eax
c00003bb:	68 d5 03 00 00       	push   $0x3d5
c00003c0:	50                   	push   %eax
c00003c1:	e8 4d fe ff ff       	call   c0000213 <outb>
c00003c6:	83 c4 08             	add    $0x8,%esp
}
c00003c9:	90                   	nop
c00003ca:	c9                   	leave  
c00003cb:	c3                   	ret    

c00003cc <terminal_putchar>:

 
void terminal_putchar(struct terminal* term, char c) 
{
c00003cc:	55                   	push   %ebp
c00003cd:	89 e5                	mov    %esp,%ebp
c00003cf:	53                   	push   %ebx
c00003d0:	83 ec 14             	sub    $0x14,%esp
c00003d3:	8b 45 0c             	mov    0xc(%ebp),%eax
c00003d6:	88 45 f4             	mov    %al,-0xc(%ebp)
	if(c == '\n')
c00003d9:	80 7d f4 0a          	cmpb   $0xa,-0xc(%ebp)
c00003dd:	75 10                	jne    c00003ef <terminal_putchar+0x23>
	{
		terminal_newline(term);
c00003df:	83 ec 0c             	sub    $0xc,%esp
c00003e2:	ff 75 08             	pushl  0x8(%ebp)
c00003e5:	e8 95 00 00 00       	call   c000047f <terminal_newline>
c00003ea:	83 c4 10             	add    $0x10,%esp
		return;
c00003ed:	eb 53                	jmp    c0000442 <terminal_putchar+0x76>
	}

	terminal_putentryat(term, c, term->color, term->column, term->row);
c00003ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00003f2:	8b 18                	mov    (%eax),%ebx
c00003f4:	8b 45 08             	mov    0x8(%ebp),%eax
c00003f7:	8b 48 04             	mov    0x4(%eax),%ecx
c00003fa:	8b 45 08             	mov    0x8(%ebp),%eax
c00003fd:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c0000401:	0f b6 d0             	movzbl %al,%edx
c0000404:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c0000408:	83 ec 0c             	sub    $0xc,%esp
c000040b:	53                   	push   %ebx
c000040c:	51                   	push   %ecx
c000040d:	52                   	push   %edx
c000040e:	50                   	push   %eax
c000040f:	ff 75 08             	pushl  0x8(%ebp)
c0000412:	e8 f1 fe ff ff       	call   c0000308 <terminal_putentryat>
c0000417:	83 c4 20             	add    $0x20,%esp
	if (++term->column == VGA_WIDTH)
c000041a:	8b 45 08             	mov    0x8(%ebp),%eax
c000041d:	8b 40 04             	mov    0x4(%eax),%eax
c0000420:	8d 50 01             	lea    0x1(%eax),%edx
c0000423:	8b 45 08             	mov    0x8(%ebp),%eax
c0000426:	89 50 04             	mov    %edx,0x4(%eax)
c0000429:	8b 45 08             	mov    0x8(%ebp),%eax
c000042c:	8b 40 04             	mov    0x4(%eax),%eax
c000042f:	83 f8 50             	cmp    $0x50,%eax
c0000432:	75 0e                	jne    c0000442 <terminal_putchar+0x76>
		terminal_newline(term);
c0000434:	83 ec 0c             	sub    $0xc,%esp
c0000437:	ff 75 08             	pushl  0x8(%ebp)
c000043a:	e8 40 00 00 00       	call   c000047f <terminal_newline>
c000043f:	83 c4 10             	add    $0x10,%esp
}
c0000442:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0000445:	c9                   	leave  
c0000446:	c3                   	ret    

c0000447 <terminal_putcharn>:

void terminal_putcharn(struct terminal* term, char c, size_t repeat) 
{
c0000447:	55                   	push   %ebp
c0000448:	89 e5                	mov    %esp,%ebp
c000044a:	83 ec 28             	sub    $0x28,%esp
c000044d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000450:	88 45 e4             	mov    %al,-0x1c(%ebp)
	for (size_t i = 0; i < repeat; i++)
c0000453:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000045a:	eb 17                	jmp    c0000473 <terminal_putcharn+0x2c>
		terminal_putchar(term, c);
c000045c:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
c0000460:	83 ec 08             	sub    $0x8,%esp
c0000463:	50                   	push   %eax
c0000464:	ff 75 08             	pushl  0x8(%ebp)
c0000467:	e8 60 ff ff ff       	call   c00003cc <terminal_putchar>
c000046c:	83 c4 10             	add    $0x10,%esp
	for (size_t i = 0; i < repeat; i++)
c000046f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0000473:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000476:	3b 45 10             	cmp    0x10(%ebp),%eax
c0000479:	72 e1                	jb     c000045c <terminal_putcharn+0x15>
}
c000047b:	90                   	nop
c000047c:	90                   	nop
c000047d:	c9                   	leave  
c000047e:	c3                   	ret    

c000047f <terminal_newline>:

void terminal_newline(struct terminal* term)
{
c000047f:	55                   	push   %ebp
c0000480:	89 e5                	mov    %esp,%ebp
c0000482:	83 ec 08             	sub    $0x8,%esp
    term->column = 0;
c0000485:	8b 45 08             	mov    0x8(%ebp),%eax
c0000488:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if (++term->row == VGA_HEIGHT)
c000048f:	8b 45 08             	mov    0x8(%ebp),%eax
c0000492:	8b 00                	mov    (%eax),%eax
c0000494:	8d 50 01             	lea    0x1(%eax),%edx
c0000497:	8b 45 08             	mov    0x8(%ebp),%eax
c000049a:	89 10                	mov    %edx,(%eax)
c000049c:	8b 45 08             	mov    0x8(%ebp),%eax
c000049f:	8b 00                	mov    (%eax),%eax
c00004a1:	83 f8 19             	cmp    $0x19,%eax
c00004a4:	75 0e                	jne    c00004b4 <terminal_newline+0x35>
        terminal_scrollline(term);
c00004a6:	83 ec 0c             	sub    $0xc,%esp
c00004a9:	ff 75 08             	pushl  0x8(%ebp)
c00004ac:	e8 06 00 00 00       	call   c00004b7 <terminal_scrollline>
c00004b1:	83 c4 10             	add    $0x10,%esp
}
c00004b4:	90                   	nop
c00004b5:	c9                   	leave  
c00004b6:	c3                   	ret    

c00004b7 <terminal_scrollline>:

void terminal_scrollline(struct terminal* term)
{
c00004b7:	55                   	push   %ebp
c00004b8:	89 e5                	mov    %esp,%ebp
c00004ba:	83 ec 08             	sub    $0x8,%esp
	// copy rows 2 though N to rows 1 through N-1
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c00004bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00004c0:	8b 40 0c             	mov    0xc(%eax),%eax
c00004c3:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c00004c9:	8b 45 08             	mov    0x8(%ebp),%eax
c00004cc:	8b 40 0c             	mov    0xc(%eax),%eax
c00004cf:	83 ec 04             	sub    $0x4,%esp
c00004d2:	68 00 0f 00 00       	push   $0xf00
c00004d7:	52                   	push   %edx
c00004d8:	50                   	push   %eax
c00004d9:	e8 d5 0f 00 00       	call   c00014b3 <memcpy>
c00004de:	83 c4 10             	add    $0x10,%esp
	// clear last row
	term->row = VGA_HEIGHT-1;
c00004e1:	8b 45 08             	mov    0x8(%ebp),%eax
c00004e4:	c7 00 18 00 00 00    	movl   $0x18,(%eax)
	terminal_clearline(term);
c00004ea:	83 ec 0c             	sub    $0xc,%esp
c00004ed:	ff 75 08             	pushl  0x8(%ebp)
c00004f0:	e8 06 00 00 00       	call   c00004fb <terminal_clearline>
c00004f5:	83 c4 10             	add    $0x10,%esp
}
c00004f8:	90                   	nop
c00004f9:	c9                   	leave  
c00004fa:	c3                   	ret    

c00004fb <terminal_clearline>:

void terminal_clearline(struct terminal* term)
{
c00004fb:	55                   	push   %ebp
c00004fc:	89 e5                	mov    %esp,%ebp
c00004fe:	53                   	push   %ebx
c00004ff:	83 ec 10             	sub    $0x10,%esp
	size_t row_start = term->row * VGA_WIDTH;
c0000502:	8b 45 08             	mov    0x8(%ebp),%eax
c0000505:	8b 10                	mov    (%eax),%edx
c0000507:	89 d0                	mov    %edx,%eax
c0000509:	c1 e0 02             	shl    $0x2,%eax
c000050c:	01 d0                	add    %edx,%eax
c000050e:	c1 e0 04             	shl    $0x4,%eax
c0000511:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c0000514:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c000051b:	eb 2f                	jmp    c000054c <terminal_clearline+0x51>
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c000051d:	8b 45 08             	mov    0x8(%ebp),%eax
c0000520:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c0000524:	0f b6 c0             	movzbl %al,%eax
c0000527:	8b 55 08             	mov    0x8(%ebp),%edx
c000052a:	8b 4a 0c             	mov    0xc(%edx),%ecx
c000052d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c0000530:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0000533:	01 da                	add    %ebx,%edx
c0000535:	01 d2                	add    %edx,%edx
c0000537:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
c000053a:	50                   	push   %eax
c000053b:	6a 20                	push   $0x20
c000053d:	e8 b0 fc ff ff       	call   c00001f2 <vga_entry>
c0000542:	83 c4 08             	add    $0x8,%esp
c0000545:	66 89 03             	mov    %ax,(%ebx)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c0000548:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c000054c:	83 7d f8 4f          	cmpl   $0x4f,-0x8(%ebp)
c0000550:	76 cb                	jbe    c000051d <terminal_clearline+0x22>

}
c0000552:	90                   	nop
c0000553:	90                   	nop
c0000554:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0000557:	c9                   	leave  
c0000558:	c3                   	ret    

c0000559 <terminal_write>:


void terminal_write(struct terminal* term, const char* data, size_t size) 
{
c0000559:	55                   	push   %ebp
c000055a:	89 e5                	mov    %esp,%ebp
c000055c:	83 ec 18             	sub    $0x18,%esp
	for (size_t i = 0; i < size; i++)
c000055f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0000566:	eb 21                	jmp    c0000589 <terminal_write+0x30>
		terminal_putchar(term, data[i]);
c0000568:	8b 55 0c             	mov    0xc(%ebp),%edx
c000056b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000056e:	01 d0                	add    %edx,%eax
c0000570:	0f b6 00             	movzbl (%eax),%eax
c0000573:	0f be c0             	movsbl %al,%eax
c0000576:	83 ec 08             	sub    $0x8,%esp
c0000579:	50                   	push   %eax
c000057a:	ff 75 08             	pushl  0x8(%ebp)
c000057d:	e8 4a fe ff ff       	call   c00003cc <terminal_putchar>
c0000582:	83 c4 10             	add    $0x10,%esp
	for (size_t i = 0; i < size; i++)
c0000585:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0000589:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000058c:	3b 45 10             	cmp    0x10(%ebp),%eax
c000058f:	72 d7                	jb     c0000568 <terminal_write+0xf>
}
c0000591:	90                   	nop
c0000592:	90                   	nop
c0000593:	c9                   	leave  
c0000594:	c3                   	ret    

c0000595 <terminal_writestring>:
 
void terminal_writestring(struct terminal* term, const char* data) 
{
c0000595:	55                   	push   %ebp
c0000596:	89 e5                	mov    %esp,%ebp
c0000598:	83 ec 08             	sub    $0x8,%esp
	terminal_write(term, data, strlen(data));
c000059b:	83 ec 0c             	sub    $0xc,%esp
c000059e:	ff 75 0c             	pushl  0xc(%ebp)
c00005a1:	e8 e6 0e 00 00       	call   c000148c <strlen>
c00005a6:	83 c4 10             	add    $0x10,%esp
c00005a9:	83 ec 04             	sub    $0x4,%esp
c00005ac:	50                   	push   %eax
c00005ad:	ff 75 0c             	pushl  0xc(%ebp)
c00005b0:	ff 75 08             	pushl  0x8(%ebp)
c00005b3:	e8 a1 ff ff ff       	call   c0000559 <terminal_write>
c00005b8:	83 c4 10             	add    $0x10,%esp
}
c00005bb:	90                   	nop
c00005bc:	c9                   	leave  
c00005bd:	c3                   	ret    

c00005be <kprint>:
unsigned int numdigits_uint(unsigned int value, unsigned int base);

int format_uint(unsigned int value, char* str, unsigned int base, int precision, int cap);

int kprint(const char* str)
{
c00005be:	55                   	push   %ebp
c00005bf:	89 e5                	mov    %esp,%ebp
c00005c1:	83 ec 08             	sub    $0x8,%esp
    terminal_writestring(&stdout, str);
c00005c4:	83 ec 08             	sub    $0x8,%esp
c00005c7:	ff 75 08             	pushl  0x8(%ebp)
c00005ca:	68 00 00 01 c0       	push   $0xc0010000
c00005cf:	e8 c1 ff ff ff       	call   c0000595 <terminal_writestring>
c00005d4:	83 c4 10             	add    $0x10,%esp
    return strlen(str);
c00005d7:	83 ec 0c             	sub    $0xc,%esp
c00005da:	ff 75 08             	pushl  0x8(%ebp)
c00005dd:	e8 aa 0e 00 00       	call   c000148c <strlen>
c00005e2:	83 c4 10             	add    $0x10,%esp
}
c00005e5:	c9                   	leave  
c00005e6:	c3                   	ret    

c00005e7 <kprintn>:

int kprintn(const char* str, size_t len)
{
c00005e7:	55                   	push   %ebp
c00005e8:	89 e5                	mov    %esp,%ebp
c00005ea:	83 ec 08             	sub    $0x8,%esp
    terminal_write(&stdout, str, len);
c00005ed:	83 ec 04             	sub    $0x4,%esp
c00005f0:	ff 75 0c             	pushl  0xc(%ebp)
c00005f3:	ff 75 08             	pushl  0x8(%ebp)
c00005f6:	68 00 00 01 c0       	push   $0xc0010000
c00005fb:	e8 59 ff ff ff       	call   c0000559 <terminal_write>
c0000600:	83 c4 10             	add    $0x10,%esp
    return len;
c0000603:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c0000606:	c9                   	leave  
c0000607:	c3                   	ret    

c0000608 <kprint_char>:

int kprint_char(char c)
{
c0000608:	55                   	push   %ebp
c0000609:	89 e5                	mov    %esp,%ebp
c000060b:	83 ec 18             	sub    $0x18,%esp
c000060e:	8b 45 08             	mov    0x8(%ebp),%eax
c0000611:	88 45 f4             	mov    %al,-0xc(%ebp)
    terminal_putchar(&stdout, c); 
c0000614:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c0000618:	83 ec 08             	sub    $0x8,%esp
c000061b:	50                   	push   %eax
c000061c:	68 00 00 01 c0       	push   $0xc0010000
c0000621:	e8 a6 fd ff ff       	call   c00003cc <terminal_putchar>
c0000626:	83 c4 10             	add    $0x10,%esp
    return 1;
c0000629:	b8 01 00 00 00       	mov    $0x1,%eax
}
c000062e:	c9                   	leave  
c000062f:	c3                   	ret    

c0000630 <kprintn_char>:

int kprintn_char(char c, size_t rpt)
{
c0000630:	55                   	push   %ebp
c0000631:	89 e5                	mov    %esp,%ebp
c0000633:	83 ec 18             	sub    $0x18,%esp
c0000636:	8b 45 08             	mov    0x8(%ebp),%eax
c0000639:	88 45 f4             	mov    %al,-0xc(%ebp)
    terminal_putcharn(&stdout, c, rpt); 
c000063c:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c0000640:	83 ec 04             	sub    $0x4,%esp
c0000643:	ff 75 0c             	pushl  0xc(%ebp)
c0000646:	50                   	push   %eax
c0000647:	68 00 00 01 c0       	push   $0xc0010000
c000064c:	e8 f6 fd ff ff       	call   c0000447 <terminal_putcharn>
c0000651:	83 c4 10             	add    $0x10,%esp
    return rpt;
c0000654:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c0000657:	c9                   	leave  
c0000658:	c3                   	ret    

c0000659 <kprintf>:


int kprintf(const char* format, ...)
{
c0000659:	55                   	push   %ebp
c000065a:	89 e5                	mov    %esp,%ebp
c000065c:	81 ec a8 02 00 00    	sub    $0x2a8,%esp
    /* initialize valist for num number of arguments */
    va_list valist;
    va_start(valist, format);
c0000662:	8d 45 0c             	lea    0xc(%ebp),%eax
c0000665:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)

    // parse format into str
    const char* f = format;
c000066b:	8b 45 08             	mov    0x8(%ebp),%eax
c000066e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int nchar = 0;
c0000671:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    while(f[0] != 0)
c0000678:	e9 9e 0a 00 00       	jmp    c000111b <kprintf+0xac2>
    {
        if(f[0] == '\\' && f[1] == '%')
c000067d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000680:	0f b6 00             	movzbl (%eax),%eax
c0000683:	3c 5c                	cmp    $0x5c,%al
c0000685:	75 22                	jne    c00006a9 <kprintf+0x50>
c0000687:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000068a:	83 c0 01             	add    $0x1,%eax
c000068d:	0f b6 00             	movzbl (%eax),%eax
c0000690:	3c 25                	cmp    $0x25,%al
c0000692:	75 15                	jne    c00006a9 <kprintf+0x50>
        {
            //write escaped "%%" as '%'
            kprint_char('%');
c0000694:	83 ec 0c             	sub    $0xc,%esp
c0000697:	6a 25                	push   $0x25
c0000699:	e8 6a ff ff ff       	call   c0000608 <kprint_char>
c000069e:	83 c4 10             	add    $0x10,%esp
            nchar++;
c00006a1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
            f += 2;
c00006a5:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
        }

        if(f[0] == '%')
c00006a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00006ac:	0f b6 00             	movzbl (%eax),%eax
c00006af:	3c 25                	cmp    $0x25,%al
c00006b1:	0f 85 45 0a 00 00    	jne    c00010fc <kprintf+0xaa3>
        {
            // found new field

            // parse flags
            struct format_flags flags = {0};
c00006b7:	c7 85 77 ff ff ff 00 	movl   $0x0,-0x89(%ebp)
c00006be:	00 00 00 
c00006c1:	c6 85 7b ff ff ff 00 	movb   $0x0,-0x85(%ebp)
            int check_flags = 1;
c00006c8:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
            while(check_flags)
c00006cf:	e9 ee 00 00 00       	jmp    c00007c2 <kprintf+0x169>
            {
                switch(*(++f))
c00006d4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00006d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00006db:	0f b6 00             	movzbl (%eax),%eax
c00006de:	0f be c0             	movsbl %al,%eax
c00006e1:	85 c0                	test   %eax,%eax
c00006e3:	0f 84 c8 00 00 00    	je     c00007b1 <kprintf+0x158>
c00006e9:	85 c0                	test   %eax,%eax
c00006eb:	0f 88 ca 00 00 00    	js     c00007bb <kprintf+0x162>
c00006f1:	83 f8 30             	cmp    $0x30,%eax
c00006f4:	0f 8f c1 00 00 00    	jg     c00007bb <kprintf+0x162>
c00006fa:	83 f8 20             	cmp    $0x20,%eax
c00006fd:	0f 8c b8 00 00 00    	jl     c00007bb <kprintf+0x162>
c0000703:	83 e8 20             	sub    $0x20,%eax
c0000706:	83 f8 10             	cmp    $0x10,%eax
c0000709:	0f 87 ac 00 00 00    	ja     c00007bb <kprintf+0x162>
c000070f:	8b 04 85 00 40 00 c0 	mov    -0x3fffc000(,%eax,4),%eax
c0000716:	ff e0                	jmp    *%eax
                {
                    case '#':
                        if(flags.alt) return 0;
c0000718:	0f b6 85 77 ff ff ff 	movzbl -0x89(%ebp),%eax
c000071f:	84 c0                	test   %al,%al
c0000721:	74 0a                	je     c000072d <kprintf+0xd4>
c0000723:	b8 00 00 00 00       	mov    $0x0,%eax
c0000728:	e9 ff 09 00 00       	jmp    c000112c <kprintf+0xad3>
                        flags.alt = 1;
c000072d:	c6 85 77 ff ff ff 01 	movb   $0x1,-0x89(%ebp)
                        break;
c0000734:	e9 89 00 00 00       	jmp    c00007c2 <kprintf+0x169>
                    case '0':
                        if(flags.zero) return 0;
c0000739:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000740:	84 c0                	test   %al,%al
c0000742:	74 0a                	je     c000074e <kprintf+0xf5>
c0000744:	b8 00 00 00 00       	mov    $0x0,%eax
c0000749:	e9 de 09 00 00       	jmp    c000112c <kprintf+0xad3>
                        flags.zero = 1;
c000074e:	c6 85 78 ff ff ff 01 	movb   $0x1,-0x88(%ebp)
                        break;
c0000755:	eb 6b                	jmp    c00007c2 <kprintf+0x169>
                    case '-':
                        if(flags.left) return 0;
c0000757:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c000075e:	84 c0                	test   %al,%al
c0000760:	74 0a                	je     c000076c <kprintf+0x113>
c0000762:	b8 00 00 00 00       	mov    $0x0,%eax
c0000767:	e9 c0 09 00 00       	jmp    c000112c <kprintf+0xad3>
                        flags.left = 1;
c000076c:	c6 85 79 ff ff ff 01 	movb   $0x1,-0x87(%ebp)
                        break;
c0000773:	eb 4d                	jmp    c00007c2 <kprintf+0x169>
                    case ' ':
                        if(flags.space) return 0;
c0000775:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c000077c:	84 c0                	test   %al,%al
c000077e:	74 0a                	je     c000078a <kprintf+0x131>
c0000780:	b8 00 00 00 00       	mov    $0x0,%eax
c0000785:	e9 a2 09 00 00       	jmp    c000112c <kprintf+0xad3>
                        flags.space = 1;
c000078a:	c6 85 7a ff ff ff 01 	movb   $0x1,-0x86(%ebp)
                        break;
c0000791:	eb 2f                	jmp    c00007c2 <kprintf+0x169>
                    case '+':
                        if(flags.sign) return 0;
c0000793:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c000079a:	84 c0                	test   %al,%al
c000079c:	74 0a                	je     c00007a8 <kprintf+0x14f>
c000079e:	b8 00 00 00 00       	mov    $0x0,%eax
c00007a3:	e9 84 09 00 00       	jmp    c000112c <kprintf+0xad3>
                        flags.sign = 1;
c00007a8:	c6 85 7b ff ff ff 01 	movb   $0x1,-0x85(%ebp)
                        break;
c00007af:	eb 11                	jmp    c00007c2 <kprintf+0x169>
                    case '\0':
                        //unexpected string termination
                        return -1;
c00007b1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00007b6:	e9 71 09 00 00       	jmp    c000112c <kprintf+0xad3>
                        break;
                    default:
                        //no more flags
                        check_flags = 0;
c00007bb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
            while(check_flags)
c00007c2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c00007c6:	0f 85 08 ff ff ff    	jne    c00006d4 <kprintf+0x7b>
                }
            }

            if(flags.left) flags.zero = 0; //If the 0 and - flags both appear, the 0 flag is ignored
c00007cc:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c00007d3:	84 c0                	test   %al,%al
c00007d5:	74 07                	je     c00007de <kprintf+0x185>
c00007d7:	c6 85 78 ff ff ff 00 	movb   $0x0,-0x88(%ebp)

            // parse field width
            int field_width=0;
c00007de:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
            int nn=0;
c00007e5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
            while(f[nn] >= '0' && f[nn] <= '9')
c00007ec:	eb 04                	jmp    c00007f2 <kprintf+0x199>
                nn++;            
c00007ee:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
            while(f[nn] >= '0' && f[nn] <= '9')
c00007f2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00007f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00007f8:	01 d0                	add    %edx,%eax
c00007fa:	0f b6 00             	movzbl (%eax),%eax
c00007fd:	3c 2f                	cmp    $0x2f,%al
c00007ff:	7e 0f                	jle    c0000810 <kprintf+0x1b7>
c0000801:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000804:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000807:	01 d0                	add    %edx,%eax
c0000809:	0f b6 00             	movzbl (%eax),%eax
c000080c:	3c 39                	cmp    $0x39,%al
c000080e:	7e de                	jle    c00007ee <kprintf+0x195>
            if(nn>0)
c0000810:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0000814:	7e 17                	jle    c000082d <kprintf+0x1d4>
            {
                field_width = atoi(f);
c0000816:	83 ec 0c             	sub    $0xc,%esp
c0000819:	ff 75 f4             	pushl  -0xc(%ebp)
c000081c:	e8 6a 0d 00 00       	call   c000158b <atoi>
c0000821:	83 c4 10             	add    $0x10,%esp
c0000824:	89 45 e8             	mov    %eax,-0x18(%ebp)
                f += nn;
c0000827:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000082a:	01 45 f4             	add    %eax,-0xc(%ebp)
            }

            // parse field precision
            int field_prec=-1; //default is -1
c000082d:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
            if(f[0] == '.')
c0000834:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000837:	0f b6 00             	movzbl (%eax),%eax
c000083a:	3c 2e                	cmp    $0x2e,%al
c000083c:	75 59                	jne    c0000897 <kprintf+0x23e>
            {
                f++;
c000083e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                nn=0;
c0000842:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
                while(f[nn] >= '0' && f[nn] <= '9')
c0000849:	eb 04                	jmp    c000084f <kprintf+0x1f6>
                    nn++;            
c000084b:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                while(f[nn] >= '0' && f[nn] <= '9')
c000084f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000852:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000855:	01 d0                	add    %edx,%eax
c0000857:	0f b6 00             	movzbl (%eax),%eax
c000085a:	3c 2f                	cmp    $0x2f,%al
c000085c:	7e 0f                	jle    c000086d <kprintf+0x214>
c000085e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000861:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000864:	01 d0                	add    %edx,%eax
c0000866:	0f b6 00             	movzbl (%eax),%eax
c0000869:	3c 39                	cmp    $0x39,%al
c000086b:	7e de                	jle    c000084b <kprintf+0x1f2>
                if(nn>0)
c000086d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0000871:	7e 24                	jle    c0000897 <kprintf+0x23e>
                {
                    field_prec = atoi(f);
c0000873:	83 ec 0c             	sub    $0xc,%esp
c0000876:	ff 75 f4             	pushl  -0xc(%ebp)
c0000879:	e8 0d 0d 00 00       	call   c000158b <atoi>
c000087e:	83 c4 10             	add    $0x10,%esp
c0000881:	89 45 e0             	mov    %eax,-0x20(%ebp)
                    if(field_prec<0) field_prec = 0;
c0000884:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000888:	79 07                	jns    c0000891 <kprintf+0x238>
c000088a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
                    f += nn;
c0000891:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0000894:	01 45 f4             	add    %eax,-0xc(%ebp)

            //parse type
            enum length_mod_t {DEFAULT, CHARINT, SHORTINT, LONGINT, LONGLONGINT,
                            LONGDOUBLE, INTMAX, SIZE, PTRDIFF} length_mod;

            switch(*(f++))
c0000897:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000089a:	8d 50 01             	lea    0x1(%eax),%edx
c000089d:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00008a0:	0f b6 00             	movzbl (%eax),%eax
c00008a3:	0f be c0             	movsbl %al,%eax
c00008a6:	83 e8 4c             	sub    $0x4c,%eax
c00008a9:	83 f8 2e             	cmp    $0x2e,%eax
c00008ac:	77 6d                	ja     c000091b <kprintf+0x2c2>
c00008ae:	8b 04 85 44 40 00 c0 	mov    -0x3fffbfbc(,%eax,4),%eax
c00008b5:	ff e0                	jmp    *%eax
            {
                case 'h':
                    if(*f == 'h')
c00008b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00008ba:	0f b6 00             	movzbl (%eax),%eax
c00008bd:	3c 68                	cmp    $0x68,%al
c00008bf:	75 0d                	jne    c00008ce <kprintf+0x275>
                    {
                        f++;
c00008c1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                        length_mod = CHARINT;
c00008c5:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
                    }
                    else
                        length_mod = SHORTINT;
                    break;
c00008cc:	eb 58                	jmp    c0000926 <kprintf+0x2cd>
                        length_mod = SHORTINT;
c00008ce:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
                    break;
c00008d5:	eb 4f                	jmp    c0000926 <kprintf+0x2cd>
                case 'l':
                    if(*f == 'l')
c00008d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00008da:	0f b6 00             	movzbl (%eax),%eax
c00008dd:	3c 6c                	cmp    $0x6c,%al
c00008df:	75 0d                	jne    c00008ee <kprintf+0x295>
                    {
                        f++;
c00008e1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                        length_mod = LONGLONGINT;
c00008e5:	c7 45 dc 04 00 00 00 	movl   $0x4,-0x24(%ebp)
                    }
                    else
                        length_mod = LONGINT;
                    break;
c00008ec:	eb 38                	jmp    c0000926 <kprintf+0x2cd>
                        length_mod = LONGINT;
c00008ee:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
                    break;
c00008f5:	eb 2f                	jmp    c0000926 <kprintf+0x2cd>
                case 'q':
                case 'L':
                    length_mod = LONGDOUBLE;
c00008f7:	c7 45 dc 05 00 00 00 	movl   $0x5,-0x24(%ebp)
                    break;
c00008fe:	eb 26                	jmp    c0000926 <kprintf+0x2cd>
                case 'j':
                    length_mod = INTMAX;
c0000900:	c7 45 dc 06 00 00 00 	movl   $0x6,-0x24(%ebp)
                    break;
c0000907:	eb 1d                	jmp    c0000926 <kprintf+0x2cd>
                case 'Z':
                case 'z':
                    length_mod = SIZE;
c0000909:	c7 45 dc 07 00 00 00 	movl   $0x7,-0x24(%ebp)
                    break;
c0000910:	eb 14                	jmp    c0000926 <kprintf+0x2cd>
                case 't':
                    length_mod = PTRDIFF;
c0000912:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
                    break;
c0000919:	eb 0b                	jmp    c0000926 <kprintf+0x2cd>
                default:
                    f--; //no length mod, back up a char...
c000091b:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
                    length_mod = DEFAULT;
c000091f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
            }

            //parse field
            char val_buf[512]; //assuming here that numberical values cannot exceed 512 chars 
            if(field_width>511)
c0000926:	81 7d e8 ff 01 00 00 	cmpl   $0x1ff,-0x18(%ebp)
c000092d:	7e 0a                	jle    c0000939 <kprintf+0x2e0>
                return -1;
c000092f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000934:	e9 f3 07 00 00       	jmp    c000112c <kprintf+0xad3>

            switch(*f)
c0000939:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000093c:	0f b6 00             	movzbl (%eax),%eax
c000093f:	0f be c0             	movsbl %al,%eax
c0000942:	83 e8 45             	sub    $0x45,%eax
c0000945:	83 f8 33             	cmp    $0x33,%eax
c0000948:	0f 87 97 07 00 00    	ja     c00010e5 <kprintf+0xa8c>
c000094e:	8b 04 85 00 41 00 c0 	mov    -0x3fffbf00(,%eax,4),%eax
c0000955:	ff e0                	jmp    *%eax
c0000957:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c000095b:	0f 87 67 01 00 00    	ja     c0000ac8 <kprintf+0x46f>
                        case(LONGINT):
                        case(LONGLONGINT):
                        case(DEFAULT):
                            {
                                int i_value;
                                if(length_mod == LONGLONGINT)
c0000961:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000965:	75 19                	jne    c0000980 <kprintf+0x327>
                                    i_value = (int) va_arg(valist, long long int); //TODO: implement actual longlong handling
c0000967:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c000096d:	8d 50 08             	lea    0x8(%eax),%edx
c0000970:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000976:	8b 50 04             	mov    0x4(%eax),%edx
c0000979:	8b 00                	mov    (%eax),%eax
c000097b:	89 45 d8             	mov    %eax,-0x28(%ebp)
c000097e:	eb 14                	jmp    c0000994 <kprintf+0x33b>
                                else
                                    i_value = va_arg(valist, int);
c0000980:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000986:	8d 50 04             	lea    0x4(%eax),%edx
c0000989:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c000098f:	8b 00                	mov    (%eax),%eax
c0000991:	89 45 d8             	mov    %eax,-0x28(%ebp)

                                char sign_char = 0; //sign character or 0 if none
c0000994:	c6 45 d7 00          	movb   $0x0,-0x29(%ebp)
                                unsigned int ui_value; //unsigned value (abs value)
                                if(i_value<0)
c0000998:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c000099c:	79 0e                	jns    c00009ac <kprintf+0x353>
                                {
                                    ui_value = -i_value;
c000099e:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00009a1:	f7 d8                	neg    %eax
c00009a3:	89 45 d0             	mov    %eax,-0x30(%ebp)
                                    sign_char = '-';
c00009a6:	c6 45 d7 2d          	movb   $0x2d,-0x29(%ebp)
c00009aa:	eb 26                	jmp    c00009d2 <kprintf+0x379>
                                }
                                else
                                {
                                    ui_value = i_value;
c00009ac:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00009af:	89 45 d0             	mov    %eax,-0x30(%ebp)
                                    if(flags.sign)
c00009b2:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c00009b9:	84 c0                	test   %al,%al
c00009bb:	74 06                	je     c00009c3 <kprintf+0x36a>
                                        sign_char = '+';
c00009bd:	c6 45 d7 2b          	movb   $0x2b,-0x29(%ebp)
c00009c1:	eb 0f                	jmp    c00009d2 <kprintf+0x379>
                                    else if(flags.space)
c00009c3:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c00009ca:	84 c0                	test   %al,%al
c00009cc:	74 04                	je     c00009d2 <kprintf+0x379>
                                        sign_char = ' ';
c00009ce:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
                                    
                                    //else positive number has no sign character
                                }

                                //convert value into string
                                int len = format_uint(ui_value, val_buf, 10, field_prec, 0);
c00009d2:	83 ec 0c             	sub    $0xc,%esp
c00009d5:	6a 00                	push   $0x0
c00009d7:	ff 75 e0             	pushl  -0x20(%ebp)
c00009da:	6a 0a                	push   $0xa
c00009dc:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c00009e2:	50                   	push   %eax
c00009e3:	ff 75 d0             	pushl  -0x30(%ebp)
c00009e6:	e8 43 07 00 00       	call   c000112e <format_uint>
c00009eb:	83 c4 20             	add    $0x20,%esp
c00009ee:	89 45 9c             	mov    %eax,-0x64(%ebp)
                                //amount of padding required to meet requested width
                                int lenpad = field_width - len; 
c00009f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00009f4:	2b 45 9c             	sub    -0x64(%ebp),%eax
c00009f7:	89 45 cc             	mov    %eax,-0x34(%ebp)

                                if(sign_char)
c00009fa:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
c00009fe:	74 22                	je     c0000a22 <kprintf+0x3c9>
                                {
                                    lenpad--; //remove one char of padding to account for sign
c0000a00:	83 6d cc 01          	subl   $0x1,-0x34(%ebp)
                                    if(flags.zero)
c0000a04:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000a0b:	84 c0                	test   %al,%al
c0000a0d:	74 13                	je     c0000a22 <kprintf+0x3c9>
                                        nchar += kprint_char(sign_char); //if zero padding, sign is at beginning
c0000a0f:	0f be 45 d7          	movsbl -0x29(%ebp),%eax
c0000a13:	83 ec 0c             	sub    $0xc,%esp
c0000a16:	50                   	push   %eax
c0000a17:	e8 ec fb ff ff       	call   c0000608 <kprint_char>
c0000a1c:	83 c4 10             	add    $0x10,%esp
c0000a1f:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                if(!flags.left && lenpad>0)
c0000a22:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000a29:	84 c0                	test   %al,%al
c0000a2b:	75 3b                	jne    c0000a68 <kprintf+0x40f>
c0000a2d:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
c0000a31:	7e 35                	jle    c0000a68 <kprintf+0x40f>
                                {
                                    if(flags.zero)
c0000a33:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000a3a:	84 c0                	test   %al,%al
c0000a3c:	74 16                	je     c0000a54 <kprintf+0x3fb>
                                        nchar += kprintn_char('0', lenpad);
c0000a3e:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0000a41:	83 ec 08             	sub    $0x8,%esp
c0000a44:	50                   	push   %eax
c0000a45:	6a 30                	push   $0x30
c0000a47:	e8 e4 fb ff ff       	call   c0000630 <kprintn_char>
c0000a4c:	83 c4 10             	add    $0x10,%esp
c0000a4f:	01 45 f0             	add    %eax,-0x10(%ebp)
c0000a52:	eb 14                	jmp    c0000a68 <kprintf+0x40f>
                                    else
                                        nchar += kprintn_char(' ', lenpad);
c0000a54:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0000a57:	83 ec 08             	sub    $0x8,%esp
c0000a5a:	50                   	push   %eax
c0000a5b:	6a 20                	push   $0x20
c0000a5d:	e8 ce fb ff ff       	call   c0000630 <kprintn_char>
c0000a62:	83 c4 10             	add    $0x10,%esp
c0000a65:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                if(!flags.zero && sign_char)
c0000a68:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000a6f:	84 c0                	test   %al,%al
c0000a71:	75 19                	jne    c0000a8c <kprintf+0x433>
c0000a73:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
c0000a77:	74 13                	je     c0000a8c <kprintf+0x433>
                                    nchar += kprint_char(sign_char); //if not zero padding, write sign here
c0000a79:	0f be 45 d7          	movsbl -0x29(%ebp),%eax
c0000a7d:	83 ec 0c             	sub    $0xc,%esp
c0000a80:	50                   	push   %eax
c0000a81:	e8 82 fb ff ff       	call   c0000608 <kprint_char>
c0000a86:	83 c4 10             	add    $0x10,%esp
c0000a89:	01 45 f0             	add    %eax,-0x10(%ebp)

                                nchar += kprint(val_buf);
c0000a8c:	83 ec 0c             	sub    $0xc,%esp
c0000a8f:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000a95:	50                   	push   %eax
c0000a96:	e8 23 fb ff ff       	call   c00005be <kprint>
c0000a9b:	83 c4 10             	add    $0x10,%esp
c0000a9e:	01 45 f0             	add    %eax,-0x10(%ebp)

                                if(flags.left && lenpad>0)
c0000aa1:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000aa8:	84 c0                	test   %al,%al
c0000aaa:	74 26                	je     c0000ad2 <kprintf+0x479>
c0000aac:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
c0000ab0:	7e 20                	jle    c0000ad2 <kprintf+0x479>
                                    nchar += kprintn_char(' ', lenpad);
c0000ab2:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0000ab5:	83 ec 08             	sub    $0x8,%esp
c0000ab8:	50                   	push   %eax
c0000ab9:	6a 20                	push   $0x20
c0000abb:	e8 70 fb ff ff       	call   c0000630 <kprintn_char>
c0000ac0:	83 c4 10             	add    $0x10,%esp
c0000ac3:	01 45 f0             	add    %eax,-0x10(%ebp)


                            }
                            break;
c0000ac6:	eb 0a                	jmp    c0000ad2 <kprintf+0x479>
                        default:
                            return -1; //invalid length mod
c0000ac8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000acd:	e9 5a 06 00 00       	jmp    c000112c <kprintf+0xad3>
                            break;
c0000ad2:	90                   	nop
                    }
                    break;
c0000ad3:	e9 1e 06 00 00       	jmp    c00010f6 <kprintf+0xa9d>
c0000ad8:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000adc:	0f 87 03 02 00 00    	ja     c0000ce5 <kprintf+0x68c>
                        case(SHORTINT):
                        case(LONGINT):
                        case(LONGLONGINT):
                        case(DEFAULT):
                            {
                                unsigned int base = 10;
c0000ae2:	c7 45 c8 0a 00 00 00 	movl   $0xa,-0x38(%ebp)
                                unsigned int ui_value;
                                if(length_mod == LONGLONGINT)
c0000ae9:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000aed:	75 19                	jne    c0000b08 <kprintf+0x4af>
                                    ui_value = (unsigned int) va_arg(valist, long long unsigned int); //TODO: implement actual longlong handling
c0000aef:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000af5:	8d 50 08             	lea    0x8(%eax),%edx
c0000af8:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000afe:	8b 50 04             	mov    0x4(%eax),%edx
c0000b01:	8b 00                	mov    (%eax),%eax
c0000b03:	89 45 c4             	mov    %eax,-0x3c(%ebp)
c0000b06:	eb 14                	jmp    c0000b1c <kprintf+0x4c3>
                                else
                                    ui_value = va_arg(valist, unsigned int);
c0000b08:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000b0e:	8d 50 04             	lea    0x4(%eax),%edx
c0000b11:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000b17:	8b 00                	mov    (%eax),%eax
c0000b19:	89 45 c4             	mov    %eax,-0x3c(%ebp)

                                if(*f == 'o')
c0000b1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000b1f:	0f b6 00             	movzbl (%eax),%eax
c0000b22:	3c 6f                	cmp    $0x6f,%al
c0000b24:	75 09                	jne    c0000b2f <kprintf+0x4d6>
                                    base = 8;
c0000b26:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
c0000b2d:	eb 3e                	jmp    c0000b6d <kprintf+0x514>
                                else if(*f == 'x' || *f == 'X')
c0000b2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000b32:	0f b6 00             	movzbl (%eax),%eax
c0000b35:	3c 78                	cmp    $0x78,%al
c0000b37:	74 0a                	je     c0000b43 <kprintf+0x4ea>
c0000b39:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000b3c:	0f b6 00             	movzbl (%eax),%eax
c0000b3f:	3c 58                	cmp    $0x58,%al
c0000b41:	75 09                	jne    c0000b4c <kprintf+0x4f3>
                                    base = 16;
c0000b43:	c7 45 c8 10 00 00 00 	movl   $0x10,-0x38(%ebp)
c0000b4a:	eb 21                	jmp    c0000b6d <kprintf+0x514>
                                else if(*f == 'p')
c0000b4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000b4f:	0f b6 00             	movzbl (%eax),%eax
c0000b52:	3c 70                	cmp    $0x70,%al
c0000b54:	75 10                	jne    c0000b66 <kprintf+0x50d>
                                {
                                    //print as hex with 0x prefix
                                    base = 16;
c0000b56:	c7 45 c8 10 00 00 00 	movl   $0x10,-0x38(%ebp)
                                    flags.alt = 1; 
c0000b5d:	c6 85 77 ff ff ff 01 	movb   $0x1,-0x89(%ebp)
c0000b64:	eb 07                	jmp    c0000b6d <kprintf+0x514>
                                }
                                else
                                    flags.alt = 0;
c0000b66:	c6 85 77 ff ff ff 00 	movb   $0x0,-0x89(%ebp)
                                
                                int cap = (*f == 'X') ? 1 : 0;
c0000b6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000b70:	0f b6 00             	movzbl (%eax),%eax
c0000b73:	3c 58                	cmp    $0x58,%al
c0000b75:	0f 94 c0             	sete   %al
c0000b78:	0f b6 c0             	movzbl %al,%eax
c0000b7b:	89 45 94             	mov    %eax,-0x6c(%ebp)

                                //convert value into string
                                int len = format_uint(ui_value, val_buf, base, field_prec, cap);
c0000b7e:	83 ec 0c             	sub    $0xc,%esp
c0000b81:	ff 75 94             	pushl  -0x6c(%ebp)
c0000b84:	ff 75 e0             	pushl  -0x20(%ebp)
c0000b87:	ff 75 c8             	pushl  -0x38(%ebp)
c0000b8a:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000b90:	50                   	push   %eax
c0000b91:	ff 75 c4             	pushl  -0x3c(%ebp)
c0000b94:	e8 95 05 00 00       	call   c000112e <format_uint>
c0000b99:	83 c4 20             	add    $0x20,%esp
c0000b9c:	89 45 90             	mov    %eax,-0x70(%ebp)
                                //amount of padding required to meet requested width
                                int lenpad = field_width - len; 
c0000b9f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000ba2:	2b 45 90             	sub    -0x70(%ebp),%eax
c0000ba5:	89 45 c0             	mov    %eax,-0x40(%ebp)


                                //format radix prefix for oct and hex with alt flag
                                char radix[3]="";
c0000ba8:	66 c7 85 74 ff ff ff 	movw   $0x0,-0x8c(%ebp)
c0000baf:	00 00 
c0000bb1:	c6 85 76 ff ff ff 00 	movb   $0x0,-0x8a(%ebp)
                                if(flags.alt)
c0000bb8:	0f b6 85 77 ff ff ff 	movzbl -0x89(%ebp),%eax
c0000bbf:	84 c0                	test   %al,%al
c0000bc1:	74 75                	je     c0000c38 <kprintf+0x5df>
                                {
                                    if(base==16)
c0000bc3:	83 7d c8 10          	cmpl   $0x10,-0x38(%ebp)
c0000bc7:	75 2c                	jne    c0000bf5 <kprintf+0x59c>
                                    {
                                        lenpad -= 2;
c0000bc9:	83 6d c0 02          	subl   $0x2,-0x40(%ebp)
                                        radix[0] = '0';
c0000bcd:	c6 85 74 ff ff ff 30 	movb   $0x30,-0x8c(%ebp)
                                        radix[1] = cap ? 'X' : 'x';
c0000bd4:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
c0000bd8:	74 07                	je     c0000be1 <kprintf+0x588>
c0000bda:	b8 58 00 00 00       	mov    $0x58,%eax
c0000bdf:	eb 05                	jmp    c0000be6 <kprintf+0x58d>
c0000be1:	b8 78 00 00 00       	mov    $0x78,%eax
c0000be6:	88 85 75 ff ff ff    	mov    %al,-0x8b(%ebp)
                                        radix[2] = 0;
c0000bec:	c6 85 76 ff ff ff 00 	movb   $0x0,-0x8a(%ebp)
c0000bf3:	eb 23                	jmp    c0000c18 <kprintf+0x5bf>
                                    }
                                    else if(base==8 && val_buf[0] != '0')
c0000bf5:	83 7d c8 08          	cmpl   $0x8,-0x38(%ebp)
c0000bf9:	75 1d                	jne    c0000c18 <kprintf+0x5bf>
c0000bfb:	0f b6 85 74 fd ff ff 	movzbl -0x28c(%ebp),%eax
c0000c02:	3c 30                	cmp    $0x30,%al
c0000c04:	74 12                	je     c0000c18 <kprintf+0x5bf>
                                    {
                                        lenpad -= 1;
c0000c06:	83 6d c0 01          	subl   $0x1,-0x40(%ebp)
                                        radix[0] = '0';
c0000c0a:	c6 85 74 ff ff ff 30 	movb   $0x30,-0x8c(%ebp)
                                        radix[1] = 0;
c0000c11:	c6 85 75 ff ff ff 00 	movb   $0x0,-0x8b(%ebp)
                                    }

                                    //if zero padding, radix is printed first
                                    if(flags.zero)
c0000c18:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000c1f:	84 c0                	test   %al,%al
c0000c21:	74 15                	je     c0000c38 <kprintf+0x5df>
                                        nchar += kprint(radix);
c0000c23:	83 ec 0c             	sub    $0xc,%esp
c0000c26:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
c0000c2c:	50                   	push   %eax
c0000c2d:	e8 8c f9 ff ff       	call   c00005be <kprint>
c0000c32:	83 c4 10             	add    $0x10,%esp
c0000c35:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }


                                //print leading padding, if any
                                if(!flags.left && lenpad>0)
c0000c38:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000c3f:	84 c0                	test   %al,%al
c0000c41:	75 3b                	jne    c0000c7e <kprintf+0x625>
c0000c43:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
c0000c47:	7e 35                	jle    c0000c7e <kprintf+0x625>
                                {
                                    if(flags.zero)
c0000c49:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000c50:	84 c0                	test   %al,%al
c0000c52:	74 16                	je     c0000c6a <kprintf+0x611>
                                        nchar += kprintn_char('0', lenpad);
c0000c54:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000c57:	83 ec 08             	sub    $0x8,%esp
c0000c5a:	50                   	push   %eax
c0000c5b:	6a 30                	push   $0x30
c0000c5d:	e8 ce f9 ff ff       	call   c0000630 <kprintn_char>
c0000c62:	83 c4 10             	add    $0x10,%esp
c0000c65:	01 45 f0             	add    %eax,-0x10(%ebp)
c0000c68:	eb 14                	jmp    c0000c7e <kprintf+0x625>
                                    else
                                        nchar += kprintn_char(' ', lenpad);
c0000c6a:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000c6d:	83 ec 08             	sub    $0x8,%esp
c0000c70:	50                   	push   %eax
c0000c71:	6a 20                	push   $0x20
c0000c73:	e8 b8 f9 ff ff       	call   c0000630 <kprintn_char>
c0000c78:	83 c4 10             	add    $0x10,%esp
c0000c7b:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                //print radix prefix if valid and not leading zeros
                                if(!flags.zero && radix[0])
c0000c7e:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000c85:	84 c0                	test   %al,%al
c0000c87:	75 20                	jne    c0000ca9 <kprintf+0x650>
c0000c89:	0f b6 85 74 ff ff ff 	movzbl -0x8c(%ebp),%eax
c0000c90:	84 c0                	test   %al,%al
c0000c92:	74 15                	je     c0000ca9 <kprintf+0x650>
                                    nchar += kprint(radix);
c0000c94:	83 ec 0c             	sub    $0xc,%esp
c0000c97:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
c0000c9d:	50                   	push   %eax
c0000c9e:	e8 1b f9 ff ff       	call   c00005be <kprint>
c0000ca3:	83 c4 10             	add    $0x10,%esp
c0000ca6:	01 45 f0             	add    %eax,-0x10(%ebp)

                                //print number itself
                                nchar += kprint(val_buf);
c0000ca9:	83 ec 0c             	sub    $0xc,%esp
c0000cac:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000cb2:	50                   	push   %eax
c0000cb3:	e8 06 f9 ff ff       	call   c00005be <kprint>
c0000cb8:	83 c4 10             	add    $0x10,%esp
c0000cbb:	01 45 f0             	add    %eax,-0x10(%ebp)

                                //print trailing padding if left justified
                                if(flags.left && lenpad>0)
c0000cbe:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000cc5:	84 c0                	test   %al,%al
c0000cc7:	74 26                	je     c0000cef <kprintf+0x696>
c0000cc9:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
c0000ccd:	7e 20                	jle    c0000cef <kprintf+0x696>
                                    nchar += kprintn_char(' ', lenpad);
c0000ccf:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000cd2:	83 ec 08             	sub    $0x8,%esp
c0000cd5:	50                   	push   %eax
c0000cd6:	6a 20                	push   $0x20
c0000cd8:	e8 53 f9 ff ff       	call   c0000630 <kprintn_char>
c0000cdd:	83 c4 10             	add    $0x10,%esp
c0000ce0:	01 45 f0             	add    %eax,-0x10(%ebp)

                            }
                            break;
c0000ce3:	eb 0a                	jmp    c0000cef <kprintf+0x696>
                        default:
                            return -1; //invalid length mod
c0000ce5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000cea:	e9 3d 04 00 00       	jmp    c000112c <kprintf+0xad3>
                            break;
c0000cef:	90                   	nop
                    }

                    break;
c0000cf0:	e9 01 04 00 00       	jmp    c00010f6 <kprintf+0xa9d>

                case 'f':
                case 'F':
                    {
                        float f_value = (float) va_arg(valist, double);
c0000cf5:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000cfb:	8d 50 08             	lea    0x8(%eax),%edx
c0000cfe:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000d04:	dd 00                	fldl   (%eax)
c0000d06:	d9 5d 8c             	fstps  -0x74(%ebp)

                        //When 0 is printed with an explicit precision 0, the output is empty.
                        if(f_value==0 && field_prec==0)
c0000d09:	d9 45 8c             	flds   -0x74(%ebp)
c0000d0c:	d9 ee                	fldz   
c0000d0e:	df e9                	fucomip %st(1),%st
c0000d10:	dd d8                	fstp   %st(0)
c0000d12:	7a 15                	jp     c0000d29 <kprintf+0x6d0>
c0000d14:	d9 45 8c             	flds   -0x74(%ebp)
c0000d17:	d9 ee                	fldz   
c0000d19:	df e9                	fucomip %st(1),%st
c0000d1b:	dd d8                	fstp   %st(0)
c0000d1d:	75 0a                	jne    c0000d29 <kprintf+0x6d0>
c0000d1f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000d23:	0f 84 c3 03 00 00    	je     c00010ec <kprintf+0xa93>
                            break;
                        if(field_prec<0) field_prec = 6;  //default is prec = 6
c0000d29:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000d2d:	79 07                	jns    c0000d36 <kprintf+0x6dd>
c0000d2f:	c7 45 e0 06 00 00 00 	movl   $0x6,-0x20(%ebp)

                        unsigned int ui_part;
                        char sign_char = 0;
c0000d36:	c6 45 bb 00          	movb   $0x0,-0x45(%ebp)
                        if(f_value<0)
c0000d3a:	d9 45 8c             	flds   -0x74(%ebp)
c0000d3d:	d9 ee                	fldz   
c0000d3f:	df f1                	fcomip %st(1),%st
c0000d41:	dd d8                	fstp   %st(0)
c0000d43:	76 3d                	jbe    c0000d82 <kprintf+0x729>
                        {
                            ui_part = (unsigned int) -f_value;
c0000d45:	d9 45 8c             	flds   -0x74(%ebp)
c0000d48:	d9 e0                	fchs   
c0000d4a:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c0000d50:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c0000d57:	80 cc 0c             	or     $0xc,%ah
c0000d5a:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c0000d61:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c0000d67:	df bd 58 fd ff ff    	fistpll -0x2a8(%ebp)
c0000d6d:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
c0000d73:	8b 85 58 fd ff ff    	mov    -0x2a8(%ebp),%eax
c0000d79:	89 45 bc             	mov    %eax,-0x44(%ebp)
                            sign_char = '-';
c0000d7c:	c6 45 bb 2d          	movb   $0x2d,-0x45(%ebp)
c0000d80:	eb 55                	jmp    c0000dd7 <kprintf+0x77e>
                        }
                        else
                        {
                            ui_part = (unsigned int) f_value;
c0000d82:	d9 45 8c             	flds   -0x74(%ebp)
c0000d85:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c0000d8b:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c0000d92:	80 cc 0c             	or     $0xc,%ah
c0000d95:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c0000d9c:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c0000da2:	df bd 58 fd ff ff    	fistpll -0x2a8(%ebp)
c0000da8:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
c0000dae:	8b 85 58 fd ff ff    	mov    -0x2a8(%ebp),%eax
c0000db4:	89 45 bc             	mov    %eax,-0x44(%ebp)
                            if(flags.sign)
c0000db7:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c0000dbe:	84 c0                	test   %al,%al
c0000dc0:	74 06                	je     c0000dc8 <kprintf+0x76f>
                                sign_char = '+';
c0000dc2:	c6 45 bb 2b          	movb   $0x2b,-0x45(%ebp)
c0000dc6:	eb 0f                	jmp    c0000dd7 <kprintf+0x77e>
                            else if(flags.space)
c0000dc8:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c0000dcf:	84 c0                	test   %al,%al
c0000dd1:	74 04                	je     c0000dd7 <kprintf+0x77e>
                                sign_char = ' ';
c0000dd3:	c6 45 bb 20          	movb   $0x20,-0x45(%ebp)
                            
                            //else positive number has no sign character
                        }

                        int int_len = format_uint(ui_part,val_buf,10,-1,0);
c0000dd7:	83 ec 0c             	sub    $0xc,%esp
c0000dda:	6a 00                	push   $0x0
c0000ddc:	6a ff                	push   $0xffffffff
c0000dde:	6a 0a                	push   $0xa
c0000de0:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000de6:	50                   	push   %eax
c0000de7:	ff 75 bc             	pushl  -0x44(%ebp)
c0000dea:	e8 3f 03 00 00       	call   c000112e <format_uint>
c0000def:	83 c4 20             	add    $0x20,%esp
c0000df2:	89 45 88             	mov    %eax,-0x78(%ebp)

                        int f_len = int_len + 1 + field_prec;
c0000df5:	8b 45 88             	mov    -0x78(%ebp),%eax
c0000df8:	8d 50 01             	lea    0x1(%eax),%edx
c0000dfb:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0000dfe:	01 d0                	add    %edx,%eax
c0000e00:	89 45 84             	mov    %eax,-0x7c(%ebp)

                        //amount of padding required to meet requested width
                        int lenpad = field_width - f_len; 
c0000e03:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000e06:	2b 45 84             	sub    -0x7c(%ebp),%eax
c0000e09:	89 45 b4             	mov    %eax,-0x4c(%ebp)

                        if(sign_char)
c0000e0c:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
c0000e10:	74 22                	je     c0000e34 <kprintf+0x7db>
                        {
                            lenpad--; //remove one char of padding to account for sign
c0000e12:	83 6d b4 01          	subl   $0x1,-0x4c(%ebp)
                            if(flags.zero)
c0000e16:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000e1d:	84 c0                	test   %al,%al
c0000e1f:	74 13                	je     c0000e34 <kprintf+0x7db>
                                nchar += kprint_char(sign_char); //if zero padding, sign is at beginning
c0000e21:	0f be 45 bb          	movsbl -0x45(%ebp),%eax
c0000e25:	83 ec 0c             	sub    $0xc,%esp
c0000e28:	50                   	push   %eax
c0000e29:	e8 da f7 ff ff       	call   c0000608 <kprint_char>
c0000e2e:	83 c4 10             	add    $0x10,%esp
c0000e31:	01 45 f0             	add    %eax,-0x10(%ebp)
                        }

                        if(!flags.left && lenpad>0)
c0000e34:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000e3b:	84 c0                	test   %al,%al
c0000e3d:	75 3b                	jne    c0000e7a <kprintf+0x821>
c0000e3f:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
c0000e43:	7e 35                	jle    c0000e7a <kprintf+0x821>
                        {
                            if(flags.zero)
c0000e45:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000e4c:	84 c0                	test   %al,%al
c0000e4e:	74 16                	je     c0000e66 <kprintf+0x80d>
                                nchar += kprintn_char('0', lenpad);
c0000e50:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c0000e53:	83 ec 08             	sub    $0x8,%esp
c0000e56:	50                   	push   %eax
c0000e57:	6a 30                	push   $0x30
c0000e59:	e8 d2 f7 ff ff       	call   c0000630 <kprintn_char>
c0000e5e:	83 c4 10             	add    $0x10,%esp
c0000e61:	01 45 f0             	add    %eax,-0x10(%ebp)
c0000e64:	eb 14                	jmp    c0000e7a <kprintf+0x821>
                            else
                                nchar += kprintn_char(' ', lenpad);
c0000e66:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c0000e69:	83 ec 08             	sub    $0x8,%esp
c0000e6c:	50                   	push   %eax
c0000e6d:	6a 20                	push   $0x20
c0000e6f:	e8 bc f7 ff ff       	call   c0000630 <kprintn_char>
c0000e74:	83 c4 10             	add    $0x10,%esp
c0000e77:	01 45 f0             	add    %eax,-0x10(%ebp)
                        }

                        if(!flags.zero && sign_char)
c0000e7a:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000e81:	84 c0                	test   %al,%al
c0000e83:	75 19                	jne    c0000e9e <kprintf+0x845>
c0000e85:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
c0000e89:	74 13                	je     c0000e9e <kprintf+0x845>
                            nchar += kprint_char(sign_char); //if not zero padding, write sign here
c0000e8b:	0f be 45 bb          	movsbl -0x45(%ebp),%eax
c0000e8f:	83 ec 0c             	sub    $0xc,%esp
c0000e92:	50                   	push   %eax
c0000e93:	e8 70 f7 ff ff       	call   c0000608 <kprint_char>
c0000e98:	83 c4 10             	add    $0x10,%esp
c0000e9b:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprint(val_buf);
c0000e9e:	83 ec 0c             	sub    $0xc,%esp
c0000ea1:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000ea7:	50                   	push   %eax
c0000ea8:	e8 11 f7 ff ff       	call   c00005be <kprint>
c0000ead:	83 c4 10             	add    $0x10,%esp
c0000eb0:	01 45 f0             	add    %eax,-0x10(%ebp)
                        nchar += kprint_char('.');
c0000eb3:	83 ec 0c             	sub    $0xc,%esp
c0000eb6:	6a 2e                	push   $0x2e
c0000eb8:	e8 4b f7 ff ff       	call   c0000608 <kprint_char>
c0000ebd:	83 c4 10             	add    $0x10,%esp
c0000ec0:	01 45 f0             	add    %eax,-0x10(%ebp)

                        //compute fractional digits.
                        float frac = f_value<0 ? -f_value - ui_part : f_value - ui_part;
c0000ec3:	d9 45 8c             	flds   -0x74(%ebp)
c0000ec6:	d9 ee                	fldz   
c0000ec8:	df f1                	fcomip %st(1),%st
c0000eca:	dd d8                	fstp   %st(0)
c0000ecc:	76 23                	jbe    c0000ef1 <kprintf+0x898>
c0000ece:	d9 45 8c             	flds   -0x74(%ebp)
c0000ed1:	d9 e0                	fchs   
c0000ed3:	8b 45 bc             	mov    -0x44(%ebp),%eax
c0000ed6:	ba 00 00 00 00       	mov    $0x0,%edx
c0000edb:	89 85 58 fd ff ff    	mov    %eax,-0x2a8(%ebp)
c0000ee1:	89 95 5c fd ff ff    	mov    %edx,-0x2a4(%ebp)
c0000ee7:	df ad 58 fd ff ff    	fildll -0x2a8(%ebp)
c0000eed:	de e9                	fsubrp %st,%st(1)
c0000eef:	eb 1f                	jmp    c0000f10 <kprintf+0x8b7>
c0000ef1:	8b 45 bc             	mov    -0x44(%ebp),%eax
c0000ef4:	ba 00 00 00 00       	mov    $0x0,%edx
c0000ef9:	89 85 58 fd ff ff    	mov    %eax,-0x2a8(%ebp)
c0000eff:	89 95 5c fd ff ff    	mov    %edx,-0x2a4(%ebp)
c0000f05:	df ad 58 fd ff ff    	fildll -0x2a8(%ebp)
c0000f0b:	d9 45 8c             	flds   -0x74(%ebp)
c0000f0e:	de e1                	fsubp  %st,%st(1)
c0000f10:	d9 5d b0             	fstps  -0x50(%ebp)
                        int d;
                        for(int nn=0;nn<field_prec; nn++)
c0000f13:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
c0000f1a:	eb 5e                	jmp    c0000f7a <kprintf+0x921>
                        {
                            frac *= 10.;
c0000f1c:	d9 45 b0             	flds   -0x50(%ebp)
c0000f1f:	d9 05 1c 44 00 c0    	flds   0xc000441c
c0000f25:	de c9                	fmulp  %st,%st(1)
c0000f27:	d9 5d b0             	fstps  -0x50(%ebp)
                            d = (int) frac;
c0000f2a:	d9 45 b0             	flds   -0x50(%ebp)
c0000f2d:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c0000f33:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c0000f3a:	80 cc 0c             	or     $0xc,%ah
c0000f3d:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c0000f44:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c0000f4a:	db 5d 80             	fistpl -0x80(%ebp)
c0000f4d:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
                            frac -= d;
c0000f53:	db 45 80             	fildl  -0x80(%ebp)
c0000f56:	d9 45 b0             	flds   -0x50(%ebp)
c0000f59:	de e1                	fsubp  %st,%st(1)
c0000f5b:	d9 5d b0             	fstps  -0x50(%ebp)
                            nchar += kprint_char('0' + d);
c0000f5e:	8b 45 80             	mov    -0x80(%ebp),%eax
c0000f61:	83 c0 30             	add    $0x30,%eax
c0000f64:	0f be c0             	movsbl %al,%eax
c0000f67:	83 ec 0c             	sub    $0xc,%esp
c0000f6a:	50                   	push   %eax
c0000f6b:	e8 98 f6 ff ff       	call   c0000608 <kprint_char>
c0000f70:	83 c4 10             	add    $0x10,%esp
c0000f73:	01 45 f0             	add    %eax,-0x10(%ebp)
                        for(int nn=0;nn<field_prec; nn++)
c0000f76:	83 45 ac 01          	addl   $0x1,-0x54(%ebp)
c0000f7a:	8b 45 ac             	mov    -0x54(%ebp),%eax
c0000f7d:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c0000f80:	7c 9a                	jl     c0000f1c <kprintf+0x8c3>
                        }

                        if(flags.left && lenpad>0)
c0000f82:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000f89:	84 c0                	test   %al,%al
c0000f8b:	0f 84 5e 01 00 00    	je     c00010ef <kprintf+0xa96>
c0000f91:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
c0000f95:	0f 8e 54 01 00 00    	jle    c00010ef <kprintf+0xa96>
                            nchar += kprintn_char(' ', lenpad);
c0000f9b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c0000f9e:	83 ec 08             	sub    $0x8,%esp
c0000fa1:	50                   	push   %eax
c0000fa2:	6a 20                	push   $0x20
c0000fa4:	e8 87 f6 ff ff       	call   c0000630 <kprintn_char>
c0000fa9:	83 c4 10             	add    $0x10,%esp
c0000fac:	01 45 f0             	add    %eax,-0x10(%ebp)

                    }
                    break;
c0000faf:	e9 3b 01 00 00       	jmp    c00010ef <kprintf+0xa96>
                case 'e':
                case 'E':
                case 'g':
                case 'G':
                    return -1; // not yet implemented
c0000fb4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000fb9:	e9 6e 01 00 00       	jmp    c000112c <kprintf+0xad3>
                case 'c':
                    {
                        char c = (char) va_arg(valist, int);
c0000fbe:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000fc4:	8d 50 04             	lea    0x4(%eax),%edx
c0000fc7:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000fcd:	8b 00                	mov    (%eax),%eax
c0000fcf:	88 45 9b             	mov    %al,-0x65(%ebp)

                        if(field_width>1 && !flags.left)    
c0000fd2:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
c0000fd6:	7e 22                	jle    c0000ffa <kprintf+0x9a1>
c0000fd8:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000fdf:	84 c0                	test   %al,%al
c0000fe1:	75 17                	jne    c0000ffa <kprintf+0x9a1>
                            nchar += kprintn_char(' ', field_width-1);
c0000fe3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000fe6:	83 e8 01             	sub    $0x1,%eax
c0000fe9:	83 ec 08             	sub    $0x8,%esp
c0000fec:	50                   	push   %eax
c0000fed:	6a 20                	push   $0x20
c0000fef:	e8 3c f6 ff ff       	call   c0000630 <kprintn_char>
c0000ff4:	83 c4 10             	add    $0x10,%esp
c0000ff7:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprint_char(c);
c0000ffa:	0f be 45 9b          	movsbl -0x65(%ebp),%eax
c0000ffe:	83 ec 0c             	sub    $0xc,%esp
c0001001:	50                   	push   %eax
c0001002:	e8 01 f6 ff ff       	call   c0000608 <kprint_char>
c0001007:	83 c4 10             	add    $0x10,%esp
c000100a:	01 45 f0             	add    %eax,-0x10(%ebp)

                        if(field_width>1 && flags.left)    
c000100d:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
c0001011:	0f 8e db 00 00 00    	jle    c00010f2 <kprintf+0xa99>
c0001017:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c000101e:	84 c0                	test   %al,%al
c0001020:	0f 84 cc 00 00 00    	je     c00010f2 <kprintf+0xa99>
                            nchar += kprintn_char(' ', field_width-1);
c0001026:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001029:	83 e8 01             	sub    $0x1,%eax
c000102c:	83 ec 08             	sub    $0x8,%esp
c000102f:	50                   	push   %eax
c0001030:	6a 20                	push   $0x20
c0001032:	e8 f9 f5 ff ff       	call   c0000630 <kprintn_char>
c0001037:	83 c4 10             	add    $0x10,%esp
c000103a:	01 45 f0             	add    %eax,-0x10(%ebp)
                    }                    
                    break;
c000103d:	e9 b0 00 00 00       	jmp    c00010f2 <kprintf+0xa99>

                case 's':
                    {
                        char* str = va_arg(valist, char*);
c0001042:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0001048:	8d 50 04             	lea    0x4(%eax),%edx
c000104b:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0001051:	8b 00                	mov    (%eax),%eax
c0001053:	89 45 a4             	mov    %eax,-0x5c(%ebp)
                        int len = strlen(str);
c0001056:	83 ec 0c             	sub    $0xc,%esp
c0001059:	ff 75 a4             	pushl  -0x5c(%ebp)
c000105c:	e8 2b 04 00 00       	call   c000148c <strlen>
c0001061:	83 c4 10             	add    $0x10,%esp
c0001064:	89 45 a8             	mov    %eax,-0x58(%ebp)
                        if(field_prec > 0 && field_prec < len)
c0001067:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c000106b:	7e 0e                	jle    c000107b <kprintf+0xa22>
c000106d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001070:	3b 45 a8             	cmp    -0x58(%ebp),%eax
c0001073:	7d 06                	jge    c000107b <kprintf+0xa22>
                            len = field_prec;
c0001075:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001078:	89 45 a8             	mov    %eax,-0x58(%ebp)

                        int lenpad = field_width - len; 
c000107b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000107e:	2b 45 a8             	sub    -0x58(%ebp),%eax
c0001081:	89 45 a0             	mov    %eax,-0x60(%ebp)

                        if(lenpad>0 && !flags.left)    
c0001084:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
c0001088:	7e 1f                	jle    c00010a9 <kprintf+0xa50>
c000108a:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0001091:	84 c0                	test   %al,%al
c0001093:	75 14                	jne    c00010a9 <kprintf+0xa50>
                            nchar += kprintn_char(' ', lenpad);
c0001095:	8b 45 a0             	mov    -0x60(%ebp),%eax
c0001098:	83 ec 08             	sub    $0x8,%esp
c000109b:	50                   	push   %eax
c000109c:	6a 20                	push   $0x20
c000109e:	e8 8d f5 ff ff       	call   c0000630 <kprintn_char>
c00010a3:	83 c4 10             	add    $0x10,%esp
c00010a6:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprintn(str,len);
c00010a9:	8b 45 a8             	mov    -0x58(%ebp),%eax
c00010ac:	83 ec 08             	sub    $0x8,%esp
c00010af:	50                   	push   %eax
c00010b0:	ff 75 a4             	pushl  -0x5c(%ebp)
c00010b3:	e8 2f f5 ff ff       	call   c00005e7 <kprintn>
c00010b8:	83 c4 10             	add    $0x10,%esp
c00010bb:	01 45 f0             	add    %eax,-0x10(%ebp)

                        if(lenpad>0 && flags.left)
c00010be:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
c00010c2:	7e 31                	jle    c00010f5 <kprintf+0xa9c>
c00010c4:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c00010cb:	84 c0                	test   %al,%al
c00010cd:	74 26                	je     c00010f5 <kprintf+0xa9c>
                            nchar += kprintn_char(' ', lenpad);
c00010cf:	8b 45 a0             	mov    -0x60(%ebp),%eax
c00010d2:	83 ec 08             	sub    $0x8,%esp
c00010d5:	50                   	push   %eax
c00010d6:	6a 20                	push   $0x20
c00010d8:	e8 53 f5 ff ff       	call   c0000630 <kprintn_char>
c00010dd:	83 c4 10             	add    $0x10,%esp
c00010e0:	01 45 f0             	add    %eax,-0x10(%ebp)
                        
                    }
                    break;
c00010e3:	eb 10                	jmp    c00010f5 <kprintf+0xa9c>
                default:
                    //unsupported type
                    return -1;
c00010e5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00010ea:	eb 40                	jmp    c000112c <kprintf+0xad3>
                            break;
c00010ec:	90                   	nop
c00010ed:	eb 07                	jmp    c00010f6 <kprintf+0xa9d>
                    break;
c00010ef:	90                   	nop
c00010f0:	eb 04                	jmp    c00010f6 <kprintf+0xa9d>
                    break;
c00010f2:	90                   	nop
c00010f3:	eb 01                	jmp    c00010f6 <kprintf+0xa9d>
                    break;
c00010f5:	90                   	nop
                
            }
            f++;
c00010f6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00010fa:	eb 1f                	jmp    c000111b <kprintf+0xac2>
        }
        else
        {
            //this isnt part of a format code, just copy char to string and increment pointers
            kprint_char(*(f++));
c00010fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00010ff:	8d 50 01             	lea    0x1(%eax),%edx
c0001102:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0001105:	0f b6 00             	movzbl (%eax),%eax
c0001108:	0f be c0             	movsbl %al,%eax
c000110b:	83 ec 0c             	sub    $0xc,%esp
c000110e:	50                   	push   %eax
c000110f:	e8 f4 f4 ff ff       	call   c0000608 <kprint_char>
c0001114:	83 c4 10             	add    $0x10,%esp
            nchar++;
c0001117:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    while(f[0] != 0)
c000111b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000111e:	0f b6 00             	movzbl (%eax),%eax
c0001121:	84 c0                	test   %al,%al
c0001123:	0f 85 54 f5 ff ff    	jne    c000067d <kprintf+0x24>
    }

   /* clean memory reserved for valist */
   va_end(valist);

   return nchar; //number of characters copied to str
c0001129:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c000112c:	c9                   	leave  
c000112d:	c3                   	ret    

c000112e <format_uint>:
// base may be 2-32
// precision is per printf format, precision<0 represents default (unspecified) 
// cap = 0, alpha-numbers are capitalized [base>10 only]
// returns length of string (not counting null termination)
int format_uint(unsigned int value, char* str, unsigned int base, int precision, int cap)
{
c000112e:	55                   	push   %ebp
c000112f:	89 e5                	mov    %esp,%ebp
c0001131:	83 ec 18             	sub    $0x18,%esp
    if(base < 2 || base > 32)
c0001134:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c0001138:	76 06                	jbe    c0001140 <format_uint+0x12>
c000113a:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
c000113e:	76 0a                	jbe    c000114a <format_uint+0x1c>
        return -1;
c0001140:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0001145:	e9 d1 00 00 00       	jmp    c000121b <format_uint+0xed>

    //When 0 is printed with an explicit precision 0, the output is empty.
    if(value==0 && precision==0)
c000114a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c000114e:	75 16                	jne    c0001166 <format_uint+0x38>
c0001150:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c0001154:	75 10                	jne    c0001166 <format_uint+0x38>
    {
        str[0] = 0;
c0001156:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001159:	c6 00 00             	movb   $0x0,(%eax)
        return 0;
c000115c:	b8 00 00 00 00       	mov    $0x0,%eax
c0001161:	e9 b5 00 00 00       	jmp    c000121b <format_uint+0xed>
    }

    // find number of digits
    int num_digits = numdigits_uint(value, base);
c0001166:	83 ec 08             	sub    $0x8,%esp
c0001169:	ff 75 10             	pushl  0x10(%ebp)
c000116c:	ff 75 08             	pushl  0x8(%ebp)
c000116f:	e8 a9 00 00 00       	call   c000121d <numdigits_uint>
c0001174:	83 c4 10             	add    $0x10,%esp
c0001177:	89 45 ec             	mov    %eax,-0x14(%ebp)
    num_digits = num_digits>precision ? num_digits : precision;
c000117a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000117d:	39 45 14             	cmp    %eax,0x14(%ebp)
c0001180:	0f 4d 45 14          	cmovge 0x14(%ebp),%eax
c0001184:	89 45 ec             	mov    %eax,-0x14(%ebp)

    //write formatted number out in reverse order
    char* s = str + num_digits;
c0001187:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000118a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000118d:	01 d0                	add    %edx,%eax
c000118f:	89 45 f4             	mov    %eax,-0xc(%ebp)

    *(s--) = '\0'; //null termination
c0001192:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001195:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001198:	89 55 f4             	mov    %edx,-0xc(%ebp)
c000119b:	c6 00 00             	movb   $0x0,(%eax)

    //compute each digit from lowest to highest.
    unsigned int d;
    for(int nn=0;nn<num_digits; nn++)
c000119e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00011a5:	eb 69                	jmp    c0001210 <format_uint+0xe2>
    {
        d = value % base;
c00011a7:	8b 45 08             	mov    0x8(%ebp),%eax
c00011aa:	ba 00 00 00 00       	mov    $0x0,%edx
c00011af:	f7 75 10             	divl   0x10(%ebp)
c00011b2:	89 55 e8             	mov    %edx,-0x18(%ebp)
        value /= base;
c00011b5:	8b 45 08             	mov    0x8(%ebp),%eax
c00011b8:	ba 00 00 00 00       	mov    $0x0,%edx
c00011bd:	f7 75 10             	divl   0x10(%ebp)
c00011c0:	89 45 08             	mov    %eax,0x8(%ebp)

        //write digit into string and decrement pointer
        if(d < 10)
c00011c3:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
c00011c7:	77 15                	ja     c00011de <format_uint+0xb0>
            *(s--) = d + '0';
c00011c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00011cc:	8d 48 30             	lea    0x30(%eax),%ecx
c00011cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00011d2:	8d 50 ff             	lea    -0x1(%eax),%edx
c00011d5:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00011d8:	89 ca                	mov    %ecx,%edx
c00011da:	88 10                	mov    %dl,(%eax)
c00011dc:	eb 2e                	jmp    c000120c <format_uint+0xde>
        else if(cap == 0)
c00011de:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
c00011e2:	75 15                	jne    c00011f9 <format_uint+0xcb>
            *(s--) = d - 10 + 'a';
c00011e4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00011e7:	8d 48 57             	lea    0x57(%eax),%ecx
c00011ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00011ed:	8d 50 ff             	lea    -0x1(%eax),%edx
c00011f0:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00011f3:	89 ca                	mov    %ecx,%edx
c00011f5:	88 10                	mov    %dl,(%eax)
c00011f7:	eb 13                	jmp    c000120c <format_uint+0xde>
        else
            *(s--) = d - 10 + 'A';
c00011f9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00011fc:	8d 48 37             	lea    0x37(%eax),%ecx
c00011ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001202:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001205:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0001208:	89 ca                	mov    %ecx,%edx
c000120a:	88 10                	mov    %dl,(%eax)
    for(int nn=0;nn<num_digits; nn++)
c000120c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0001210:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001213:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0001216:	7c 8f                	jl     c00011a7 <format_uint+0x79>
    }

    return num_digits;
c0001218:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c000121b:	c9                   	leave  
c000121c:	c3                   	ret    

c000121d <numdigits_uint>:


//returns number of digits of unsigned int represented in given base
//num_digits is always >= 1
unsigned int numdigits_uint(unsigned int value, unsigned int base)
{
c000121d:	55                   	push   %ebp
c000121e:	89 e5                	mov    %esp,%ebp
c0001220:	83 ec 10             	sub    $0x10,%esp
    unsigned int num_digits = 1;
c0001223:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
    while(value >= base)
c000122a:	eb 12                	jmp    c000123e <numdigits_uint+0x21>
    {
        num_digits++;
c000122c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        value /= base;
c0001230:	8b 45 08             	mov    0x8(%ebp),%eax
c0001233:	ba 00 00 00 00       	mov    $0x0,%edx
c0001238:	f7 75 0c             	divl   0xc(%ebp)
c000123b:	89 45 08             	mov    %eax,0x8(%ebp)
    while(value >= base)
c000123e:	8b 45 08             	mov    0x8(%ebp),%eax
c0001241:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0001244:	73 e6                	jae    c000122c <numdigits_uint+0xf>
    }
    return num_digits;
c0001246:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0001249:	c9                   	leave  
c000124a:	c3                   	ret    

c000124b <kprintf_test>:



void kprintf_test()
{
c000124b:	55                   	push   %ebp
c000124c:	89 e5                	mov    %esp,%ebp
c000124e:	83 ec 18             	sub    $0x18,%esp
    int num = 12345678;    
c0001251:	c7 45 f4 4e 61 bc 00 	movl   $0xbc614e,-0xc(%ebp)
    kprintf("\nkprintf() tests...\n", num);
c0001258:	83 ec 08             	sub    $0x8,%esp
c000125b:	ff 75 f4             	pushl  -0xc(%ebp)
c000125e:	68 d0 41 00 c0       	push   $0xc00041d0
c0001263:	e8 f1 f3 ff ff       	call   c0000659 <kprintf>
c0001268:	83 c4 10             	add    $0x10,%esp
    kprintf("Fixed width, right justify:\n");
c000126b:	83 ec 0c             	sub    $0xc,%esp
c000126e:	68 e5 41 00 c0       	push   $0xc00041e5
c0001273:	e8 e1 f3 ff ff       	call   c0000659 <kprintf>
c0001278:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%15d]\n", num);
c000127b:	83 ec 08             	sub    $0x8,%esp
c000127e:	ff 75 f4             	pushl  -0xc(%ebp)
c0001281:	68 02 42 00 c0       	push   $0xc0004202
c0001286:	e8 ce f3 ff ff       	call   c0000659 <kprintf>
c000128b:	83 c4 10             	add    $0x10,%esp
    kprintf("Hex:     [%#15x]\n", num);
c000128e:	83 ec 08             	sub    $0x8,%esp
c0001291:	ff 75 f4             	pushl  -0xc(%ebp)
c0001294:	68 13 42 00 c0       	push   $0xc0004213
c0001299:	e8 bb f3 ff ff       	call   c0000659 <kprintf>
c000129e:	83 c4 10             	add    $0x10,%esp
    kprintf("Oct:     [%#15o]\n", num);
c00012a1:	83 ec 08             	sub    $0x8,%esp
c00012a4:	ff 75 f4             	pushl  -0xc(%ebp)
c00012a7:	68 25 42 00 c0       	push   $0xc0004225
c00012ac:	e8 a8 f3 ff ff       	call   c0000659 <kprintf>
c00012b1:	83 c4 10             	add    $0x10,%esp
    kprintf("String:  [%15s]\n", "Hello World!");
c00012b4:	83 ec 08             	sub    $0x8,%esp
c00012b7:	68 37 42 00 c0       	push   $0xc0004237
c00012bc:	68 44 42 00 c0       	push   $0xc0004244
c00012c1:	e8 93 f3 ff ff       	call   c0000659 <kprintf>
c00012c6:	83 c4 10             	add    $0x10,%esp
    kprintf("Char:    [%15c]\n", '!');
c00012c9:	83 ec 08             	sub    $0x8,%esp
c00012cc:	6a 21                	push   $0x21
c00012ce:	68 55 42 00 c0       	push   $0xc0004255
c00012d3:	e8 81 f3 ff ff       	call   c0000659 <kprintf>
c00012d8:	83 c4 10             	add    $0x10,%esp

    kprintf("\nFixed width, left justify:\n");
c00012db:	83 ec 0c             	sub    $0xc,%esp
c00012de:	68 66 42 00 c0       	push   $0xc0004266
c00012e3:	e8 71 f3 ff ff       	call   c0000659 <kprintf>
c00012e8:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%-15d]\n", num);
c00012eb:	83 ec 08             	sub    $0x8,%esp
c00012ee:	ff 75 f4             	pushl  -0xc(%ebp)
c00012f1:	68 83 42 00 c0       	push   $0xc0004283
c00012f6:	e8 5e f3 ff ff       	call   c0000659 <kprintf>
c00012fb:	83 c4 10             	add    $0x10,%esp
    kprintf("Hex:     [%-#15x]\n", num);
c00012fe:	83 ec 08             	sub    $0x8,%esp
c0001301:	ff 75 f4             	pushl  -0xc(%ebp)
c0001304:	68 95 42 00 c0       	push   $0xc0004295
c0001309:	e8 4b f3 ff ff       	call   c0000659 <kprintf>
c000130e:	83 c4 10             	add    $0x10,%esp
    kprintf("String:  [%-15s]\n", "Hello World!");
c0001311:	83 ec 08             	sub    $0x8,%esp
c0001314:	68 37 42 00 c0       	push   $0xc0004237
c0001319:	68 a8 42 00 c0       	push   $0xc00042a8
c000131e:	e8 36 f3 ff ff       	call   c0000659 <kprintf>
c0001323:	83 c4 10             	add    $0x10,%esp

    kprintf("\nFixed Precision:\n");
c0001326:	83 ec 0c             	sub    $0xc,%esp
c0001329:	68 ba 42 00 c0       	push   $0xc00042ba
c000132e:	e8 26 f3 ff ff       	call   c0000659 <kprintf>
c0001333:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%15.10d]\nHex:     [%#15.10x]\nOct:     [%#15.10o]\nString:  [%15.10s]\n", 
c0001336:	83 ec 0c             	sub    $0xc,%esp
c0001339:	68 37 42 00 c0       	push   $0xc0004237
c000133e:	ff 75 f4             	pushl  -0xc(%ebp)
c0001341:	ff 75 f4             	pushl  -0xc(%ebp)
c0001344:	ff 75 f4             	pushl  -0xc(%ebp)
c0001347:	68 d0 42 00 c0       	push   $0xc00042d0
c000134c:	e8 08 f3 ff ff       	call   c0000659 <kprintf>
c0001351:	83 c4 20             	add    $0x20,%esp
        num, num, num, "Hello World!");

    kprintf("\nLeading Zeros:\n");
c0001354:	83 ec 0c             	sub    $0xc,%esp
c0001357:	68 1f 43 00 c0       	push   $0xc000431f
c000135c:	e8 f8 f2 ff ff       	call   c0000659 <kprintf>
c0001361:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%015.10d]\nHex:     [%#015.10x]\nOct:     [%#015.10o]\n",num, num, num);
c0001364:	ff 75 f4             	pushl  -0xc(%ebp)
c0001367:	ff 75 f4             	pushl  -0xc(%ebp)
c000136a:	ff 75 f4             	pushl  -0xc(%ebp)
c000136d:	68 30 43 00 c0       	push   $0xc0004330
c0001372:	e8 e2 f2 ff ff       	call   c0000659 <kprintf>
c0001377:	83 c4 10             	add    $0x10,%esp

    kprintf("Signed (none):  [%d], [%d]\n",num, -num);
c000137a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000137d:	f7 d8                	neg    %eax
c000137f:	83 ec 04             	sub    $0x4,%esp
c0001382:	50                   	push   %eax
c0001383:	ff 75 f4             	pushl  -0xc(%ebp)
c0001386:	68 6f 43 00 c0       	push   $0xc000436f
c000138b:	e8 c9 f2 ff ff       	call   c0000659 <kprintf>
c0001390:	83 c4 10             	add    $0x10,%esp
    kprintf("Signed (space): [% d], [% d]\n",num, -num);
c0001393:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001396:	f7 d8                	neg    %eax
c0001398:	83 ec 04             	sub    $0x4,%esp
c000139b:	50                   	push   %eax
c000139c:	ff 75 f4             	pushl  -0xc(%ebp)
c000139f:	68 8b 43 00 c0       	push   $0xc000438b
c00013a4:	e8 b0 f2 ff ff       	call   c0000659 <kprintf>
c00013a9:	83 c4 10             	add    $0x10,%esp
    kprintf("Signed (+):     [%+d], [%+d]\n",num, -num);
c00013ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00013af:	f7 d8                	neg    %eax
c00013b1:	83 ec 04             	sub    $0x4,%esp
c00013b4:	50                   	push   %eax
c00013b5:	ff 75 f4             	pushl  -0xc(%ebp)
c00013b8:	68 a9 43 00 c0       	push   $0xc00043a9
c00013bd:	e8 97 f2 ff ff       	call   c0000659 <kprintf>
c00013c2:	83 c4 10             	add    $0x10,%esp

    float f = 1.23456789;
c00013c5:	d9 05 20 44 00 c0    	flds   0xc0004420
c00013cb:	d9 5d f0             	fstps  -0x10(%ebp)
    kprintf("\nfloat:     [%15.f]\n",f);
c00013ce:	d9 45 f0             	flds   -0x10(%ebp)
c00013d1:	83 ec 04             	sub    $0x4,%esp
c00013d4:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c00013d8:	dd 1c 24             	fstpl  (%esp)
c00013db:	68 c7 43 00 c0       	push   $0xc00043c7
c00013e0:	e8 74 f2 ff ff       	call   c0000659 <kprintf>
c00013e5:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.3f]\n",f);
c00013e8:	d9 45 f0             	flds   -0x10(%ebp)
c00013eb:	83 ec 04             	sub    $0x4,%esp
c00013ee:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c00013f2:	dd 1c 24             	fstpl  (%esp)
c00013f5:	68 dc 43 00 c0       	push   $0xc00043dc
c00013fa:	e8 5a f2 ff ff       	call   c0000659 <kprintf>
c00013ff:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.10f]\n",f);
c0001402:	d9 45 f0             	flds   -0x10(%ebp)
c0001405:	83 ec 04             	sub    $0x4,%esp
c0001408:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c000140c:	dd 1c 24             	fstpl  (%esp)
c000140f:	68 f1 43 00 c0       	push   $0xc00043f1
c0001414:	e8 40 f2 ff ff       	call   c0000659 <kprintf>
c0001419:	83 c4 10             	add    $0x10,%esp

    f = -12345.6789;
c000141c:	d9 05 24 44 00 c0    	flds   0xc0004424
c0001422:	d9 5d f0             	fstps  -0x10(%ebp)
    kprintf("float:     [%15f]\n",f);
c0001425:	d9 45 f0             	flds   -0x10(%ebp)
c0001428:	83 ec 04             	sub    $0x4,%esp
c000142b:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c000142f:	dd 1c 24             	fstpl  (%esp)
c0001432:	68 07 44 00 c0       	push   $0xc0004407
c0001437:	e8 1d f2 ff ff       	call   c0000659 <kprintf>
c000143c:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.3f]\n",f);
c000143f:	d9 45 f0             	flds   -0x10(%ebp)
c0001442:	83 ec 04             	sub    $0x4,%esp
c0001445:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001449:	dd 1c 24             	fstpl  (%esp)
c000144c:	68 dc 43 00 c0       	push   $0xc00043dc
c0001451:	e8 03 f2 ff ff       	call   c0000659 <kprintf>
c0001456:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.10f]\n",f);
c0001459:	d9 45 f0             	flds   -0x10(%ebp)
c000145c:	83 ec 04             	sub    $0x4,%esp
c000145f:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001463:	dd 1c 24             	fstpl  (%esp)
c0001466:	68 f1 43 00 c0       	push   $0xc00043f1
c000146b:	e8 e9 f1 ff ff       	call   c0000659 <kprintf>
c0001470:	83 c4 10             	add    $0x10,%esp
}
c0001473:	90                   	nop
c0001474:	c9                   	leave  
c0001475:	c3                   	ret    

c0001476 <panic>:
#include "common.h"
#include "kprintf.h"

void panic(char* str)
{
c0001476:	55                   	push   %ebp
c0001477:	89 e5                	mov    %esp,%ebp
c0001479:	83 ec 08             	sub    $0x8,%esp
    kprintf(str);
c000147c:	83 ec 0c             	sub    $0xc,%esp
c000147f:	ff 75 08             	pushl  0x8(%ebp)
c0001482:	e8 d2 f1 ff ff       	call   c0000659 <kprintf>
c0001487:	83 c4 10             	add    $0x10,%esp
    while(1);
c000148a:	eb fe                	jmp    c000148a <panic+0x14>

c000148c <strlen>:
}

size_t strlen(const char* str) 
{
c000148c:	55                   	push   %ebp
c000148d:	89 e5                	mov    %esp,%ebp
c000148f:	83 ec 10             	sub    $0x10,%esp
	size_t len = 0;
c0001492:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while (str[len])
c0001499:	eb 04                	jmp    c000149f <strlen+0x13>
		len++;
c000149b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
	while (str[len])
c000149f:	8b 55 08             	mov    0x8(%ebp),%edx
c00014a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00014a5:	01 d0                	add    %edx,%eax
c00014a7:	0f b6 00             	movzbl (%eax),%eax
c00014aa:	84 c0                	test   %al,%al
c00014ac:	75 ed                	jne    c000149b <strlen+0xf>
	return len;
c00014ae:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00014b1:	c9                   	leave  
c00014b2:	c3                   	ret    

c00014b3 <memcpy>:

// copy n bytes from src to dest
void *memcpy(void *dest, const void *src, size_t n)
{
c00014b3:	55                   	push   %ebp
c00014b4:	89 e5                	mov    %esp,%ebp
c00014b6:	83 ec 20             	sub    $0x20,%esp
    //system wordsize is equal to length of size_t
    size_t n_words = n/sizeof(size_t);
c00014b9:	8b 45 10             	mov    0x10(%ebp),%eax
c00014bc:	c1 e8 02             	shr    $0x2,%eax
c00014bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t* dest_word = (size_t *) dest;
c00014c2:	8b 45 08             	mov    0x8(%ebp),%eax
c00014c5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    size_t* src_word = (size_t *) src;
c00014c8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00014cb:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for(size_t nn=0; nn<n_words; nn++)
c00014ce:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00014d5:	eb 26                	jmp    c00014fd <memcpy+0x4a>
        dest_word[nn]=src_word[nn];
c00014d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00014da:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c00014e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00014e4:	01 d0                	add    %edx,%eax
c00014e6:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00014e9:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
c00014f0:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00014f3:	01 ca                	add    %ecx,%edx
c00014f5:	8b 00                	mov    (%eax),%eax
c00014f7:	89 02                	mov    %eax,(%edx)
    for(size_t nn=0; nn<n_words; nn++)
c00014f9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c00014fd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001500:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0001503:	72 d2                	jb     c00014d7 <memcpy+0x24>
    
    //copy remaining bytes
    size_t n_bytes = n - n_words*sizeof(size_t);
c0001505:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001508:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000150f:	8b 45 10             	mov    0x10(%ebp),%eax
c0001512:	29 d0                	sub    %edx,%eax
c0001514:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(n_bytes > 0)
c0001517:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c000151b:	74 36                	je     c0001553 <memcpy+0xa0>
    {
        char* dest_byte = (char *) dest;
c000151d:	8b 45 08             	mov    0x8(%ebp),%eax
c0001520:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        char* src_byte = (char *) src;
c0001523:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001526:	89 45 e0             	mov    %eax,-0x20(%ebp)
        for(size_t nn=0; nn<n_bytes; nn++)
c0001529:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0001530:	eb 19                	jmp    c000154b <memcpy+0x98>
            dest_byte[nn]=src_byte[nn];
c0001532:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0001535:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0001538:	01 d0                	add    %edx,%eax
c000153a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c000153d:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0001540:	01 ca                	add    %ecx,%edx
c0001542:	0f b6 00             	movzbl (%eax),%eax
c0001545:	88 02                	mov    %al,(%edx)
        for(size_t nn=0; nn<n_bytes; nn++)
c0001547:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c000154b:	8b 45 f8             	mov    -0x8(%ebp),%eax
c000154e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0001551:	72 df                	jb     c0001532 <memcpy+0x7f>
    }

    return dest;
c0001553:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0001556:	c9                   	leave  
c0001557:	c3                   	ret    

c0001558 <memset>:

void* memset(void* addr, int val, size_t cnt)
{
c0001558:	55                   	push   %ebp
c0001559:	89 e5                	mov    %esp,%ebp
c000155b:	83 ec 10             	sub    $0x10,%esp
    char* m = (char*) addr;
c000155e:	8b 45 08             	mov    0x8(%ebp),%eax
c0001561:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for(size_t nn=0;nn<cnt; nn++)
c0001564:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c000156b:	eb 11                	jmp    c000157e <memset+0x26>
        m[nn] = val;
c000156d:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0001570:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001573:	01 d0                	add    %edx,%eax
c0001575:	8b 55 0c             	mov    0xc(%ebp),%edx
c0001578:	88 10                	mov    %dl,(%eax)
    for(size_t nn=0;nn<cnt; nn++)
c000157a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c000157e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001581:	3b 45 10             	cmp    0x10(%ebp),%eax
c0001584:	72 e7                	jb     c000156d <memset+0x15>

    return addr;
c0001586:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0001589:	c9                   	leave  
c000158a:	c3                   	ret    

c000158b <atoi>:


int atoi(const char* str)
{
c000158b:	55                   	push   %ebp
c000158c:	89 e5                	mov    %esp,%ebp
c000158e:	83 ec 20             	sub    $0x20,%esp
    int p = 0;
c0001591:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    int neg = 0;
c0001598:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    //find start of number string, ignore whitespace
    while(str[p] == '-' || str[p] == ' ' || (str[p] >= 9 && str[p] <= 13))
c000159f:	eb 41                	jmp    c00015e2 <atoi+0x57>
    {
        if(str[p++] == '-')
c00015a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00015a4:	8d 50 01             	lea    0x1(%eax),%edx
c00015a7:	89 55 fc             	mov    %edx,-0x4(%ebp)
c00015aa:	89 c2                	mov    %eax,%edx
c00015ac:	8b 45 08             	mov    0x8(%ebp),%eax
c00015af:	01 d0                	add    %edx,%eax
c00015b1:	0f b6 00             	movzbl (%eax),%eax
c00015b4:	3c 2d                	cmp    $0x2d,%al
c00015b6:	75 09                	jne    c00015c1 <atoi+0x36>
        {
            neg=1;
c00015b8:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
            break;
c00015bf:	eb 5d                	jmp    c000161e <atoi+0x93>
        }
        if(str[p++] == '\0')
c00015c1:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00015c4:	8d 50 01             	lea    0x1(%eax),%edx
c00015c7:	89 55 fc             	mov    %edx,-0x4(%ebp)
c00015ca:	89 c2                	mov    %eax,%edx
c00015cc:	8b 45 08             	mov    0x8(%ebp),%eax
c00015cf:	01 d0                	add    %edx,%eax
c00015d1:	0f b6 00             	movzbl (%eax),%eax
c00015d4:	84 c0                	test   %al,%al
c00015d6:	75 0a                	jne    c00015e2 <atoi+0x57>
            return 0; //invalid string (only whitespace found)
c00015d8:	b8 00 00 00 00       	mov    $0x0,%eax
c00015dd:	e9 ee 00 00 00       	jmp    c00016d0 <atoi+0x145>
    while(str[p] == '-' || str[p] == ' ' || (str[p] >= 9 && str[p] <= 13))
c00015e2:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00015e5:	8b 45 08             	mov    0x8(%ebp),%eax
c00015e8:	01 d0                	add    %edx,%eax
c00015ea:	0f b6 00             	movzbl (%eax),%eax
c00015ed:	3c 2d                	cmp    $0x2d,%al
c00015ef:	74 b0                	je     c00015a1 <atoi+0x16>
c00015f1:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00015f4:	8b 45 08             	mov    0x8(%ebp),%eax
c00015f7:	01 d0                	add    %edx,%eax
c00015f9:	0f b6 00             	movzbl (%eax),%eax
c00015fc:	3c 20                	cmp    $0x20,%al
c00015fe:	74 a1                	je     c00015a1 <atoi+0x16>
c0001600:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0001603:	8b 45 08             	mov    0x8(%ebp),%eax
c0001606:	01 d0                	add    %edx,%eax
c0001608:	0f b6 00             	movzbl (%eax),%eax
c000160b:	3c 08                	cmp    $0x8,%al
c000160d:	7e 0f                	jle    c000161e <atoi+0x93>
c000160f:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0001612:	8b 45 08             	mov    0x8(%ebp),%eax
c0001615:	01 d0                	add    %edx,%eax
c0001617:	0f b6 00             	movzbl (%eax),%eax
c000161a:	3c 0d                	cmp    $0xd,%al
c000161c:	7e 83                	jle    c00015a1 <atoi+0x16>
    }

    int num_start = p;
c000161e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001621:	89 45 e8             	mov    %eax,-0x18(%ebp)

    //find end of integer string (ints only, no decimal point)
    while(str[p] >= '0' && str[p] <= '9')
c0001624:	eb 21                	jmp    c0001647 <atoi+0xbc>
    {
        if(str[p++] == '\0')
c0001626:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001629:	8d 50 01             	lea    0x1(%eax),%edx
c000162c:	89 55 fc             	mov    %edx,-0x4(%ebp)
c000162f:	89 c2                	mov    %eax,%edx
c0001631:	8b 45 08             	mov    0x8(%ebp),%eax
c0001634:	01 d0                	add    %edx,%eax
c0001636:	0f b6 00             	movzbl (%eax),%eax
c0001639:	84 c0                	test   %al,%al
c000163b:	75 0a                	jne    c0001647 <atoi+0xbc>
            return 0; //invalid string (only whitespace found)
c000163d:	b8 00 00 00 00       	mov    $0x0,%eax
c0001642:	e9 89 00 00 00       	jmp    c00016d0 <atoi+0x145>
    while(str[p] >= '0' && str[p] <= '9')
c0001647:	8b 55 fc             	mov    -0x4(%ebp),%edx
c000164a:	8b 45 08             	mov    0x8(%ebp),%eax
c000164d:	01 d0                	add    %edx,%eax
c000164f:	0f b6 00             	movzbl (%eax),%eax
c0001652:	3c 2f                	cmp    $0x2f,%al
c0001654:	7e 0f                	jle    c0001665 <atoi+0xda>
c0001656:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0001659:	8b 45 08             	mov    0x8(%ebp),%eax
c000165c:	01 d0                	add    %edx,%eax
c000165e:	0f b6 00             	movzbl (%eax),%eax
c0001661:	3c 39                	cmp    $0x39,%al
c0001663:	7e c1                	jle    c0001626 <atoi+0x9b>
    }

    if(num_start == p) return 0; //length 0 string
c0001665:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001668:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c000166b:	75 07                	jne    c0001674 <atoi+0xe9>
c000166d:	b8 00 00 00 00       	mov    $0x0,%eax
c0001672:	eb 5c                	jmp    c00016d0 <atoi+0x145>

    int number = 0;
c0001674:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    int place = 1;
c000167b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    //iterate backwards through number to add each digit
    for(int digit = p-1; digit >= num_start; digit--)
c0001682:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001685:	83 e8 01             	sub    $0x1,%eax
c0001688:	89 45 ec             	mov    %eax,-0x14(%ebp)
c000168b:	eb 2b                	jmp    c00016b8 <atoi+0x12d>
    {
        number += (int) (str[digit] - '0') * place;
c000168d:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0001690:	8b 45 08             	mov    0x8(%ebp),%eax
c0001693:	01 d0                	add    %edx,%eax
c0001695:	0f b6 00             	movzbl (%eax),%eax
c0001698:	0f be c0             	movsbl %al,%eax
c000169b:	83 e8 30             	sub    $0x30,%eax
c000169e:	0f af 45 f0          	imul   -0x10(%ebp),%eax
c00016a2:	01 45 f4             	add    %eax,-0xc(%ebp)
        place *= 10;
c00016a5:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00016a8:	89 d0                	mov    %edx,%eax
c00016aa:	c1 e0 02             	shl    $0x2,%eax
c00016ad:	01 d0                	add    %edx,%eax
c00016af:	01 c0                	add    %eax,%eax
c00016b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for(int digit = p-1; digit >= num_start; digit--)
c00016b4:	83 6d ec 01          	subl   $0x1,-0x14(%ebp)
c00016b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00016bb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c00016be:	7d cd                	jge    c000168d <atoi+0x102>
    }

    if(neg)
c00016c0:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c00016c4:	74 07                	je     c00016cd <atoi+0x142>
        return -1*number;
c00016c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00016c9:	f7 d8                	neg    %eax
c00016cb:	eb 03                	jmp    c00016d0 <atoi+0x145>
    else
        return number;
c00016cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00016d0:	c9                   	leave  
c00016d1:	c3                   	ret    

c00016d2 <itoa>:

char* itoa( int value, char* str, int base)
{
c00016d2:	55                   	push   %ebp
c00016d3:	89 e5                	mov    %esp,%ebp
c00016d5:	83 ec 20             	sub    $0x20,%esp
    if(base < 2 || base > 32)
c00016d8:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c00016dc:	7e 06                	jle    c00016e4 <itoa+0x12>
c00016de:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
c00016e2:	7e 0a                	jle    c00016ee <itoa+0x1c>
        return NULL;
c00016e4:	b8 00 00 00 00       	mov    $0x0,%eax
c00016e9:	e9 df 00 00 00       	jmp    c00017cd <itoa+0xfb>

    //handle zero as special case 
    if(value == 0)
c00016ee:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00016f2:	75 17                	jne    c000170b <itoa+0x39>
    {
        str[0] = '0';
c00016f4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00016f7:	c6 00 30             	movb   $0x30,(%eax)
        str[1] = '\0';
c00016fa:	8b 45 0c             	mov    0xc(%ebp),%eax
c00016fd:	83 c0 01             	add    $0x1,%eax
c0001700:	c6 00 00             	movb   $0x0,(%eax)
        return str;
c0001703:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001706:	e9 c2 00 00 00       	jmp    c00017cd <itoa+0xfb>
    }

    char* s = str;
c000170b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000170e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    unsigned int residual; //holds the unsigned value still to be parsed
    if(base == 10 && value < 0)
c0001711:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
c0001715:	75 1c                	jne    c0001733 <itoa+0x61>
c0001717:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c000171b:	79 16                	jns    c0001733 <itoa+0x61>
    {
        residual = -value;
c000171d:	8b 45 08             	mov    0x8(%ebp),%eax
c0001720:	f7 d8                	neg    %eax
c0001722:	89 45 f8             	mov    %eax,-0x8(%ebp)
        *(s++) = '-';
c0001725:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001728:	8d 50 01             	lea    0x1(%eax),%edx
c000172b:	89 55 fc             	mov    %edx,-0x4(%ebp)
c000172e:	c6 00 2d             	movb   $0x2d,(%eax)
c0001731:	eb 06                	jmp    c0001739 <itoa+0x67>
    }
    else
    {
        //all non-decimal numbers are treated as unsigned
        residual = (unsigned int) value;
c0001733:	8b 45 08             	mov    0x8(%ebp),%eax
c0001736:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    
    // find number of digits so that we can parse number
    // directly into string from lowest to highest digit    
    unsigned int num_digits = 0;
c0001739:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    unsigned int temp = residual;
c0001740:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0001743:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(temp>0)
c0001746:	eb 14                	jmp    c000175c <itoa+0x8a>
    {
        num_digits++;
c0001748:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
        temp /= base;
c000174c:	8b 4d 10             	mov    0x10(%ebp),%ecx
c000174f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001752:	ba 00 00 00 00       	mov    $0x0,%edx
c0001757:	f7 f1                	div    %ecx
c0001759:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(temp>0)
c000175c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0001760:	75 e6                	jne    c0001748 <itoa+0x76>
    }

    //point at end of string
    s += num_digits;
c0001762:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001765:	01 45 fc             	add    %eax,-0x4(%ebp)
    *(s--) = '\0'; //null termination
c0001768:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000176b:	8d 50 ff             	lea    -0x1(%eax),%edx
c000176e:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001771:	c6 00 00             	movb   $0x0,(%eax)

    //compute each digit from lowest to highest.
    unsigned int digit;
    while(residual>0)
c0001774:	eb 4e                	jmp    c00017c4 <itoa+0xf2>
    {
        digit = residual % base;
c0001776:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0001779:	8b 45 f8             	mov    -0x8(%ebp),%eax
c000177c:	ba 00 00 00 00       	mov    $0x0,%edx
c0001781:	f7 f1                	div    %ecx
c0001783:	89 55 ec             	mov    %edx,-0x14(%ebp)
        residual /= base;
c0001786:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0001789:	8b 45 f8             	mov    -0x8(%ebp),%eax
c000178c:	ba 00 00 00 00       	mov    $0x0,%edx
c0001791:	f7 f1                	div    %ecx
c0001793:	89 45 f8             	mov    %eax,-0x8(%ebp)

        //write digit into string and decrement pointer
        if(digit < 10)
c0001796:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
c000179a:	77 15                	ja     c00017b1 <itoa+0xdf>
            *(s--) = digit + '0';
c000179c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000179f:	8d 48 30             	lea    0x30(%eax),%ecx
c00017a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00017a5:	8d 50 ff             	lea    -0x1(%eax),%edx
c00017a8:	89 55 fc             	mov    %edx,-0x4(%ebp)
c00017ab:	89 ca                	mov    %ecx,%edx
c00017ad:	88 10                	mov    %dl,(%eax)
c00017af:	eb 13                	jmp    c00017c4 <itoa+0xf2>
        else
            *(s--) = digit - 10 + 'A';        
c00017b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00017b4:	8d 48 37             	lea    0x37(%eax),%ecx
c00017b7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00017ba:	8d 50 ff             	lea    -0x1(%eax),%edx
c00017bd:	89 55 fc             	mov    %edx,-0x4(%ebp)
c00017c0:	89 ca                	mov    %ecx,%edx
c00017c2:	88 10                	mov    %dl,(%eax)
    while(residual>0)
c00017c4:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c00017c8:	75 ac                	jne    c0001776 <itoa+0xa4>
    }

    return str;
c00017ca:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c00017cd:	c9                   	leave  
c00017ce:	c3                   	ret    

c00017cf <printregs>:
#include "regs.h"
#include "kprintf.h"

void printregs(const reg_t* regs)
{
c00017cf:	55                   	push   %ebp
c00017d0:	89 e5                	mov    %esp,%ebp
c00017d2:	57                   	push   %edi
c00017d3:	56                   	push   %esi
c00017d4:	53                   	push   %ebx
c00017d5:	83 ec 0c             	sub    $0xc,%esp
    kprintf("Registers:\n");
c00017d8:	83 ec 0c             	sub    $0xc,%esp
c00017db:	68 28 44 00 c0       	push   $0xc0004428
c00017e0:	e8 74 ee ff ff       	call   c0000659 <kprintf>
c00017e5:	83 c4 10             	add    $0x10,%esp
    kprintf("eax: 0x%x\n", regs->eax);
c00017e8:	8b 45 08             	mov    0x8(%ebp),%eax
c00017eb:	8b 00                	mov    (%eax),%eax
c00017ed:	83 ec 08             	sub    $0x8,%esp
c00017f0:	50                   	push   %eax
c00017f1:	68 34 44 00 c0       	push   $0xc0004434
c00017f6:	e8 5e ee ff ff       	call   c0000659 <kprintf>
c00017fb:	83 c4 10             	add    $0x10,%esp
    kprintf("ebx: 0x%x\n", regs->ebx);
c00017fe:	8b 45 08             	mov    0x8(%ebp),%eax
c0001801:	8b 40 04             	mov    0x4(%eax),%eax
c0001804:	83 ec 08             	sub    $0x8,%esp
c0001807:	50                   	push   %eax
c0001808:	68 3f 44 00 c0       	push   $0xc000443f
c000180d:	e8 47 ee ff ff       	call   c0000659 <kprintf>
c0001812:	83 c4 10             	add    $0x10,%esp
    kprintf("ecx: 0x%x\n", regs->ecx);
c0001815:	8b 45 08             	mov    0x8(%ebp),%eax
c0001818:	8b 40 08             	mov    0x8(%eax),%eax
c000181b:	83 ec 08             	sub    $0x8,%esp
c000181e:	50                   	push   %eax
c000181f:	68 4a 44 00 c0       	push   $0xc000444a
c0001824:	e8 30 ee ff ff       	call   c0000659 <kprintf>
c0001829:	83 c4 10             	add    $0x10,%esp
    kprintf("edx: 0x%x\n", regs->edx);
c000182c:	8b 45 08             	mov    0x8(%ebp),%eax
c000182f:	8b 40 0c             	mov    0xc(%eax),%eax
c0001832:	83 ec 08             	sub    $0x8,%esp
c0001835:	50                   	push   %eax
c0001836:	68 55 44 00 c0       	push   $0xc0004455
c000183b:	e8 19 ee ff ff       	call   c0000659 <kprintf>
c0001840:	83 c4 10             	add    $0x10,%esp
    kprintf("esi: 0x%x\n", regs->esi);
c0001843:	8b 45 08             	mov    0x8(%ebp),%eax
c0001846:	8b 40 10             	mov    0x10(%eax),%eax
c0001849:	83 ec 08             	sub    $0x8,%esp
c000184c:	50                   	push   %eax
c000184d:	68 60 44 00 c0       	push   $0xc0004460
c0001852:	e8 02 ee ff ff       	call   c0000659 <kprintf>
c0001857:	83 c4 10             	add    $0x10,%esp
    kprintf("edi: 0x%x\n", regs->edi);
c000185a:	8b 45 08             	mov    0x8(%ebp),%eax
c000185d:	8b 40 14             	mov    0x14(%eax),%eax
c0001860:	83 ec 08             	sub    $0x8,%esp
c0001863:	50                   	push   %eax
c0001864:	68 6b 44 00 c0       	push   $0xc000446b
c0001869:	e8 eb ed ff ff       	call   c0000659 <kprintf>
c000186e:	83 c4 10             	add    $0x10,%esp
    kprintf("ebp: 0x%x\n", regs->ebp);
c0001871:	8b 45 08             	mov    0x8(%ebp),%eax
c0001874:	8b 40 1c             	mov    0x1c(%eax),%eax
c0001877:	83 ec 08             	sub    $0x8,%esp
c000187a:	50                   	push   %eax
c000187b:	68 76 44 00 c0       	push   $0xc0004476
c0001880:	e8 d4 ed ff ff       	call   c0000659 <kprintf>
c0001885:	83 c4 10             	add    $0x10,%esp
    kprintf("esp: 0x%x\n", regs->esp);
c0001888:	8b 45 08             	mov    0x8(%ebp),%eax
c000188b:	8b 40 18             	mov    0x18(%eax),%eax
c000188e:	83 ec 08             	sub    $0x8,%esp
c0001891:	50                   	push   %eax
c0001892:	68 81 44 00 c0       	push   $0xc0004481
c0001897:	e8 bd ed ff ff       	call   c0000659 <kprintf>
c000189c:	83 c4 10             	add    $0x10,%esp
    kprintf("eip: 0x%x\n", regs->eip);
c000189f:	8b 45 08             	mov    0x8(%ebp),%eax
c00018a2:	8b 40 20             	mov    0x20(%eax),%eax
c00018a5:	83 ec 08             	sub    $0x8,%esp
c00018a8:	50                   	push   %eax
c00018a9:	68 8c 44 00 c0       	push   $0xc000448c
c00018ae:	e8 a6 ed ff ff       	call   c0000659 <kprintf>
c00018b3:	83 c4 10             	add    $0x10,%esp
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
                                                            (regs->eflags&EFLAGS_PF) == EFLAGS_PF,
                                                            (regs->eflags&EFLAGS_AF) == EFLAGS_AF,
                                                            (regs->eflags&EFLAGS_ZF) == EFLAGS_ZF,
                                                            (regs->eflags&EFLAGS_SF) == EFLAGS_SF,
                                                            (regs->eflags&EFLAGS_TF) == EFLAGS_TF);
c00018b6:	8b 45 08             	mov    0x8(%ebp),%eax
c00018b9:	8b 40 24             	mov    0x24(%eax),%eax
c00018bc:	25 00 01 00 00       	and    $0x100,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c00018c1:	85 c0                	test   %eax,%eax
c00018c3:	0f 95 c0             	setne  %al
c00018c6:	0f b6 f8             	movzbl %al,%edi
                                                            (regs->eflags&EFLAGS_SF) == EFLAGS_SF,
c00018c9:	8b 45 08             	mov    0x8(%ebp),%eax
c00018cc:	8b 40 24             	mov    0x24(%eax),%eax
c00018cf:	25 80 00 00 00       	and    $0x80,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c00018d4:	85 c0                	test   %eax,%eax
c00018d6:	0f 95 c0             	setne  %al
c00018d9:	0f b6 f0             	movzbl %al,%esi
                                                            (regs->eflags&EFLAGS_ZF) == EFLAGS_ZF,
c00018dc:	8b 45 08             	mov    0x8(%ebp),%eax
c00018df:	8b 40 24             	mov    0x24(%eax),%eax
c00018e2:	83 e0 40             	and    $0x40,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c00018e5:	85 c0                	test   %eax,%eax
c00018e7:	0f 95 c0             	setne  %al
c00018ea:	0f b6 d8             	movzbl %al,%ebx
                                                            (regs->eflags&EFLAGS_AF) == EFLAGS_AF,
c00018ed:	8b 45 08             	mov    0x8(%ebp),%eax
c00018f0:	8b 40 24             	mov    0x24(%eax),%eax
c00018f3:	83 e0 10             	and    $0x10,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c00018f6:	85 c0                	test   %eax,%eax
c00018f8:	0f 95 c0             	setne  %al
c00018fb:	0f b6 c8             	movzbl %al,%ecx
                                                            (regs->eflags&EFLAGS_PF) == EFLAGS_PF,
c00018fe:	8b 45 08             	mov    0x8(%ebp),%eax
c0001901:	8b 40 24             	mov    0x24(%eax),%eax
c0001904:	83 e0 04             	and    $0x4,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c0001907:	85 c0                	test   %eax,%eax
c0001909:	0f 95 c0             	setne  %al
c000190c:	0f b6 d0             	movzbl %al,%edx
c000190f:	8b 45 08             	mov    0x8(%ebp),%eax
c0001912:	8b 40 24             	mov    0x24(%eax),%eax
c0001915:	83 e0 01             	and    $0x1,%eax
c0001918:	85 c0                	test   %eax,%eax
c000191a:	0f 95 c0             	setne  %al
c000191d:	0f b6 c0             	movzbl %al,%eax
c0001920:	83 ec 04             	sub    $0x4,%esp
c0001923:	57                   	push   %edi
c0001924:	56                   	push   %esi
c0001925:	53                   	push   %ebx
c0001926:	51                   	push   %ecx
c0001927:	52                   	push   %edx
c0001928:	50                   	push   %eax
c0001929:	68 98 44 00 c0       	push   $0xc0004498
c000192e:	e8 26 ed ff ff       	call   c0000659 <kprintf>
c0001933:	83 c4 20             	add    $0x20,%esp
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
                                                            (regs->eflags&EFLAGS_DF) == EFLAGS_DF,
                                                            (regs->eflags&EFLAGS_OF) == EFLAGS_OF,
                                                            (regs->eflags&EFLAGS_IOPL) >> 12,
                                                            (regs->eflags&EFLAGS_NT) == EFLAGS_NT,
                                                            (regs->eflags&EFLAGS_RF) == EFLAGS_RF);
c0001936:	8b 45 08             	mov    0x8(%ebp),%eax
c0001939:	8b 40 24             	mov    0x24(%eax),%eax
c000193c:	25 00 00 01 00       	and    $0x10000,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001941:	85 c0                	test   %eax,%eax
c0001943:	0f 95 c0             	setne  %al
c0001946:	0f b6 f0             	movzbl %al,%esi
                                                            (regs->eflags&EFLAGS_NT) == EFLAGS_NT,
c0001949:	8b 45 08             	mov    0x8(%ebp),%eax
c000194c:	8b 40 24             	mov    0x24(%eax),%eax
c000194f:	25 00 40 00 00       	and    $0x4000,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001954:	85 c0                	test   %eax,%eax
c0001956:	0f 95 c0             	setne  %al
c0001959:	0f b6 d8             	movzbl %al,%ebx
                                                            (regs->eflags&EFLAGS_IOPL) >> 12,
c000195c:	8b 45 08             	mov    0x8(%ebp),%eax
c000195f:	8b 40 24             	mov    0x24(%eax),%eax
c0001962:	c1 e8 0c             	shr    $0xc,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001965:	83 e0 03             	and    $0x3,%eax
c0001968:	89 c7                	mov    %eax,%edi
                                                            (regs->eflags&EFLAGS_OF) == EFLAGS_OF,
c000196a:	8b 45 08             	mov    0x8(%ebp),%eax
c000196d:	8b 40 24             	mov    0x24(%eax),%eax
c0001970:	25 00 08 00 00       	and    $0x800,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001975:	85 c0                	test   %eax,%eax
c0001977:	0f 95 c0             	setne  %al
c000197a:	0f b6 c8             	movzbl %al,%ecx
                                                            (regs->eflags&EFLAGS_DF) == EFLAGS_DF,
c000197d:	8b 45 08             	mov    0x8(%ebp),%eax
c0001980:	8b 40 24             	mov    0x24(%eax),%eax
c0001983:	25 00 04 00 00       	and    $0x400,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001988:	85 c0                	test   %eax,%eax
c000198a:	0f 95 c0             	setne  %al
c000198d:	0f b6 d0             	movzbl %al,%edx
c0001990:	8b 45 08             	mov    0x8(%ebp),%eax
c0001993:	8b 40 24             	mov    0x24(%eax),%eax
c0001996:	25 00 02 00 00       	and    $0x200,%eax
c000199b:	85 c0                	test   %eax,%eax
c000199d:	0f 95 c0             	setne  %al
c00019a0:	0f b6 c0             	movzbl %al,%eax
c00019a3:	83 ec 04             	sub    $0x4,%esp
c00019a6:	56                   	push   %esi
c00019a7:	53                   	push   %ebx
c00019a8:	57                   	push   %edi
c00019a9:	51                   	push   %ecx
c00019aa:	52                   	push   %edx
c00019ab:	50                   	push   %eax
c00019ac:	68 c8 44 00 c0       	push   $0xc00044c8
c00019b1:	e8 a3 ec ff ff       	call   c0000659 <kprintf>
c00019b6:	83 c4 20             	add    $0x20,%esp
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
                                                            (regs->eflags&EFLAGS_AC) == EFLAGS_AC,
                                                            (regs->eflags&EFLAGS_VIF) == EFLAGS_VIF,
                                                            (regs->eflags&EFLAGS_VIP) == EFLAGS_VIP,
                                                            (regs->eflags&EFLAGS_ID) == EFLAGS_ID);
c00019b9:	8b 45 08             	mov    0x8(%ebp),%eax
c00019bc:	8b 40 24             	mov    0x24(%eax),%eax
c00019bf:	25 00 00 20 00       	and    $0x200000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c00019c4:	85 c0                	test   %eax,%eax
c00019c6:	0f 95 c0             	setne  %al
c00019c9:	0f b6 f0             	movzbl %al,%esi
                                                            (regs->eflags&EFLAGS_VIP) == EFLAGS_VIP,
c00019cc:	8b 45 08             	mov    0x8(%ebp),%eax
c00019cf:	8b 40 24             	mov    0x24(%eax),%eax
c00019d2:	25 00 00 10 00       	and    $0x100000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c00019d7:	85 c0                	test   %eax,%eax
c00019d9:	0f 95 c0             	setne  %al
c00019dc:	0f b6 d8             	movzbl %al,%ebx
                                                            (regs->eflags&EFLAGS_VIF) == EFLAGS_VIF,
c00019df:	8b 45 08             	mov    0x8(%ebp),%eax
c00019e2:	8b 40 24             	mov    0x24(%eax),%eax
c00019e5:	25 00 00 08 00       	and    $0x80000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c00019ea:	85 c0                	test   %eax,%eax
c00019ec:	0f 95 c0             	setne  %al
c00019ef:	0f b6 c8             	movzbl %al,%ecx
                                                            (regs->eflags&EFLAGS_AC) == EFLAGS_AC,
c00019f2:	8b 45 08             	mov    0x8(%ebp),%eax
c00019f5:	8b 40 24             	mov    0x24(%eax),%eax
c00019f8:	25 00 00 04 00       	and    $0x40000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c00019fd:	85 c0                	test   %eax,%eax
c00019ff:	0f 95 c0             	setne  %al
c0001a02:	0f b6 d0             	movzbl %al,%edx
c0001a05:	8b 45 08             	mov    0x8(%ebp),%eax
c0001a08:	8b 40 24             	mov    0x24(%eax),%eax
c0001a0b:	25 00 00 02 00       	and    $0x20000,%eax
c0001a10:	85 c0                	test   %eax,%eax
c0001a12:	0f 95 c0             	setne  %al
c0001a15:	0f b6 c0             	movzbl %al,%eax
c0001a18:	83 ec 08             	sub    $0x8,%esp
c0001a1b:	56                   	push   %esi
c0001a1c:	53                   	push   %ebx
c0001a1d:	51                   	push   %ecx
c0001a1e:	52                   	push   %edx
c0001a1f:	50                   	push   %eax
c0001a20:	68 f8 44 00 c0       	push   $0xc00044f8
c0001a25:	e8 2f ec ff ff       	call   c0000659 <kprintf>
c0001a2a:	83 c4 20             	add    $0x20,%esp
    kprintf("cr0: 0x%x\n", regs->cr0);
c0001a2d:	8b 45 08             	mov    0x8(%ebp),%eax
c0001a30:	8b 40 28             	mov    0x28(%eax),%eax
c0001a33:	83 ec 08             	sub    $0x8,%esp
c0001a36:	50                   	push   %eax
c0001a37:	68 21 45 00 c0       	push   $0xc0004521
c0001a3c:	e8 18 ec ff ff       	call   c0000659 <kprintf>
c0001a41:	83 c4 10             	add    $0x10,%esp
    kprintf("cr2: 0x%x\n", regs->cr2);
c0001a44:	8b 45 08             	mov    0x8(%ebp),%eax
c0001a47:	8b 40 2c             	mov    0x2c(%eax),%eax
c0001a4a:	83 ec 08             	sub    $0x8,%esp
c0001a4d:	50                   	push   %eax
c0001a4e:	68 2c 45 00 c0       	push   $0xc000452c
c0001a53:	e8 01 ec ff ff       	call   c0000659 <kprintf>
c0001a58:	83 c4 10             	add    $0x10,%esp
    kprintf("cr3: 0x%x\n", regs->cr3);
c0001a5b:	8b 45 08             	mov    0x8(%ebp),%eax
c0001a5e:	8b 40 30             	mov    0x30(%eax),%eax
c0001a61:	83 ec 08             	sub    $0x8,%esp
c0001a64:	50                   	push   %eax
c0001a65:	68 37 45 00 c0       	push   $0xc0004537
c0001a6a:	e8 ea eb ff ff       	call   c0000659 <kprintf>
c0001a6f:	83 c4 10             	add    $0x10,%esp
    kprintf("cr4: 0x%x\n", regs->cr4);
c0001a72:	8b 45 08             	mov    0x8(%ebp),%eax
c0001a75:	8b 40 34             	mov    0x34(%eax),%eax
c0001a78:	83 ec 08             	sub    $0x8,%esp
c0001a7b:	50                   	push   %eax
c0001a7c:	68 42 45 00 c0       	push   $0xc0004542
c0001a81:	e8 d3 eb ff ff       	call   c0000659 <kprintf>
c0001a86:	83 c4 10             	add    $0x10,%esp
}
c0001a89:	90                   	nop
c0001a8a:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0001a8d:	5b                   	pop    %ebx
c0001a8e:	5e                   	pop    %esi
c0001a8f:	5f                   	pop    %edi
c0001a90:	5d                   	pop    %ebp
c0001a91:	c3                   	ret    

c0001a92 <memory_table>:
#include "multiboot.h"
#include "kprintf.h"

size_t memory_table(multiboot_info_t* mbd)
{
c0001a92:	55                   	push   %ebp
c0001a93:	89 e5                	mov    %esp,%ebp
c0001a95:	56                   	push   %esi
c0001a96:	53                   	push   %ebx
c0001a97:	83 ec 10             	sub    $0x10,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c0001a9a:	8b 45 08             	mov    0x8(%ebp),%eax
c0001a9d:	8b 40 30             	mov    0x30(%eax),%eax
c0001aa0:	89 45 ec             	mov    %eax,-0x14(%ebp)
    size_t available_mem = 0;
c0001aa3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001aaa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0001ab1:	e9 83 00 00 00       	jmp    c0001b39 <memory_table+0xa7>
	{
		if(mmap_table[nn].len>0 && mmap_table[nn].size>0)
c0001ab6:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001ab9:	89 d0                	mov    %edx,%eax
c0001abb:	01 c0                	add    %eax,%eax
c0001abd:	01 d0                	add    %edx,%eax
c0001abf:	c1 e0 03             	shl    $0x3,%eax
c0001ac2:	89 c2                	mov    %eax,%edx
c0001ac4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001ac7:	01 d0                	add    %edx,%eax
c0001ac9:	8b 50 10             	mov    0x10(%eax),%edx
c0001acc:	8b 40 0c             	mov    0xc(%eax),%eax
c0001acf:	89 c6                	mov    %eax,%esi
c0001ad1:	83 f6 00             	xor    $0x0,%esi
c0001ad4:	89 f1                	mov    %esi,%ecx
c0001ad6:	89 d0                	mov    %edx,%eax
c0001ad8:	80 f4 00             	xor    $0x0,%ah
c0001adb:	89 c3                	mov    %eax,%ebx
c0001add:	89 d8                	mov    %ebx,%eax
c0001adf:	09 c8                	or     %ecx,%eax
c0001ae1:	85 c0                	test   %eax,%eax
c0001ae3:	74 50                	je     c0001b35 <memory_table+0xa3>
c0001ae5:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001ae8:	89 d0                	mov    %edx,%eax
c0001aea:	01 c0                	add    %eax,%eax
c0001aec:	01 d0                	add    %edx,%eax
c0001aee:	c1 e0 03             	shl    $0x3,%eax
c0001af1:	89 c2                	mov    %eax,%edx
c0001af3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001af6:	01 d0                	add    %edx,%eax
c0001af8:	8b 00                	mov    (%eax),%eax
c0001afa:	85 c0                	test   %eax,%eax
c0001afc:	74 37                	je     c0001b35 <memory_table+0xa3>
        {
            if(mmap_table[nn].type == 1)
c0001afe:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001b01:	89 d0                	mov    %edx,%eax
c0001b03:	01 c0                	add    %eax,%eax
c0001b05:	01 d0                	add    %edx,%eax
c0001b07:	c1 e0 03             	shl    $0x3,%eax
c0001b0a:	89 c2                	mov    %eax,%edx
c0001b0c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001b0f:	01 d0                	add    %edx,%eax
c0001b11:	8b 40 14             	mov    0x14(%eax),%eax
c0001b14:	83 f8 01             	cmp    $0x1,%eax
c0001b17:	75 1c                	jne    c0001b35 <memory_table+0xa3>
            available_mem += mmap_table[nn].len;
c0001b19:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001b1c:	89 d0                	mov    %edx,%eax
c0001b1e:	01 c0                	add    %eax,%eax
c0001b20:	01 d0                	add    %edx,%eax
c0001b22:	c1 e0 03             	shl    $0x3,%eax
c0001b25:	89 c2                	mov    %eax,%edx
c0001b27:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001b2a:	01 d0                	add    %edx,%eax
c0001b2c:	8b 50 10             	mov    0x10(%eax),%edx
c0001b2f:	8b 40 0c             	mov    0xc(%eax),%eax
c0001b32:	01 45 f4             	add    %eax,-0xc(%ebp)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001b35:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0001b39:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b3c:	8b 40 2c             	mov    0x2c(%eax),%eax
c0001b3f:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0001b42:	0f 82 6e ff ff ff    	jb     c0001ab6 <memory_table+0x24>
        }
		
	}

    return available_mem;
c0001b48:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0001b4b:	83 c4 10             	add    $0x10,%esp
c0001b4e:	5b                   	pop    %ebx
c0001b4f:	5e                   	pop    %esi
c0001b50:	5d                   	pop    %ebp
c0001b51:	c3                   	ret    

c0001b52 <print_memory_table>:

int print_memory_table(multiboot_info_t* mbd)
{
c0001b52:	55                   	push   %ebp
c0001b53:	89 e5                	mov    %esp,%ebp
c0001b55:	57                   	push   %edi
c0001b56:	56                   	push   %esi
c0001b57:	53                   	push   %ebx
c0001b58:	83 ec 2c             	sub    $0x2c,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c0001b5b:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b5e:	8b 40 30             	mov    0x30(%eax),%eax
c0001b61:	89 45 e0             	mov    %eax,-0x20(%ebp)
	kprintf("Memory Table:\n");
c0001b64:	83 ec 0c             	sub    $0xc,%esp
c0001b67:	68 50 45 00 c0       	push   $0xc0004550
c0001b6c:	e8 e8 ea ff ff       	call   c0000659 <kprintf>
c0001b71:	83 c4 10             	add    $0x10,%esp
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001b74:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c0001b7b:	e9 a6 01 00 00       	jmp    c0001d26 <print_memory_table+0x1d4>
	{
        if(mmap_table[nn].size == 0)
c0001b80:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001b83:	89 d0                	mov    %edx,%eax
c0001b85:	01 c0                	add    %eax,%eax
c0001b87:	01 d0                	add    %edx,%eax
c0001b89:	c1 e0 03             	shl    $0x3,%eax
c0001b8c:	89 c2                	mov    %eax,%edx
c0001b8e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001b91:	01 d0                	add    %edx,%eax
c0001b93:	8b 00                	mov    (%eax),%eax
c0001b95:	85 c0                	test   %eax,%eax
c0001b97:	0f 84 9a 01 00 00    	je     c0001d37 <print_memory_table+0x1e5>
            break;

		if(mmap_table[nn].len>0)
c0001b9d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001ba0:	89 d0                	mov    %edx,%eax
c0001ba2:	01 c0                	add    %eax,%eax
c0001ba4:	01 d0                	add    %edx,%eax
c0001ba6:	c1 e0 03             	shl    $0x3,%eax
c0001ba9:	89 c2                	mov    %eax,%edx
c0001bab:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001bae:	01 d0                	add    %edx,%eax
c0001bb0:	8b 50 10             	mov    0x10(%eax),%edx
c0001bb3:	8b 40 0c             	mov    0xc(%eax),%eax
c0001bb6:	89 c7                	mov    %eax,%edi
c0001bb8:	83 f7 00             	xor    $0x0,%edi
c0001bbb:	89 7d d0             	mov    %edi,-0x30(%ebp)
c0001bbe:	89 d0                	mov    %edx,%eax
c0001bc0:	80 f4 00             	xor    $0x0,%ah
c0001bc3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
c0001bc6:	8b 5d d0             	mov    -0x30(%ebp),%ebx
c0001bc9:	8b 75 d4             	mov    -0x2c(%ebp),%esi
c0001bcc:	89 f0                	mov    %esi,%eax
c0001bce:	09 d8                	or     %ebx,%eax
c0001bd0:	85 c0                	test   %eax,%eax
c0001bd2:	0f 84 4a 01 00 00    	je     c0001d22 <print_memory_table+0x1d0>
		{
			if(mmap_table[nn].type == MULTIBOOT_MEMORY_AVAILABLE)
c0001bd8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001bdb:	89 d0                	mov    %edx,%eax
c0001bdd:	01 c0                	add    %eax,%eax
c0001bdf:	01 d0                	add    %edx,%eax
c0001be1:	c1 e0 03             	shl    $0x3,%eax
c0001be4:	89 c2                	mov    %eax,%edx
c0001be6:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001be9:	01 d0                	add    %edx,%eax
c0001beb:	8b 40 14             	mov    0x14(%eax),%eax
c0001bee:	83 f8 01             	cmp    $0x1,%eax
c0001bf1:	0f 85 98 00 00 00    	jne    c0001c8f <print_memory_table+0x13d>
				kprintf("%.8llp - %.8llp [AVAILABLE] (%6llu kiB)\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c0001bf7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001bfa:	89 d0                	mov    %edx,%eax
c0001bfc:	01 c0                	add    %eax,%eax
c0001bfe:	01 d0                	add    %edx,%eax
c0001c00:	c1 e0 03             	shl    $0x3,%eax
c0001c03:	89 c2                	mov    %eax,%edx
c0001c05:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001c08:	01 d0                	add    %edx,%eax
c0001c0a:	8b 50 10             	mov    0x10(%eax),%edx
c0001c0d:	8b 40 0c             	mov    0xc(%eax),%eax
c0001c10:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c0001c14:	c1 ea 0a             	shr    $0xa,%edx
c0001c17:	89 c6                	mov    %eax,%esi
c0001c19:	89 d7                	mov    %edx,%edi
c0001c1b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001c1e:	89 d0                	mov    %edx,%eax
c0001c20:	01 c0                	add    %eax,%eax
c0001c22:	01 d0                	add    %edx,%eax
c0001c24:	c1 e0 03             	shl    $0x3,%eax
c0001c27:	89 c2                	mov    %eax,%edx
c0001c29:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001c2c:	01 d0                	add    %edx,%eax
c0001c2e:	8b 48 04             	mov    0x4(%eax),%ecx
c0001c31:	8b 58 08             	mov    0x8(%eax),%ebx
c0001c34:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001c37:	89 d0                	mov    %edx,%eax
c0001c39:	01 c0                	add    %eax,%eax
c0001c3b:	01 d0                	add    %edx,%eax
c0001c3d:	c1 e0 03             	shl    $0x3,%eax
c0001c40:	89 c2                	mov    %eax,%edx
c0001c42:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001c45:	01 d0                	add    %edx,%eax
c0001c47:	8b 50 10             	mov    0x10(%eax),%edx
c0001c4a:	8b 40 0c             	mov    0xc(%eax),%eax
c0001c4d:	01 c8                	add    %ecx,%eax
c0001c4f:	11 da                	adc    %ebx,%edx
c0001c51:	83 c0 ff             	add    $0xffffffff,%eax
c0001c54:	83 d2 ff             	adc    $0xffffffff,%edx
c0001c57:	89 c1                	mov    %eax,%ecx
c0001c59:	89 d3                	mov    %edx,%ebx
c0001c5b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001c5e:	89 d0                	mov    %edx,%eax
c0001c60:	01 c0                	add    %eax,%eax
c0001c62:	01 d0                	add    %edx,%eax
c0001c64:	c1 e0 03             	shl    $0x3,%eax
c0001c67:	89 c2                	mov    %eax,%edx
c0001c69:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001c6c:	01 d0                	add    %edx,%eax
c0001c6e:	8b 50 08             	mov    0x8(%eax),%edx
c0001c71:	8b 40 04             	mov    0x4(%eax),%eax
c0001c74:	83 ec 04             	sub    $0x4,%esp
c0001c77:	57                   	push   %edi
c0001c78:	56                   	push   %esi
c0001c79:	53                   	push   %ebx
c0001c7a:	51                   	push   %ecx
c0001c7b:	52                   	push   %edx
c0001c7c:	50                   	push   %eax
c0001c7d:	68 60 45 00 c0       	push   $0xc0004560
c0001c82:	e8 d2 e9 ff ff       	call   c0000659 <kprintf>
c0001c87:	83 c4 20             	add    $0x20,%esp
c0001c8a:	e9 93 00 00 00       	jmp    c0001d22 <print_memory_table+0x1d0>
			else
				kprintf("%.8llp - %.8llp [RESERVED]\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c0001c8f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001c92:	89 d0                	mov    %edx,%eax
c0001c94:	01 c0                	add    %eax,%eax
c0001c96:	01 d0                	add    %edx,%eax
c0001c98:	c1 e0 03             	shl    $0x3,%eax
c0001c9b:	89 c2                	mov    %eax,%edx
c0001c9d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001ca0:	01 d0                	add    %edx,%eax
c0001ca2:	8b 50 10             	mov    0x10(%eax),%edx
c0001ca5:	8b 40 0c             	mov    0xc(%eax),%eax
c0001ca8:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c0001cac:	c1 ea 0a             	shr    $0xa,%edx
c0001caf:	89 c6                	mov    %eax,%esi
c0001cb1:	89 d7                	mov    %edx,%edi
c0001cb3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001cb6:	89 d0                	mov    %edx,%eax
c0001cb8:	01 c0                	add    %eax,%eax
c0001cba:	01 d0                	add    %edx,%eax
c0001cbc:	c1 e0 03             	shl    $0x3,%eax
c0001cbf:	89 c2                	mov    %eax,%edx
c0001cc1:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001cc4:	01 d0                	add    %edx,%eax
c0001cc6:	8b 48 04             	mov    0x4(%eax),%ecx
c0001cc9:	8b 58 08             	mov    0x8(%eax),%ebx
c0001ccc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001ccf:	89 d0                	mov    %edx,%eax
c0001cd1:	01 c0                	add    %eax,%eax
c0001cd3:	01 d0                	add    %edx,%eax
c0001cd5:	c1 e0 03             	shl    $0x3,%eax
c0001cd8:	89 c2                	mov    %eax,%edx
c0001cda:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001cdd:	01 d0                	add    %edx,%eax
c0001cdf:	8b 50 10             	mov    0x10(%eax),%edx
c0001ce2:	8b 40 0c             	mov    0xc(%eax),%eax
c0001ce5:	01 c8                	add    %ecx,%eax
c0001ce7:	11 da                	adc    %ebx,%edx
c0001ce9:	83 c0 ff             	add    $0xffffffff,%eax
c0001cec:	83 d2 ff             	adc    $0xffffffff,%edx
c0001cef:	89 c1                	mov    %eax,%ecx
c0001cf1:	89 d3                	mov    %edx,%ebx
c0001cf3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001cf6:	89 d0                	mov    %edx,%eax
c0001cf8:	01 c0                	add    %eax,%eax
c0001cfa:	01 d0                	add    %edx,%eax
c0001cfc:	c1 e0 03             	shl    $0x3,%eax
c0001cff:	89 c2                	mov    %eax,%edx
c0001d01:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001d04:	01 d0                	add    %edx,%eax
c0001d06:	8b 50 08             	mov    0x8(%eax),%edx
c0001d09:	8b 40 04             	mov    0x4(%eax),%eax
c0001d0c:	83 ec 04             	sub    $0x4,%esp
c0001d0f:	57                   	push   %edi
c0001d10:	56                   	push   %esi
c0001d11:	53                   	push   %ebx
c0001d12:	51                   	push   %ecx
c0001d13:	52                   	push   %edx
c0001d14:	50                   	push   %eax
c0001d15:	68 89 45 00 c0       	push   $0xc0004589
c0001d1a:	e8 3a e9 ff ff       	call   c0000659 <kprintf>
c0001d1f:	83 c4 20             	add    $0x20,%esp
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001d22:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c0001d26:	8b 45 08             	mov    0x8(%ebp),%eax
c0001d29:	8b 40 2c             	mov    0x2c(%eax),%eax
c0001d2c:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c0001d2f:	0f 82 4b fe ff ff    	jb     c0001b80 <print_memory_table+0x2e>
c0001d35:	eb 01                	jmp    c0001d38 <print_memory_table+0x1e6>
            break;
c0001d37:	90                   	nop
    //         kprintf("[%3u] %p (%#x)\n", nn, addr, flags);		
	// }

    // print_crs();

    return 0;
c0001d38:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0001d3d:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0001d40:	5b                   	pop    %ebx
c0001d41:	5e                   	pop    %esi
c0001d42:	5f                   	pop    %edi
c0001d43:	5d                   	pop    %ebp
c0001d44:	c3                   	ret    

c0001d45 <inb>:
{
c0001d45:	55                   	push   %ebp
c0001d46:	89 e5                	mov    %esp,%ebp
c0001d48:	83 ec 14             	sub    $0x14,%esp
c0001d4b:	8b 45 08             	mov    0x8(%ebp),%eax
c0001d4e:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  __asm__ __volatile__ ("inb %w1,%0":"=a" (_v):"Nd" (__port));
c0001d52:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0001d56:	89 c2                	mov    %eax,%edx
c0001d58:	ec                   	in     (%dx),%al
c0001d59:	88 45 ff             	mov    %al,-0x1(%ebp)
  return _v;
c0001d5c:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0001d60:	c9                   	leave  
c0001d61:	c3                   	ret    

c0001d62 <outb>:
{
c0001d62:	55                   	push   %ebp
c0001d63:	89 e5                	mov    %esp,%ebp
c0001d65:	83 ec 08             	sub    $0x8,%esp
c0001d68:	8b 55 08             	mov    0x8(%ebp),%edx
c0001d6b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001d6e:	88 55 fc             	mov    %dl,-0x4(%ebp)
c0001d71:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
c0001d75:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0001d79:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
c0001d7d:	ee                   	out    %al,(%dx)
}
c0001d7e:	90                   	nop
c0001d7f:	c9                   	leave  
c0001d80:	c3                   	ret    

c0001d81 <init_interrupts>:

idt_entry_t __aligned idt[NUM_INTERRUPT_HANDLERS] = {0};
idt_descriptor_t __aligned idtd;

void init_interrupts()
{
c0001d81:	55                   	push   %ebp
c0001d82:	89 e5                	mov    %esp,%ebp
c0001d84:	83 ec 08             	sub    $0x8,%esp
    /* init the PIC */
	outb(PIC_INIT, PIC1_CMD);  // init PIC 1
c0001d87:	6a 20                	push   $0x20
c0001d89:	6a 11                	push   $0x11
c0001d8b:	e8 d2 ff ff ff       	call   c0001d62 <outb>
c0001d90:	83 c4 08             	add    $0x8,%esp
    outb(PIC_INIT, PIC2_CMD);  // init PIC 2
c0001d93:	68 a0 00 00 00       	push   $0xa0
c0001d98:	6a 11                	push   $0x11
c0001d9a:	e8 c3 ff ff ff       	call   c0001d62 <outb>
c0001d9f:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_OFFSET, PIC1_DATA); // map irq 0x0-0x7 to int 0x20-0x27
c0001da2:	6a 21                	push   $0x21
c0001da4:	6a 20                	push   $0x20
c0001da6:	e8 b7 ff ff ff       	call   c0001d62 <outb>
c0001dab:	83 c4 08             	add    $0x8,%esp
    outb(PIC2_OFFSET, PIC2_DATA); // map irq 0x8-0xf to int 0x28-0x2f
c0001dae:	68 a1 00 00 00       	push   $0xa1
c0001db3:	6a 28                	push   $0x28
c0001db5:	e8 a8 ff ff ff       	call   c0001d62 <outb>
c0001dba:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_MS, PIC1_DATA);     // pic1 is master, with slave at irq 2
c0001dbd:	6a 21                	push   $0x21
c0001dbf:	6a 04                	push   $0x4
c0001dc1:	e8 9c ff ff ff       	call   c0001d62 <outb>
c0001dc6:	83 c4 08             	add    $0x8,%esp
    outb(PIC2_MS, PIC2_DATA);     // pic2 is slave with id 2
c0001dc9:	68 a1 00 00 00       	push   $0xa1
c0001dce:	6a 02                	push   $0x2
c0001dd0:	e8 8d ff ff ff       	call   c0001d62 <outb>
c0001dd5:	83 c4 08             	add    $0x8,%esp
    outb(PIC_8086MODE, PIC1_DATA); //enable 8086 mode
c0001dd8:	6a 21                	push   $0x21
c0001dda:	6a 01                	push   $0x1
c0001ddc:	e8 81 ff ff ff       	call   c0001d62 <outb>
c0001de1:	83 c4 08             	add    $0x8,%esp
    outb(PIC_8086MODE, PIC2_DATA); //enable 8086 mode
c0001de4:	68 a1 00 00 00       	push   $0xa1
c0001de9:	6a 01                	push   $0x1
c0001deb:	e8 72 ff ff ff       	call   c0001d62 <outb>
c0001df0:	83 c4 08             	add    $0x8,%esp
    // interrupt mask
    outb( ~(1<<1) , PIC1_DATA); //enable irq1 (keyboard)
c0001df3:	6a 21                	push   $0x21
c0001df5:	68 fd 00 00 00       	push   $0xfd
c0001dfa:	e8 63 ff ff ff       	call   c0001d62 <outb>
c0001dff:	83 c4 08             	add    $0x8,%esp
    outb(0xff, PIC2_DATA); //disable interrupts from slave
c0001e02:	68 a1 00 00 00       	push   $0xa1
c0001e07:	68 ff 00 00 00       	push   $0xff
c0001e0c:	e8 51 ff ff ff       	call   c0001d62 <outb>
c0001e11:	83 c4 08             	add    $0x8,%esp


    // individual handler routines defined in interrupt.S
    // these call back to exception_handler() and irq_handler()
    set_interrupt_handler(0,except_0);
c0001e14:	83 ec 08             	sub    $0x8,%esp
c0001e17:	68 f4 36 00 c0       	push   $0xc00036f4
c0001e1c:	6a 00                	push   $0x0
c0001e1e:	e8 94 02 00 00       	call   c00020b7 <set_interrupt_handler>
c0001e23:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(1,except_1);
c0001e26:	83 ec 08             	sub    $0x8,%esp
c0001e29:	68 14 37 00 c0       	push   $0xc0003714
c0001e2e:	6a 01                	push   $0x1
c0001e30:	e8 82 02 00 00       	call   c00020b7 <set_interrupt_handler>
c0001e35:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(2,except_2);
c0001e38:	83 ec 08             	sub    $0x8,%esp
c0001e3b:	68 34 37 00 c0       	push   $0xc0003734
c0001e40:	6a 02                	push   $0x2
c0001e42:	e8 70 02 00 00       	call   c00020b7 <set_interrupt_handler>
c0001e47:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(3,except_3);
c0001e4a:	83 ec 08             	sub    $0x8,%esp
c0001e4d:	68 54 37 00 c0       	push   $0xc0003754
c0001e52:	6a 03                	push   $0x3
c0001e54:	e8 5e 02 00 00       	call   c00020b7 <set_interrupt_handler>
c0001e59:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(4,except_4);
c0001e5c:	83 ec 08             	sub    $0x8,%esp
c0001e5f:	68 74 37 00 c0       	push   $0xc0003774
c0001e64:	6a 04                	push   $0x4
c0001e66:	e8 4c 02 00 00       	call   c00020b7 <set_interrupt_handler>
c0001e6b:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(5,except_5);
c0001e6e:	83 ec 08             	sub    $0x8,%esp
c0001e71:	68 94 37 00 c0       	push   $0xc0003794
c0001e76:	6a 05                	push   $0x5
c0001e78:	e8 3a 02 00 00       	call   c00020b7 <set_interrupt_handler>
c0001e7d:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(6,except_6);
c0001e80:	83 ec 08             	sub    $0x8,%esp
c0001e83:	68 b4 37 00 c0       	push   $0xc00037b4
c0001e88:	6a 06                	push   $0x6
c0001e8a:	e8 28 02 00 00       	call   c00020b7 <set_interrupt_handler>
c0001e8f:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(7,except_7);
c0001e92:	83 ec 08             	sub    $0x8,%esp
c0001e95:	68 d4 37 00 c0       	push   $0xc00037d4
c0001e9a:	6a 07                	push   $0x7
c0001e9c:	e8 16 02 00 00       	call   c00020b7 <set_interrupt_handler>
c0001ea1:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(8,except_8);
c0001ea4:	83 ec 08             	sub    $0x8,%esp
c0001ea7:	68 f4 37 00 c0       	push   $0xc00037f4
c0001eac:	6a 08                	push   $0x8
c0001eae:	e8 04 02 00 00       	call   c00020b7 <set_interrupt_handler>
c0001eb3:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(10,except_10);
c0001eb6:	83 ec 08             	sub    $0x8,%esp
c0001eb9:	68 14 38 00 c0       	push   $0xc0003814
c0001ebe:	6a 0a                	push   $0xa
c0001ec0:	e8 f2 01 00 00       	call   c00020b7 <set_interrupt_handler>
c0001ec5:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(11,except_11);
c0001ec8:	83 ec 08             	sub    $0x8,%esp
c0001ecb:	68 34 38 00 c0       	push   $0xc0003834
c0001ed0:	6a 0b                	push   $0xb
c0001ed2:	e8 e0 01 00 00       	call   c00020b7 <set_interrupt_handler>
c0001ed7:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(12,except_12);
c0001eda:	83 ec 08             	sub    $0x8,%esp
c0001edd:	68 54 38 00 c0       	push   $0xc0003854
c0001ee2:	6a 0c                	push   $0xc
c0001ee4:	e8 ce 01 00 00       	call   c00020b7 <set_interrupt_handler>
c0001ee9:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(13,except_13);
c0001eec:	83 ec 08             	sub    $0x8,%esp
c0001eef:	68 74 38 00 c0       	push   $0xc0003874
c0001ef4:	6a 0d                	push   $0xd
c0001ef6:	e8 bc 01 00 00       	call   c00020b7 <set_interrupt_handler>
c0001efb:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(14,except_14);
c0001efe:	83 ec 08             	sub    $0x8,%esp
c0001f01:	68 94 38 00 c0       	push   $0xc0003894
c0001f06:	6a 0e                	push   $0xe
c0001f08:	e8 aa 01 00 00       	call   c00020b7 <set_interrupt_handler>
c0001f0d:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(16,except_16);
c0001f10:	83 ec 08             	sub    $0x8,%esp
c0001f13:	68 b4 38 00 c0       	push   $0xc00038b4
c0001f18:	6a 10                	push   $0x10
c0001f1a:	e8 98 01 00 00       	call   c00020b7 <set_interrupt_handler>
c0001f1f:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(17,except_17);
c0001f22:	83 ec 08             	sub    $0x8,%esp
c0001f25:	68 d4 38 00 c0       	push   $0xc00038d4
c0001f2a:	6a 11                	push   $0x11
c0001f2c:	e8 86 01 00 00       	call   c00020b7 <set_interrupt_handler>
c0001f31:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(18,except_18);
c0001f34:	83 ec 08             	sub    $0x8,%esp
c0001f37:	68 f4 38 00 c0       	push   $0xc00038f4
c0001f3c:	6a 12                	push   $0x12
c0001f3e:	e8 74 01 00 00       	call   c00020b7 <set_interrupt_handler>
c0001f43:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(19,except_19);
c0001f46:	83 ec 08             	sub    $0x8,%esp
c0001f49:	68 14 39 00 c0       	push   $0xc0003914
c0001f4e:	6a 13                	push   $0x13
c0001f50:	e8 62 01 00 00       	call   c00020b7 <set_interrupt_handler>
c0001f55:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(20,except_20);
c0001f58:	83 ec 08             	sub    $0x8,%esp
c0001f5b:	68 34 39 00 c0       	push   $0xc0003934
c0001f60:	6a 14                	push   $0x14
c0001f62:	e8 50 01 00 00       	call   c00020b7 <set_interrupt_handler>
c0001f67:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(30,except_30);
c0001f6a:	83 ec 08             	sub    $0x8,%esp
c0001f6d:	68 54 39 00 c0       	push   $0xc0003954
c0001f72:	6a 1e                	push   $0x1e
c0001f74:	e8 3e 01 00 00       	call   c00020b7 <set_interrupt_handler>
c0001f79:	83 c4 10             	add    $0x10,%esp

    set_interrupt_handler(32,irq_0);
c0001f7c:	83 ec 08             	sub    $0x8,%esp
c0001f7f:	68 74 39 00 c0       	push   $0xc0003974
c0001f84:	6a 20                	push   $0x20
c0001f86:	e8 2c 01 00 00       	call   c00020b7 <set_interrupt_handler>
c0001f8b:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(33,irq_1);
c0001f8e:	83 ec 08             	sub    $0x8,%esp
c0001f91:	68 88 39 00 c0       	push   $0xc0003988
c0001f96:	6a 21                	push   $0x21
c0001f98:	e8 1a 01 00 00       	call   c00020b7 <set_interrupt_handler>
c0001f9d:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(34,irq_2);
c0001fa0:	83 ec 08             	sub    $0x8,%esp
c0001fa3:	68 9c 39 00 c0       	push   $0xc000399c
c0001fa8:	6a 22                	push   $0x22
c0001faa:	e8 08 01 00 00       	call   c00020b7 <set_interrupt_handler>
c0001faf:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(35,irq_3);
c0001fb2:	83 ec 08             	sub    $0x8,%esp
c0001fb5:	68 b0 39 00 c0       	push   $0xc00039b0
c0001fba:	6a 23                	push   $0x23
c0001fbc:	e8 f6 00 00 00       	call   c00020b7 <set_interrupt_handler>
c0001fc1:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(36,irq_4);
c0001fc4:	83 ec 08             	sub    $0x8,%esp
c0001fc7:	68 c4 39 00 c0       	push   $0xc00039c4
c0001fcc:	6a 24                	push   $0x24
c0001fce:	e8 e4 00 00 00       	call   c00020b7 <set_interrupt_handler>
c0001fd3:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(37,irq_5);
c0001fd6:	83 ec 08             	sub    $0x8,%esp
c0001fd9:	68 d8 39 00 c0       	push   $0xc00039d8
c0001fde:	6a 25                	push   $0x25
c0001fe0:	e8 d2 00 00 00       	call   c00020b7 <set_interrupt_handler>
c0001fe5:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(38,irq_6);
c0001fe8:	83 ec 08             	sub    $0x8,%esp
c0001feb:	68 ec 39 00 c0       	push   $0xc00039ec
c0001ff0:	6a 26                	push   $0x26
c0001ff2:	e8 c0 00 00 00       	call   c00020b7 <set_interrupt_handler>
c0001ff7:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(39,irq_7);
c0001ffa:	83 ec 08             	sub    $0x8,%esp
c0001ffd:	68 00 3a 00 c0       	push   $0xc0003a00
c0002002:	6a 27                	push   $0x27
c0002004:	e8 ae 00 00 00       	call   c00020b7 <set_interrupt_handler>
c0002009:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(40,irq_8);
c000200c:	83 ec 08             	sub    $0x8,%esp
c000200f:	68 14 3a 00 c0       	push   $0xc0003a14
c0002014:	6a 28                	push   $0x28
c0002016:	e8 9c 00 00 00       	call   c00020b7 <set_interrupt_handler>
c000201b:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(41,irq_9);
c000201e:	83 ec 08             	sub    $0x8,%esp
c0002021:	68 28 3a 00 c0       	push   $0xc0003a28
c0002026:	6a 29                	push   $0x29
c0002028:	e8 8a 00 00 00       	call   c00020b7 <set_interrupt_handler>
c000202d:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(42,irq_10);
c0002030:	83 ec 08             	sub    $0x8,%esp
c0002033:	68 3c 3a 00 c0       	push   $0xc0003a3c
c0002038:	6a 2a                	push   $0x2a
c000203a:	e8 78 00 00 00       	call   c00020b7 <set_interrupt_handler>
c000203f:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(43,irq_11);
c0002042:	83 ec 08             	sub    $0x8,%esp
c0002045:	68 50 3a 00 c0       	push   $0xc0003a50
c000204a:	6a 2b                	push   $0x2b
c000204c:	e8 66 00 00 00       	call   c00020b7 <set_interrupt_handler>
c0002051:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(44,irq_12);
c0002054:	83 ec 08             	sub    $0x8,%esp
c0002057:	68 64 3a 00 c0       	push   $0xc0003a64
c000205c:	6a 2c                	push   $0x2c
c000205e:	e8 54 00 00 00       	call   c00020b7 <set_interrupt_handler>
c0002063:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(45,irq_13);
c0002066:	83 ec 08             	sub    $0x8,%esp
c0002069:	68 78 3a 00 c0       	push   $0xc0003a78
c000206e:	6a 2d                	push   $0x2d
c0002070:	e8 42 00 00 00       	call   c00020b7 <set_interrupt_handler>
c0002075:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(46,irq_14);
c0002078:	83 ec 08             	sub    $0x8,%esp
c000207b:	68 8c 3a 00 c0       	push   $0xc0003a8c
c0002080:	6a 2e                	push   $0x2e
c0002082:	e8 30 00 00 00       	call   c00020b7 <set_interrupt_handler>
c0002087:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(47,irq_15);
c000208a:	83 ec 08             	sub    $0x8,%esp
c000208d:	68 a0 3a 00 c0       	push   $0xc0003aa0
c0002092:	6a 2f                	push   $0x2f
c0002094:	e8 1e 00 00 00       	call   c00020b7 <set_interrupt_handler>
c0002099:	83 c4 10             	add    $0x10,%esp



    idtd.base = (uint32_t) idt;
c000209c:	b8 20 00 01 c0       	mov    $0xc0010020,%eax
c00020a1:	a3 22 08 01 c0       	mov    %eax,0xc0010822
    idtd.limit = sizeof(idt_entry_t) * NUM_INTERRUPT_HANDLERS - 1;
c00020a6:	66 c7 05 20 08 01 c0 	movw   $0x7ff,0xc0010820
c00020ad:	ff 07 
    load_idt();
c00020af:	e8 30 16 00 00       	call   c00036e4 <load_idt>
}
c00020b4:	90                   	nop
c00020b5:	c9                   	leave  
c00020b6:	c3                   	ret    

c00020b7 <set_interrupt_handler>:

void set_interrupt_handler(int int_num, void* handler)
{
c00020b7:	55                   	push   %ebp
c00020b8:	89 e5                	mov    %esp,%ebp
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c00020ba:	8b 45 0c             	mov    0xc(%ebp),%eax
c00020bd:	89 c2                	mov    %eax,%edx
c00020bf:	8b 45 08             	mov    0x8(%ebp),%eax
c00020c2:	66 89 14 c5 20 00 01 	mov    %dx,-0x3ffeffe0(,%eax,8)
c00020c9:	c0 
	idt[int_num].segment = KERNEL_CODE_SEGMENT;
c00020ca:	8b 45 08             	mov    0x8(%ebp),%eax
c00020cd:	66 c7 04 c5 22 00 01 	movw   $0x8,-0x3ffeffde(,%eax,8)
c00020d4:	c0 08 00 
	idt[int_num].zero = 0;
c00020d7:	8b 45 08             	mov    0x8(%ebp),%eax
c00020da:	c6 04 c5 24 00 01 c0 	movb   $0x0,-0x3ffeffdc(,%eax,8)
c00020e1:	00 
	idt[int_num].type = 0x8e; /* INTERRUPT_GATE */
c00020e2:	8b 45 08             	mov    0x8(%ebp),%eax
c00020e5:	c6 04 c5 25 00 01 c0 	movb   $0x8e,-0x3ffeffdb(,%eax,8)
c00020ec:	8e 
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c00020ed:	8b 45 0c             	mov    0xc(%ebp),%eax
c00020f0:	c1 e8 10             	shr    $0x10,%eax
c00020f3:	89 c2                	mov    %eax,%edx
c00020f5:	8b 45 08             	mov    0x8(%ebp),%eax
c00020f8:	66 89 14 c5 26 00 01 	mov    %dx,-0x3ffeffda(,%eax,8)
c00020ff:	c0 
}
c0002100:	90                   	nop
c0002101:	5d                   	pop    %ebp
c0002102:	c3                   	ret    

c0002103 <page_fault_handler>:

void page_fault_handler(uint32_t code, void* fault_ip)
{
c0002103:	55                   	push   %ebp
c0002104:	89 e5                	mov    %esp,%ebp
c0002106:	83 ec 08             	sub    $0x8,%esp

    if(code & PF_CODE_WRITE)
c0002109:	8b 45 08             	mov    0x8(%ebp),%eax
c000210c:	83 e0 02             	and    $0x2,%eax
c000210f:	85 c0                	test   %eax,%eax
c0002111:	74 1b                	je     c000212e <page_fault_handler+0x2b>
        kprintf("\n\nPage Fault writing to 0x%x (instruction 0x%x)\n", pf_addr(), fault_ip);
c0002113:	e8 d8 15 00 00       	call   c00036f0 <pf_addr>
c0002118:	83 ec 04             	sub    $0x4,%esp
c000211b:	ff 75 0c             	pushl  0xc(%ebp)
c000211e:	50                   	push   %eax
c000211f:	68 a8 45 00 c0       	push   $0xc00045a8
c0002124:	e8 30 e5 ff ff       	call   c0000659 <kprintf>
c0002129:	83 c4 10             	add    $0x10,%esp
c000212c:	eb 19                	jmp    c0002147 <page_fault_handler+0x44>
    else        
        kprintf("\n\nPage Fault reading from 0x%x (instruction 0x%x)\n", pf_addr(), fault_ip);
c000212e:	e8 bd 15 00 00       	call   c00036f0 <pf_addr>
c0002133:	83 ec 04             	sub    $0x4,%esp
c0002136:	ff 75 0c             	pushl  0xc(%ebp)
c0002139:	50                   	push   %eax
c000213a:	68 dc 45 00 c0       	push   $0xc00045dc
c000213f:	e8 15 e5 ff ff       	call   c0000659 <kprintf>
c0002144:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_PGPROT)
c0002147:	8b 45 08             	mov    0x8(%ebp),%eax
c000214a:	83 e0 01             	and    $0x1,%eax
c000214d:	85 c0                	test   %eax,%eax
c000214f:	74 12                	je     c0002163 <page_fault_handler+0x60>
        kprintf("Page protection violation\n");
c0002151:	83 ec 0c             	sub    $0xc,%esp
c0002154:	68 0f 46 00 c0       	push   $0xc000460f
c0002159:	e8 fb e4 ff ff       	call   c0000659 <kprintf>
c000215e:	83 c4 10             	add    $0x10,%esp
c0002161:	eb 10                	jmp    c0002173 <page_fault_handler+0x70>
    else
        kprintf("Page not present\n");
c0002163:	83 ec 0c             	sub    $0xc,%esp
c0002166:	68 2a 46 00 c0       	push   $0xc000462a
c000216b:	e8 e9 e4 ff ff       	call   c0000659 <kprintf>
c0002170:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_USER)
c0002173:	8b 45 08             	mov    0x8(%ebp),%eax
c0002176:	83 e0 04             	and    $0x4,%eax
c0002179:	85 c0                	test   %eax,%eax
c000217b:	74 10                	je     c000218d <page_fault_handler+0x8a>
        kprintf("\n\nFault caused by user code\n");
c000217d:	83 ec 0c             	sub    $0xc,%esp
c0002180:	68 3c 46 00 c0       	push   $0xc000463c
c0002185:	e8 cf e4 ff ff       	call   c0000659 <kprintf>
c000218a:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_RES)
c000218d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002190:	83 e0 08             	and    $0x8,%eax
c0002193:	85 c0                	test   %eax,%eax
c0002195:	74 10                	je     c00021a7 <page_fault_handler+0xa4>
        kprintf("Page reserved bit set\n");
c0002197:	83 ec 0c             	sub    $0xc,%esp
c000219a:	68 59 46 00 c0       	push   $0xc0004659
c000219f:	e8 b5 e4 ff ff       	call   c0000659 <kprintf>
c00021a4:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_IF)
c00021a7:	8b 45 08             	mov    0x8(%ebp),%eax
c00021aa:	83 e0 10             	and    $0x10,%eax
c00021ad:	85 c0                	test   %eax,%eax
c00021af:	74 10                	je     c00021c1 <page_fault_handler+0xbe>
        kprintf("Fault caused by instruction fetch\n");
c00021b1:	83 ec 0c             	sub    $0xc,%esp
c00021b4:	68 70 46 00 c0       	push   $0xc0004670
c00021b9:	e8 9b e4 ff ff       	call   c0000659 <kprintf>
c00021be:	83 c4 10             	add    $0x10,%esp

    while(1);
c00021c1:	eb fe                	jmp    c00021c1 <page_fault_handler+0xbe>

c00021c3 <exception_handler>:
}


void exception_handler(uint32_t exception_num, uint32_t code, void* fault_ip)
{
c00021c3:	55                   	push   %ebp
c00021c4:	89 e5                	mov    %esp,%ebp
c00021c6:	83 ec 08             	sub    $0x8,%esp
    if(exception_num==14)
c00021c9:	83 7d 08 0e          	cmpl   $0xe,0x8(%ebp)
c00021cd:	75 13                	jne    c00021e2 <exception_handler+0x1f>
        page_fault_handler(code, fault_ip);
c00021cf:	83 ec 08             	sub    $0x8,%esp
c00021d2:	ff 75 10             	pushl  0x10(%ebp)
c00021d5:	ff 75 0c             	pushl  0xc(%ebp)
c00021d8:	e8 26 ff ff ff       	call   c0002103 <page_fault_handler>
c00021dd:	83 c4 10             	add    $0x10,%esp
c00021e0:	eb 16                	jmp    c00021f8 <exception_handler+0x35>
    else
        kprintf("\n\nException %u with code 0x%x at instruction 0x%x\n", exception_num, code, fault_ip);
c00021e2:	ff 75 10             	pushl  0x10(%ebp)
c00021e5:	ff 75 0c             	pushl  0xc(%ebp)
c00021e8:	ff 75 08             	pushl  0x8(%ebp)
c00021eb:	68 94 46 00 c0       	push   $0xc0004694
c00021f0:	e8 64 e4 ff ff       	call   c0000659 <kprintf>
c00021f5:	83 c4 10             	add    $0x10,%esp
    while(1);
c00021f8:	eb fe                	jmp    c00021f8 <exception_handler+0x35>

c00021fa <irq_handler>:
}

void irq_handler(uint32_t irq_num)
{
c00021fa:	55                   	push   %ebp
c00021fb:	89 e5                	mov    %esp,%ebp
c00021fd:	83 ec 18             	sub    $0x18,%esp
    if(irq_num == 1)
c0002200:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0002204:	75 36                	jne    c000223c <irq_handler+0x42>
    {
        unsigned char scan_code = inb(0x60);
c0002206:	6a 60                	push   $0x60
c0002208:	e8 38 fb ff ff       	call   c0001d45 <inb>
c000220d:	83 c4 04             	add    $0x4,%esp
c0002210:	88 45 f7             	mov    %al,-0x9(%ebp)
        char key_ascii = scancode_to_ascii(scan_code);
c0002213:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0002217:	83 ec 0c             	sub    $0xc,%esp
c000221a:	50                   	push   %eax
c000221b:	e8 53 11 00 00       	call   c0003373 <scancode_to_ascii>
c0002220:	83 c4 10             	add    $0x10,%esp
c0002223:	88 45 f6             	mov    %al,-0xa(%ebp)
        // kprintf("code: 0x%x, ascii:%c\n", scan_code, key_ascii);
        if(key_ascii>0)
c0002226:	80 7d f6 00          	cmpb   $0x0,-0xa(%ebp)
c000222a:	7e 10                	jle    c000223c <irq_handler+0x42>
            kprint_char(key_ascii);
c000222c:	0f be 45 f6          	movsbl -0xa(%ebp),%eax
c0002230:	83 ec 0c             	sub    $0xc,%esp
c0002233:	50                   	push   %eax
c0002234:	e8 cf e3 ff ff       	call   c0000608 <kprint_char>
c0002239:	83 c4 10             	add    $0x10,%esp
    
    }

    // notify PIC that interrupt handling is complete
    if(irq_num >= 8)
c000223c:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
c0002240:	76 12                	jbe    c0002254 <irq_handler+0x5a>
        outb(PIC_EOI, PIC2_CMD);
c0002242:	83 ec 08             	sub    $0x8,%esp
c0002245:	68 a0 00 00 00       	push   $0xa0
c000224a:	6a 20                	push   $0x20
c000224c:	e8 11 fb ff ff       	call   c0001d62 <outb>
c0002251:	83 c4 10             	add    $0x10,%esp

    outb(PIC_EOI, PIC1_CMD);
c0002254:	83 ec 08             	sub    $0x8,%esp
c0002257:	6a 20                	push   $0x20
c0002259:	6a 20                	push   $0x20
c000225b:	e8 02 fb ff ff       	call   c0001d62 <outb>
c0002260:	83 c4 10             	add    $0x10,%esp

    return;
c0002263:	90                   	nop
}
c0002264:	c9                   	leave  
c0002265:	c3                   	ret    

c0002266 <initialize_multitasking>:
task_control_block_t kernel_main_task;

uint32_t pid_counter;

void initialize_multitasking()
{    
c0002266:	55                   	push   %ebp
c0002267:	89 e5                	mov    %esp,%ebp
c0002269:	83 ec 08             	sub    $0x8,%esp
    // initialize current task as initial task
    kernel_main_task.pid = pid_counter = 0;
c000226c:	c7 05 80 08 01 c0 00 	movl   $0x0,0xc0010880
c0002273:	00 00 00 
c0002276:	a1 80 08 01 c0       	mov    0xc0010880,%eax
c000227b:	a3 60 08 01 c0       	mov    %eax,0xc0010860
    kernel_main_task.state = RUNNING;
c0002280:	c7 05 64 08 01 c0 00 	movl   $0x0,0xc0010864
c0002287:	00 00 00 
    kernel_main_task.esp = NULL; //this is initialized only on task switch
c000228a:	c7 05 68 08 01 c0 00 	movl   $0x0,0xc0010868
c0002291:	00 00 00 
    kernel_main_task.pd = get_page_dir();
c0002294:	e8 9b 18 00 00       	call   c0003b34 <get_page_dir>
c0002299:	a3 70 08 01 c0       	mov    %eax,0xc0010870

    // this is the only task so far
    //as we add tasks this becomes circular linked list
    kernel_main_task.next_task = &kernel_main_task;
c000229e:	c7 05 74 08 01 c0 60 	movl   $0xc0010860,0xc0010874
c00022a5:	08 01 c0 
    current_task = &kernel_main_task;
c00022a8:	c7 05 40 08 01 c0 60 	movl   $0xc0010860,0xc0010840
c00022af:	08 01 c0 
}
c00022b2:	90                   	nop
c00022b3:	c9                   	leave  
c00022b4:	c3                   	ret    

c00022b5 <new_kernel_task>:

task_control_block_t* new_kernel_task(int32_t (*task_entry) (void))
{
c00022b5:	55                   	push   %ebp
c00022b6:	89 e5                	mov    %esp,%ebp
c00022b8:	83 ec 18             	sub    $0x18,%esp
    task_control_block_t* new_task = kmalloc(sizeof(task_control_block_t));
c00022bb:	83 ec 0c             	sub    $0xc,%esp
c00022be:	6a 20                	push   $0x20
c00022c0:	e8 43 0e 00 00       	call   c0003108 <kmalloc>
c00022c5:	83 c4 10             	add    $0x10,%esp
c00022c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void* new_stack = kmalloc(KERNEL_STACK_SIZE);
c00022cb:	83 ec 0c             	sub    $0xc,%esp
c00022ce:	68 00 80 00 00       	push   $0x8000
c00022d3:	e8 30 0e 00 00       	call   c0003108 <kmalloc>
c00022d8:	83 c4 10             	add    $0x10,%esp
c00022db:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint32_t* esp0 = (uint32_t*) (new_stack + KERNEL_STACK_SIZE);
c00022de:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00022e1:	05 00 80 00 00       	add    $0x8000,%eax
c00022e6:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // init new stack with valid context to launch new task
    *(--esp0) = (uint32_t) new_task; //argument to launch_task
c00022e9:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c00022ed:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00022f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00022f3:	89 10                	mov    %edx,(%eax)
    *(--esp0) = (uint32_t) terminate_task; // launch_task() returns to here, to close out task
c00022f5:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c00022f9:	ba e9 3a 00 c0       	mov    $0xc0003ae9,%edx
c00022fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002301:	89 10                	mov    %edx,(%eax)
    *(--esp0) = (uint32_t) launch_task; //common entry function for new tasks
c0002303:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c0002307:	ba 72 24 00 c0       	mov    $0xc0002472,%edx
c000230c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000230f:	89 10                	mov    %edx,(%eax)
    *(--esp0) = 0; //push ebx
c0002311:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c0002315:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002318:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp0) = 0; //push esi
c000231e:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c0002322:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002325:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp0) = 0; //push edi
c000232b:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c000232f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002332:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp0) = 0; //push ebp
c0002338:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c000233c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000233f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    update_kstack(esp0); //update tss with esp0
c0002345:	83 ec 0c             	sub    $0xc,%esp
c0002348:	ff 75 ec             	pushl  -0x14(%ebp)
c000234b:	e8 fc 12 00 00       	call   c000364c <update_kstack>
c0002350:	83 c4 10             	add    $0x10,%esp

    //create copy of kernel page_dir
    void* new_pd = kmalloc_aligned(PAGE_SIZE, PAGE_SIZE);
c0002353:	83 ec 08             	sub    $0x8,%esp
c0002356:	68 00 10 00 00       	push   $0x1000
c000235b:	68 00 10 00 00       	push   $0x1000
c0002360:	e8 60 0e 00 00       	call   c00031c5 <kmalloc_aligned>
c0002365:	83 c4 10             	add    $0x10,%esp
c0002368:	89 45 e8             	mov    %eax,-0x18(%ebp)
    memcpy(new_pd, (void*) &pd->dir,PAGE_SIZE);
c000236b:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c0002370:	05 00 f0 3f 00       	add    $0x3ff000,%eax
c0002375:	83 ec 04             	sub    $0x4,%esp
c0002378:	68 00 10 00 00       	push   $0x1000
c000237d:	50                   	push   %eax
c000237e:	ff 75 e8             	pushl  -0x18(%ebp)
c0002381:	e8 2d f1 ff ff       	call   c00014b3 <memcpy>
c0002386:	83 c4 10             	add    $0x10,%esp
    new_task->pd = get_physaddr(new_pd); //page dir is physical address.
c0002389:	83 ec 0c             	sub    $0xc,%esp
c000238c:	ff 75 e8             	pushl  -0x18(%ebp)
c000238f:	e8 0a 02 00 00       	call   c000259e <get_physaddr>
c0002394:	83 c4 10             	add    $0x10,%esp
c0002397:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000239a:	89 42 10             	mov    %eax,0x10(%edx)


    new_task->pid = ++pid_counter;
c000239d:	a1 80 08 01 c0       	mov    0xc0010880,%eax
c00023a2:	83 c0 01             	add    $0x1,%eax
c00023a5:	a3 80 08 01 c0       	mov    %eax,0xc0010880
c00023aa:	8b 15 80 08 01 c0    	mov    0xc0010880,%edx
c00023b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00023b3:	89 10                	mov    %edx,(%eax)
    new_task->state = WAITING;
c00023b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00023b8:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
    new_task->esp = esp0;
c00023bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00023c2:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00023c5:	89 50 08             	mov    %edx,0x8(%eax)
    new_task->task_entry = task_entry;
c00023c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00023cb:	8b 55 08             	mov    0x8(%ebp),%edx
c00023ce:	89 50 18             	mov    %edx,0x18(%eax)
    new_task->return_val = -1;
c00023d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00023d4:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%eax)

    //insert task into the ll
    new_task->next_task = current_task->next_task;
c00023db:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c00023e0:	8b 50 14             	mov    0x14(%eax),%edx
c00023e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00023e6:	89 50 14             	mov    %edx,0x14(%eax)
    current_task->next_task = new_task;
c00023e9:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c00023ee:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00023f1:	89 50 14             	mov    %edx,0x14(%eax)

    return new_task;
c00023f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00023f7:	c9                   	leave  
c00023f8:	c3                   	ret    

c00023f9 <yield>:

void yield(void)
{
c00023f9:	55                   	push   %ebp
c00023fa:	89 e5                	mov    %esp,%ebp
c00023fc:	83 ec 08             	sub    $0x8,%esp
    current_task->state = WAITING;
c00023ff:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c0002404:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
    current_task->next_task->state = RUNNING;    
c000240b:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c0002410:	8b 40 14             	mov    0x14(%eax),%eax
c0002413:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    switch_to_task(current_task->next_task);
c000241a:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c000241f:	8b 40 14             	mov    0x14(%eax),%eax
c0002422:	83 ec 0c             	sub    $0xc,%esp
c0002425:	50                   	push   %eax
c0002426:	e8 89 16 00 00       	call   c0003ab4 <switch_to_task>
c000242b:	83 c4 10             	add    $0x10,%esp
}
c000242e:	90                   	nop
c000242f:	c9                   	leave  
c0002430:	c3                   	ret    

c0002431 <join>:

int32_t join(task_control_block_t* task)
{
c0002431:	55                   	push   %ebp
c0002432:	89 e5                	mov    %esp,%ebp
c0002434:	83 ec 08             	sub    $0x8,%esp
    // make sure we are not trying to join the current task or the main kernel task
    if(task == current_task || task == &kernel_main_task)
c0002437:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c000243c:	39 45 08             	cmp    %eax,0x8(%ebp)
c000243f:	74 09                	je     c000244a <join+0x19>
c0002441:	81 7d 08 60 08 01 c0 	cmpl   $0xc0010860,0x8(%ebp)
c0002448:	75 0c                	jne    c0002456 <join+0x25>
        return -1; 
c000244a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000244f:	eb 1f                	jmp    c0002470 <join+0x3f>

    while(task->state == WAITING || task->state == RUNNING)
        yield();
c0002451:	e8 a3 ff ff ff       	call   c00023f9 <yield>
    while(task->state == WAITING || task->state == RUNNING)
c0002456:	8b 45 08             	mov    0x8(%ebp),%eax
c0002459:	8b 40 04             	mov    0x4(%eax),%eax
c000245c:	83 f8 02             	cmp    $0x2,%eax
c000245f:	74 f0                	je     c0002451 <join+0x20>
c0002461:	8b 45 08             	mov    0x8(%ebp),%eax
c0002464:	8b 40 04             	mov    0x4(%eax),%eax
c0002467:	85 c0                	test   %eax,%eax
c0002469:	74 e6                	je     c0002451 <join+0x20>

    // free task memory: stack, heap and paging structures
    // free tcb? << what should lifetime be?  Want to interrogate after process completes, but dont want it to live forever...
    // before I can do any of this, I need to actually implement free() :)

    return 0;
c000246b:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002470:	c9                   	leave  
c0002471:	c3                   	ret    

c0002472 <launch_task>:


void launch_task(task_control_block_t* task)
{
c0002472:	55                   	push   %ebp
c0002473:	89 e5                	mov    %esp,%ebp
c0002475:	83 ec 18             	sub    $0x18,%esp
    task->state = RUNNING;
c0002478:	8b 45 08             	mov    0x8(%ebp),%eax
c000247b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

   // call task main function
    task->return_val = (*task->task_entry)();
c0002482:	8b 45 08             	mov    0x8(%ebp),%eax
c0002485:	8b 40 18             	mov    0x18(%eax),%eax
c0002488:	ff d0                	call   *%eax
c000248a:	8b 55 08             	mov    0x8(%ebp),%edx
c000248d:	89 42 1c             	mov    %eax,0x1c(%edx)

    //remove this task from active task list
    task_control_block_t* t = task->next_task;
c0002490:	8b 45 08             	mov    0x8(%ebp),%eax
c0002493:	8b 40 14             	mov    0x14(%eax),%eax
c0002496:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while( t->next_task != task)
c0002499:	eb 09                	jmp    c00024a4 <launch_task+0x32>
        t = t->next_task;
c000249b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000249e:	8b 40 14             	mov    0x14(%eax),%eax
c00024a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while( t->next_task != task)
c00024a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00024a7:	8b 40 14             	mov    0x14(%eax),%eax
c00024aa:	39 45 08             	cmp    %eax,0x8(%ebp)
c00024ad:	75 ec                	jne    c000249b <launch_task+0x29>
    t->next_task = t->next_task->next_task;
c00024af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00024b2:	8b 40 14             	mov    0x14(%eax),%eax
c00024b5:	8b 50 14             	mov    0x14(%eax),%edx
c00024b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00024bb:	89 50 14             	mov    %edx,0x14(%eax)

    task->state = COMPLETE;
c00024be:	8b 45 08             	mov    0x8(%ebp),%eax
c00024c1:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)

    // this will "return" to terminite_task 
}
c00024c8:	90                   	nop
c00024c9:	c9                   	leave  
c00024ca:	c3                   	ret    

c00024cb <num_tasks>:

int num_tasks()
{
c00024cb:	55                   	push   %ebp
c00024cc:	89 e5                	mov    %esp,%ebp
c00024ce:	83 ec 10             	sub    $0x10,%esp
    task_control_block_t* t = current_task;
c00024d1:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c00024d6:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int nn = 1;
c00024d9:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    while( t->next_task != current_task)
c00024e0:	eb 0d                	jmp    c00024ef <num_tasks+0x24>
    {
        t = t->next_task;
c00024e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00024e5:	8b 40 14             	mov    0x14(%eax),%eax
c00024e8:	89 45 fc             	mov    %eax,-0x4(%ebp)
        nn++;
c00024eb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while( t->next_task != current_task)
c00024ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00024f2:	8b 50 14             	mov    0x14(%eax),%edx
c00024f5:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c00024fa:	39 c2                	cmp    %eax,%edx
c00024fc:	75 e4                	jne    c00024e2 <num_tasks+0x17>
    }
    return nn;
c00024fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c0002501:	c9                   	leave  
c0002502:	c3                   	ret    

c0002503 <user_test>:
int user_test()
{
c0002503:	55                   	push   %ebp
c0002504:	89 e5                	mov    %esp,%ebp
c0002506:	83 ec 10             	sub    $0x10,%esp
    int a = 1;
c0002509:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
    int b = 2;
c0002510:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
    int c = b/a;
c0002517:	8b 45 f8             	mov    -0x8(%ebp),%eax
c000251a:	99                   	cltd   
c000251b:	f7 7d fc             	idivl  -0x4(%ebp)
c000251e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return c;
c0002521:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002524:	c9                   	leave  
c0002525:	c3                   	ret    

c0002526 <get_ptindex>:
//global pointer to page directory
extern page_directory_virt_t* pd;   //initialized in paging_asm.S

// return page table index for virtual address
static inline uint32_t get_ptindex(void* addr)
{
c0002526:	55                   	push   %ebp
c0002527:	89 e5                	mov    %esp,%ebp
    return (((uint32_t) addr) & PAGE_PTE_MASK ) >> 12;
c0002529:	8b 45 08             	mov    0x8(%ebp),%eax
c000252c:	c1 e8 0c             	shr    $0xc,%eax
c000252f:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c0002534:	5d                   	pop    %ebp
c0002535:	c3                   	ret    

c0002536 <get_pdindex>:

// return page directory index for virtual address
static inline uint32_t get_pdindex(void* addr)
{
c0002536:	55                   	push   %ebp
c0002537:	89 e5                	mov    %esp,%ebp
    return ((uint32_t) addr) >> 22;
c0002539:	8b 45 08             	mov    0x8(%ebp),%eax
c000253c:	c1 e8 16             	shr    $0x16,%eax
}
c000253f:	5d                   	pop    %ebp
c0002540:	c3                   	ret    

c0002541 <get_page_offset>:

// return offset into page
static inline uint32_t get_page_offset(void* addr)
{
c0002541:	55                   	push   %ebp
c0002542:	89 e5                	mov    %esp,%ebp
    return ((uint32_t) addr) & ~PAGE_ADDRMASK;
c0002544:	8b 45 08             	mov    0x8(%ebp),%eax
c0002547:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c000254c:	5d                   	pop    %ebp
c000254d:	c3                   	ret    

c000254e <get_table>:

page_directory_virt_t* pd = (page_directory_virt_t*) PD_ADDR;

// return page directory index for virtual address
page_table_t* get_table(void* addr)
{
c000254e:	55                   	push   %ebp
c000254f:	89 e5                	mov    %esp,%ebp
c0002551:	53                   	push   %ebx
c0002552:	83 ec 10             	sub    $0x10,%esp
    uint32_t idx = get_pdindex(addr);
c0002555:	ff 75 08             	pushl  0x8(%ebp)
c0002558:	e8 d9 ff ff ff       	call   c0002536 <get_pdindex>
c000255d:	83 c4 04             	add    $0x4,%esp
c0002560:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(pd->dir.pde[idx] & PAGE_FLAG_PRESENT)
c0002563:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c0002568:	8b 55 f8             	mov    -0x8(%ebp),%edx
c000256b:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c0002571:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0002574:	83 e0 01             	and    $0x1,%eax
c0002577:	85 c0                	test   %eax,%eax
c0002579:	74 19                	je     c0002594 <get_table+0x46>
        return pd->tables + get_pdindex(addr);
c000257b:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c0002580:	89 c3                	mov    %eax,%ebx
c0002582:	ff 75 08             	pushl  0x8(%ebp)
c0002585:	e8 ac ff ff ff       	call   c0002536 <get_pdindex>
c000258a:	83 c4 04             	add    $0x4,%esp
c000258d:	c1 e0 0c             	shl    $0xc,%eax
c0002590:	01 d8                	add    %ebx,%eax
c0002592:	eb 05                	jmp    c0002599 <get_table+0x4b>
    else 
        return NULL;
c0002594:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002599:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000259c:	c9                   	leave  
c000259d:	c3                   	ret    

c000259e <get_physaddr>:

// return physical addr from virt addr
void* get_physaddr(void* addr)
{
c000259e:	55                   	push   %ebp
c000259f:	89 e5                	mov    %esp,%ebp
c00025a1:	53                   	push   %ebx
c00025a2:	83 ec 10             	sub    $0x10,%esp
    //check pd entry is present
    uint32_t pdi = get_pdindex(addr);
c00025a5:	ff 75 08             	pushl  0x8(%ebp)
c00025a8:	e8 89 ff ff ff       	call   c0002536 <get_pdindex>
c00025ad:	83 c4 04             	add    $0x4,%esp
c00025b0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(! pd->dir.pde[pdi] & PAGE_FLAG_PRESENT)
c00025b3:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c00025b8:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00025bb:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c00025c1:	8b 04 90             	mov    (%eax,%edx,4),%eax
c00025c4:	85 c0                	test   %eax,%eax
c00025c6:	75 07                	jne    c00025cf <get_physaddr+0x31>
        return NULL;
c00025c8:	b8 00 00 00 00       	mov    $0x0,%eax
c00025cd:	eb 45                	jmp    c0002614 <get_physaddr+0x76>

    //check pt entry is present
    uint32_t pte = pd->tables[pdi].pte[get_ptindex(addr)];
c00025cf:	8b 1d 00 50 00 c0    	mov    0xc0005000,%ebx
c00025d5:	ff 75 08             	pushl  0x8(%ebp)
c00025d8:	e8 49 ff ff ff       	call   c0002526 <get_ptindex>
c00025dd:	83 c4 04             	add    $0x4,%esp
c00025e0:	89 c2                	mov    %eax,%edx
c00025e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00025e5:	c1 e0 0a             	shl    $0xa,%eax
c00025e8:	01 d0                	add    %edx,%eax
c00025ea:	8b 04 83             	mov    (%ebx,%eax,4),%eax
c00025ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(! pte & PAGE_FLAG_PRESENT)
c00025f0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00025f4:	75 07                	jne    c00025fd <get_physaddr+0x5f>
        return NULL;
c00025f6:	b8 00 00 00 00       	mov    $0x0,%eax
c00025fb:	eb 17                	jmp    c0002614 <get_physaddr+0x76>

    return (void*) ((pte & PAGE_ADDRMASK) +  get_page_offset(addr) );
c00025fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002600:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002605:	89 c3                	mov    %eax,%ebx
c0002607:	ff 75 08             	pushl  0x8(%ebp)
c000260a:	e8 32 ff ff ff       	call   c0002541 <get_page_offset>
c000260f:	83 c4 04             	add    $0x4,%esp
c0002612:	01 d8                	add    %ebx,%eax
}
c0002614:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0002617:	c9                   	leave  
c0002618:	c3                   	ret    

c0002619 <get_ptindex>:
{
c0002619:	55                   	push   %ebp
c000261a:	89 e5                	mov    %esp,%ebp
    return (((uint32_t) addr) & PAGE_PTE_MASK ) >> 12;
c000261c:	8b 45 08             	mov    0x8(%ebp),%eax
c000261f:	c1 e8 0c             	shr    $0xc,%eax
c0002622:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c0002627:	5d                   	pop    %ebp
c0002628:	c3                   	ret    

c0002629 <get_pdindex>:
{
c0002629:	55                   	push   %ebp
c000262a:	89 e5                	mov    %esp,%ebp
    return ((uint32_t) addr) >> 22;
c000262c:	8b 45 08             	mov    0x8(%ebp),%eax
c000262f:	c1 e8 16             	shr    $0x16,%eax
}
c0002632:	5d                   	pop    %ebp
c0002633:	c3                   	ret    

c0002634 <align_addr>:
page_t* map_page(page_t* page_virt, uint32_t flags);
page_t* map_page_at(page_t* page_virt, page_t* page_phys, uint32_t flags);
page_table_t* new_page_table(void* addr, uint32_t flags);

static inline void* align_addr(void* addr, uint32_t alignment)
{
c0002634:	55                   	push   %ebp
c0002635:	89 e5                	mov    %esp,%ebp
c0002637:	83 ec 10             	sub    $0x10,%esp
    uint32_t am = alignment - 1;
c000263a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000263d:	83 e8 01             	sub    $0x1,%eax
c0002640:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (char*) (((uint32_t)addr + am) & ~am);
c0002643:	8b 55 08             	mov    0x8(%ebp),%edx
c0002646:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002649:	01 c2                	add    %eax,%edx
c000264b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000264e:	f7 d0                	not    %eax
c0002650:	21 d0                	and    %edx,%eax
}
c0002652:	c9                   	leave  
c0002653:	c3                   	ret    

c0002654 <pop_free_page>:
page_t** free_stack_base;   //end of stack data
page_t*  free_stack_brk;   //end of allocated memory for page allocation stack

// allocate a physical page from the stack
page_t* pop_free_page()
{
c0002654:	55                   	push   %ebp
c0002655:	89 e5                	mov    %esp,%ebp
c0002657:	83 ec 10             	sub    $0x10,%esp
    page_t* free_page = *(free_stack_top++);
c000265a:	a1 98 08 01 c0       	mov    0xc0010898,%eax
c000265f:	8d 50 04             	lea    0x4(%eax),%edx
c0002662:	89 15 98 08 01 c0    	mov    %edx,0xc0010898
c0002668:	8b 00                	mov    (%eax),%eax
c000266a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(free_stack_top<free_stack_base)
c000266d:	8b 15 98 08 01 c0    	mov    0xc0010898,%edx
c0002673:	a1 9c 08 01 c0       	mov    0xc001089c,%eax
c0002678:	39 c2                	cmp    %eax,%edx
c000267a:	73 05                	jae    c0002681 <pop_free_page+0x2d>
        return free_page;
c000267c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000267f:	eb 05                	jmp    c0002686 <pop_free_page+0x32>
    else
        return NULL; //out of memory!    
c0002681:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002686:	c9                   	leave  
c0002687:	c3                   	ret    

c0002688 <push_free_page>:

// free a physical page back to the stack
int push_free_page(page_t* free_page)
{
c0002688:	55                   	push   %ebp
c0002689:	89 e5                	mov    %esp,%ebp
    if(free_stack_top<=free_stack_start)
c000268b:	8b 15 98 08 01 c0    	mov    0xc0010898,%edx
c0002691:	a1 94 08 01 c0       	mov    0xc0010894,%eax
c0002696:	39 c2                	cmp    %eax,%edx
c0002698:	77 07                	ja     c00026a1 <push_free_page+0x19>
        return -1;
c000269a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000269f:	eb 18                	jmp    c00026b9 <push_free_page+0x31>

    *(free_stack_top--) = free_page;
c00026a1:	a1 98 08 01 c0       	mov    0xc0010898,%eax
c00026a6:	8d 50 fc             	lea    -0x4(%eax),%edx
c00026a9:	89 15 98 08 01 c0    	mov    %edx,0xc0010898
c00026af:	8b 55 08             	mov    0x8(%ebp),%edx
c00026b2:	89 10                	mov    %edx,(%eax)
    return 0;
c00026b4:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00026b9:	5d                   	pop    %ebp
c00026ba:	c3                   	ret    

c00026bb <init_page_stack>:


// set up a stack will all free pages of physical memory
void init_page_stack(multiboot_info_t* mbd)
{
c00026bb:	55                   	push   %ebp
c00026bc:	89 e5                	mov    %esp,%ebp
c00026be:	57                   	push   %edi
c00026bf:	56                   	push   %esi
c00026c0:	83 ec 30             	sub    $0x30,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c00026c3:	8b 45 08             	mov    0x8(%ebp),%eax
c00026c6:	8b 40 30             	mov    0x30(%eax),%eax
c00026c9:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // We will start looking for free physical memory just above the kernel
    page_t* first_free_page = align_addr( &_kernel_end_phys, PAGE_SIZE); //physical address of first free page after the kernel
c00026cc:	68 00 10 00 00       	push   $0x1000
c00026d1:	68 88 19 11 00       	push   $0x111988
c00026d6:	e8 59 ff ff ff       	call   c0002634 <align_addr>
c00026db:	83 c4 08             	add    $0x8,%esp
c00026de:	89 45 e8             	mov    %eax,-0x18(%ebp)

    // Map the stack just past the end of the kernel in virtual mem

    // stack_break points to the end of the allocated region for the stack  
    free_stack_brk = align_addr( &_kernel_end, PAGE_SIZE);
c00026e1:	68 00 10 00 00       	push   $0x1000
c00026e6:	68 88 09 01 c0       	push   $0xc0010988
c00026eb:	e8 44 ff ff ff       	call   c0002634 <align_addr>
c00026f0:	83 c4 08             	add    $0x8,%esp
c00026f3:	a3 a0 08 01 c0       	mov    %eax,0xc00108a0

    // initialize stack pointers
    // we will initialize the stack by adding new pages to the base
    // first pages (in low mem) will be at top of the stack
    free_stack_start = (page_t**) free_stack_brk;
c00026f8:	a1 a0 08 01 c0       	mov    0xc00108a0,%eax
c00026fd:	a3 94 08 01 c0       	mov    %eax,0xc0010894
    free_stack_top = free_stack_start;
c0002702:	a1 94 08 01 c0       	mov    0xc0010894,%eax
c0002707:	a3 98 08 01 c0       	mov    %eax,0xc0010898
    free_stack_base = free_stack_top;
c000270c:	a1 98 08 01 c0       	mov    0xc0010898,%eax
c0002711:	a3 9c 08 01 c0       	mov    %eax,0xc001089c

    // allocate one page for the stack, incrementing the stack_break and first_free_page pointers
    // We will allocate more pages for the stack as we go as needed
    if(!map_page_at(free_stack_brk++, first_free_page++, PAGE_FLAG_WRITE))
c0002716:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0002719:	8d 82 00 10 00 00    	lea    0x1000(%edx),%eax
c000271f:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0002722:	a1 a0 08 01 c0       	mov    0xc00108a0,%eax
c0002727:	8d 88 00 10 00 00    	lea    0x1000(%eax),%ecx
c000272d:	89 0d a0 08 01 c0    	mov    %ecx,0xc00108a0
c0002733:	83 ec 04             	sub    $0x4,%esp
c0002736:	6a 02                	push   $0x2
c0002738:	52                   	push   %edx
c0002739:	50                   	push   %eax
c000273a:	e8 32 04 00 00       	call   c0002b71 <map_page_at>
c000273f:	83 c4 10             	add    $0x10,%esp
c0002742:	85 c0                	test   %eax,%eax
c0002744:	75 10                	jne    c0002756 <init_page_stack+0x9b>
        panic("Error reserving memory for physical page allocation!");
c0002746:	83 ec 0c             	sub    $0xc,%esp
c0002749:	68 c8 46 00 c0       	push   $0xc00046c8
c000274e:	e8 23 ed ff ff       	call   c0001476 <panic>
c0002753:	83 c4 10             	add    $0x10,%esp

    // loop through each block of memory defined in the multiboot record
    // for each block of memory, add free pages to stack
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0002756:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000275d:	e9 50 01 00 00       	jmp    c00028b2 <init_page_stack+0x1f7>
	{
        if(mmap_table[nn].size == 0) // end of table
c0002762:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002765:	89 d0                	mov    %edx,%eax
c0002767:	01 c0                	add    %eax,%eax
c0002769:	01 d0                	add    %edx,%eax
c000276b:	c1 e0 03             	shl    $0x3,%eax
c000276e:	89 c2                	mov    %eax,%edx
c0002770:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002773:	01 d0                	add    %edx,%eax
c0002775:	8b 00                	mov    (%eax),%eax
c0002777:	85 c0                	test   %eax,%eax
c0002779:	0f 84 44 01 00 00    	je     c00028c3 <init_page_stack+0x208>
            break;

        if(mmap_table[nn].addr >> 32) // ignore anything above 32bits
c000277f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002782:	89 d0                	mov    %edx,%eax
c0002784:	01 c0                	add    %eax,%eax
c0002786:	01 d0                	add    %edx,%eax
c0002788:	c1 e0 03             	shl    $0x3,%eax
c000278b:	89 c2                	mov    %eax,%edx
c000278d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002790:	01 d0                	add    %edx,%eax
c0002792:	8b 50 08             	mov    0x8(%eax),%edx
c0002795:	8b 40 04             	mov    0x4(%eax),%eax
c0002798:	89 d0                	mov    %edx,%eax
c000279a:	31 d2                	xor    %edx,%edx
c000279c:	89 c1                	mov    %eax,%ecx
c000279e:	80 f5 00             	xor    $0x0,%ch
c00027a1:	89 ce                	mov    %ecx,%esi
c00027a3:	89 d0                	mov    %edx,%eax
c00027a5:	80 f4 00             	xor    $0x0,%ah
c00027a8:	89 c7                	mov    %eax,%edi
c00027aa:	89 f8                	mov    %edi,%eax
c00027ac:	09 f0                	or     %esi,%eax
c00027ae:	85 c0                	test   %eax,%eax
c00027b0:	0f 85 f7 00 00 00    	jne    c00028ad <init_page_stack+0x1f2>
            continue;

		if(mmap_table[nn].type == MULTIBOOT_MEMORY_AVAILABLE)
c00027b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00027b9:	89 d0                	mov    %edx,%eax
c00027bb:	01 c0                	add    %eax,%eax
c00027bd:	01 d0                	add    %edx,%eax
c00027bf:	c1 e0 03             	shl    $0x3,%eax
c00027c2:	89 c2                	mov    %eax,%edx
c00027c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00027c7:	01 d0                	add    %edx,%eax
c00027c9:	8b 40 14             	mov    0x14(%eax),%eax
c00027cc:	83 f8 01             	cmp    $0x1,%eax
c00027cf:	0f 85 d9 00 00 00    	jne    c00028ae <init_page_stack+0x1f3>
        {
            //pointers to the first and last page in this memory block 
            size_t block_addr = mmap_table[nn].addr;
c00027d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00027d8:	89 d0                	mov    %edx,%eax
c00027da:	01 c0                	add    %eax,%eax
c00027dc:	01 d0                	add    %edx,%eax
c00027de:	c1 e0 03             	shl    $0x3,%eax
c00027e1:	89 c2                	mov    %eax,%edx
c00027e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00027e6:	01 d0                	add    %edx,%eax
c00027e8:	8b 50 08             	mov    0x8(%eax),%edx
c00027eb:	8b 40 04             	mov    0x4(%eax),%eax
c00027ee:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            size_t block_len = mmap_table[nn].len;
c00027f1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00027f4:	89 d0                	mov    %edx,%eax
c00027f6:	01 c0                	add    %eax,%eax
c00027f8:	01 d0                	add    %edx,%eax
c00027fa:	c1 e0 03             	shl    $0x3,%eax
c00027fd:	89 c2                	mov    %eax,%edx
c00027ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002802:	01 d0                	add    %edx,%eax
c0002804:	8b 50 10             	mov    0x10(%eax),%edx
c0002807:	8b 40 0c             	mov    0xc(%eax),%eax
c000280a:	89 45 e0             	mov    %eax,-0x20(%ebp)
            page_t* pg = align_addr( (char*) block_addr, PAGE_SIZE); // first whole page in block
c000280d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0002810:	83 ec 08             	sub    $0x8,%esp
c0002813:	68 00 10 00 00       	push   $0x1000
c0002818:	50                   	push   %eax
c0002819:	e8 16 fe ff ff       	call   c0002634 <align_addr>
c000281e:	83 c4 10             	add    $0x10,%esp
c0002821:	89 45 f0             	mov    %eax,-0x10(%ebp)
            page_t* pg_end = (page_t*) ((block_addr+block_len) & PAGE_ADDRMASK); // first page *after* last whole page in block
c0002824:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0002827:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000282a:	01 d0                	add    %edx,%eax
c000282c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002831:	89 45 dc             	mov    %eax,-0x24(%ebp)

            //don't map any memory before end of the kernel
            pg = pg<first_free_page ? first_free_page : pg; 
c0002834:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002837:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c000283a:	0f 43 45 f0          	cmovae -0x10(%ebp),%eax
c000283e:	89 45 f0             	mov    %eax,-0x10(%ebp)

            //fill stack with pointers to each page in the block
            for(; pg<pg_end; pg++)
c0002841:	eb 60                	jmp    c00028a3 <init_page_stack+0x1e8>
            {
                // extend end of stack and make sure we have allocated enough memory
                if( (void*) ++free_stack_base >= (void*) free_stack_brk)
c0002843:	a1 9c 08 01 c0       	mov    0xc001089c,%eax
c0002848:	83 c0 04             	add    $0x4,%eax
c000284b:	a3 9c 08 01 c0       	mov    %eax,0xc001089c
c0002850:	8b 15 9c 08 01 c0    	mov    0xc001089c,%edx
c0002856:	a1 a0 08 01 c0       	mov    0xc00108a0,%eax
c000285b:	39 c2                	cmp    %eax,%edx
c000285d:	72 33                	jb     c0002892 <init_page_stack+0x1d7>
                {
                    // map a new page at the end of the stack
                    // note that this will pop a free page off the top of the stack
                    if(!map_page(free_stack_brk++, PAGE_FLAG_WRITE))
c000285f:	a1 a0 08 01 c0       	mov    0xc00108a0,%eax
c0002864:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c000286a:	89 15 a0 08 01 c0    	mov    %edx,0xc00108a0
c0002870:	83 ec 08             	sub    $0x8,%esp
c0002873:	6a 02                	push   $0x2
c0002875:	50                   	push   %eax
c0002876:	e8 86 03 00 00       	call   c0002c01 <map_page>
c000287b:	83 c4 10             	add    $0x10,%esp
c000287e:	85 c0                	test   %eax,%eax
c0002880:	75 10                	jne    c0002892 <init_page_stack+0x1d7>
                        panic("Error reserving memory for physical page allocation!");
c0002882:	83 ec 0c             	sub    $0xc,%esp
c0002885:	68 c8 46 00 c0       	push   $0xc00046c8
c000288a:	e8 e7 eb ff ff       	call   c0001476 <panic>
c000288f:	83 c4 10             	add    $0x10,%esp
                }

                //record physical page at end stack
                *free_stack_base = pg;
c0002892:	a1 9c 08 01 c0       	mov    0xc001089c,%eax
c0002897:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000289a:	89 10                	mov    %edx,(%eax)
            for(; pg<pg_end; pg++)
c000289c:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
c00028a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00028a6:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c00028a9:	72 98                	jb     c0002843 <init_page_stack+0x188>
c00028ab:	eb 01                	jmp    c00028ae <init_page_stack+0x1f3>
            continue;
c00028ad:	90                   	nop
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c00028ae:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00028b2:	8b 45 08             	mov    0x8(%ebp),%eax
c00028b5:	8b 40 2c             	mov    0x2c(%eax),%eax
c00028b8:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c00028bb:	0f 82 a1 fe ff ff    	jb     c0002762 <init_page_stack+0xa7>
c00028c1:	eb 01                	jmp    c00028c4 <init_page_stack+0x209>
            break;
c00028c3:	90                   	nop
            }
        }
	}

    size_t free_pages = free_stack_base-free_stack_top;
c00028c4:	a1 9c 08 01 c0       	mov    0xc001089c,%eax
c00028c9:	8b 15 98 08 01 c0    	mov    0xc0010898,%edx
c00028cf:	29 d0                	sub    %edx,%eax
c00028d1:	c1 f8 02             	sar    $0x2,%eax
c00028d4:	89 45 d8             	mov    %eax,-0x28(%ebp)
	kprintf("\nFound %d pages (%f MB)\n", free_pages, free_pages*PAGE_SIZE/1e6);
c00028d7:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00028da:	c1 e0 0c             	shl    $0xc,%eax
c00028dd:	89 45 d0             	mov    %eax,-0x30(%ebp)
c00028e0:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
c00028e7:	df 6d d0             	fildll -0x30(%ebp)
c00028ea:	dd 05 18 47 00 c0    	fldl   0xc0004718
c00028f0:	de f9                	fdivrp %st,%st(1)
c00028f2:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c00028f6:	dd 1c 24             	fstpl  (%esp)
c00028f9:	ff 75 d8             	pushl  -0x28(%ebp)
c00028fc:	68 fd 46 00 c0       	push   $0xc00046fd
c0002901:	e8 53 dd ff ff       	call   c0000659 <kprintf>
c0002906:	83 c4 10             	add    $0x10,%esp

}
c0002909:	90                   	nop
c000290a:	8d 65 f8             	lea    -0x8(%ebp),%esp
c000290d:	5e                   	pop    %esi
c000290e:	5f                   	pop    %edi
c000290f:	5d                   	pop    %ebp
c0002910:	c3                   	ret    

c0002911 <ksbrk>:


// increment heap size, return pointer to *old* break (beginning of newly allocated memory)
void* ksbrk(size_t increment)
{
c0002911:	55                   	push   %ebp
c0002912:	89 e5                	mov    %esp,%ebp
c0002914:	83 ec 18             	sub    $0x18,%esp
    if(increment == 0) return kheap_brk;
c0002917:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c000291b:	75 07                	jne    c0002924 <ksbrk+0x13>
c000291d:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
c0002922:	eb 2d                	jmp    c0002951 <ksbrk+0x40>

    page_t* old_brk = kheap_brk;
c0002924:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
c0002929:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(kbrk(((char*)kheap_brk) + increment)) return NULL;
c000292c:	8b 15 8c 08 01 c0    	mov    0xc001088c,%edx
c0002932:	8b 45 08             	mov    0x8(%ebp),%eax
c0002935:	01 d0                	add    %edx,%eax
c0002937:	83 ec 0c             	sub    $0xc,%esp
c000293a:	50                   	push   %eax
c000293b:	e8 13 00 00 00       	call   c0002953 <kbrk>
c0002940:	83 c4 10             	add    $0x10,%esp
c0002943:	85 c0                	test   %eax,%eax
c0002945:	74 07                	je     c000294e <ksbrk+0x3d>
c0002947:	b8 00 00 00 00       	mov    $0x0,%eax
c000294c:	eb 03                	jmp    c0002951 <ksbrk+0x40>

    return old_brk;
c000294e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0002951:	c9                   	leave  
c0002952:	c3                   	ret    

c0002953 <kbrk>:

// set kheap break to addr, growing or shrinking heap accordingly
// returns 0 on success
int kbrk(void* addr)
{
c0002953:	55                   	push   %ebp
c0002954:	89 e5                	mov    %esp,%ebp
c0002956:	83 ec 18             	sub    $0x18,%esp
    //make sure this is a valid break (not before heap begins or into stack)
    if(addr < (void*) kheap_base || addr >= (void*) kstack_brk)
c0002959:	a1 90 08 01 c0       	mov    0xc0010890,%eax
c000295e:	39 45 08             	cmp    %eax,0x8(%ebp)
c0002961:	72 0a                	jb     c000296d <kbrk+0x1a>
c0002963:	a1 88 08 01 c0       	mov    0xc0010888,%eax
c0002968:	39 45 08             	cmp    %eax,0x8(%ebp)
c000296b:	72 0a                	jb     c0002977 <kbrk+0x24>
        return -1; 
c000296d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002972:	e9 8f 00 00 00       	jmp    c0002a06 <kbrk+0xb3>

    page_t* pg_addr = align_addr(addr, PAGE_SIZE); // align addr to a page
c0002977:	68 00 10 00 00       	push   $0x1000
c000297c:	ff 75 08             	pushl  0x8(%ebp)
c000297f:	e8 b0 fc ff ff       	call   c0002634 <align_addr>
c0002984:	83 c4 08             	add    $0x8,%esp
c0002987:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(pg_addr > kheap_brk)
c000298a:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
c000298f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0002992:	76 63                	jbe    c00029f7 <kbrk+0xa4>
    {
        // we are increasing size of the heap
        while(pg_addr > kheap_brk)
c0002994:	eb 2a                	jmp    c00029c0 <kbrk+0x6d>
        {
            // allocate a new page and map to end of heap
            if(!map_page(kheap_brk++, PAGE_FLAG_WRITE))
c0002996:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
c000299b:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c00029a1:	89 15 8c 08 01 c0    	mov    %edx,0xc001088c
c00029a7:	83 ec 08             	sub    $0x8,%esp
c00029aa:	6a 02                	push   $0x2
c00029ac:	50                   	push   %eax
c00029ad:	e8 4f 02 00 00       	call   c0002c01 <map_page>
c00029b2:	83 c4 10             	add    $0x10,%esp
c00029b5:	85 c0                	test   %eax,%eax
c00029b7:	75 07                	jne    c00029c0 <kbrk+0x6d>
                return -1; // out of physical memory
c00029b9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00029be:	eb 46                	jmp    c0002a06 <kbrk+0xb3>
        while(pg_addr > kheap_brk)
c00029c0:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
c00029c5:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c00029c8:	77 cc                	ja     c0002996 <kbrk+0x43>
c00029ca:	eb 35                	jmp    c0002a01 <kbrk+0xae>
    {
        // we are decreasing size of the heap
        while(pg_addr < kheap_brk)
        {
            //free page from end of heap
            if(unmap_page(--kheap_brk))
c00029cc:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
c00029d1:	2d 00 10 00 00       	sub    $0x1000,%eax
c00029d6:	a3 8c 08 01 c0       	mov    %eax,0xc001088c
c00029db:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
c00029e0:	83 ec 0c             	sub    $0xc,%esp
c00029e3:	50                   	push   %eax
c00029e4:	e8 37 02 00 00       	call   c0002c20 <unmap_page>
c00029e9:	83 c4 10             	add    $0x10,%esp
c00029ec:	85 c0                	test   %eax,%eax
c00029ee:	74 07                	je     c00029f7 <kbrk+0xa4>
                return -1; // error!
c00029f0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00029f5:	eb 0f                	jmp    c0002a06 <kbrk+0xb3>
        while(pg_addr < kheap_brk)
c00029f7:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
c00029fc:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c00029ff:	72 cb                	jb     c00029cc <kbrk+0x79>
        }
    }

	// kprintf("Setting kernel heap break to 0x%x\n", kheap_brk);
    
    return 0;
c0002a01:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002a06:	c9                   	leave  
c0002a07:	c3                   	ret    

c0002a08 <memory_init>:


int memory_init(multiboot_info_t* mbd)
{
c0002a08:	55                   	push   %ebp
c0002a09:	89 e5                	mov    %esp,%ebp
c0002a0b:	83 ec 08             	sub    $0x8,%esp
    init_page_stack(mbd);
c0002a0e:	83 ec 0c             	sub    $0xc,%esp
c0002a11:	ff 75 08             	pushl  0x8(%ebp)
c0002a14:	e8 a2 fc ff ff       	call   c00026bb <init_page_stack>
c0002a19:	83 c4 10             	add    $0x10,%esp

    // define some dummy pointers for where we will put the stack
    // TODO: actually set up a stack here
    kstack_base = (page_t*) 0xffb00000; 
c0002a1c:	c7 05 84 08 01 c0 00 	movl   $0xffb00000,0xc0010884
c0002a23:	00 b0 ff 
    kstack_brk = (page_t*)  0xf0000000;
c0002a26:	c7 05 88 08 01 c0 00 	movl   $0xf0000000,0xc0010888
c0002a2d:	00 00 f0 

    kheap_base = free_stack_brk; //start heap after the page stack allocator
c0002a30:	a1 a0 08 01 c0       	mov    0xc00108a0,%eax
c0002a35:	a3 90 08 01 c0       	mov    %eax,0xc0010890
    kheap_brk = kheap_base;     // heap starts empty - increase with ksbrk
c0002a3a:	a1 90 08 01 c0       	mov    0xc0010890,%eax
c0002a3f:	a3 8c 08 01 c0       	mov    %eax,0xc001088c

    // we don't need the 1st MB anymore so unmap it
	if( unmap_lowmem() )
c0002a44:	e8 22 00 00 00       	call   c0002a6b <unmap_lowmem>
c0002a49:	85 c0                	test   %eax,%eax
c0002a4b:	74 07                	je     c0002a54 <memory_init+0x4c>
        return -1;
c0002a4d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002a52:	eb 15                	jmp    c0002a69 <memory_init+0x61>

    // except for VGA memory - still need that..
	if(! map_vga() )
c0002a54:	e8 33 00 00 00       	call   c0002a8c <map_vga>
c0002a59:	85 c0                	test   %eax,%eax
c0002a5b:	75 07                	jne    c0002a64 <memory_init+0x5c>
        return -1;
c0002a5d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002a62:	eb 05                	jmp    c0002a69 <memory_init+0x61>

    return 0;
c0002a64:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002a69:	c9                   	leave  
c0002a6a:	c3                   	ret    

c0002a6b <unmap_lowmem>:

int unmap_lowmem()
{
c0002a6b:	55                   	push   %ebp
c0002a6c:	89 e5                	mov    %esp,%ebp
c0002a6e:	83 ec 08             	sub    $0x8,%esp
    pd->dir.pde[0] = PAGE_FLAG_EMPTY;
c0002a71:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c0002a76:	c7 80 00 f0 3f 00 00 	movl   $0x0,0x3ff000(%eax)
c0002a7d:	00 00 00 
    refresh_tlb();
c0002a80:	e8 b3 10 00 00       	call   c0003b38 <refresh_tlb>
    return 0;
c0002a85:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002a8a:	c9                   	leave  
c0002a8b:	c3                   	ret    

c0002a8c <map_vga>:
// {

// }

char* map_vga()
{
c0002a8c:	55                   	push   %ebp
c0002a8d:	89 e5                	mov    %esp,%ebp
c0002a8f:	83 ec 18             	sub    $0x18,%esp
    page_t* vga_buf = (page_t*) VGA_BUFFER;
c0002a92:	c7 45 f4 00 80 0b 00 	movl   $0xb8000,-0xc(%ebp)

    //map 6 pages of vga memory    
    map_page_at(vga_buf,vga_buf, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c0002a99:	83 ec 04             	sub    $0x4,%esp
c0002a9c:	6a 06                	push   $0x6
c0002a9e:	ff 75 f4             	pushl  -0xc(%ebp)
c0002aa1:	ff 75 f4             	pushl  -0xc(%ebp)
c0002aa4:	e8 c8 00 00 00       	call   c0002b71 <map_page_at>
c0002aa9:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+1,vga_buf+1, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c0002aac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002aaf:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c0002ab5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002ab8:	05 00 10 00 00       	add    $0x1000,%eax
c0002abd:	83 ec 04             	sub    $0x4,%esp
c0002ac0:	6a 06                	push   $0x6
c0002ac2:	52                   	push   %edx
c0002ac3:	50                   	push   %eax
c0002ac4:	e8 a8 00 00 00       	call   c0002b71 <map_page_at>
c0002ac9:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+2,vga_buf+2, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c0002acc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002acf:	8d 90 00 20 00 00    	lea    0x2000(%eax),%edx
c0002ad5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002ad8:	05 00 20 00 00       	add    $0x2000,%eax
c0002add:	83 ec 04             	sub    $0x4,%esp
c0002ae0:	6a 06                	push   $0x6
c0002ae2:	52                   	push   %edx
c0002ae3:	50                   	push   %eax
c0002ae4:	e8 88 00 00 00       	call   c0002b71 <map_page_at>
c0002ae9:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+3,vga_buf+3, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c0002aec:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002aef:	8d 90 00 30 00 00    	lea    0x3000(%eax),%edx
c0002af5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002af8:	05 00 30 00 00       	add    $0x3000,%eax
c0002afd:	83 ec 04             	sub    $0x4,%esp
c0002b00:	6a 06                	push   $0x6
c0002b02:	52                   	push   %edx
c0002b03:	50                   	push   %eax
c0002b04:	e8 68 00 00 00       	call   c0002b71 <map_page_at>
c0002b09:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+4,vga_buf+4, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c0002b0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002b0f:	8d 90 00 40 00 00    	lea    0x4000(%eax),%edx
c0002b15:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002b18:	05 00 40 00 00       	add    $0x4000,%eax
c0002b1d:	83 ec 04             	sub    $0x4,%esp
c0002b20:	6a 06                	push   $0x6
c0002b22:	52                   	push   %edx
c0002b23:	50                   	push   %eax
c0002b24:	e8 48 00 00 00       	call   c0002b71 <map_page_at>
c0002b29:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+5,vga_buf+5, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c0002b2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002b2f:	8d 90 00 50 00 00    	lea    0x5000(%eax),%edx
c0002b35:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002b38:	05 00 50 00 00       	add    $0x5000,%eax
c0002b3d:	83 ec 04             	sub    $0x4,%esp
c0002b40:	6a 06                	push   $0x6
c0002b42:	52                   	push   %edx
c0002b43:	50                   	push   %eax
c0002b44:	e8 28 00 00 00       	call   c0002b71 <map_page_at>
c0002b49:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+6,vga_buf+6, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c0002b4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002b4f:	8d 90 00 60 00 00    	lea    0x6000(%eax),%edx
c0002b55:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002b58:	05 00 60 00 00       	add    $0x6000,%eax
c0002b5d:	83 ec 04             	sub    $0x4,%esp
c0002b60:	6a 06                	push   $0x6
c0002b62:	52                   	push   %edx
c0002b63:	50                   	push   %eax
c0002b64:	e8 08 00 00 00       	call   c0002b71 <map_page_at>
c0002b69:	83 c4 10             	add    $0x10,%esp

    return (char*) vga_buf;
c0002b6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0002b6f:	c9                   	leave  
c0002b70:	c3                   	ret    

c0002b71 <map_page_at>:

page_t* map_page_at(page_t* page_virt, page_t* page_phys, uint32_t flags)
{
c0002b71:	55                   	push   %ebp
c0002b72:	89 e5                	mov    %esp,%ebp
c0002b74:	53                   	push   %ebx
c0002b75:	83 ec 14             	sub    $0x14,%esp
    page_table_t* pt = get_table(page_virt);
c0002b78:	83 ec 0c             	sub    $0xc,%esp
c0002b7b:	ff 75 08             	pushl  0x8(%ebp)
c0002b7e:	e8 cb f9 ff ff       	call   c000254e <get_table>
c0002b83:	83 c4 10             	add    $0x10,%esp
c0002b86:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(!pt)
c0002b89:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002b8d:	75 14                	jne    c0002ba3 <map_page_at+0x32>
        pt = new_page_table(page_virt, flags); // page table is not present, allocate a new one
c0002b8f:	83 ec 08             	sub    $0x8,%esp
c0002b92:	ff 75 10             	pushl  0x10(%ebp)
c0002b95:	ff 75 08             	pushl  0x8(%ebp)
c0002b98:	e8 a5 00 00 00       	call   c0002c42 <new_page_table>
c0002b9d:	83 c4 10             	add    $0x10,%esp
c0002ba0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    
    if(pt->pte[get_ptindex(page_virt)] & PAGE_FLAG_PRESENT)
c0002ba3:	83 ec 0c             	sub    $0xc,%esp
c0002ba6:	ff 75 08             	pushl  0x8(%ebp)
c0002ba9:	e8 6b fa ff ff       	call   c0002619 <get_ptindex>
c0002bae:	83 c4 10             	add    $0x10,%esp
c0002bb1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002bb4:	8b 04 82             	mov    (%edx,%eax,4),%eax
c0002bb7:	83 e0 01             	and    $0x1,%eax
c0002bba:	85 c0                	test   %eax,%eax
c0002bbc:	74 07                	je     c0002bc5 <map_page_at+0x54>
        return NULL; //page already mapped
c0002bbe:	b8 00 00 00 00       	mov    $0x0,%eax
c0002bc3:	eb 37                	jmp    c0002bfc <map_page_at+0x8b>

    // map page
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0002bc5:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002bc8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002bcd:	0b 45 10             	or     0x10(%ebp),%eax
c0002bd0:	89 c3                	mov    %eax,%ebx
c0002bd2:	83 ec 0c             	sub    $0xc,%esp
c0002bd5:	ff 75 08             	pushl  0x8(%ebp)
c0002bd8:	e8 3c fa ff ff       	call   c0002619 <get_ptindex>
c0002bdd:	83 c4 10             	add    $0x10,%esp
c0002be0:	89 d9                	mov    %ebx,%ecx
c0002be2:	83 c9 01             	or     $0x1,%ecx
c0002be5:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002be8:	89 0c 82             	mov    %ecx,(%edx,%eax,4)

    refresh_page(page_virt);
c0002beb:	83 ec 0c             	sub    $0xc,%esp
c0002bee:	ff 75 08             	pushl  0x8(%ebp)
c0002bf1:	e8 4a 0f 00 00       	call   c0003b40 <refresh_page>
c0002bf6:	83 c4 10             	add    $0x10,%esp
    return page_virt;
c0002bf9:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0002bfc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0002bff:	c9                   	leave  
c0002c00:	c3                   	ret    

c0002c01 <map_page>:

page_t* map_page(page_t* page_virt, uint32_t flags)
{
c0002c01:	55                   	push   %ebp
c0002c02:	89 e5                	mov    %esp,%ebp
c0002c04:	83 ec 08             	sub    $0x8,%esp
    return map_page_at(page_virt, pop_free_page(), flags);
c0002c07:	e8 48 fa ff ff       	call   c0002654 <pop_free_page>
c0002c0c:	83 ec 04             	sub    $0x4,%esp
c0002c0f:	ff 75 0c             	pushl  0xc(%ebp)
c0002c12:	50                   	push   %eax
c0002c13:	ff 75 08             	pushl  0x8(%ebp)
c0002c16:	e8 56 ff ff ff       	call   c0002b71 <map_page_at>
c0002c1b:	83 c4 10             	add    $0x10,%esp
}
c0002c1e:	c9                   	leave  
c0002c1f:	c3                   	ret    

c0002c20 <unmap_page>:

int unmap_page(page_t* page_virt)
{
c0002c20:	55                   	push   %ebp
c0002c21:	89 e5                	mov    %esp,%ebp
c0002c23:	83 ec 08             	sub    $0x8,%esp
    return push_free_page(get_physaddr(page_virt));
c0002c26:	83 ec 0c             	sub    $0xc,%esp
c0002c29:	ff 75 08             	pushl  0x8(%ebp)
c0002c2c:	e8 6d f9 ff ff       	call   c000259e <get_physaddr>
c0002c31:	83 c4 10             	add    $0x10,%esp
c0002c34:	83 ec 0c             	sub    $0xc,%esp
c0002c37:	50                   	push   %eax
c0002c38:	e8 4b fa ff ff       	call   c0002688 <push_free_page>
c0002c3d:	83 c4 10             	add    $0x10,%esp
}
c0002c40:	c9                   	leave  
c0002c41:	c3                   	ret    

c0002c42 <new_page_table>:

page_table_t* new_page_table(void* addr, uint32_t flags)
{
c0002c42:	55                   	push   %ebp
c0002c43:	89 e5                	mov    %esp,%ebp
c0002c45:	83 ec 18             	sub    $0x18,%esp
    uint32_t pdindex = get_pdindex(addr);      // index into page dir (which table does this address point to)
c0002c48:	ff 75 08             	pushl  0x8(%ebp)
c0002c4b:	e8 d9 f9 ff ff       	call   c0002629 <get_pdindex>
c0002c50:	83 c4 04             	add    $0x4,%esp
c0002c53:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // is this table already mapped?
    if(pd->dir.pde[pdindex] & PAGE_FLAG_PRESENT)
c0002c56:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c0002c5b:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002c5e:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c0002c64:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0002c67:	83 e0 01             	and    $0x1,%eax
c0002c6a:	85 c0                	test   %eax,%eax
c0002c6c:	74 07                	je     c0002c75 <new_page_table+0x33>
        return NULL;
c0002c6e:	b8 00 00 00 00       	mov    $0x0,%eax
c0002c73:	eb 70                	jmp    c0002ce5 <new_page_table+0xa3>

    page_t* pp = pop_free_page();         // find a free page in physical mem for page table
c0002c75:	e8 da f9 ff ff       	call   c0002654 <pop_free_page>
c0002c7a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!pp) return NULL; // OOM
c0002c7d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0002c81:	75 07                	jne    c0002c8a <new_page_table+0x48>
c0002c83:	b8 00 00 00 00       	mov    $0x0,%eax
c0002c88:	eb 5b                	jmp    c0002ce5 <new_page_table+0xa3>

    // we don't need to allocate virtual memory space, since table lives in our paging structure
    page_table_t* pv = pd->tables + pdindex;        // pointer to table (virtual)
c0002c8a:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c0002c8f:	89 c2                	mov    %eax,%edx
c0002c91:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002c94:	c1 e0 0c             	shl    $0xc,%eax
c0002c97:	01 d0                	add    %edx,%eax
c0002c99:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // map table: point the pd entry at the physical page we just reserved, and set flags
    pd->dir.pde[pdindex] = (((uint32_t) pp) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0002c9c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002c9f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002ca4:	0b 45 0c             	or     0xc(%ebp),%eax
c0002ca7:	89 c2                	mov    %eax,%edx
c0002ca9:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c0002cae:	89 d1                	mov    %edx,%ecx
c0002cb0:	83 c9 01             	or     $0x1,%ecx
c0002cb3:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002cb6:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c0002cbc:	89 0c 90             	mov    %ecx,(%eax,%edx,4)

    // flush the tlb
    refresh_page(pv);
c0002cbf:	83 ec 0c             	sub    $0xc,%esp
c0002cc2:	ff 75 ec             	pushl  -0x14(%ebp)
c0002cc5:	e8 76 0e 00 00       	call   c0003b40 <refresh_page>
c0002cca:	83 c4 10             	add    $0x10,%esp

    //clear table
    memset((char*) pv, 0, PAGE_SIZE);     
c0002ccd:	83 ec 04             	sub    $0x4,%esp
c0002cd0:	68 00 10 00 00       	push   $0x1000
c0002cd5:	6a 00                	push   $0x0
c0002cd7:	ff 75 ec             	pushl  -0x14(%ebp)
c0002cda:	e8 79 e8 ff ff       	call   c0001558 <memset>
c0002cdf:	83 c4 10             	add    $0x10,%esp

    // return pointer to table (virtual)
    return pv;
c0002ce2:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c0002ce5:	c9                   	leave  
c0002ce6:	c3                   	ret    

c0002ce7 <kheap_validate_block>:
void* kmalloc_aligned(size_t sz, size_t alignment);
int kfree(void* p);

// check magic number
static inline int kheap_validate_block(heap_block_t* b)
{
c0002ce7:	55                   	push   %ebp
c0002ce8:	89 e5                	mov    %esp,%ebp
    return b->magic != HEAP_BLOCK_MAGIC;
c0002cea:	8b 45 08             	mov    0x8(%ebp),%eax
c0002ced:	8b 00                	mov    (%eax),%eax
c0002cef:	25 ff ff ff 0f       	and    $0xfffffff,%eax
c0002cf4:	3d ef be 23 01       	cmp    $0x123beef,%eax
c0002cf9:	0f 95 c0             	setne  %al
c0002cfc:	0f b6 c0             	movzbl %al,%eax
}
c0002cff:	5d                   	pop    %ebp
c0002d00:	c3                   	ret    

c0002d01 <align_addr>:
{
c0002d01:	55                   	push   %ebp
c0002d02:	89 e5                	mov    %esp,%ebp
c0002d04:	83 ec 10             	sub    $0x10,%esp
    uint32_t am = alignment - 1;
c0002d07:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002d0a:	83 e8 01             	sub    $0x1,%eax
c0002d0d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (char*) (((uint32_t)addr + am) & ~am);
c0002d10:	8b 55 08             	mov    0x8(%ebp),%edx
c0002d13:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002d16:	01 c2                	add    %eax,%edx
c0002d18:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002d1b:	f7 d0                	not    %eax
c0002d1d:	21 d0                	and    %edx,%eax
}
c0002d1f:	c9                   	leave  
c0002d20:	c3                   	ret    

c0002d21 <kmalloc_init>:
#include "common.h"

heap_block_t* kheap_head = NULL;

int kmalloc_init()
{
c0002d21:	55                   	push   %ebp
c0002d22:	89 e5                	mov    %esp,%ebp
c0002d24:	83 ec 08             	sub    $0x8,%esp
    kheap_head = ksbrk(HEAP_INCREMENT);
c0002d27:	83 ec 0c             	sub    $0xc,%esp
c0002d2a:	68 00 40 00 00       	push   $0x4000
c0002d2f:	e8 dd fb ff ff       	call   c0002911 <ksbrk>
c0002d34:	83 c4 10             	add    $0x10,%esp
c0002d37:	a3 a4 08 01 c0       	mov    %eax,0xc00108a4
   
    if(!kheap_head)
c0002d3c:	a1 a4 08 01 c0       	mov    0xc00108a4,%eax
c0002d41:	85 c0                	test   %eax,%eax
c0002d43:	75 0a                	jne    c0002d4f <kmalloc_init+0x2e>
        return -1;
c0002d45:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002d4a:	e9 a1 00 00 00       	jmp    c0002df0 <kmalloc_init+0xcf>

    kheap_head = align_addr(kheap_head,HEAP_BLOCKSIZE_UNITS);
c0002d4f:	a1 a4 08 01 c0       	mov    0xc00108a4,%eax
c0002d54:	83 ec 08             	sub    $0x8,%esp
c0002d57:	6a 10                	push   $0x10
c0002d59:	50                   	push   %eax
c0002d5a:	e8 a2 ff ff ff       	call   c0002d01 <align_addr>
c0002d5f:	83 c4 10             	add    $0x10,%esp
c0002d62:	a3 a4 08 01 c0       	mov    %eax,0xc00108a4

    kheap_head->magic = HEAP_BLOCK_MAGIC;
c0002d67:	a1 a4 08 01 c0       	mov    0xc00108a4,%eax
c0002d6c:	8b 10                	mov    (%eax),%edx
c0002d6e:	81 e2 00 00 00 f0    	and    $0xf0000000,%edx
c0002d74:	81 ca ef be 23 01    	or     $0x123beef,%edx
c0002d7a:	89 10                	mov    %edx,(%eax)
    kheap_head->status = HEAP_BLOCK_FREE;
c0002d7c:	a1 a4 08 01 c0       	mov    0xc00108a4,%eax
c0002d81:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c0002d85:	83 e2 0f             	and    $0xf,%edx
c0002d88:	88 50 03             	mov    %dl,0x3(%eax)
    kheap_head->prev = kheap_head;
c0002d8b:	a1 a4 08 01 c0       	mov    0xc00108a4,%eax
c0002d90:	8b 15 a4 08 01 c0    	mov    0xc00108a4,%edx
c0002d96:	89 50 04             	mov    %edx,0x4(%eax)
    kheap_head->next = kheap_head;
c0002d99:	a1 a4 08 01 c0       	mov    0xc00108a4,%eax
c0002d9e:	8b 15 a4 08 01 c0    	mov    0xc00108a4,%edx
c0002da4:	89 50 08             	mov    %edx,0x8(%eax)

    kheap_head->size = ((heap_block_t*) ksbrk(0)) - kheap_head;
c0002da7:	83 ec 0c             	sub    $0xc,%esp
c0002daa:	6a 00                	push   $0x0
c0002dac:	e8 60 fb ff ff       	call   c0002911 <ksbrk>
c0002db1:	83 c4 10             	add    $0x10,%esp
c0002db4:	8b 15 a4 08 01 c0    	mov    0xc00108a4,%edx
c0002dba:	29 d0                	sub    %edx,%eax
c0002dbc:	c1 f8 04             	sar    $0x4,%eax
c0002dbf:	89 c2                	mov    %eax,%edx
c0002dc1:	a1 a4 08 01 c0       	mov    0xc00108a4,%eax
c0002dc6:	89 50 0c             	mov    %edx,0xc(%eax)

    if(kheap_head->size == 0 || kheap_head->size < HEAP_INCREMENT/HEAP_BLOCKSIZE_UNITS)
c0002dc9:	a1 a4 08 01 c0       	mov    0xc00108a4,%eax
c0002dce:	8b 40 0c             	mov    0xc(%eax),%eax
c0002dd1:	85 c0                	test   %eax,%eax
c0002dd3:	74 0f                	je     c0002de4 <kmalloc_init+0xc3>
c0002dd5:	a1 a4 08 01 c0       	mov    0xc00108a4,%eax
c0002dda:	8b 40 0c             	mov    0xc(%eax),%eax
c0002ddd:	3d ff 03 00 00       	cmp    $0x3ff,%eax
c0002de2:	77 07                	ja     c0002deb <kmalloc_init+0xca>
        return 0;    
c0002de4:	b8 00 00 00 00       	mov    $0x0,%eax
c0002de9:	eb 05                	jmp    c0002df0 <kmalloc_init+0xcf>

    return -1;    
c0002deb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0002df0:	c9                   	leave  
c0002df1:	c3                   	ret    

c0002df2 <kheap_insert_block>:

// insert new_block into LL between b and b->next
// return 0 on success 
int kheap_insert_block(heap_block_t* b, heap_block_t* new_block)
{
c0002df2:	55                   	push   %ebp
c0002df3:	89 e5                	mov    %esp,%ebp
c0002df5:	83 ec 08             	sub    $0x8,%esp
    
    if(kheap_validate_block(b) || kheap_validate_block(new_block))
c0002df8:	ff 75 08             	pushl  0x8(%ebp)
c0002dfb:	e8 e7 fe ff ff       	call   c0002ce7 <kheap_validate_block>
c0002e00:	83 c4 04             	add    $0x4,%esp
c0002e03:	85 c0                	test   %eax,%eax
c0002e05:	75 0f                	jne    c0002e16 <kheap_insert_block+0x24>
c0002e07:	ff 75 0c             	pushl  0xc(%ebp)
c0002e0a:	e8 d8 fe ff ff       	call   c0002ce7 <kheap_validate_block>
c0002e0f:	83 c4 04             	add    $0x4,%esp
c0002e12:	85 c0                	test   %eax,%eax
c0002e14:	74 17                	je     c0002e2d <kheap_insert_block+0x3b>
    {
        panic("kernel heap corrupted");
c0002e16:	83 ec 0c             	sub    $0xc,%esp
c0002e19:	68 20 47 00 c0       	push   $0xc0004720
c0002e1e:	e8 53 e6 ff ff       	call   c0001476 <panic>
c0002e23:	83 c4 10             	add    $0x10,%esp
        return -1;
c0002e26:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002e2b:	eb 2f                	jmp    c0002e5c <kheap_insert_block+0x6a>
    }

    new_block->prev = b;
c0002e2d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002e30:	8b 55 08             	mov    0x8(%ebp),%edx
c0002e33:	89 50 04             	mov    %edx,0x4(%eax)
    new_block->next = b->next;            
c0002e36:	8b 45 08             	mov    0x8(%ebp),%eax
c0002e39:	8b 50 08             	mov    0x8(%eax),%edx
c0002e3c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002e3f:	89 50 08             	mov    %edx,0x8(%eax)
    b->next->prev = new_block;
c0002e42:	8b 45 08             	mov    0x8(%ebp),%eax
c0002e45:	8b 40 08             	mov    0x8(%eax),%eax
c0002e48:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002e4b:	89 50 04             	mov    %edx,0x4(%eax)
    b->next = new_block;
c0002e4e:	8b 45 08             	mov    0x8(%ebp),%eax
c0002e51:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002e54:	89 50 08             	mov    %edx,0x8(%eax)

    return 0;
c0002e57:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002e5c:	c9                   	leave  
c0002e5d:	c3                   	ret    

c0002e5e <kheap_delete_block>:


// remove block b from LL
// return pointer to previous block, NULL on error
heap_block_t* kheap_delete_block(heap_block_t* b)
{
c0002e5e:	55                   	push   %ebp
c0002e5f:	89 e5                	mov    %esp,%ebp
c0002e61:	83 ec 08             	sub    $0x8,%esp
    if(kheap_validate_block(b->prev) || kheap_validate_block(b->next))
c0002e64:	8b 45 08             	mov    0x8(%ebp),%eax
c0002e67:	8b 40 04             	mov    0x4(%eax),%eax
c0002e6a:	50                   	push   %eax
c0002e6b:	e8 77 fe ff ff       	call   c0002ce7 <kheap_validate_block>
c0002e70:	83 c4 04             	add    $0x4,%esp
c0002e73:	85 c0                	test   %eax,%eax
c0002e75:	75 13                	jne    c0002e8a <kheap_delete_block+0x2c>
c0002e77:	8b 45 08             	mov    0x8(%ebp),%eax
c0002e7a:	8b 40 08             	mov    0x8(%eax),%eax
c0002e7d:	50                   	push   %eax
c0002e7e:	e8 64 fe ff ff       	call   c0002ce7 <kheap_validate_block>
c0002e83:	83 c4 04             	add    $0x4,%esp
c0002e86:	85 c0                	test   %eax,%eax
c0002e88:	74 17                	je     c0002ea1 <kheap_delete_block+0x43>
    {
        panic("kernel heap corrupted");
c0002e8a:	83 ec 0c             	sub    $0xc,%esp
c0002e8d:	68 20 47 00 c0       	push   $0xc0004720
c0002e92:	e8 df e5 ff ff       	call   c0001476 <panic>
c0002e97:	83 c4 10             	add    $0x10,%esp
        return NULL;
c0002e9a:	b8 00 00 00 00       	mov    $0x0,%eax
c0002e9f:	eb 24                	jmp    c0002ec5 <kheap_delete_block+0x67>
    }

    b->prev->next = b->next;
c0002ea1:	8b 45 08             	mov    0x8(%ebp),%eax
c0002ea4:	8b 40 04             	mov    0x4(%eax),%eax
c0002ea7:	8b 55 08             	mov    0x8(%ebp),%edx
c0002eaa:	8b 52 08             	mov    0x8(%edx),%edx
c0002ead:	89 50 08             	mov    %edx,0x8(%eax)
    b->next->prev = b->prev;
c0002eb0:	8b 45 08             	mov    0x8(%ebp),%eax
c0002eb3:	8b 40 08             	mov    0x8(%eax),%eax
c0002eb6:	8b 55 08             	mov    0x8(%ebp),%edx
c0002eb9:	8b 52 04             	mov    0x4(%edx),%edx
c0002ebc:	89 50 04             	mov    %edx,0x4(%eax)

    return b->prev;
c0002ebf:	8b 45 08             	mov    0x8(%ebp),%eax
c0002ec2:	8b 40 04             	mov    0x4(%eax),%eax
}
c0002ec5:	c9                   	leave  
c0002ec6:	c3                   	ret    

c0002ec7 <kheap_free_block>:

// free block and merge with free neighbors
// return ptr to new free block
heap_block_t* kheap_free_block(heap_block_t* b)
{
c0002ec7:	55                   	push   %ebp
c0002ec8:	89 e5                	mov    %esp,%ebp
c0002eca:	83 ec 08             	sub    $0x8,%esp
    //check magic numbers to make sure theres no overrun
    if(kheap_validate_block(b))
c0002ecd:	ff 75 08             	pushl  0x8(%ebp)
c0002ed0:	e8 12 fe ff ff       	call   c0002ce7 <kheap_validate_block>
c0002ed5:	83 c4 04             	add    $0x4,%esp
c0002ed8:	85 c0                	test   %eax,%eax
c0002eda:	74 1a                	je     c0002ef6 <kheap_free_block+0x2f>
    {
        panic("kernel heap corrupted");
c0002edc:	83 ec 0c             	sub    $0xc,%esp
c0002edf:	68 20 47 00 c0       	push   $0xc0004720
c0002ee4:	e8 8d e5 ff ff       	call   c0001476 <panic>
c0002ee9:	83 c4 10             	add    $0x10,%esp
        return NULL;
c0002eec:	b8 00 00 00 00       	mov    $0x0,%eax
c0002ef1:	e9 9c 00 00 00       	jmp    c0002f92 <kheap_free_block+0xcb>
    }

    b->status = HEAP_BLOCK_FREE;
c0002ef6:	8b 45 08             	mov    0x8(%ebp),%eax
c0002ef9:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c0002efd:	83 e2 0f             	and    $0xf,%edx
c0002f00:	88 50 03             	mov    %dl,0x3(%eax)

    //merge with next block if free
    if(b->next == HEAP_BLOCK_FREE && b->next != kheap_head)
c0002f03:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f06:	8b 40 08             	mov    0x8(%eax),%eax
c0002f09:	85 c0                	test   %eax,%eax
c0002f0b:	75 43                	jne    c0002f50 <kheap_free_block+0x89>
c0002f0d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f10:	8b 50 08             	mov    0x8(%eax),%edx
c0002f13:	a1 a4 08 01 c0       	mov    0xc00108a4,%eax
c0002f18:	39 c2                	cmp    %eax,%edx
c0002f1a:	74 34                	je     c0002f50 <kheap_free_block+0x89>
    {
        b->size += b->next->size;
c0002f1c:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f1f:	8b 50 0c             	mov    0xc(%eax),%edx
c0002f22:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f25:	8b 40 08             	mov    0x8(%eax),%eax
c0002f28:	8b 40 0c             	mov    0xc(%eax),%eax
c0002f2b:	01 c2                	add    %eax,%edx
c0002f2d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f30:	89 50 0c             	mov    %edx,0xc(%eax)
        if(!kheap_delete_block(b->next)) return NULL;
c0002f33:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f36:	8b 40 08             	mov    0x8(%eax),%eax
c0002f39:	83 ec 0c             	sub    $0xc,%esp
c0002f3c:	50                   	push   %eax
c0002f3d:	e8 1c ff ff ff       	call   c0002e5e <kheap_delete_block>
c0002f42:	83 c4 10             	add    $0x10,%esp
c0002f45:	85 c0                	test   %eax,%eax
c0002f47:	75 07                	jne    c0002f50 <kheap_free_block+0x89>
c0002f49:	b8 00 00 00 00       	mov    $0x0,%eax
c0002f4e:	eb 42                	jmp    c0002f92 <kheap_free_block+0xcb>
    }

    //merge with previous block if free, and set b = b->prev
    if(b->prev == HEAP_BLOCK_FREE && b != kheap_head)
c0002f50:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f53:	8b 40 04             	mov    0x4(%eax),%eax
c0002f56:	85 c0                	test   %eax,%eax
c0002f58:	75 35                	jne    c0002f8f <kheap_free_block+0xc8>
c0002f5a:	a1 a4 08 01 c0       	mov    0xc00108a4,%eax
c0002f5f:	39 45 08             	cmp    %eax,0x8(%ebp)
c0002f62:	74 2b                	je     c0002f8f <kheap_free_block+0xc8>
    {
        b->prev->size += b->size;
c0002f64:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f67:	8b 40 04             	mov    0x4(%eax),%eax
c0002f6a:	8b 48 0c             	mov    0xc(%eax),%ecx
c0002f6d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f70:	8b 50 0c             	mov    0xc(%eax),%edx
c0002f73:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f76:	8b 40 04             	mov    0x4(%eax),%eax
c0002f79:	01 ca                	add    %ecx,%edx
c0002f7b:	89 50 0c             	mov    %edx,0xc(%eax)
        b = kheap_delete_block(b);
c0002f7e:	83 ec 0c             	sub    $0xc,%esp
c0002f81:	ff 75 08             	pushl  0x8(%ebp)
c0002f84:	e8 d5 fe ff ff       	call   c0002e5e <kheap_delete_block>
c0002f89:	83 c4 10             	add    $0x10,%esp
c0002f8c:	89 45 08             	mov    %eax,0x8(%ebp)
    }

    return b;
c0002f8f:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0002f92:	c9                   	leave  
c0002f93:	c3                   	ret    

c0002f94 <kheap_split_block>:
// if there is enough extra room, split b into two
// return new size of block on successful split (in HEAP_BLOCKSIZE_UNITS)
// return 0 on insufficinet size for splitting into new block (b->size < size+1)
// return <0 on error
int kheap_split_block(heap_block_t* b, size_t size)
{
c0002f94:	55                   	push   %ebp
c0002f95:	89 e5                	mov    %esp,%ebp
c0002f97:	83 ec 18             	sub    $0x18,%esp
    //check magic numbers to make sure theres no overrun
    if(kheap_validate_block(b))
c0002f9a:	ff 75 08             	pushl  0x8(%ebp)
c0002f9d:	e8 45 fd ff ff       	call   c0002ce7 <kheap_validate_block>
c0002fa2:	83 c4 04             	add    $0x4,%esp
c0002fa5:	85 c0                	test   %eax,%eax
c0002fa7:	74 1a                	je     c0002fc3 <kheap_split_block+0x2f>
    {
        panic("kernel heap corrupted");
c0002fa9:	83 ec 0c             	sub    $0xc,%esp
c0002fac:	68 20 47 00 c0       	push   $0xc0004720
c0002fb1:	e8 c0 e4 ff ff       	call   c0001476 <panic>
c0002fb6:	83 c4 10             	add    $0x10,%esp
        return -1;
c0002fb9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002fbe:	e9 83 00 00 00       	jmp    c0003046 <kheap_split_block+0xb2>
    }

    if(b->size < size + 1 ) return 0;
c0002fc3:	8b 45 08             	mov    0x8(%ebp),%eax
c0002fc6:	8b 40 0c             	mov    0xc(%eax),%eax
c0002fc9:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002fcc:	83 c2 01             	add    $0x1,%edx
c0002fcf:	39 d0                	cmp    %edx,%eax
c0002fd1:	73 07                	jae    c0002fda <kheap_split_block+0x46>
c0002fd3:	b8 00 00 00 00       	mov    $0x0,%eax
c0002fd8:	eb 6c                	jmp    c0003046 <kheap_split_block+0xb2>

    // create new empty block
    heap_block_t* new_block = b + size;
c0002fda:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002fdd:	c1 e0 04             	shl    $0x4,%eax
c0002fe0:	89 c2                	mov    %eax,%edx
c0002fe2:	8b 45 08             	mov    0x8(%ebp),%eax
c0002fe5:	01 d0                	add    %edx,%eax
c0002fe7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    new_block->magic = HEAP_BLOCK_MAGIC;
c0002fea:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002fed:	8b 10                	mov    (%eax),%edx
c0002fef:	81 e2 00 00 00 f0    	and    $0xf0000000,%edx
c0002ff5:	81 ca ef be 23 01    	or     $0x123beef,%edx
c0002ffb:	89 10                	mov    %edx,(%eax)
    new_block->status = HEAP_BLOCK_FREE;
c0002ffd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003000:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c0003004:	83 e2 0f             	and    $0xf,%edx
c0003007:	88 50 03             	mov    %dl,0x3(%eax)
    new_block->size = b->size - size;
c000300a:	8b 45 08             	mov    0x8(%ebp),%eax
c000300d:	8b 40 0c             	mov    0xc(%eax),%eax
c0003010:	2b 45 0c             	sub    0xc(%ebp),%eax
c0003013:	89 c2                	mov    %eax,%edx
c0003015:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003018:	89 50 0c             	mov    %edx,0xc(%eax)

    // insert new block to into LL after b
    if(kheap_insert_block(b,new_block)) return -1;
c000301b:	83 ec 08             	sub    $0x8,%esp
c000301e:	ff 75 f4             	pushl  -0xc(%ebp)
c0003021:	ff 75 08             	pushl  0x8(%ebp)
c0003024:	e8 c9 fd ff ff       	call   c0002df2 <kheap_insert_block>
c0003029:	83 c4 10             	add    $0x10,%esp
c000302c:	85 c0                	test   %eax,%eax
c000302e:	74 07                	je     c0003037 <kheap_split_block+0xa3>
c0003030:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003035:	eb 0f                	jmp    c0003046 <kheap_split_block+0xb2>

    // shrink b and return new size
    return b->size = size;
c0003037:	8b 45 08             	mov    0x8(%ebp),%eax
c000303a:	8b 55 0c             	mov    0xc(%ebp),%edx
c000303d:	89 50 0c             	mov    %edx,0xc(%eax)
c0003040:	8b 45 08             	mov    0x8(%ebp),%eax
c0003043:	8b 40 0c             	mov    0xc(%eax),%eax
}
c0003046:	c9                   	leave  
c0003047:	c3                   	ret    

c0003048 <grow_kheap>:

// grow the kernel heap by at least minimum_block_size*HEAP_BLOCKSIZE_UNITS bytes
// and return new tail block that is guaranteeed to be at least minimum_block_size
// return NULL on error or OOM
heap_block_t* grow_kheap(size_t minimum_block_size)
{
c0003048:	55                   	push   %ebp
c0003049:	89 e5                	mov    %esp,%ebp
c000304b:	83 ec 18             	sub    $0x18,%esp
    size_t grow_size = minimum_block_size*HEAP_BLOCKSIZE_UNITS > HEAP_INCREMENT ? minimum_block_size*HEAP_BLOCKSIZE_UNITS : HEAP_INCREMENT;
c000304e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003051:	c1 e0 04             	shl    $0x4,%eax
c0003054:	ba 00 40 00 00       	mov    $0x4000,%edx
c0003059:	3d 00 40 00 00       	cmp    $0x4000,%eax
c000305e:	0f 42 c2             	cmovb  %edx,%eax
c0003061:	89 45 f4             	mov    %eax,-0xc(%ebp)
    heap_block_t* new_block = ksbrk(grow_size);
c0003064:	83 ec 0c             	sub    $0xc,%esp
c0003067:	ff 75 f4             	pushl  -0xc(%ebp)
c000306a:	e8 a2 f8 ff ff       	call   c0002911 <ksbrk>
c000306f:	83 c4 10             	add    $0x10,%esp
c0003072:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!new_block)
c0003075:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0003079:	75 0a                	jne    c0003085 <grow_kheap+0x3d>
        return NULL; // error in ksbrk, e.g. out of memory
c000307b:	b8 00 00 00 00       	mov    $0x0,%eax
c0003080:	e9 81 00 00 00       	jmp    c0003106 <grow_kheap+0xbe>

    //ksbrk doesnt guarantee properly aligned blocks, so make sure we are aligned
    new_block = align_addr(new_block,HEAP_BLOCKSIZE_UNITS);
c0003085:	83 ec 08             	sub    $0x8,%esp
c0003088:	6a 10                	push   $0x10
c000308a:	ff 75 f0             	pushl  -0x10(%ebp)
c000308d:	e8 6f fc ff ff       	call   c0002d01 <align_addr>
c0003092:	83 c4 10             	add    $0x10,%esp
c0003095:	89 45 f0             	mov    %eax,-0x10(%ebp)
    
    new_block->magic = HEAP_BLOCK_MAGIC;
c0003098:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000309b:	8b 10                	mov    (%eax),%edx
c000309d:	81 e2 00 00 00 f0    	and    $0xf0000000,%edx
c00030a3:	81 ca ef be 23 01    	or     $0x123beef,%edx
c00030a9:	89 10                	mov    %edx,(%eax)
    new_block->status = HEAP_BLOCK_FREE;
c00030ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00030ae:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c00030b2:	83 e2 0f             	and    $0xf,%edx
c00030b5:	88 50 03             	mov    %dl,0x3(%eax)

    // get end of block from ksbrk(0), and again make sure it is aligned.
    // this time align with a mask so that aligned address is <= ksbrk(0)
    new_block->size = new_block - (heap_block_t*) ( (uint32_t) ksbrk(0) & HEAP_BLOCKSIZE_MASK);
c00030b8:	83 ec 0c             	sub    $0xc,%esp
c00030bb:	6a 00                	push   $0x0
c00030bd:	e8 4f f8 ff ff       	call   c0002911 <ksbrk>
c00030c2:	83 c4 10             	add    $0x10,%esp
c00030c5:	83 e0 f0             	and    $0xfffffff0,%eax
c00030c8:	89 c2                	mov    %eax,%edx
c00030ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00030cd:	29 d0                	sub    %edx,%eax
c00030cf:	c1 f8 04             	sar    $0x4,%eax
c00030d2:	89 c2                	mov    %eax,%edx
c00030d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00030d7:	89 50 0c             	mov    %edx,0xc(%eax)

    //doublecheck that new block is large enough
    if(new_block->size < minimum_block_size) return NULL;
c00030da:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00030dd:	8b 40 0c             	mov    0xc(%eax),%eax
c00030e0:	39 45 08             	cmp    %eax,0x8(%ebp)
c00030e3:	76 07                	jbe    c00030ec <grow_kheap+0xa4>
c00030e5:	b8 00 00 00 00       	mov    $0x0,%eax
c00030ea:	eb 1a                	jmp    c0003106 <grow_kheap+0xbe>

    kheap_insert_block(kheap_head->prev, new_block); //add new block to tail
c00030ec:	a1 a4 08 01 c0       	mov    0xc00108a4,%eax
c00030f1:	8b 40 04             	mov    0x4(%eax),%eax
c00030f4:	83 ec 08             	sub    $0x8,%esp
c00030f7:	ff 75 f0             	pushl  -0x10(%ebp)
c00030fa:	50                   	push   %eax
c00030fb:	e8 f2 fc ff ff       	call   c0002df2 <kheap_insert_block>
c0003100:	83 c4 10             	add    $0x10,%esp
    return new_block;
c0003103:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0003106:	c9                   	leave  
c0003107:	c3                   	ret    

c0003108 <kmalloc>:

void* kmalloc(size_t sz)
{
c0003108:	55                   	push   %ebp
c0003109:	89 e5                	mov    %esp,%ebp
c000310b:	83 ec 18             	sub    $0x18,%esp
    //convert to HEAP_BLOCKSIZE_UNITS, rounding up, and add one for header
    size_t block_size = 1 + (sz+ HEAP_BLOCKSIZE_UNITS -1)/HEAP_BLOCKSIZE_UNITS;
c000310e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003111:	83 c0 0f             	add    $0xf,%eax
c0003114:	c1 e8 04             	shr    $0x4,%eax
c0003117:	83 c0 01             	add    $0x1,%eax
c000311a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    
    if(!kheap_head)
c000311d:	a1 a4 08 01 c0       	mov    0xc00108a4,%eax
c0003122:	85 c0                	test   %eax,%eax
c0003124:	75 19                	jne    c000313f <kmalloc+0x37>
    {
        //initialize the heap with some space
        if(!kmalloc_init())
c0003126:	e8 f6 fb ff ff       	call   c0002d21 <kmalloc_init>
c000312b:	85 c0                	test   %eax,%eax
c000312d:	75 10                	jne    c000313f <kmalloc+0x37>
            panic("Error initializing kernel heap");
c000312f:	83 ec 0c             	sub    $0xc,%esp
c0003132:	68 38 47 00 c0       	push   $0xc0004738
c0003137:	e8 3a e3 ff ff       	call   c0001476 <panic>
c000313c:	83 c4 10             	add    $0x10,%esp
    }

    heap_block_t* block = kheap_head;
c000313f:	a1 a4 08 01 c0       	mov    0xc00108a4,%eax
c0003144:	89 45 f4             	mov    %eax,-0xc(%ebp)

    while(block->status != HEAP_BLOCK_FREE || block->size < block_size)
c0003147:	eb 36                	jmp    c000317f <kmalloc+0x77>
    {
        //if we've returned to the head, we have run through the entire list without finding a free block
        if(block->next == kheap_head)
c0003149:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000314c:	8b 50 08             	mov    0x8(%eax),%edx
c000314f:	a1 a4 08 01 c0       	mov    0xc00108a4,%eax
c0003154:	39 c2                	cmp    %eax,%edx
c0003156:	75 1e                	jne    c0003176 <kmalloc+0x6e>
        {
            //we've reached the end of the heap, so add a new block at the end
            block = grow_kheap(block_size);
c0003158:	83 ec 0c             	sub    $0xc,%esp
c000315b:	ff 75 f0             	pushl  -0x10(%ebp)
c000315e:	e8 e5 fe ff ff       	call   c0003048 <grow_kheap>
c0003163:	83 c4 10             	add    $0x10,%esp
c0003166:	89 45 f4             	mov    %eax,-0xc(%ebp)
            if(!block) return NULL; //grow_kheap() failed, e.g. OOM 
c0003169:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c000316d:	75 10                	jne    c000317f <kmalloc+0x77>
c000316f:	b8 00 00 00 00       	mov    $0x0,%eax
c0003174:	eb 4d                	jmp    c00031c3 <kmalloc+0xbb>
        }
        else
        {
            block = block->next;
c0003176:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003179:	8b 40 08             	mov    0x8(%eax),%eax
c000317c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(block->status != HEAP_BLOCK_FREE || block->size < block_size)
c000317f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003182:	0f b6 40 03          	movzbl 0x3(%eax),%eax
c0003186:	83 e0 f0             	and    $0xfffffff0,%eax
c0003189:	84 c0                	test   %al,%al
c000318b:	75 bc                	jne    c0003149 <kmalloc+0x41>
c000318d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003190:	8b 40 0c             	mov    0xc(%eax),%eax
c0003193:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0003196:	77 b1                	ja     c0003149 <kmalloc+0x41>
    }

    // block is a free block that is large enough for this allocation

    //split block if its big enough
    if(kheap_split_block(block, block_size)<0)
c0003198:	83 ec 08             	sub    $0x8,%esp
c000319b:	ff 75 f0             	pushl  -0x10(%ebp)
c000319e:	ff 75 f4             	pushl  -0xc(%ebp)
c00031a1:	e8 ee fd ff ff       	call   c0002f94 <kheap_split_block>
c00031a6:	83 c4 10             	add    $0x10,%esp
c00031a9:	85 c0                	test   %eax,%eax
c00031ab:	79 10                	jns    c00031bd <kmalloc+0xb5>
        panic("Critical error in malloc()");
c00031ad:	83 ec 0c             	sub    $0xc,%esp
c00031b0:	68 57 47 00 c0       	push   $0xc0004757
c00031b5:	e8 bc e2 ff ff       	call   c0001476 <panic>
c00031ba:	83 c4 10             	add    $0x10,%esp

    return block+1; // return pointer after header
c00031bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00031c0:	83 c0 10             	add    $0x10,%eax
}
c00031c3:	c9                   	leave  
c00031c4:	c3                   	ret    

c00031c5 <kmalloc_aligned>:

void* kmalloc_aligned(size_t sz, size_t alignment)
{
c00031c5:	55                   	push   %ebp
c00031c6:	89 e5                	mov    %esp,%ebp
c00031c8:	83 ec 28             	sub    $0x28,%esp
    //alignement must be multiple of HEAP_BLOCKSIZE_UNITS
    if(alignment % HEAP_BLOCKSIZE_UNITS) return NULL;
c00031cb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00031ce:	83 e0 0f             	and    $0xf,%eax
c00031d1:	85 c0                	test   %eax,%eax
c00031d3:	74 0a                	je     c00031df <kmalloc_aligned+0x1a>
c00031d5:	b8 00 00 00 00       	mov    $0x0,%eax
c00031da:	e9 3d 01 00 00       	jmp    c000331c <kmalloc_aligned+0x157>

    //convert alignment to HEAP_BLOCKSIZE_UNITS
    size_t block_alignment = alignment/HEAP_BLOCKSIZE_UNITS;
c00031df:	8b 45 0c             	mov    0xc(%ebp),%eax
c00031e2:	c1 e8 04             	shr    $0x4,%eax
c00031e5:	89 45 f0             	mov    %eax,-0x10(%ebp)

    //convert sz to HEAP_BLOCKSIZE_UNITS, rounding up, and add one for header
    size_t block_size = 1 + (sz+ HEAP_BLOCKSIZE_UNITS -1)/HEAP_BLOCKSIZE_UNITS;
c00031e8:	8b 45 08             	mov    0x8(%ebp),%eax
c00031eb:	83 c0 0f             	add    $0xf,%eax
c00031ee:	c1 e8 04             	shr    $0x4,%eax
c00031f1:	83 c0 01             	add    $0x1,%eax
c00031f4:	89 45 ec             	mov    %eax,-0x14(%ebp)

    
    if(!kheap_head)
c00031f7:	a1 a4 08 01 c0       	mov    0xc00108a4,%eax
c00031fc:	85 c0                	test   %eax,%eax
c00031fe:	75 19                	jne    c0003219 <kmalloc_aligned+0x54>
    {
        //initialize the heap with some space
        if(!kmalloc_init())
c0003200:	e8 1c fb ff ff       	call   c0002d21 <kmalloc_init>
c0003205:	85 c0                	test   %eax,%eax
c0003207:	75 10                	jne    c0003219 <kmalloc_aligned+0x54>
            panic("Error initializing kernel heap");
c0003209:	83 ec 0c             	sub    $0xc,%esp
c000320c:	68 38 47 00 c0       	push   $0xc0004738
c0003211:	e8 60 e2 ff ff       	call   c0001476 <panic>
c0003216:	83 c4 10             	add    $0x10,%esp
    }

    heap_block_t* block = kheap_head;
c0003219:	a1 a4 08 01 c0       	mov    0xc00108a4,%eax
c000321e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    //how many additional units are needed to align this block?
    size_t alignment_space;

    while(true)
    {
        if(block->status == HEAP_BLOCK_FREE)
c0003221:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003224:	0f b6 40 03          	movzbl 0x3(%eax),%eax
c0003228:	83 e0 f0             	and    $0xfffffff0,%eax
c000322b:	84 c0                	test   %al,%al
c000322d:	75 42                	jne    c0003271 <kmalloc_aligned+0xac>
        {
            // where would aligned data start in this block?
            size_t block_data = (size_t)block/HEAP_BLOCKSIZE_UNITS + 1;  //(unaligned) data starts after header
c000322f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003232:	c1 e8 04             	shr    $0x4,%eax
c0003235:	83 c0 01             	add    $0x1,%eax
c0003238:	89 45 e8             	mov    %eax,-0x18(%ebp)
            size_t am = block_alignment - 1;
c000323b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000323e:	83 e8 01             	sub    $0x1,%eax
c0003241:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            size_t block_data_aligned = ((block_data + am) & ~am); //align data
c0003244:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0003247:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000324a:	01 c2                	add    %eax,%edx
c000324c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000324f:	f7 d0                	not    %eax
c0003251:	21 d0                	and    %edx,%eax
c0003253:	89 45 e0             	mov    %eax,-0x20(%ebp)

            alignment_space = block_data_aligned-block_data; 
c0003256:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0003259:	2b 45 e8             	sub    -0x18(%ebp),%eax
c000325c:	89 45 dc             	mov    %eax,-0x24(%ebp)

            if(block->size >= block_size + alignment_space)
c000325f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003262:	8b 40 0c             	mov    0xc(%eax),%eax
c0003265:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0003268:	8b 55 dc             	mov    -0x24(%ebp),%edx
c000326b:	01 ca                	add    %ecx,%edx
c000326d:	39 d0                	cmp    %edx,%eax
c000326f:	73 3b                	jae    c00032ac <kmalloc_aligned+0xe7>
                break;

        }

        //if we've returned to the head, we have run through the entire list without finding a free block
        if(block->next == kheap_head)
c0003271:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003274:	8b 50 08             	mov    0x8(%eax),%edx
c0003277:	a1 a4 08 01 c0       	mov    0xc00108a4,%eax
c000327c:	39 c2                	cmp    %eax,%edx
c000327e:	75 1e                	jne    c000329e <kmalloc_aligned+0xd9>
        {
            //we've reached the end of the heap, so add a new block at the end
            block = grow_kheap(block_size);
c0003280:	83 ec 0c             	sub    $0xc,%esp
c0003283:	ff 75 ec             	pushl  -0x14(%ebp)
c0003286:	e8 bd fd ff ff       	call   c0003048 <grow_kheap>
c000328b:	83 c4 10             	add    $0x10,%esp
c000328e:	89 45 f4             	mov    %eax,-0xc(%ebp)
            if(!block) return NULL; //grow_kheap() failed, e.g. OOM 
c0003291:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0003295:	75 8a                	jne    c0003221 <kmalloc_aligned+0x5c>
c0003297:	b8 00 00 00 00       	mov    $0x0,%eax
c000329c:	eb 7e                	jmp    c000331c <kmalloc_aligned+0x157>
        }
        else
        {
            block = block->next;
c000329e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00032a1:	8b 40 08             	mov    0x8(%eax),%eax
c00032a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(block->status == HEAP_BLOCK_FREE)
c00032a7:	e9 75 ff ff ff       	jmp    c0003221 <kmalloc_aligned+0x5c>
                break;
c00032ac:	90                   	nop
    }

    // block is a free block that is large enough for this allocation

    //if we need to realign, split off the first part of the block
    if(alignment_space>0)
c00032ad:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c00032b1:	74 2e                	je     c00032e1 <kmalloc_aligned+0x11c>
    {
        if(kheap_split_block(block, alignment_space)<0)
c00032b3:	83 ec 08             	sub    $0x8,%esp
c00032b6:	ff 75 dc             	pushl  -0x24(%ebp)
c00032b9:	ff 75 f4             	pushl  -0xc(%ebp)
c00032bc:	e8 d3 fc ff ff       	call   c0002f94 <kheap_split_block>
c00032c1:	83 c4 10             	add    $0x10,%esp
c00032c4:	85 c0                	test   %eax,%eax
c00032c6:	79 10                	jns    c00032d8 <kmalloc_aligned+0x113>
            panic("Critical error in malloc()");
c00032c8:	83 ec 0c             	sub    $0xc,%esp
c00032cb:	68 57 47 00 c0       	push   $0xc0004757
c00032d0:	e8 a1 e1 ff ff       	call   c0001476 <panic>
c00032d5:	83 c4 10             	add    $0x10,%esp
        block = block->next;
c00032d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00032db:	8b 40 08             	mov    0x8(%eax),%eax
c00032de:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    
    //split end of block off its big enough
    if(kheap_split_block(block, block_size)<0)
c00032e1:	83 ec 08             	sub    $0x8,%esp
c00032e4:	ff 75 ec             	pushl  -0x14(%ebp)
c00032e7:	ff 75 f4             	pushl  -0xc(%ebp)
c00032ea:	e8 a5 fc ff ff       	call   c0002f94 <kheap_split_block>
c00032ef:	83 c4 10             	add    $0x10,%esp
c00032f2:	85 c0                	test   %eax,%eax
c00032f4:	79 10                	jns    c0003306 <kmalloc_aligned+0x141>
        panic("Critical error in malloc()");
c00032f6:	83 ec 0c             	sub    $0xc,%esp
c00032f9:	68 57 47 00 c0       	push   $0xc0004757
c00032fe:	e8 73 e1 ff ff       	call   c0001476 <panic>
c0003303:	83 c4 10             	add    $0x10,%esp

    block->status = HEAP_BLOCK_USED;
c0003306:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003309:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c000330d:	83 e2 0f             	and    $0xf,%edx
c0003310:	83 ca 10             	or     $0x10,%edx
c0003313:	88 50 03             	mov    %dl,0x3(%eax)
    return block+1; // return pointer after header
c0003316:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003319:	83 c0 10             	add    $0x10,%eax
}
c000331c:	c9                   	leave  
c000331d:	c3                   	ret    

c000331e <kfree>:

// free memory previously allocated with kmalloc
// return 0 on success.
// return -1 on fail (e.g. if p was not allocated with malloc, or memory corruption detected)
int kfree(void* p)
{
c000331e:	55                   	push   %ebp
c000331f:	89 e5                	mov    %esp,%ebp
c0003321:	83 ec 18             	sub    $0x18,%esp
    //get pointer to block header
    heap_block_t* b = ((heap_block_t*) p) - 1;
c0003324:	8b 45 08             	mov    0x8(%ebp),%eax
c0003327:	83 e8 10             	sub    $0x10,%eax
c000332a:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(kheap_validate_block(b))
c000332d:	ff 75 f4             	pushl  -0xc(%ebp)
c0003330:	e8 b2 f9 ff ff       	call   c0002ce7 <kheap_validate_block>
c0003335:	83 c4 04             	add    $0x4,%esp
c0003338:	85 c0                	test   %eax,%eax
c000333a:	74 17                	je     c0003353 <kfree+0x35>
    {
        panic("kernel heap corrupted");
c000333c:	83 ec 0c             	sub    $0xc,%esp
c000333f:	68 20 47 00 c0       	push   $0xc0004720
c0003344:	e8 2d e1 ff ff       	call   c0001476 <panic>
c0003349:	83 c4 10             	add    $0x10,%esp
        return -1;
c000334c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003351:	eb 1e                	jmp    c0003371 <kfree+0x53>
    }

    if(kheap_free_block(b)) return 0;
c0003353:	83 ec 0c             	sub    $0xc,%esp
c0003356:	ff 75 f4             	pushl  -0xc(%ebp)
c0003359:	e8 69 fb ff ff       	call   c0002ec7 <kheap_free_block>
c000335e:	83 c4 10             	add    $0x10,%esp
c0003361:	85 c0                	test   %eax,%eax
c0003363:	74 07                	je     c000336c <kfree+0x4e>
c0003365:	b8 00 00 00 00       	mov    $0x0,%eax
c000336a:	eb 05                	jmp    c0003371 <kfree+0x53>

    return -1;
c000336c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0003371:	c9                   	leave  
c0003372:	c3                   	ret    

c0003373 <scancode_to_ascii>:
    0,  /* F12 Key */
    0,  /* All other keys are undefined */
};

char scancode_to_ascii(uint8_t scancode)
{
c0003373:	55                   	push   %ebp
c0003374:	89 e5                	mov    %esp,%ebp
c0003376:	83 ec 04             	sub    $0x4,%esp
c0003379:	8b 45 08             	mov    0x8(%ebp),%eax
c000337c:	88 45 fc             	mov    %al,-0x4(%ebp)
    return kbd_US[scancode];
c000337f:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0003383:	0f b6 80 20 50 00 c0 	movzbl -0x3fffafe0(%eax),%eax
}
c000338a:	c9                   	leave  
c000338b:	c3                   	ret    

c000338c <test_multitasking2>:
#include "test.h"
#include "kprintf.h"
#include "task.h"

int32_t test_multitasking2()
{
c000338c:	55                   	push   %ebp
c000338d:	89 e5                	mov    %esp,%ebp
c000338f:	83 ec 18             	sub    $0x18,%esp
	int nn;
	for(nn=0;nn<5;nn++)
c0003392:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0003399:	eb 09                	jmp    c00033a4 <test_multitasking2+0x18>
		yield();
c000339b:	e8 59 f0 ff ff       	call   c00023f9 <yield>
	for(nn=0;nn<5;nn++)
c00033a0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00033a4:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
c00033a8:	7e f1                	jle    c000339b <test_multitasking2+0xf>
	return nn;
c00033aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00033ad:	c9                   	leave  
c00033ae:	c3                   	ret    

c00033af <test_multitasking>:

int test_multitasking()
{
c00033af:	55                   	push   %ebp
c00033b0:	89 e5                	mov    %esp,%ebp
c00033b2:	83 ec 18             	sub    $0x18,%esp
	task_control_block_t* task2 = new_kernel_task( &test_multitasking2 );
c00033b5:	83 ec 0c             	sub    $0xc,%esp
c00033b8:	68 8c 33 00 c0       	push   $0xc000338c
c00033bd:	e8 f3 ee ff ff       	call   c00022b5 <new_kernel_task>
c00033c2:	83 c4 10             	add    $0x10,%esp
c00033c5:	89 45 f0             	mov    %eax,-0x10(%ebp)

	int nn;
	for(nn=0;nn<10;nn++)
c00033c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00033cf:	eb 09                	jmp    c00033da <test_multitasking+0x2b>
		yield();
c00033d1:	e8 23 f0 ff ff       	call   c00023f9 <yield>
	for(nn=0;nn<10;nn++)
c00033d6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00033da:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c00033de:	7e f1                	jle    c00033d1 <test_multitasking+0x22>

	join(task2);
c00033e0:	83 ec 0c             	sub    $0xc,%esp
c00033e3:	ff 75 f0             	pushl  -0x10(%ebp)
c00033e6:	e8 46 f0 ff ff       	call   c0002431 <join>
c00033eb:	83 c4 10             	add    $0x10,%esp

    if(task2->return_val == 5) return 0;
c00033ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00033f1:	8b 40 1c             	mov    0x1c(%eax),%eax
c00033f4:	83 f8 05             	cmp    $0x5,%eax
c00033f7:	75 07                	jne    c0003400 <test_multitasking+0x51>
c00033f9:	b8 00 00 00 00       	mov    $0x0,%eax
c00033fe:	eb 05                	jmp    c0003405 <test_multitasking+0x56>

    return -1;
c0003400:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0003405:	c9                   	leave  
c0003406:	c3                   	ret    

c0003407 <kernel_main>:
#if defined(__linux__)  || !defined(__i386__)
#error "This kernel requires ix86-elf cross compiler"
#endif

void kernel_main(multiboot_info_t* mbd)
{
c0003407:	55                   	push   %ebp
c0003408:	89 e5                	mov    %esp,%ebp
c000340a:	83 ec 08             	sub    $0x8,%esp
	init_gdt();
c000340d:	e8 7f 01 00 00       	call   c0003591 <init_gdt>
	init_interrupts();
c0003412:	e8 6a e9 ff ff       	call   c0001d81 <init_interrupts>

	terminal_init(&stdout);
c0003417:	83 ec 0c             	sub    $0xc,%esp
c000341a:	68 00 00 01 c0       	push   $0xc0010000
c000341f:	e8 0e ce ff ff       	call   c0000232 <terminal_init>
c0003424:	83 c4 10             	add    $0x10,%esp

    // terminal_setcolor(&stdout, VGA_COLOR_WHITE);
	kprintf("Let's learn about Operating Systems!\n");
c0003427:	83 ec 0c             	sub    $0xc,%esp
c000342a:	68 74 47 00 c0       	push   $0xc0004774
c000342f:	e8 25 d2 ff ff       	call   c0000659 <kprintf>
c0003434:	83 c4 10             	add    $0x10,%esp
	kprintf("Jon Doane, 2020\n\n");
c0003437:	83 ec 0c             	sub    $0xc,%esp
c000343a:	68 9a 47 00 c0       	push   $0xc000479a
c000343f:	e8 15 d2 ff ff       	call   c0000659 <kprintf>
c0003444:	83 c4 10             	add    $0x10,%esp

	print_memory_table(mbd);
c0003447:	83 ec 0c             	sub    $0xc,%esp
c000344a:	ff 75 08             	pushl  0x8(%ebp)
c000344d:	e8 00 e7 ff ff       	call   c0001b52 <print_memory_table>
c0003452:	83 c4 10             	add    $0x10,%esp
	memory_init(mbd);	//after this the multiboot structure is unmapped
c0003455:	83 ec 0c             	sub    $0xc,%esp
c0003458:	ff 75 08             	pushl  0x8(%ebp)
c000345b:	e8 a8 f5 ff ff       	call   c0002a08 <memory_init>
c0003460:	83 c4 10             	add    $0x10,%esp
	initialize_multitasking();
c0003463:	e8 fe ed ff ff       	call   c0002266 <initialize_multitasking>
    // reg_t regs;
    // getregs(&regs);
	// printregs(&regs);


	if(test_kmalloc())
c0003468:	e8 93 cb ff ff       	call   c0000000 <test_kmalloc>
c000346d:	85 c0                	test   %eax,%eax
c000346f:	74 12                	je     c0003483 <kernel_main+0x7c>
		kprintf("Malloc tests FAILED!\n");
c0003471:	83 ec 0c             	sub    $0xc,%esp
c0003474:	68 ac 47 00 c0       	push   $0xc00047ac
c0003479:	e8 db d1 ff ff       	call   c0000659 <kprintf>
c000347e:	83 c4 10             	add    $0x10,%esp
c0003481:	eb 10                	jmp    c0003493 <kernel_main+0x8c>
	else
		kprintf("Malloc tests PASSED!\n");
c0003483:	83 ec 0c             	sub    $0xc,%esp
c0003486:	68 c2 47 00 c0       	push   $0xc00047c2
c000348b:	e8 c9 d1 ff ff       	call   c0000659 <kprintf>
c0003490:	83 c4 10             	add    $0x10,%esp

	if(test_multitasking())
c0003493:	e8 17 ff ff ff       	call   c00033af <test_multitasking>
c0003498:	85 c0                	test   %eax,%eax
c000349a:	74 12                	je     c00034ae <kernel_main+0xa7>
		kprintf("Multitasking tests FAILED!\n");
c000349c:	83 ec 0c             	sub    $0xc,%esp
c000349f:	68 d8 47 00 c0       	push   $0xc00047d8
c00034a4:	e8 b0 d1 ff ff       	call   c0000659 <kprintf>
c00034a9:	83 c4 10             	add    $0x10,%esp
c00034ac:	eb 10                	jmp    c00034be <kernel_main+0xb7>
	else
		kprintf("Multitasking tests PASSED!\n");
c00034ae:	83 ec 0c             	sub    $0xc,%esp
c00034b1:	68 f4 47 00 c0       	push   $0xc00047f4
c00034b6:	e8 9e d1 ff ff       	call   c0000659 <kprintf>
c00034bb:	83 c4 10             	add    $0x10,%esp

	while(1);
c00034be:	eb fe                	jmp    c00034be <kernel_main+0xb7>

c00034c0 <populate_gdt_entry>:
   uint16_t iomap_base;
} tss_entry_t;


static inline void populate_gdt_entry(gdt_entry_t* sd, uint32_t base, uint32_t limit, uint8_t access, uint8_t flags)
{
c00034c0:	55                   	push   %ebp
c00034c1:	89 e5                	mov    %esp,%ebp
c00034c3:	53                   	push   %ebx
c00034c4:	83 ec 08             	sub    $0x8,%esp
c00034c7:	8b 55 14             	mov    0x14(%ebp),%edx
c00034ca:	8b 45 18             	mov    0x18(%ebp),%eax
c00034cd:	88 55 f8             	mov    %dl,-0x8(%ebp)
c00034d0:	88 45 f4             	mov    %al,-0xc(%ebp)
    sd->limit_low = limit & SEGMENT_LIMIT_LOW_MASK;
c00034d3:	8b 45 10             	mov    0x10(%ebp),%eax
c00034d6:	89 c2                	mov    %eax,%edx
c00034d8:	8b 45 08             	mov    0x8(%ebp),%eax
c00034db:	0f b7 ca             	movzwl %dx,%ecx
c00034de:	0f b6 d9             	movzbl %cl,%ebx
c00034e1:	0f b6 08             	movzbl (%eax),%ecx
c00034e4:	83 e1 00             	and    $0x0,%ecx
c00034e7:	09 d9                	or     %ebx,%ecx
c00034e9:	88 08                	mov    %cl,(%eax)
c00034eb:	66 c1 ea 08          	shr    $0x8,%dx
c00034ef:	0f b7 ca             	movzwl %dx,%ecx
c00034f2:	0f b6 50 01          	movzbl 0x1(%eax),%edx
c00034f6:	83 e2 00             	and    $0x0,%edx
c00034f9:	09 ca                	or     %ecx,%edx
c00034fb:	88 50 01             	mov    %dl,0x1(%eax)
    sd->limit_high = (limit & SEGMENT_LIMIT_HIGH_MASK) >> 16;
c00034fe:	8b 45 10             	mov    0x10(%ebp),%eax
c0003501:	c1 e8 10             	shr    $0x10,%eax
c0003504:	83 e0 0f             	and    $0xf,%eax
c0003507:	8b 55 08             	mov    0x8(%ebp),%edx
c000350a:	83 e0 0f             	and    $0xf,%eax
c000350d:	89 c1                	mov    %eax,%ecx
c000350f:	0f b6 42 06          	movzbl 0x6(%edx),%eax
c0003513:	83 e0 f0             	and    $0xfffffff0,%eax
c0003516:	09 c8                	or     %ecx,%eax
c0003518:	88 42 06             	mov    %al,0x6(%edx)
    sd->base_low = base & SEGMENT_BASE_LOW_MASK;
c000351b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000351e:	89 c2                	mov    %eax,%edx
c0003520:	8b 45 08             	mov    0x8(%ebp),%eax
c0003523:	0f b7 ca             	movzwl %dx,%ecx
c0003526:	0f b6 d9             	movzbl %cl,%ebx
c0003529:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
c000352d:	83 e1 00             	and    $0x0,%ecx
c0003530:	09 d9                	or     %ebx,%ecx
c0003532:	88 48 02             	mov    %cl,0x2(%eax)
c0003535:	66 c1 ea 08          	shr    $0x8,%dx
c0003539:	0f b7 ca             	movzwl %dx,%ecx
c000353c:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c0003540:	83 e2 00             	and    $0x0,%edx
c0003543:	09 ca                	or     %ecx,%edx
c0003545:	88 50 03             	mov    %dl,0x3(%eax)
    sd->base_mid = (base & SEGMENT_BASE_MID_MASK) >> 16;
c0003548:	8b 45 0c             	mov    0xc(%ebp),%eax
c000354b:	c1 e8 10             	shr    $0x10,%eax
c000354e:	89 c2                	mov    %eax,%edx
c0003550:	8b 45 08             	mov    0x8(%ebp),%eax
c0003553:	88 50 04             	mov    %dl,0x4(%eax)
    sd->base_high = (base & SEGMENT_BASE_HIGH_MASK) >> 24;
c0003556:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003559:	c1 e8 18             	shr    $0x18,%eax
c000355c:	89 c2                	mov    %eax,%edx
c000355e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003561:	88 50 07             	mov    %dl,0x7(%eax)
    sd->access = access;
c0003564:	8b 45 08             	mov    0x8(%ebp),%eax
c0003567:	0f b6 55 f8          	movzbl -0x8(%ebp),%edx
c000356b:	88 50 05             	mov    %dl,0x5(%eax)
    sd->flags = flags;
c000356e:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0003572:	83 e0 0f             	and    $0xf,%eax
c0003575:	89 c2                	mov    %eax,%edx
c0003577:	8b 45 08             	mov    0x8(%ebp),%eax
c000357a:	89 d1                	mov    %edx,%ecx
c000357c:	c1 e1 04             	shl    $0x4,%ecx
c000357f:	0f b6 50 06          	movzbl 0x6(%eax),%edx
c0003583:	83 e2 0f             	and    $0xf,%edx
c0003586:	09 ca                	or     %ecx,%edx
c0003588:	88 50 06             	mov    %dl,0x6(%eax)
}
c000358b:	90                   	nop
c000358c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000358f:	c9                   	leave  
c0003590:	c3                   	ret    

c0003591 <init_gdt>:
gdt_description_t __aligned  gdtd;

tss_entry_t tss = {0};

void init_gdt()
{
c0003591:	55                   	push   %ebp
c0003592:	89 e5                	mov    %esp,%ebp
c0003594:	83 ec 08             	sub    $0x8,%esp
    // gdt[0] unused
    populate_gdt_entry(&gdt[1], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(0) | SEG_DESCTYPE(1) | SEG_CODE_EXRD, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // priv code, seg 0x008
c0003597:	6a 0c                	push   $0xc
c0003599:	68 9a 00 00 00       	push   $0x9a
c000359e:	6a ff                	push   $0xffffffff
c00035a0:	6a 00                	push   $0x0
c00035a2:	68 c8 08 01 c0       	push   $0xc00108c8
c00035a7:	e8 14 ff ff ff       	call   c00034c0 <populate_gdt_entry>
c00035ac:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[2], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(0) | SEG_DESCTYPE(1) | SEG_DATA_RDWR, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // priv data, seg 0x010
c00035af:	6a 0c                	push   $0xc
c00035b1:	68 92 00 00 00       	push   $0x92
c00035b6:	6a ff                	push   $0xffffffff
c00035b8:	6a 00                	push   $0x0
c00035ba:	68 d0 08 01 c0       	push   $0xc00108d0
c00035bf:	e8 fc fe ff ff       	call   c00034c0 <populate_gdt_entry>
c00035c4:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[3], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(3) | SEG_DESCTYPE(1) | SEG_CODE_EXRD, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // user code, seg 0x018
c00035c7:	6a 0c                	push   $0xc
c00035c9:	68 fa 00 00 00       	push   $0xfa
c00035ce:	6a ff                	push   $0xffffffff
c00035d0:	6a 00                	push   $0x0
c00035d2:	68 d8 08 01 c0       	push   $0xc00108d8
c00035d7:	e8 e4 fe ff ff       	call   c00034c0 <populate_gdt_entry>
c00035dc:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[4], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(3) | SEG_DESCTYPE(1) | SEG_DATA_RDWR, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // user data  seg 0x020
c00035df:	6a 0c                	push   $0xc
c00035e1:	68 f2 00 00 00       	push   $0xf2
c00035e6:	6a ff                	push   $0xffffffff
c00035e8:	6a 00                	push   $0x0
c00035ea:	68 e0 08 01 c0       	push   $0xc00108e0
c00035ef:	e8 cc fe ff ff       	call   c00034c0 <populate_gdt_entry>
c00035f4:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[5], (uint32_t) &tss, sizeof(tss_entry_t), SEG_TSS, SEG_FLAG_TSS); // tss, seg 0x028
c00035f7:	b8 20 09 01 c0       	mov    $0xc0010920,%eax
c00035fc:	6a 04                	push   $0x4
c00035fe:	68 89 00 00 00       	push   $0x89
c0003603:	6a 68                	push   $0x68
c0003605:	50                   	push   %eax
c0003606:	68 e8 08 01 c0       	push   $0xc00108e8
c000360b:	e8 b0 fe ff ff       	call   c00034c0 <populate_gdt_entry>
c0003610:	83 c4 14             	add    $0x14,%esp

    //tss.esp0 = XXXXX
    tss.ss0 = KERNEL_DATA_SEGMENT; //kernel data segment    
c0003613:	c7 05 28 09 01 c0 10 	movl   $0x10,0xc0010928
c000361a:	00 00 00 
    tss.iomap_base = sizeof(tss_entry_t);
c000361d:	66 c7 05 86 09 01 c0 	movw   $0x68,0xc0010986
c0003624:	68 00 
    // before we can actually switch tasks, we must first set the kernel stack pointer, with update_tss()

    gdtd.addr = (uint32_t) gdt;
c0003626:	b8 c0 08 01 c0       	mov    $0xc00108c0,%eax
c000362b:	a3 02 09 01 c0       	mov    %eax,0xc0010902
    gdtd.size = sizeof(gdt);    
c0003630:	66 c7 05 00 09 01 c0 	movw   $0x30,0xc0010900
c0003637:	30 00 
    load_gdt(&gdtd);
c0003639:	83 ec 0c             	sub    $0xc,%esp
c000363c:	68 00 09 01 c0       	push   $0xc0010900
c0003641:	e8 1e 00 00 00       	call   c0003664 <load_gdt>
c0003646:	83 c4 10             	add    $0x10,%esp
}
c0003649:	90                   	nop
c000364a:	c9                   	leave  
c000364b:	c3                   	ret    

c000364c <update_kstack>:

void update_kstack(void* kernel_stack_ptr)
{
c000364c:	55                   	push   %ebp
c000364d:	89 e5                	mov    %esp,%ebp
c000364f:	83 ec 08             	sub    $0x8,%esp
    tss.esp0 = (uint32_t) kernel_stack_ptr; //kernel stack ptr
c0003652:	8b 45 08             	mov    0x8(%ebp),%eax
c0003655:	a3 24 09 01 c0       	mov    %eax,0xc0010924
    load_tss();
c000365a:	e8 25 00 00 00       	call   c0003684 <load_tss>
}
c000365f:	90                   	nop
c0003660:	c9                   	leave  
c0003661:	c3                   	ret    
c0003662:	66 90                	xchg   %ax,%ax

c0003664 <load_gdt>:
c0003664:	0f 01 15 00 09 01 c0 	lgdtl  0xc0010900
c000366b:	ea 72 36 00 c0 08 00 	ljmp   $0x8,$0xc0003672

c0003672 <complete_flush>:
c0003672:	66 b8 10 00          	mov    $0x10,%ax
c0003676:	8e d8                	mov    %eax,%ds
c0003678:	8e c0                	mov    %eax,%es
c000367a:	8e e0                	mov    %eax,%fs
c000367c:	8e e8                	mov    %eax,%gs
c000367e:	8e d0                	mov    %eax,%ss
c0003680:	c3                   	ret    
c0003681:	8d 76 00             	lea    0x0(%esi),%esi

c0003684 <load_tss>:
c0003684:	66 b8 28 00          	mov    $0x28,%ax
c0003688:	66 83 c8 03          	or     $0x3,%ax
c000368c:	0f 00 d8             	ltr    %ax
c000368f:	c3                   	ret    

c0003690 <getregs>:
c0003690:	55                   	push   %ebp
c0003691:	89 e5                	mov    %esp,%ebp
c0003693:	53                   	push   %ebx
c0003694:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0003697:	89 03                	mov    %eax,(%ebx)
c0003699:	8b 04 24             	mov    (%esp),%eax
c000369c:	89 43 04             	mov    %eax,0x4(%ebx)
c000369f:	89 4b 08             	mov    %ecx,0x8(%ebx)
c00036a2:	89 53 0c             	mov    %edx,0xc(%ebx)
c00036a5:	89 73 10             	mov    %esi,0x10(%ebx)
c00036a8:	89 7b 14             	mov    %edi,0x14(%ebx)
c00036ab:	89 e8                	mov    %ebp,%eax
c00036ad:	83 c0 0c             	add    $0xc,%eax
c00036b0:	89 43 18             	mov    %eax,0x18(%ebx)
c00036b3:	8b 45 00             	mov    0x0(%ebp),%eax
c00036b6:	89 43 1c             	mov    %eax,0x1c(%ebx)
c00036b9:	8b 45 04             	mov    0x4(%ebp),%eax
c00036bc:	89 43 20             	mov    %eax,0x20(%ebx)
c00036bf:	b8 00 00 00 00       	mov    $0x0,%eax
c00036c4:	9f                   	lahf   
c00036c5:	89 43 24             	mov    %eax,0x24(%ebx)
c00036c8:	0f 20 c0             	mov    %cr0,%eax
c00036cb:	89 43 28             	mov    %eax,0x28(%ebx)
c00036ce:	0f 20 d0             	mov    %cr2,%eax
c00036d1:	89 43 2c             	mov    %eax,0x2c(%ebx)
c00036d4:	0f 20 d8             	mov    %cr3,%eax
c00036d7:	89 43 30             	mov    %eax,0x30(%ebx)
c00036da:	0f 20 e0             	mov    %cr4,%eax
c00036dd:	89 43 34             	mov    %eax,0x34(%ebx)
c00036e0:	5b                   	pop    %ebx
c00036e1:	5d                   	pop    %ebp
c00036e2:	c3                   	ret    
c00036e3:	90                   	nop

c00036e4 <load_idt>:
c00036e4:	0f 01 1d 20 08 01 c0 	lidtl  0xc0010820
c00036eb:	fb                   	sti    
c00036ec:	c3                   	ret    
c00036ed:	8d 76 00             	lea    0x0(%esi),%esi

c00036f0 <pf_addr>:
c00036f0:	0f 20 d0             	mov    %cr2,%eax
c00036f3:	c3                   	ret    

c00036f4 <except_0>:
c00036f4:	55                   	push   %ebp
c00036f5:	89 e5                	mov    %esp,%ebp
c00036f7:	60                   	pusha  
c00036f8:	8b 45 04             	mov    0x4(%ebp),%eax
c00036fb:	50                   	push   %eax
c00036fc:	b8 00 00 00 00       	mov    $0x0,%eax
c0003701:	50                   	push   %eax
c0003702:	b8 00 00 00 00       	mov    $0x0,%eax
c0003707:	50                   	push   %eax
c0003708:	e8 b6 ea ff ff       	call   c00021c3 <exception_handler>
c000370d:	83 c4 0c             	add    $0xc,%esp
c0003710:	61                   	popa   
c0003711:	5d                   	pop    %ebp
c0003712:	cf                   	iret   
c0003713:	90                   	nop

c0003714 <except_1>:
c0003714:	55                   	push   %ebp
c0003715:	89 e5                	mov    %esp,%ebp
c0003717:	60                   	pusha  
c0003718:	8b 45 04             	mov    0x4(%ebp),%eax
c000371b:	50                   	push   %eax
c000371c:	b8 00 00 00 00       	mov    $0x0,%eax
c0003721:	50                   	push   %eax
c0003722:	b8 01 00 00 00       	mov    $0x1,%eax
c0003727:	50                   	push   %eax
c0003728:	e8 96 ea ff ff       	call   c00021c3 <exception_handler>
c000372d:	83 c4 0c             	add    $0xc,%esp
c0003730:	61                   	popa   
c0003731:	5d                   	pop    %ebp
c0003732:	cf                   	iret   
c0003733:	90                   	nop

c0003734 <except_2>:
c0003734:	55                   	push   %ebp
c0003735:	89 e5                	mov    %esp,%ebp
c0003737:	60                   	pusha  
c0003738:	8b 45 04             	mov    0x4(%ebp),%eax
c000373b:	50                   	push   %eax
c000373c:	b8 00 00 00 00       	mov    $0x0,%eax
c0003741:	50                   	push   %eax
c0003742:	b8 02 00 00 00       	mov    $0x2,%eax
c0003747:	50                   	push   %eax
c0003748:	e8 76 ea ff ff       	call   c00021c3 <exception_handler>
c000374d:	83 c4 0c             	add    $0xc,%esp
c0003750:	61                   	popa   
c0003751:	5d                   	pop    %ebp
c0003752:	cf                   	iret   
c0003753:	90                   	nop

c0003754 <except_3>:
c0003754:	55                   	push   %ebp
c0003755:	89 e5                	mov    %esp,%ebp
c0003757:	60                   	pusha  
c0003758:	8b 45 04             	mov    0x4(%ebp),%eax
c000375b:	50                   	push   %eax
c000375c:	b8 00 00 00 00       	mov    $0x0,%eax
c0003761:	50                   	push   %eax
c0003762:	b8 03 00 00 00       	mov    $0x3,%eax
c0003767:	50                   	push   %eax
c0003768:	e8 56 ea ff ff       	call   c00021c3 <exception_handler>
c000376d:	83 c4 0c             	add    $0xc,%esp
c0003770:	61                   	popa   
c0003771:	5d                   	pop    %ebp
c0003772:	cf                   	iret   
c0003773:	90                   	nop

c0003774 <except_4>:
c0003774:	55                   	push   %ebp
c0003775:	89 e5                	mov    %esp,%ebp
c0003777:	60                   	pusha  
c0003778:	8b 45 04             	mov    0x4(%ebp),%eax
c000377b:	50                   	push   %eax
c000377c:	b8 00 00 00 00       	mov    $0x0,%eax
c0003781:	50                   	push   %eax
c0003782:	b8 04 00 00 00       	mov    $0x4,%eax
c0003787:	50                   	push   %eax
c0003788:	e8 36 ea ff ff       	call   c00021c3 <exception_handler>
c000378d:	83 c4 0c             	add    $0xc,%esp
c0003790:	61                   	popa   
c0003791:	5d                   	pop    %ebp
c0003792:	cf                   	iret   
c0003793:	90                   	nop

c0003794 <except_5>:
c0003794:	55                   	push   %ebp
c0003795:	89 e5                	mov    %esp,%ebp
c0003797:	60                   	pusha  
c0003798:	8b 45 04             	mov    0x4(%ebp),%eax
c000379b:	50                   	push   %eax
c000379c:	b8 00 00 00 00       	mov    $0x0,%eax
c00037a1:	50                   	push   %eax
c00037a2:	b8 05 00 00 00       	mov    $0x5,%eax
c00037a7:	50                   	push   %eax
c00037a8:	e8 16 ea ff ff       	call   c00021c3 <exception_handler>
c00037ad:	83 c4 0c             	add    $0xc,%esp
c00037b0:	61                   	popa   
c00037b1:	5d                   	pop    %ebp
c00037b2:	cf                   	iret   
c00037b3:	90                   	nop

c00037b4 <except_6>:
c00037b4:	55                   	push   %ebp
c00037b5:	89 e5                	mov    %esp,%ebp
c00037b7:	60                   	pusha  
c00037b8:	8b 45 04             	mov    0x4(%ebp),%eax
c00037bb:	50                   	push   %eax
c00037bc:	b8 00 00 00 00       	mov    $0x0,%eax
c00037c1:	50                   	push   %eax
c00037c2:	b8 06 00 00 00       	mov    $0x6,%eax
c00037c7:	50                   	push   %eax
c00037c8:	e8 f6 e9 ff ff       	call   c00021c3 <exception_handler>
c00037cd:	83 c4 0c             	add    $0xc,%esp
c00037d0:	61                   	popa   
c00037d1:	5d                   	pop    %ebp
c00037d2:	cf                   	iret   
c00037d3:	90                   	nop

c00037d4 <except_7>:
c00037d4:	55                   	push   %ebp
c00037d5:	89 e5                	mov    %esp,%ebp
c00037d7:	60                   	pusha  
c00037d8:	8b 45 04             	mov    0x4(%ebp),%eax
c00037db:	50                   	push   %eax
c00037dc:	b8 00 00 00 00       	mov    $0x0,%eax
c00037e1:	50                   	push   %eax
c00037e2:	b8 07 00 00 00       	mov    $0x7,%eax
c00037e7:	50                   	push   %eax
c00037e8:	e8 d6 e9 ff ff       	call   c00021c3 <exception_handler>
c00037ed:	83 c4 0c             	add    $0xc,%esp
c00037f0:	61                   	popa   
c00037f1:	5d                   	pop    %ebp
c00037f2:	cf                   	iret   
c00037f3:	90                   	nop

c00037f4 <except_8>:
c00037f4:	55                   	push   %ebp
c00037f5:	89 e5                	mov    %esp,%ebp
c00037f7:	60                   	pusha  
c00037f8:	8b 45 08             	mov    0x8(%ebp),%eax
c00037fb:	50                   	push   %eax
c00037fc:	8b 45 04             	mov    0x4(%ebp),%eax
c00037ff:	50                   	push   %eax
c0003800:	b8 08 00 00 00       	mov    $0x8,%eax
c0003805:	50                   	push   %eax
c0003806:	e8 b8 e9 ff ff       	call   c00021c3 <exception_handler>
c000380b:	83 c4 0c             	add    $0xc,%esp
c000380e:	61                   	popa   
c000380f:	5d                   	pop    %ebp
c0003810:	83 c4 04             	add    $0x4,%esp
c0003813:	cf                   	iret   

c0003814 <except_10>:
c0003814:	55                   	push   %ebp
c0003815:	89 e5                	mov    %esp,%ebp
c0003817:	60                   	pusha  
c0003818:	8b 45 08             	mov    0x8(%ebp),%eax
c000381b:	50                   	push   %eax
c000381c:	8b 45 04             	mov    0x4(%ebp),%eax
c000381f:	50                   	push   %eax
c0003820:	b8 0a 00 00 00       	mov    $0xa,%eax
c0003825:	50                   	push   %eax
c0003826:	e8 98 e9 ff ff       	call   c00021c3 <exception_handler>
c000382b:	83 c4 0c             	add    $0xc,%esp
c000382e:	61                   	popa   
c000382f:	5d                   	pop    %ebp
c0003830:	83 c4 04             	add    $0x4,%esp
c0003833:	cf                   	iret   

c0003834 <except_11>:
c0003834:	55                   	push   %ebp
c0003835:	89 e5                	mov    %esp,%ebp
c0003837:	60                   	pusha  
c0003838:	8b 45 08             	mov    0x8(%ebp),%eax
c000383b:	50                   	push   %eax
c000383c:	8b 45 04             	mov    0x4(%ebp),%eax
c000383f:	50                   	push   %eax
c0003840:	b8 0b 00 00 00       	mov    $0xb,%eax
c0003845:	50                   	push   %eax
c0003846:	e8 78 e9 ff ff       	call   c00021c3 <exception_handler>
c000384b:	83 c4 0c             	add    $0xc,%esp
c000384e:	61                   	popa   
c000384f:	5d                   	pop    %ebp
c0003850:	83 c4 04             	add    $0x4,%esp
c0003853:	cf                   	iret   

c0003854 <except_12>:
c0003854:	55                   	push   %ebp
c0003855:	89 e5                	mov    %esp,%ebp
c0003857:	60                   	pusha  
c0003858:	8b 45 08             	mov    0x8(%ebp),%eax
c000385b:	50                   	push   %eax
c000385c:	8b 45 04             	mov    0x4(%ebp),%eax
c000385f:	50                   	push   %eax
c0003860:	b8 0c 00 00 00       	mov    $0xc,%eax
c0003865:	50                   	push   %eax
c0003866:	e8 58 e9 ff ff       	call   c00021c3 <exception_handler>
c000386b:	83 c4 0c             	add    $0xc,%esp
c000386e:	61                   	popa   
c000386f:	5d                   	pop    %ebp
c0003870:	83 c4 04             	add    $0x4,%esp
c0003873:	cf                   	iret   

c0003874 <except_13>:
c0003874:	55                   	push   %ebp
c0003875:	89 e5                	mov    %esp,%ebp
c0003877:	60                   	pusha  
c0003878:	8b 45 08             	mov    0x8(%ebp),%eax
c000387b:	50                   	push   %eax
c000387c:	8b 45 04             	mov    0x4(%ebp),%eax
c000387f:	50                   	push   %eax
c0003880:	b8 0d 00 00 00       	mov    $0xd,%eax
c0003885:	50                   	push   %eax
c0003886:	e8 38 e9 ff ff       	call   c00021c3 <exception_handler>
c000388b:	83 c4 0c             	add    $0xc,%esp
c000388e:	61                   	popa   
c000388f:	5d                   	pop    %ebp
c0003890:	83 c4 04             	add    $0x4,%esp
c0003893:	cf                   	iret   

c0003894 <except_14>:
c0003894:	55                   	push   %ebp
c0003895:	89 e5                	mov    %esp,%ebp
c0003897:	60                   	pusha  
c0003898:	8b 45 08             	mov    0x8(%ebp),%eax
c000389b:	50                   	push   %eax
c000389c:	8b 45 04             	mov    0x4(%ebp),%eax
c000389f:	50                   	push   %eax
c00038a0:	b8 0e 00 00 00       	mov    $0xe,%eax
c00038a5:	50                   	push   %eax
c00038a6:	e8 18 e9 ff ff       	call   c00021c3 <exception_handler>
c00038ab:	83 c4 0c             	add    $0xc,%esp
c00038ae:	61                   	popa   
c00038af:	5d                   	pop    %ebp
c00038b0:	83 c4 04             	add    $0x4,%esp
c00038b3:	cf                   	iret   

c00038b4 <except_16>:
c00038b4:	55                   	push   %ebp
c00038b5:	89 e5                	mov    %esp,%ebp
c00038b7:	60                   	pusha  
c00038b8:	8b 45 08             	mov    0x8(%ebp),%eax
c00038bb:	50                   	push   %eax
c00038bc:	8b 45 04             	mov    0x4(%ebp),%eax
c00038bf:	50                   	push   %eax
c00038c0:	b8 10 00 00 00       	mov    $0x10,%eax
c00038c5:	50                   	push   %eax
c00038c6:	e8 f8 e8 ff ff       	call   c00021c3 <exception_handler>
c00038cb:	83 c4 0c             	add    $0xc,%esp
c00038ce:	61                   	popa   
c00038cf:	5d                   	pop    %ebp
c00038d0:	83 c4 04             	add    $0x4,%esp
c00038d3:	cf                   	iret   

c00038d4 <except_17>:
c00038d4:	55                   	push   %ebp
c00038d5:	89 e5                	mov    %esp,%ebp
c00038d7:	60                   	pusha  
c00038d8:	8b 45 08             	mov    0x8(%ebp),%eax
c00038db:	50                   	push   %eax
c00038dc:	8b 45 04             	mov    0x4(%ebp),%eax
c00038df:	50                   	push   %eax
c00038e0:	b8 11 00 00 00       	mov    $0x11,%eax
c00038e5:	50                   	push   %eax
c00038e6:	e8 d8 e8 ff ff       	call   c00021c3 <exception_handler>
c00038eb:	83 c4 0c             	add    $0xc,%esp
c00038ee:	61                   	popa   
c00038ef:	5d                   	pop    %ebp
c00038f0:	83 c4 04             	add    $0x4,%esp
c00038f3:	cf                   	iret   

c00038f4 <except_18>:
c00038f4:	55                   	push   %ebp
c00038f5:	89 e5                	mov    %esp,%ebp
c00038f7:	60                   	pusha  
c00038f8:	8b 45 08             	mov    0x8(%ebp),%eax
c00038fb:	50                   	push   %eax
c00038fc:	8b 45 04             	mov    0x4(%ebp),%eax
c00038ff:	50                   	push   %eax
c0003900:	b8 12 00 00 00       	mov    $0x12,%eax
c0003905:	50                   	push   %eax
c0003906:	e8 b8 e8 ff ff       	call   c00021c3 <exception_handler>
c000390b:	83 c4 0c             	add    $0xc,%esp
c000390e:	61                   	popa   
c000390f:	5d                   	pop    %ebp
c0003910:	83 c4 04             	add    $0x4,%esp
c0003913:	cf                   	iret   

c0003914 <except_19>:
c0003914:	55                   	push   %ebp
c0003915:	89 e5                	mov    %esp,%ebp
c0003917:	60                   	pusha  
c0003918:	8b 45 08             	mov    0x8(%ebp),%eax
c000391b:	50                   	push   %eax
c000391c:	8b 45 04             	mov    0x4(%ebp),%eax
c000391f:	50                   	push   %eax
c0003920:	b8 13 00 00 00       	mov    $0x13,%eax
c0003925:	50                   	push   %eax
c0003926:	e8 98 e8 ff ff       	call   c00021c3 <exception_handler>
c000392b:	83 c4 0c             	add    $0xc,%esp
c000392e:	61                   	popa   
c000392f:	5d                   	pop    %ebp
c0003930:	83 c4 04             	add    $0x4,%esp
c0003933:	cf                   	iret   

c0003934 <except_20>:
c0003934:	55                   	push   %ebp
c0003935:	89 e5                	mov    %esp,%ebp
c0003937:	60                   	pusha  
c0003938:	8b 45 08             	mov    0x8(%ebp),%eax
c000393b:	50                   	push   %eax
c000393c:	8b 45 04             	mov    0x4(%ebp),%eax
c000393f:	50                   	push   %eax
c0003940:	b8 14 00 00 00       	mov    $0x14,%eax
c0003945:	50                   	push   %eax
c0003946:	e8 78 e8 ff ff       	call   c00021c3 <exception_handler>
c000394b:	83 c4 0c             	add    $0xc,%esp
c000394e:	61                   	popa   
c000394f:	5d                   	pop    %ebp
c0003950:	83 c4 04             	add    $0x4,%esp
c0003953:	cf                   	iret   

c0003954 <except_30>:
c0003954:	55                   	push   %ebp
c0003955:	89 e5                	mov    %esp,%ebp
c0003957:	60                   	pusha  
c0003958:	8b 45 08             	mov    0x8(%ebp),%eax
c000395b:	50                   	push   %eax
c000395c:	8b 45 04             	mov    0x4(%ebp),%eax
c000395f:	50                   	push   %eax
c0003960:	b8 1e 00 00 00       	mov    $0x1e,%eax
c0003965:	50                   	push   %eax
c0003966:	e8 58 e8 ff ff       	call   c00021c3 <exception_handler>
c000396b:	83 c4 0c             	add    $0xc,%esp
c000396e:	61                   	popa   
c000396f:	5d                   	pop    %ebp
c0003970:	83 c4 04             	add    $0x4,%esp
c0003973:	cf                   	iret   

c0003974 <irq_0>:
c0003974:	60                   	pusha  
c0003975:	b8 00 00 00 00       	mov    $0x0,%eax
c000397a:	50                   	push   %eax
c000397b:	e8 7a e8 ff ff       	call   c00021fa <irq_handler>
c0003980:	83 c4 04             	add    $0x4,%esp
c0003983:	61                   	popa   
c0003984:	cf                   	iret   
c0003985:	8d 76 00             	lea    0x0(%esi),%esi

c0003988 <irq_1>:
c0003988:	60                   	pusha  
c0003989:	b8 01 00 00 00       	mov    $0x1,%eax
c000398e:	50                   	push   %eax
c000398f:	e8 66 e8 ff ff       	call   c00021fa <irq_handler>
c0003994:	83 c4 04             	add    $0x4,%esp
c0003997:	61                   	popa   
c0003998:	cf                   	iret   
c0003999:	8d 76 00             	lea    0x0(%esi),%esi

c000399c <irq_2>:
c000399c:	60                   	pusha  
c000399d:	b8 02 00 00 00       	mov    $0x2,%eax
c00039a2:	50                   	push   %eax
c00039a3:	e8 52 e8 ff ff       	call   c00021fa <irq_handler>
c00039a8:	83 c4 04             	add    $0x4,%esp
c00039ab:	61                   	popa   
c00039ac:	cf                   	iret   
c00039ad:	8d 76 00             	lea    0x0(%esi),%esi

c00039b0 <irq_3>:
c00039b0:	60                   	pusha  
c00039b1:	b8 03 00 00 00       	mov    $0x3,%eax
c00039b6:	50                   	push   %eax
c00039b7:	e8 3e e8 ff ff       	call   c00021fa <irq_handler>
c00039bc:	83 c4 04             	add    $0x4,%esp
c00039bf:	61                   	popa   
c00039c0:	cf                   	iret   
c00039c1:	8d 76 00             	lea    0x0(%esi),%esi

c00039c4 <irq_4>:
c00039c4:	60                   	pusha  
c00039c5:	b8 04 00 00 00       	mov    $0x4,%eax
c00039ca:	50                   	push   %eax
c00039cb:	e8 2a e8 ff ff       	call   c00021fa <irq_handler>
c00039d0:	83 c4 04             	add    $0x4,%esp
c00039d3:	61                   	popa   
c00039d4:	cf                   	iret   
c00039d5:	8d 76 00             	lea    0x0(%esi),%esi

c00039d8 <irq_5>:
c00039d8:	60                   	pusha  
c00039d9:	b8 05 00 00 00       	mov    $0x5,%eax
c00039de:	50                   	push   %eax
c00039df:	e8 16 e8 ff ff       	call   c00021fa <irq_handler>
c00039e4:	83 c4 04             	add    $0x4,%esp
c00039e7:	61                   	popa   
c00039e8:	cf                   	iret   
c00039e9:	8d 76 00             	lea    0x0(%esi),%esi

c00039ec <irq_6>:
c00039ec:	60                   	pusha  
c00039ed:	b8 06 00 00 00       	mov    $0x6,%eax
c00039f2:	50                   	push   %eax
c00039f3:	e8 02 e8 ff ff       	call   c00021fa <irq_handler>
c00039f8:	83 c4 04             	add    $0x4,%esp
c00039fb:	61                   	popa   
c00039fc:	cf                   	iret   
c00039fd:	8d 76 00             	lea    0x0(%esi),%esi

c0003a00 <irq_7>:
c0003a00:	60                   	pusha  
c0003a01:	b8 07 00 00 00       	mov    $0x7,%eax
c0003a06:	50                   	push   %eax
c0003a07:	e8 ee e7 ff ff       	call   c00021fa <irq_handler>
c0003a0c:	83 c4 04             	add    $0x4,%esp
c0003a0f:	61                   	popa   
c0003a10:	cf                   	iret   
c0003a11:	8d 76 00             	lea    0x0(%esi),%esi

c0003a14 <irq_8>:
c0003a14:	60                   	pusha  
c0003a15:	b8 08 00 00 00       	mov    $0x8,%eax
c0003a1a:	50                   	push   %eax
c0003a1b:	e8 da e7 ff ff       	call   c00021fa <irq_handler>
c0003a20:	83 c4 04             	add    $0x4,%esp
c0003a23:	61                   	popa   
c0003a24:	cf                   	iret   
c0003a25:	8d 76 00             	lea    0x0(%esi),%esi

c0003a28 <irq_9>:
c0003a28:	60                   	pusha  
c0003a29:	b8 09 00 00 00       	mov    $0x9,%eax
c0003a2e:	50                   	push   %eax
c0003a2f:	e8 c6 e7 ff ff       	call   c00021fa <irq_handler>
c0003a34:	83 c4 04             	add    $0x4,%esp
c0003a37:	61                   	popa   
c0003a38:	cf                   	iret   
c0003a39:	8d 76 00             	lea    0x0(%esi),%esi

c0003a3c <irq_10>:
c0003a3c:	60                   	pusha  
c0003a3d:	b8 0a 00 00 00       	mov    $0xa,%eax
c0003a42:	50                   	push   %eax
c0003a43:	e8 b2 e7 ff ff       	call   c00021fa <irq_handler>
c0003a48:	83 c4 04             	add    $0x4,%esp
c0003a4b:	61                   	popa   
c0003a4c:	cf                   	iret   
c0003a4d:	8d 76 00             	lea    0x0(%esi),%esi

c0003a50 <irq_11>:
c0003a50:	60                   	pusha  
c0003a51:	b8 0b 00 00 00       	mov    $0xb,%eax
c0003a56:	50                   	push   %eax
c0003a57:	e8 9e e7 ff ff       	call   c00021fa <irq_handler>
c0003a5c:	83 c4 04             	add    $0x4,%esp
c0003a5f:	61                   	popa   
c0003a60:	cf                   	iret   
c0003a61:	8d 76 00             	lea    0x0(%esi),%esi

c0003a64 <irq_12>:
c0003a64:	60                   	pusha  
c0003a65:	b8 0c 00 00 00       	mov    $0xc,%eax
c0003a6a:	50                   	push   %eax
c0003a6b:	e8 8a e7 ff ff       	call   c00021fa <irq_handler>
c0003a70:	83 c4 04             	add    $0x4,%esp
c0003a73:	61                   	popa   
c0003a74:	cf                   	iret   
c0003a75:	8d 76 00             	lea    0x0(%esi),%esi

c0003a78 <irq_13>:
c0003a78:	60                   	pusha  
c0003a79:	b8 0d 00 00 00       	mov    $0xd,%eax
c0003a7e:	50                   	push   %eax
c0003a7f:	e8 76 e7 ff ff       	call   c00021fa <irq_handler>
c0003a84:	83 c4 04             	add    $0x4,%esp
c0003a87:	61                   	popa   
c0003a88:	cf                   	iret   
c0003a89:	8d 76 00             	lea    0x0(%esi),%esi

c0003a8c <irq_14>:
c0003a8c:	60                   	pusha  
c0003a8d:	b8 0e 00 00 00       	mov    $0xe,%eax
c0003a92:	50                   	push   %eax
c0003a93:	e8 62 e7 ff ff       	call   c00021fa <irq_handler>
c0003a98:	83 c4 04             	add    $0x4,%esp
c0003a9b:	61                   	popa   
c0003a9c:	cf                   	iret   
c0003a9d:	8d 76 00             	lea    0x0(%esi),%esi

c0003aa0 <irq_15>:
c0003aa0:	60                   	pusha  
c0003aa1:	b8 0f 00 00 00       	mov    $0xf,%eax
c0003aa6:	50                   	push   %eax
c0003aa7:	e8 4e e7 ff ff       	call   c00021fa <irq_handler>
c0003aac:	83 c4 04             	add    $0x4,%esp
c0003aaf:	61                   	popa   
c0003ab0:	cf                   	iret   
c0003ab1:	66 90                	xchg   %ax,%ax
c0003ab3:	90                   	nop

c0003ab4 <switch_to_task>:
c0003ab4:	53                   	push   %ebx
c0003ab5:	56                   	push   %esi
c0003ab6:	57                   	push   %edi
c0003ab7:	55                   	push   %ebp
c0003ab8:	8b 3d 40 08 01 c0    	mov    0xc0010840,%edi
c0003abe:	89 67 08             	mov    %esp,0x8(%edi)
c0003ac1:	8b 74 24 14          	mov    0x14(%esp),%esi
c0003ac5:	89 35 40 08 01 c0    	mov    %esi,0xc0010840
c0003acb:	8b 66 08             	mov    0x8(%esi),%esp
c0003ace:	8b 5e 0c             	mov    0xc(%esi),%ebx
c0003ad1:	8b 46 10             	mov    0x10(%esi),%eax
c0003ad4:	89 1d 24 09 01 c0    	mov    %ebx,0xc0010924
c0003ada:	0f 20 d9             	mov    %cr3,%ecx
c0003add:	39 c8                	cmp    %ecx,%eax
c0003adf:	74 03                	je     c0003ae4 <.done>
c0003ae1:	0f 22 d8             	mov    %eax,%cr3

c0003ae4 <.done>:
c0003ae4:	5d                   	pop    %ebp
c0003ae5:	5f                   	pop    %edi
c0003ae6:	5e                   	pop    %esi
c0003ae7:	5b                   	pop    %ebx
c0003ae8:	c3                   	ret    

c0003ae9 <terminate_task>:
c0003ae9:	8d 35 60 08 01 c0    	lea    0xc0010860,%esi
c0003aef:	89 35 40 08 01 c0    	mov    %esi,0xc0010840
c0003af5:	8b 66 08             	mov    0x8(%esi),%esp
c0003af8:	8b 5e 0c             	mov    0xc(%esi),%ebx
c0003afb:	8b 46 10             	mov    0x10(%esi),%eax
c0003afe:	89 1d 24 09 01 c0    	mov    %ebx,0xc0010924
c0003b04:	0f 20 d9             	mov    %cr3,%ecx
c0003b07:	39 c8                	cmp    %ecx,%eax
c0003b09:	74 d9                	je     c0003ae4 <.done>
c0003b0b:	0f 22 d8             	mov    %eax,%cr3

c0003b0e <.done2>:
c0003b0e:	5d                   	pop    %ebp
c0003b0f:	5f                   	pop    %edi
c0003b10:	5e                   	pop    %esi
c0003b11:	5b                   	pop    %ebx
c0003b12:	c3                   	ret    
c0003b13:	90                   	nop

c0003b14 <enable_paging>:
c0003b14:	55                   	push   %ebp
c0003b15:	89 e5                	mov    %esp,%ebp
c0003b17:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b1a:	0f 22 d8             	mov    %eax,%cr3
c0003b1d:	0f 20 c0             	mov    %cr0,%eax
c0003b20:	0d 01 00 00 80       	or     $0x80000001,%eax
c0003b25:	0f 22 c0             	mov    %eax,%cr0
c0003b28:	89 ec                	mov    %ebp,%esp
c0003b2a:	5d                   	pop    %ebp
c0003b2b:	c3                   	ret    

c0003b2c <set_page_dir>:
c0003b2c:	8b 44 24 04          	mov    0x4(%esp),%eax
c0003b30:	0f 22 d8             	mov    %eax,%cr3
c0003b33:	c3                   	ret    

c0003b34 <get_page_dir>:
c0003b34:	0f 20 d8             	mov    %cr3,%eax
c0003b37:	c3                   	ret    

c0003b38 <refresh_tlb>:
c0003b38:	0f 20 d8             	mov    %cr3,%eax
c0003b3b:	0f 22 d8             	mov    %eax,%cr3
c0003b3e:	c3                   	ret    
c0003b3f:	90                   	nop

c0003b40 <refresh_page>:
c0003b40:	8b 44 24 04          	mov    0x4(%esp),%eax
c0003b44:	0f 01 38             	invlpg (%eax)
c0003b47:	c3                   	ret    
