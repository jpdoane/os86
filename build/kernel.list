
build/kernel:     file format elf32-i386


Disassembly of section .text.boot:

00100000 <_start-0xc>:
  100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fb                   	sti    
  100009:	4f                   	dec    %edi
  10000a:	52                   	push   %edx
  10000b:	e4                   	.byte 0xe4

0010000c <_start>:
  10000c:	fa                   	cli    
  10000d:	3d 02 b0 ad 2b       	cmp    $0x2badb002,%eax
  100012:	0f 85 e4 00 00 00    	jne    1000fc <kpanic>
  100018:	8d 25 00 d0 10 00    	lea    0x10d000,%esp
  10001e:	53                   	push   %ebx
  10001f:	8d 3d 00 a0 10 00    	lea    0x10a000,%edi
  100025:	b8 83 00 00 00       	mov    $0x83,%eax
  10002a:	89 07                	mov    %eax,(%edi)
  10002c:	0f 20 e0             	mov    %cr4,%eax
  10002f:	83 c8 10             	or     $0x10,%eax
  100032:	0f 22 e0             	mov    %eax,%cr4

00100035 <.init_pagedir>:
  100035:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  10003b:	c1 e8 16             	shr    $0x16,%eax
  10003e:	bb 04 00 00 00       	mov    $0x4,%ebx
  100043:	f7 e3                	mul    %ebx
  100045:	8d 3d 00 a0 10 00    	lea    0x10a000,%edi
  10004b:	01 c7                	add    %eax,%edi
  10004d:	8d 05 00 f0 10 00    	lea    0x10f000,%eax
  100053:	83 c8 03             	or     $0x3,%eax
  100056:	b9 ff 00 00 00       	mov    $0xff,%ecx
  10005b:	fc                   	cld    

0010005c <.nextpde>:
  10005c:	ab                   	stos   %eax,%es:(%edi)
  10005d:	05 00 10 00 00       	add    $0x1000,%eax
  100062:	e2 f8                	loop   10005c <.nextpde>

00100064 <.init_pagetables>:
  100064:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  10006a:	c1 e8 16             	shr    $0x16,%eax
  10006d:	bb 04 00 00 00       	mov    $0x4,%ebx
  100072:	f7 e3                	mul    %ebx
  100074:	8d 3d 00 a0 10 00    	lea    0x10a000,%edi
  10007a:	01 c7                	add    %eax,%edi
  10007c:	8d 1d 00 00 00 c0    	lea    0xc0000000,%ebx
  100082:	c1 eb 0c             	shr    $0xc,%ebx
  100085:	8d 0d 00 d0 10 c0    	lea    0xc010d000,%ecx
  10008b:	81 c1 ff 0f 00 00    	add    $0xfff,%ecx
  100091:	c1 e9 0c             	shr    $0xc,%ecx
  100094:	29 d9                	sub    %ebx,%ecx
  100096:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  10009c:	25 00 f0 3f 00       	and    $0x3ff000,%eax
  1000a1:	c1 e8 0c             	shr    $0xc,%eax
  1000a4:	bb 04 00 00 00       	mov    $0x4,%ebx
  1000a9:	f7 e3                	mul    %ebx
  1000ab:	8d 3d 00 f0 10 00    	lea    0x10f000,%edi
  1000b1:	01 c7                	add    %eax,%edi
  1000b3:	8d 05 00 10 10 00    	lea    0x101000,%eax
  1000b9:	83 c8 03             	or     $0x3,%eax

001000bc <.nextpte>:
  1000bc:	ab                   	stos   %eax,%es:(%edi)
  1000bd:	05 00 10 00 00       	add    $0x1000,%eax
  1000c2:	e2 f8                	loop   1000bc <.nextpte>
  1000c4:	8d 35 00 a0 10 00    	lea    0x10a000,%esi
  1000ca:	89 f7                	mov    %esi,%edi
  1000cc:	81 c7 fc 0f 00 00    	add    $0xffc,%edi
  1000d2:	83 ce 03             	or     $0x3,%esi
  1000d5:	89 37                	mov    %esi,(%edi)
  1000d7:	5b                   	pop    %ebx

001000d8 <_enable_paging>:
  1000d8:	8d 05 00 a0 10 00    	lea    0x10a000,%eax
  1000de:	0f 22 d8             	mov    %eax,%cr3
  1000e1:	0f 20 c0             	mov    %cr0,%eax
  1000e4:	0d 00 00 01 80       	or     $0x80010000,%eax
  1000e9:	0f 22 c0             	mov    %eax,%cr0
  1000ec:	8d 25 00 c0 00 c0    	lea    0xc000c000,%esp
  1000f2:	50                   	push   %eax
  1000f3:	50                   	push   %eax
  1000f4:	50                   	push   %eax
  1000f5:	53                   	push   %ebx
  1000f6:	e8 4e 3a f0 bf       	call   c0003b49 <kernel_main>
  1000fb:	fa                   	cli    

001000fc <kpanic>:
  1000fc:	f4                   	hlt    
  1000fd:	eb fd                	jmp    1000fc <kpanic>

Disassembly of section .text:

c0000000 <align_int>:
{
  __asm__ ("xchg %bx, %bx");
}

static inline size_t align_int(size_t len, size_t alignment)
{
c0000000:	55                   	push   %ebp
c0000001:	89 e5                	mov    %esp,%ebp
c0000003:	83 ec 10             	sub    $0x10,%esp
    size_t am = alignment - 1;
c0000006:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000009:	83 e8 01             	sub    $0x1,%eax
c000000c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (((size_t)len + am) & ~am);
c000000f:	8b 55 08             	mov    0x8(%ebp),%edx
c0000012:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0000015:	01 c2                	add    %eax,%edx
c0000017:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000001a:	f7 d0                	not    %eax
c000001c:	21 d0                	and    %edx,%eax
}
c000001e:	c9                   	leave  
c000001f:	c3                   	ret    

c0000020 <test_allocation>:


//allocate memory, return ptr
//check heap usage before and after for consistenty with expected allocation
int test_allocation(size_t sz, void** ptr)
{
c0000020:	55                   	push   %ebp
c0000021:	89 e5                	mov    %esp,%ebp
c0000023:	83 ec 28             	sub    $0x28,%esp
    size_t sz_used;
    size_t sz_free;
    // get initial size of heap
    if(kheap_size(&sz_used, &sz_free)) return -1;
c0000026:	83 ec 08             	sub    $0x8,%esp
c0000029:	8d 45 ec             	lea    -0x14(%ebp),%eax
c000002c:	50                   	push   %eax
c000002d:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0000030:	50                   	push   %eax
c0000031:	e8 83 39 00 00       	call   c00039b9 <kheap_size>
c0000036:	83 c4 10             	add    $0x10,%esp
c0000039:	85 c0                	test   %eax,%eax
c000003b:	74 0a                	je     c0000047 <test_allocation+0x27>
c000003d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000042:	e9 b5 00 00 00       	jmp    c00000fc <test_allocation+0xdc>

    // allocate memory
    *ptr = kmalloc(sz);
c0000047:	83 ec 0c             	sub    $0xc,%esp
c000004a:	ff 75 08             	pushl  0x8(%ebp)
c000004d:	e8 ec 36 00 00       	call   c000373e <kmalloc>
c0000052:	83 c4 10             	add    $0x10,%esp
c0000055:	8b 55 0c             	mov    0xc(%ebp),%edx
c0000058:	89 02                	mov    %eax,(%edx)
    if(! *ptr) return -1;
c000005a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000005d:	8b 00                	mov    (%eax),%eax
c000005f:	85 c0                	test   %eax,%eax
c0000061:	75 0a                	jne    c000006d <test_allocation+0x4d>
c0000063:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000068:	e9 8f 00 00 00       	jmp    c00000fc <test_allocation+0xdc>

    // check heap size
    size_t sz_used_new;
    size_t sz_free_new;
    if(kheap_size(&sz_used_new, &sz_free_new)) return -1;
c000006d:	83 ec 08             	sub    $0x8,%esp
c0000070:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0000073:	50                   	push   %eax
c0000074:	8d 45 e8             	lea    -0x18(%ebp),%eax
c0000077:	50                   	push   %eax
c0000078:	e8 3c 39 00 00       	call   c00039b9 <kheap_size>
c000007d:	83 c4 10             	add    $0x10,%esp
c0000080:	85 c0                	test   %eax,%eax
c0000082:	74 07                	je     c000008b <test_allocation+0x6b>
c0000084:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000089:	eb 71                	jmp    c00000fc <test_allocation+0xdc>
    // memory is allocated in increments of HEAP_BLOCKSIZE_UNITS, with extra HEAP_BLOCKSIZE_UNITS for header
    size_t sz_alloc = HEAP_BLOCKSIZE_UNITS + align_int(sz, HEAP_BLOCKSIZE_UNITS);
c000008b:	83 ec 08             	sub    $0x8,%esp
c000008e:	6a 10                	push   $0x10
c0000090:	ff 75 08             	pushl  0x8(%ebp)
c0000093:	e8 68 ff ff ff       	call   c0000000 <align_int>
c0000098:	83 c4 10             	add    $0x10,%esp
c000009b:	83 c0 10             	add    $0x10,%eax
c000009e:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // allocated memory should have increased by sz_alloc
    if(sz_used_new != sz_used + sz_alloc)
c00000a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00000a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00000a7:	01 c2                	add    %eax,%edx
c00000a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00000ac:	39 c2                	cmp    %eax,%edx
c00000ae:	74 07                	je     c00000b7 <test_allocation+0x97>
        return -1;
c00000b0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00000b5:	eb 45                	jmp    c00000fc <test_allocation+0xdc>

    // total heap size (used + free) should not have decreased
    if(sz_used_new + sz_free_new < sz_used + sz_free)
c00000b7:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00000ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00000bd:	01 c2                	add    %eax,%edx
c00000bf:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c00000c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00000c5:	01 c8                	add    %ecx,%eax
c00000c7:	39 c2                	cmp    %eax,%edx
c00000c9:	73 07                	jae    c00000d2 <test_allocation+0xb2>
        return -1;
c00000cb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00000d0:	eb 2a                	jmp    c00000fc <test_allocation+0xdc>

    // if heap size (used + free) has changed, it must have increased in units of HEAP_INCREMENT 
    if( ( (sz_used_new + sz_free_new) - (sz_used + sz_free) ) % HEAP_INCREMENT != 0)
c00000d2:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00000d5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00000d8:	01 d0                	add    %edx,%eax
c00000da:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c00000dd:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00000e0:	01 ca                	add    %ecx,%edx
c00000e2:	29 d0                	sub    %edx,%eax
c00000e4:	25 ff 0f 00 00       	and    $0xfff,%eax
c00000e9:	c1 e0 02             	shl    $0x2,%eax
c00000ec:	85 c0                	test   %eax,%eax
c00000ee:	74 07                	je     c00000f7 <test_allocation+0xd7>
        return -1;
c00000f0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00000f5:	eb 05                	jmp    c00000fc <test_allocation+0xdc>

    return 0;
c00000f7:	b8 00 00 00 00       	mov    $0x0,%eax

}
c00000fc:	c9                   	leave  
c00000fd:	c3                   	ret    

c00000fe <test_free>:

// free memory and check heap for consistenty with expected free
int test_free(size_t sz, void* ptr)
{
c00000fe:	55                   	push   %ebp
c00000ff:	89 e5                	mov    %esp,%ebp
c0000101:	83 ec 28             	sub    $0x28,%esp
    size_t sz_used;
    size_t sz_free;
    // get initial size of heap
    if(kheap_size(&sz_used, &sz_free)) return -1;
c0000104:	83 ec 08             	sub    $0x8,%esp
c0000107:	8d 45 ec             	lea    -0x14(%ebp),%eax
c000010a:	50                   	push   %eax
c000010b:	8d 45 f0             	lea    -0x10(%ebp),%eax
c000010e:	50                   	push   %eax
c000010f:	e8 a5 38 00 00       	call   c00039b9 <kheap_size>
c0000114:	83 c4 10             	add    $0x10,%esp
c0000117:	85 c0                	test   %eax,%eax
c0000119:	74 07                	je     c0000122 <test_free+0x24>
c000011b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000120:	eb 7e                	jmp    c00001a0 <test_free+0xa2>

    // test free and make sure we have recovered all the memory
    if( kfree(ptr) ) return -1;
c0000122:	83 ec 0c             	sub    $0xc,%esp
c0000125:	ff 75 0c             	pushl  0xc(%ebp)
c0000128:	e8 37 38 00 00       	call   c0003964 <kfree>
c000012d:	83 c4 10             	add    $0x10,%esp
c0000130:	85 c0                	test   %eax,%eax
c0000132:	74 07                	je     c000013b <test_free+0x3d>
c0000134:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000139:	eb 65                	jmp    c00001a0 <test_free+0xa2>
    // memory is allocated in increments of HEAP_BLOCKSIZE_UNITS, with extra HEAP_BLOCKSIZE_UNITS for header
    size_t sz_alloc = HEAP_BLOCKSIZE_UNITS + align_int(sz, HEAP_BLOCKSIZE_UNITS);
c000013b:	83 ec 08             	sub    $0x8,%esp
c000013e:	6a 10                	push   $0x10
c0000140:	ff 75 08             	pushl  0x8(%ebp)
c0000143:	e8 b8 fe ff ff       	call   c0000000 <align_int>
c0000148:	83 c4 10             	add    $0x10,%esp
c000014b:	83 c0 10             	add    $0x10,%eax
c000014e:	89 45 f4             	mov    %eax,-0xc(%ebp)

    size_t sz_used_new;
    size_t sz_free_new;
    if(kheap_size(&sz_used_new, &sz_free_new)) return -1;
c0000151:	83 ec 08             	sub    $0x8,%esp
c0000154:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0000157:	50                   	push   %eax
c0000158:	8d 45 e8             	lea    -0x18(%ebp),%eax
c000015b:	50                   	push   %eax
c000015c:	e8 58 38 00 00       	call   c00039b9 <kheap_size>
c0000161:	83 c4 10             	add    $0x10,%esp
c0000164:	85 c0                	test   %eax,%eax
c0000166:	74 07                	je     c000016f <test_free+0x71>
c0000168:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000016d:	eb 31                	jmp    c00001a0 <test_free+0xa2>

    if(sz_used_new != sz_used - sz_alloc)
c000016f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0000172:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0000175:	89 c2                	mov    %eax,%edx
c0000177:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000017a:	39 c2                	cmp    %eax,%edx
c000017c:	74 07                	je     c0000185 <test_free+0x87>
        return -1;
c000017e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000183:	eb 1b                	jmp    c00001a0 <test_free+0xa2>
    if(sz_free_new != sz_free + sz_alloc)
c0000185:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0000188:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000018b:	01 c2                	add    %eax,%edx
c000018d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0000190:	39 c2                	cmp    %eax,%edx
c0000192:	74 07                	je     c000019b <test_free+0x9d>
        return -1;
c0000194:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000199:	eb 05                	jmp    c00001a0 <test_free+0xa2>

    return 0;
c000019b:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00001a0:	c9                   	leave  
c00001a1:	c3                   	ret    

c00001a2 <test_kmalloc>:

int test_kmalloc()
{
c00001a2:	55                   	push   %ebp
c00001a3:	89 e5                	mov    %esp,%ebp
c00001a5:	83 ec 38             	sub    $0x38,%esp
    if(kmalloc_init()) return -1;
c00001a8:	e8 9e 31 00 00       	call   c000334b <kmalloc_init>
c00001ad:	85 c0                	test   %eax,%eax
c00001af:	74 0a                	je     c00001bb <test_kmalloc+0x19>
c00001b1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00001b6:	e9 78 02 00 00       	jmp    c0000433 <test_kmalloc+0x291>

    //allocate uint32_t
    uint32_t* a;
    if(test_allocation(sizeof(uint32_t), (void**) &a)) return -1;
c00001bb:	83 ec 08             	sub    $0x8,%esp
c00001be:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c00001c1:	50                   	push   %eax
c00001c2:	6a 04                	push   $0x4
c00001c4:	e8 57 fe ff ff       	call   c0000020 <test_allocation>
c00001c9:	83 c4 10             	add    $0x10,%esp
c00001cc:	85 c0                	test   %eax,%eax
c00001ce:	74 0a                	je     c00001da <test_kmalloc+0x38>
c00001d0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00001d5:	e9 59 02 00 00       	jmp    c0000433 <test_kmalloc+0x291>

    // test assignment and read
    *a = 5;
c00001da:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00001dd:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    if(*a != 5) return -1;
c00001e3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00001e6:	8b 00                	mov    (%eax),%eax
c00001e8:	83 f8 05             	cmp    $0x5,%eax
c00001eb:	74 0a                	je     c00001f7 <test_kmalloc+0x55>
c00001ed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00001f2:	e9 3c 02 00 00       	jmp    c0000433 <test_kmalloc+0x291>

    if(test_free(sizeof(uint32_t), a)) return -1;
c00001f7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00001fa:	83 ec 08             	sub    $0x8,%esp
c00001fd:	50                   	push   %eax
c00001fe:	6a 04                	push   $0x4
c0000200:	e8 f9 fe ff ff       	call   c00000fe <test_free>
c0000205:	83 c4 10             	add    $0x10,%esp
c0000208:	85 c0                	test   %eax,%eax
c000020a:	74 0a                	je     c0000216 <test_kmalloc+0x74>
c000020c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000211:	e9 1d 02 00 00       	jmp    c0000433 <test_kmalloc+0x291>

    // try to free again, make sure this FAILS
    if( !kfree(a) ) return -1;
c0000216:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0000219:	83 ec 0c             	sub    $0xc,%esp
c000021c:	50                   	push   %eax
c000021d:	e8 42 37 00 00       	call   c0003964 <kfree>
c0000222:	83 c4 10             	add    $0x10,%esp
c0000225:	85 c0                	test   %eax,%eax
c0000227:	75 0a                	jne    c0000233 <test_kmalloc+0x91>
c0000229:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000022e:	e9 00 02 00 00       	jmp    c0000433 <test_kmalloc+0x291>


    //allocate some larger arrays
    uint32_t *b, *c, *d;
    size_t NB = 1000;
c0000233:	c7 45 e4 e8 03 00 00 	movl   $0x3e8,-0x1c(%ebp)
    size_t NC = 16000;
c000023a:	c7 45 e0 80 3e 00 00 	movl   $0x3e80,-0x20(%ebp)
    size_t ND = 1000;
c0000241:	c7 45 dc e8 03 00 00 	movl   $0x3e8,-0x24(%ebp)
        
    if(test_allocation(sizeof(uint32_t)*NB, (void**)&b)) return -1;
c0000248:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000024b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0000252:	83 ec 08             	sub    $0x8,%esp
c0000255:	8d 45 d0             	lea    -0x30(%ebp),%eax
c0000258:	50                   	push   %eax
c0000259:	52                   	push   %edx
c000025a:	e8 c1 fd ff ff       	call   c0000020 <test_allocation>
c000025f:	83 c4 10             	add    $0x10,%esp
c0000262:	85 c0                	test   %eax,%eax
c0000264:	74 0a                	je     c0000270 <test_kmalloc+0xce>
c0000266:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000026b:	e9 c3 01 00 00       	jmp    c0000433 <test_kmalloc+0x291>
    if(test_allocation(sizeof(uint32_t)*NC, (void**)&c)) return -1;
c0000270:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0000273:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000027a:	83 ec 08             	sub    $0x8,%esp
c000027d:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0000280:	50                   	push   %eax
c0000281:	52                   	push   %edx
c0000282:	e8 99 fd ff ff       	call   c0000020 <test_allocation>
c0000287:	83 c4 10             	add    $0x10,%esp
c000028a:	85 c0                	test   %eax,%eax
c000028c:	74 0a                	je     c0000298 <test_kmalloc+0xf6>
c000028e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000293:	e9 9b 01 00 00       	jmp    c0000433 <test_kmalloc+0x291>
    if(test_allocation(sizeof(uint32_t)*ND, (void**)&d)) return -1;
c0000298:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000029b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c00002a2:	83 ec 08             	sub    $0x8,%esp
c00002a5:	8d 45 c8             	lea    -0x38(%ebp),%eax
c00002a8:	50                   	push   %eax
c00002a9:	52                   	push   %edx
c00002aa:	e8 71 fd ff ff       	call   c0000020 <test_allocation>
c00002af:	83 c4 10             	add    $0x10,%esp
c00002b2:	85 c0                	test   %eax,%eax
c00002b4:	74 0a                	je     c00002c0 <test_kmalloc+0x11e>
c00002b6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00002bb:	e9 73 01 00 00       	jmp    c0000433 <test_kmalloc+0x291>

    //test read and write
    for(size_t nn=0; nn<NB; nn++)
c00002c0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00002c7:	eb 14                	jmp    c00002dd <test_kmalloc+0x13b>
        b[nn] = (uint32_t) nn;
c00002c9:	8b 55 d0             	mov    -0x30(%ebp),%edx
c00002cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00002cf:	c1 e0 02             	shl    $0x2,%eax
c00002d2:	01 c2                	add    %eax,%edx
c00002d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00002d7:	89 02                	mov    %eax,(%edx)
    for(size_t nn=0; nn<NB; nn++)
c00002d9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00002dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00002e0:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c00002e3:	72 e4                	jb     c00002c9 <test_kmalloc+0x127>
    for(size_t nn=0; nn<ND; nn++)
c00002e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00002ec:	eb 14                	jmp    c0000302 <test_kmalloc+0x160>
        d[nn] = (uint32_t) nn;
c00002ee:	8b 55 c8             	mov    -0x38(%ebp),%edx
c00002f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00002f4:	c1 e0 02             	shl    $0x2,%eax
c00002f7:	01 c2                	add    %eax,%edx
c00002f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00002fc:	89 02                	mov    %eax,(%edx)
    for(size_t nn=0; nn<ND; nn++)
c00002fe:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0000302:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0000305:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c0000308:	72 e4                	jb     c00002ee <test_kmalloc+0x14c>
    for(size_t nn=0; nn<NB; nn++)
c000030a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0000311:	eb 20                	jmp    c0000333 <test_kmalloc+0x191>
        if(b[nn] != (uint32_t) nn) return -1;
c0000313:	8b 55 d0             	mov    -0x30(%ebp),%edx
c0000316:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0000319:	c1 e0 02             	shl    $0x2,%eax
c000031c:	01 d0                	add    %edx,%eax
c000031e:	8b 00                	mov    (%eax),%eax
c0000320:	39 45 ec             	cmp    %eax,-0x14(%ebp)
c0000323:	74 0a                	je     c000032f <test_kmalloc+0x18d>
c0000325:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000032a:	e9 04 01 00 00       	jmp    c0000433 <test_kmalloc+0x291>
    for(size_t nn=0; nn<NB; nn++)
c000032f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0000333:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0000336:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0000339:	72 d8                	jb     c0000313 <test_kmalloc+0x171>
    for(size_t nn=0; nn<ND; nn++)
c000033b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c0000342:	eb 20                	jmp    c0000364 <test_kmalloc+0x1c2>
        if(d[nn] != (uint32_t) nn) return -1;
c0000344:	8b 55 c8             	mov    -0x38(%ebp),%edx
c0000347:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000034a:	c1 e0 02             	shl    $0x2,%eax
c000034d:	01 d0                	add    %edx,%eax
c000034f:	8b 00                	mov    (%eax),%eax
c0000351:	39 45 e8             	cmp    %eax,-0x18(%ebp)
c0000354:	74 0a                	je     c0000360 <test_kmalloc+0x1be>
c0000356:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000035b:	e9 d3 00 00 00       	jmp    c0000433 <test_kmalloc+0x291>
    for(size_t nn=0; nn<ND; nn++)
c0000360:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c0000364:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000367:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c000036a:	72 d8                	jb     c0000344 <test_kmalloc+0x1a2>


    // test aligned allocation
    uint32_t* e = kmalloc_aligned(sizeof(uint32_t), 4096); // align to page
c000036c:	83 ec 08             	sub    $0x8,%esp
c000036f:	68 00 10 00 00       	push   $0x1000
c0000374:	6a 04                	push   $0x4
c0000376:	e8 90 34 00 00       	call   c000380b <kmalloc_aligned>
c000037b:	83 c4 10             	add    $0x10,%esp
c000037e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if(!e) return -1;
c0000381:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c0000385:	75 0a                	jne    c0000391 <test_kmalloc+0x1ef>
c0000387:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000038c:	e9 a2 00 00 00       	jmp    c0000433 <test_kmalloc+0x291>
    if( (size_t) e % 4096 ) return -1;
c0000391:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0000394:	25 ff 0f 00 00       	and    $0xfff,%eax
c0000399:	85 c0                	test   %eax,%eax
c000039b:	74 0a                	je     c00003a7 <test_kmalloc+0x205>
c000039d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00003a2:	e9 8c 00 00 00       	jmp    c0000433 <test_kmalloc+0x291>
    if((*e = 128) != 128) return -1;
c00003a7:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00003aa:	c7 00 80 00 00 00    	movl   $0x80,(%eax)

    if(test_free(sizeof(uint32_t)*NB, b)) return -1;
c00003b0:	8b 45 d0             	mov    -0x30(%ebp),%eax
c00003b3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00003b6:	c1 e2 02             	shl    $0x2,%edx
c00003b9:	83 ec 08             	sub    $0x8,%esp
c00003bc:	50                   	push   %eax
c00003bd:	52                   	push   %edx
c00003be:	e8 3b fd ff ff       	call   c00000fe <test_free>
c00003c3:	83 c4 10             	add    $0x10,%esp
c00003c6:	85 c0                	test   %eax,%eax
c00003c8:	74 07                	je     c00003d1 <test_kmalloc+0x22f>
c00003ca:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00003cf:	eb 62                	jmp    c0000433 <test_kmalloc+0x291>
    if(test_free(sizeof(uint32_t)*NC, c)) return -1;
c00003d1:	8b 45 cc             	mov    -0x34(%ebp),%eax
c00003d4:	8b 55 e0             	mov    -0x20(%ebp),%edx
c00003d7:	c1 e2 02             	shl    $0x2,%edx
c00003da:	83 ec 08             	sub    $0x8,%esp
c00003dd:	50                   	push   %eax
c00003de:	52                   	push   %edx
c00003df:	e8 1a fd ff ff       	call   c00000fe <test_free>
c00003e4:	83 c4 10             	add    $0x10,%esp
c00003e7:	85 c0                	test   %eax,%eax
c00003e9:	74 07                	je     c00003f2 <test_kmalloc+0x250>
c00003eb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00003f0:	eb 41                	jmp    c0000433 <test_kmalloc+0x291>
    if(test_free(sizeof(uint32_t)*ND, d)) return -1;
c00003f2:	8b 45 c8             	mov    -0x38(%ebp),%eax
c00003f5:	8b 55 dc             	mov    -0x24(%ebp),%edx
c00003f8:	c1 e2 02             	shl    $0x2,%edx
c00003fb:	83 ec 08             	sub    $0x8,%esp
c00003fe:	50                   	push   %eax
c00003ff:	52                   	push   %edx
c0000400:	e8 f9 fc ff ff       	call   c00000fe <test_free>
c0000405:	83 c4 10             	add    $0x10,%esp
c0000408:	85 c0                	test   %eax,%eax
c000040a:	74 07                	je     c0000413 <test_kmalloc+0x271>
c000040c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000411:	eb 20                	jmp    c0000433 <test_kmalloc+0x291>
    if(test_free(sizeof(uint32_t), e)) return -1;
c0000413:	83 ec 08             	sub    $0x8,%esp
c0000416:	ff 75 d8             	pushl  -0x28(%ebp)
c0000419:	6a 04                	push   $0x4
c000041b:	e8 de fc ff ff       	call   c00000fe <test_free>
c0000420:	83 c4 10             	add    $0x10,%esp
c0000423:	85 c0                	test   %eax,%eax
c0000425:	74 07                	je     c000042e <test_kmalloc+0x28c>
c0000427:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000042c:	eb 05                	jmp    c0000433 <test_kmalloc+0x291>

    return 0;
c000042e:	b8 00 00 00 00       	mov    $0x0,%eax
c0000433:	c9                   	leave  
c0000434:	c3                   	ret    

c0000435 <syscall>:
#include "terminal.h"
#include "kprintf.h"

void syscall()
{
c0000435:	55                   	push   %ebp
c0000436:	89 e5                	mov    %esp,%ebp
}
c0000438:	90                   	nop
c0000439:	5d                   	pop    %ebp
c000043a:	c3                   	ret    

c000043b <vga_entry_color>:
	VGA_COLOR_LIGHT_BROWN = 14,
	VGA_COLOR_WHITE = 15,
};
 
static inline uint8_t vga_entry_color(enum vga_color fg, enum vga_color bg) 
{
c000043b:	55                   	push   %ebp
c000043c:	89 e5                	mov    %esp,%ebp
	return fg | bg << 4;
c000043e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000441:	c1 e0 04             	shl    $0x4,%eax
c0000444:	89 c2                	mov    %eax,%edx
c0000446:	8b 45 08             	mov    0x8(%ebp),%eax
c0000449:	09 d0                	or     %edx,%eax
}
c000044b:	5d                   	pop    %ebp
c000044c:	c3                   	ret    

c000044d <vga_entry>:
 
static inline uint16_t vga_entry(unsigned char uc, uint8_t color) 
{
c000044d:	55                   	push   %ebp
c000044e:	89 e5                	mov    %esp,%ebp
c0000450:	83 ec 08             	sub    $0x8,%esp
c0000453:	8b 55 08             	mov    0x8(%ebp),%edx
c0000456:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000459:	88 55 fc             	mov    %dl,-0x4(%ebp)
c000045c:	88 45 f8             	mov    %al,-0x8(%ebp)
	return (uint16_t) uc | (uint16_t) color << 8;
c000045f:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c0000463:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0000467:	c1 e0 08             	shl    $0x8,%eax
c000046a:	09 d0                	or     %edx,%eax
}
c000046c:	c9                   	leave  
c000046d:	c3                   	ret    

c000046e <outb>:
  return _v;
}

static inline void
outb (unsigned char __value, unsigned short int __port)
{
c000046e:	55                   	push   %ebp
c000046f:	89 e5                	mov    %esp,%ebp
c0000471:	83 ec 08             	sub    $0x8,%esp
c0000474:	8b 55 08             	mov    0x8(%ebp),%edx
c0000477:	8b 45 0c             	mov    0xc(%ebp),%eax
c000047a:	88 55 fc             	mov    %dl,-0x4(%ebp)
c000047d:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
c0000481:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0000485:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
c0000489:	ee                   	out    %al,(%dx)
}
c000048a:	90                   	nop
c000048b:	c9                   	leave  
c000048c:	c3                   	ret    

c000048d <terminal_init>:
#include "io.h"

struct terminal stdout;

void terminal_init(struct terminal* term) 
{
c000048d:	55                   	push   %ebp
c000048e:	89 e5                	mov    %esp,%ebp
c0000490:	53                   	push   %ebx
c0000491:	83 ec 14             	sub    $0x14,%esp
	//map vga buffer
	map_hardware_buffer((void*) VGA_BUFFER, (void*) VGA_BUFFER_PHYS, VGA_BUFFER_SIZE, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c0000494:	6a 06                	push   $0x6
c0000496:	68 00 70 00 00       	push   $0x7000
c000049b:	68 00 80 0b 00       	push   $0xb8000
c00004a0:	68 00 00 00 ff       	push   $0xff000000
c00004a5:	e8 73 2a 00 00       	call   c0002f1d <map_hardware_buffer>
c00004aa:	83 c4 10             	add    $0x10,%esp

	term->row = 0;
c00004ad:	8b 45 08             	mov    0x8(%ebp),%eax
c00004b0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	term->column = 0;
c00004b6:	8b 45 08             	mov    0x8(%ebp),%eax
c00004b9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	term->color = vga_entry_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
c00004c0:	83 ec 08             	sub    $0x8,%esp
c00004c3:	6a 00                	push   $0x0
c00004c5:	6a 07                	push   $0x7
c00004c7:	e8 6f ff ff ff       	call   c000043b <vga_entry_color>
c00004cc:	83 c4 10             	add    $0x10,%esp
c00004cf:	8b 55 08             	mov    0x8(%ebp),%edx
c00004d2:	88 42 08             	mov    %al,0x8(%edx)
	term->buffer = (uint16_t*) VGA_BUFFER;
c00004d5:	8b 45 08             	mov    0x8(%ebp),%eax
c00004d8:	c7 40 0c 00 00 00 ff 	movl   $0xff000000,0xc(%eax)
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
c00004df:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00004e6:	eb 57                	jmp    c000053f <terminal_init+0xb2>
		for (size_t x = 0; x < VGA_WIDTH; x++) {
c00004e8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00004ef:	eb 44                	jmp    c0000535 <terminal_init+0xa8>
			const size_t index = y * VGA_WIDTH + x;
c00004f1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00004f4:	89 d0                	mov    %edx,%eax
c00004f6:	c1 e0 02             	shl    $0x2,%eax
c00004f9:	01 d0                	add    %edx,%eax
c00004fb:	c1 e0 04             	shl    $0x4,%eax
c00004fe:	89 c2                	mov    %eax,%edx
c0000500:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0000503:	01 d0                	add    %edx,%eax
c0000505:	89 45 ec             	mov    %eax,-0x14(%ebp)
			term->buffer[index] = vga_entry(' ', term->color);
c0000508:	8b 45 08             	mov    0x8(%ebp),%eax
c000050b:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c000050f:	0f b6 c0             	movzbl %al,%eax
c0000512:	8b 55 08             	mov    0x8(%ebp),%edx
c0000515:	8b 4a 0c             	mov    0xc(%edx),%ecx
c0000518:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000051b:	01 d2                	add    %edx,%edx
c000051d:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
c0000520:	83 ec 08             	sub    $0x8,%esp
c0000523:	50                   	push   %eax
c0000524:	6a 20                	push   $0x20
c0000526:	e8 22 ff ff ff       	call   c000044d <vga_entry>
c000052b:	83 c4 10             	add    $0x10,%esp
c000052e:	66 89 03             	mov    %ax,(%ebx)
		for (size_t x = 0; x < VGA_WIDTH; x++) {
c0000531:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0000535:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
c0000539:	76 b6                	jbe    c00004f1 <terminal_init+0x64>
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
c000053b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c000053f:	83 7d f4 18          	cmpl   $0x18,-0xc(%ebp)
c0000543:	76 a3                	jbe    c00004e8 <terminal_init+0x5b>
		}
	}

	//disable cursor
	outb(0x0A, 0x3D4);
c0000545:	83 ec 08             	sub    $0x8,%esp
c0000548:	68 d4 03 00 00       	push   $0x3d4
c000054d:	6a 0a                	push   $0xa
c000054f:	e8 1a ff ff ff       	call   c000046e <outb>
c0000554:	83 c4 10             	add    $0x10,%esp
	outb(0x20, 0x3D5);
c0000557:	83 ec 08             	sub    $0x8,%esp
c000055a:	68 d5 03 00 00       	push   $0x3d5
c000055f:	6a 20                	push   $0x20
c0000561:	e8 08 ff ff ff       	call   c000046e <outb>
c0000566:	83 c4 10             	add    $0x10,%esp
	// outb(0x0A, 0x3D4);
	// outb((inb(0x3D5) & 0xC0) | cursor_start, 0x3D5);
 
	// outb(0x0B, 0x3D4);
	// outb((inb(0x3D5) & 0xE0) | cursor_end, 0x3D5);
}
c0000569:	90                   	nop
c000056a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000056d:	c9                   	leave  
c000056e:	c3                   	ret    

c000056f <terminal_setcolor>:
 
void terminal_setcolor(struct terminal* term, uint8_t color) 
{
c000056f:	55                   	push   %ebp
c0000570:	89 e5                	mov    %esp,%ebp
c0000572:	83 ec 04             	sub    $0x4,%esp
c0000575:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000578:	88 45 fc             	mov    %al,-0x4(%ebp)
	term->color = color;
c000057b:	8b 45 08             	mov    0x8(%ebp),%eax
c000057e:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c0000582:	88 50 08             	mov    %dl,0x8(%eax)
}
c0000585:	90                   	nop
c0000586:	c9                   	leave  
c0000587:	c3                   	ret    

c0000588 <terminal_getcolor>:

uint8_t terminal_getcolor(struct terminal* term) 
{
c0000588:	55                   	push   %ebp
c0000589:	89 e5                	mov    %esp,%ebp
	return term->color;
c000058b:	8b 45 08             	mov    0x8(%ebp),%eax
c000058e:	0f b6 40 08          	movzbl 0x8(%eax),%eax
}
c0000592:	5d                   	pop    %ebp
c0000593:	c3                   	ret    

c0000594 <terminal_putentryat>:
 
void terminal_putentryat(struct terminal* term, char c, uint8_t color, size_t x, size_t y) 
{
c0000594:	55                   	push   %ebp
c0000595:	89 e5                	mov    %esp,%ebp
c0000597:	53                   	push   %ebx
c0000598:	83 ec 18             	sub    $0x18,%esp
c000059b:	8b 55 0c             	mov    0xc(%ebp),%edx
c000059e:	8b 45 10             	mov    0x10(%ebp),%eax
c00005a1:	88 55 e8             	mov    %dl,-0x18(%ebp)
c00005a4:	88 45 e4             	mov    %al,-0x1c(%ebp)
	const size_t index = y * VGA_WIDTH + x;
c00005a7:	8b 55 18             	mov    0x18(%ebp),%edx
c00005aa:	89 d0                	mov    %edx,%eax
c00005ac:	c1 e0 02             	shl    $0x2,%eax
c00005af:	01 d0                	add    %edx,%eax
c00005b1:	c1 e0 04             	shl    $0x4,%eax
c00005b4:	89 c2                	mov    %eax,%edx
c00005b6:	8b 45 14             	mov    0x14(%ebp),%eax
c00005b9:	01 d0                	add    %edx,%eax
c00005bb:	89 45 f8             	mov    %eax,-0x8(%ebp)
	term->buffer[index] = vga_entry(c, color);
c00005be:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c00005c2:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c00005c6:	0f b6 c0             	movzbl %al,%eax
c00005c9:	8b 4d 08             	mov    0x8(%ebp),%ecx
c00005cc:	8b 59 0c             	mov    0xc(%ecx),%ebx
c00005cf:	8b 4d f8             	mov    -0x8(%ebp),%ecx
c00005d2:	01 c9                	add    %ecx,%ecx
c00005d4:	01 cb                	add    %ecx,%ebx
c00005d6:	52                   	push   %edx
c00005d7:	50                   	push   %eax
c00005d8:	e8 70 fe ff ff       	call   c000044d <vga_entry>
c00005dd:	83 c4 08             	add    $0x8,%esp
c00005e0:	66 89 03             	mov    %ax,(%ebx)
	// terminal_movecursor(term, x, y);
}
c00005e3:	90                   	nop
c00005e4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00005e7:	c9                   	leave  
c00005e8:	c3                   	ret    

c00005e9 <terminal_movecursor>:

void terminal_movecursor(struct terminal* term, size_t x, size_t y)
{
c00005e9:	55                   	push   %ebp
c00005ea:	89 e5                	mov    %esp,%ebp
c00005ec:	83 ec 10             	sub    $0x10,%esp
	(void) term; //we are directly manipulating curser, so were arean't using the term struct

	uint16_t pos = y * VGA_WIDTH + x;
c00005ef:	8b 45 10             	mov    0x10(%ebp),%eax
c00005f2:	89 c2                	mov    %eax,%edx
c00005f4:	89 d0                	mov    %edx,%eax
c00005f6:	c1 e0 02             	shl    $0x2,%eax
c00005f9:	01 d0                	add    %edx,%eax
c00005fb:	c1 e0 04             	shl    $0x4,%eax
c00005fe:	89 c2                	mov    %eax,%edx
c0000600:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000603:	01 d0                	add    %edx,%eax
c0000605:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

	outb(0x0F, 0x3D4);
c0000609:	68 d4 03 00 00       	push   $0x3d4
c000060e:	6a 0f                	push   $0xf
c0000610:	e8 59 fe ff ff       	call   c000046e <outb>
c0000615:	83 c4 08             	add    $0x8,%esp
	outb((uint8_t) (pos & 0xFF), 0x3D5);
c0000618:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c000061c:	0f b6 c0             	movzbl %al,%eax
c000061f:	68 d5 03 00 00       	push   $0x3d5
c0000624:	50                   	push   %eax
c0000625:	e8 44 fe ff ff       	call   c000046e <outb>
c000062a:	83 c4 08             	add    $0x8,%esp
	outb(0x0E, 0x3D4);
c000062d:	68 d4 03 00 00       	push   $0x3d4
c0000632:	6a 0e                	push   $0xe
c0000634:	e8 35 fe ff ff       	call   c000046e <outb>
c0000639:	83 c4 08             	add    $0x8,%esp
	outb((uint8_t) ((pos >> 8) & 0xFF), 0x3D5);
c000063c:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c0000640:	66 c1 e8 08          	shr    $0x8,%ax
c0000644:	0f b6 c0             	movzbl %al,%eax
c0000647:	68 d5 03 00 00       	push   $0x3d5
c000064c:	50                   	push   %eax
c000064d:	e8 1c fe ff ff       	call   c000046e <outb>
c0000652:	83 c4 08             	add    $0x8,%esp
}
c0000655:	90                   	nop
c0000656:	c9                   	leave  
c0000657:	c3                   	ret    

c0000658 <terminal_putchar>:

 
void terminal_putchar(struct terminal* term, char c) 
{
c0000658:	55                   	push   %ebp
c0000659:	89 e5                	mov    %esp,%ebp
c000065b:	53                   	push   %ebx
c000065c:	83 ec 14             	sub    $0x14,%esp
c000065f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000662:	88 45 f4             	mov    %al,-0xc(%ebp)
	if(c == '\n')
c0000665:	80 7d f4 0a          	cmpb   $0xa,-0xc(%ebp)
c0000669:	75 10                	jne    c000067b <terminal_putchar+0x23>
	{
		terminal_newline(term);
c000066b:	83 ec 0c             	sub    $0xc,%esp
c000066e:	ff 75 08             	pushl  0x8(%ebp)
c0000671:	e8 95 00 00 00       	call   c000070b <terminal_newline>
c0000676:	83 c4 10             	add    $0x10,%esp
		return;
c0000679:	eb 53                	jmp    c00006ce <terminal_putchar+0x76>
	}

	terminal_putentryat(term, c, term->color, term->column, term->row);
c000067b:	8b 45 08             	mov    0x8(%ebp),%eax
c000067e:	8b 18                	mov    (%eax),%ebx
c0000680:	8b 45 08             	mov    0x8(%ebp),%eax
c0000683:	8b 48 04             	mov    0x4(%eax),%ecx
c0000686:	8b 45 08             	mov    0x8(%ebp),%eax
c0000689:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c000068d:	0f b6 d0             	movzbl %al,%edx
c0000690:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c0000694:	83 ec 0c             	sub    $0xc,%esp
c0000697:	53                   	push   %ebx
c0000698:	51                   	push   %ecx
c0000699:	52                   	push   %edx
c000069a:	50                   	push   %eax
c000069b:	ff 75 08             	pushl  0x8(%ebp)
c000069e:	e8 f1 fe ff ff       	call   c0000594 <terminal_putentryat>
c00006a3:	83 c4 20             	add    $0x20,%esp
	if (++term->column == VGA_WIDTH)
c00006a6:	8b 45 08             	mov    0x8(%ebp),%eax
c00006a9:	8b 40 04             	mov    0x4(%eax),%eax
c00006ac:	8d 50 01             	lea    0x1(%eax),%edx
c00006af:	8b 45 08             	mov    0x8(%ebp),%eax
c00006b2:	89 50 04             	mov    %edx,0x4(%eax)
c00006b5:	8b 45 08             	mov    0x8(%ebp),%eax
c00006b8:	8b 40 04             	mov    0x4(%eax),%eax
c00006bb:	83 f8 50             	cmp    $0x50,%eax
c00006be:	75 0e                	jne    c00006ce <terminal_putchar+0x76>
		terminal_newline(term);
c00006c0:	83 ec 0c             	sub    $0xc,%esp
c00006c3:	ff 75 08             	pushl  0x8(%ebp)
c00006c6:	e8 40 00 00 00       	call   c000070b <terminal_newline>
c00006cb:	83 c4 10             	add    $0x10,%esp
}
c00006ce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00006d1:	c9                   	leave  
c00006d2:	c3                   	ret    

c00006d3 <terminal_putcharn>:

void terminal_putcharn(struct terminal* term, char c, size_t repeat) 
{
c00006d3:	55                   	push   %ebp
c00006d4:	89 e5                	mov    %esp,%ebp
c00006d6:	83 ec 28             	sub    $0x28,%esp
c00006d9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00006dc:	88 45 e4             	mov    %al,-0x1c(%ebp)
	for (size_t i = 0; i < repeat; i++)
c00006df:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00006e6:	eb 17                	jmp    c00006ff <terminal_putcharn+0x2c>
		terminal_putchar(term, c);
c00006e8:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
c00006ec:	83 ec 08             	sub    $0x8,%esp
c00006ef:	50                   	push   %eax
c00006f0:	ff 75 08             	pushl  0x8(%ebp)
c00006f3:	e8 60 ff ff ff       	call   c0000658 <terminal_putchar>
c00006f8:	83 c4 10             	add    $0x10,%esp
	for (size_t i = 0; i < repeat; i++)
c00006fb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00006ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000702:	3b 45 10             	cmp    0x10(%ebp),%eax
c0000705:	72 e1                	jb     c00006e8 <terminal_putcharn+0x15>
}
c0000707:	90                   	nop
c0000708:	90                   	nop
c0000709:	c9                   	leave  
c000070a:	c3                   	ret    

c000070b <terminal_newline>:

void terminal_newline(struct terminal* term)
{
c000070b:	55                   	push   %ebp
c000070c:	89 e5                	mov    %esp,%ebp
c000070e:	83 ec 08             	sub    $0x8,%esp
    term->column = 0;
c0000711:	8b 45 08             	mov    0x8(%ebp),%eax
c0000714:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if (++term->row == VGA_HEIGHT)
c000071b:	8b 45 08             	mov    0x8(%ebp),%eax
c000071e:	8b 00                	mov    (%eax),%eax
c0000720:	8d 50 01             	lea    0x1(%eax),%edx
c0000723:	8b 45 08             	mov    0x8(%ebp),%eax
c0000726:	89 10                	mov    %edx,(%eax)
c0000728:	8b 45 08             	mov    0x8(%ebp),%eax
c000072b:	8b 00                	mov    (%eax),%eax
c000072d:	83 f8 19             	cmp    $0x19,%eax
c0000730:	75 0e                	jne    c0000740 <terminal_newline+0x35>
        terminal_scrollline(term);
c0000732:	83 ec 0c             	sub    $0xc,%esp
c0000735:	ff 75 08             	pushl  0x8(%ebp)
c0000738:	e8 06 00 00 00       	call   c0000743 <terminal_scrollline>
c000073d:	83 c4 10             	add    $0x10,%esp
}
c0000740:	90                   	nop
c0000741:	c9                   	leave  
c0000742:	c3                   	ret    

c0000743 <terminal_scrollline>:

void terminal_scrollline(struct terminal* term)
{
c0000743:	55                   	push   %ebp
c0000744:	89 e5                	mov    %esp,%ebp
c0000746:	83 ec 08             	sub    $0x8,%esp
	// copy rows 2 though N to rows 1 through N-1
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c0000749:	8b 45 08             	mov    0x8(%ebp),%eax
c000074c:	8b 40 0c             	mov    0xc(%eax),%eax
c000074f:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c0000755:	8b 45 08             	mov    0x8(%ebp),%eax
c0000758:	8b 40 0c             	mov    0xc(%eax),%eax
c000075b:	83 ec 04             	sub    $0x4,%esp
c000075e:	68 00 0f 00 00       	push   $0xf00
c0000763:	52                   	push   %edx
c0000764:	50                   	push   %eax
c0000765:	e8 d5 0f 00 00       	call   c000173f <memcpy>
c000076a:	83 c4 10             	add    $0x10,%esp
	// clear last row
	term->row = VGA_HEIGHT-1;
c000076d:	8b 45 08             	mov    0x8(%ebp),%eax
c0000770:	c7 00 18 00 00 00    	movl   $0x18,(%eax)
	terminal_clearline(term);
c0000776:	83 ec 0c             	sub    $0xc,%esp
c0000779:	ff 75 08             	pushl  0x8(%ebp)
c000077c:	e8 06 00 00 00       	call   c0000787 <terminal_clearline>
c0000781:	83 c4 10             	add    $0x10,%esp
}
c0000784:	90                   	nop
c0000785:	c9                   	leave  
c0000786:	c3                   	ret    

c0000787 <terminal_clearline>:

void terminal_clearline(struct terminal* term)
{
c0000787:	55                   	push   %ebp
c0000788:	89 e5                	mov    %esp,%ebp
c000078a:	53                   	push   %ebx
c000078b:	83 ec 10             	sub    $0x10,%esp
	size_t row_start = term->row * VGA_WIDTH;
c000078e:	8b 45 08             	mov    0x8(%ebp),%eax
c0000791:	8b 10                	mov    (%eax),%edx
c0000793:	89 d0                	mov    %edx,%eax
c0000795:	c1 e0 02             	shl    $0x2,%eax
c0000798:	01 d0                	add    %edx,%eax
c000079a:	c1 e0 04             	shl    $0x4,%eax
c000079d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c00007a0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c00007a7:	eb 2f                	jmp    c00007d8 <terminal_clearline+0x51>
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c00007a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00007ac:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c00007b0:	0f b6 c0             	movzbl %al,%eax
c00007b3:	8b 55 08             	mov    0x8(%ebp),%edx
c00007b6:	8b 4a 0c             	mov    0xc(%edx),%ecx
c00007b9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c00007bc:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00007bf:	01 da                	add    %ebx,%edx
c00007c1:	01 d2                	add    %edx,%edx
c00007c3:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
c00007c6:	50                   	push   %eax
c00007c7:	6a 20                	push   $0x20
c00007c9:	e8 7f fc ff ff       	call   c000044d <vga_entry>
c00007ce:	83 c4 08             	add    $0x8,%esp
c00007d1:	66 89 03             	mov    %ax,(%ebx)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c00007d4:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c00007d8:	83 7d f8 4f          	cmpl   $0x4f,-0x8(%ebp)
c00007dc:	76 cb                	jbe    c00007a9 <terminal_clearline+0x22>

}
c00007de:	90                   	nop
c00007df:	90                   	nop
c00007e0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00007e3:	c9                   	leave  
c00007e4:	c3                   	ret    

c00007e5 <terminal_write>:


void terminal_write(struct terminal* term, const char* data, size_t size) 
{
c00007e5:	55                   	push   %ebp
c00007e6:	89 e5                	mov    %esp,%ebp
c00007e8:	83 ec 18             	sub    $0x18,%esp
	for (size_t i = 0; i < size; i++)
c00007eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00007f2:	eb 21                	jmp    c0000815 <terminal_write+0x30>
		terminal_putchar(term, data[i]);
c00007f4:	8b 55 0c             	mov    0xc(%ebp),%edx
c00007f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00007fa:	01 d0                	add    %edx,%eax
c00007fc:	0f b6 00             	movzbl (%eax),%eax
c00007ff:	0f be c0             	movsbl %al,%eax
c0000802:	83 ec 08             	sub    $0x8,%esp
c0000805:	50                   	push   %eax
c0000806:	ff 75 08             	pushl  0x8(%ebp)
c0000809:	e8 4a fe ff ff       	call   c0000658 <terminal_putchar>
c000080e:	83 c4 10             	add    $0x10,%esp
	for (size_t i = 0; i < size; i++)
c0000811:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0000815:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000818:	3b 45 10             	cmp    0x10(%ebp),%eax
c000081b:	72 d7                	jb     c00007f4 <terminal_write+0xf>
}
c000081d:	90                   	nop
c000081e:	90                   	nop
c000081f:	c9                   	leave  
c0000820:	c3                   	ret    

c0000821 <terminal_writestring>:
 
void terminal_writestring(struct terminal* term, const char* data) 
{
c0000821:	55                   	push   %ebp
c0000822:	89 e5                	mov    %esp,%ebp
c0000824:	83 ec 08             	sub    $0x8,%esp
	terminal_write(term, data, strlen(data));
c0000827:	83 ec 0c             	sub    $0xc,%esp
c000082a:	ff 75 0c             	pushl  0xc(%ebp)
c000082d:	e8 e6 0e 00 00       	call   c0001718 <strlen>
c0000832:	83 c4 10             	add    $0x10,%esp
c0000835:	83 ec 04             	sub    $0x4,%esp
c0000838:	50                   	push   %eax
c0000839:	ff 75 0c             	pushl  0xc(%ebp)
c000083c:	ff 75 08             	pushl  0x8(%ebp)
c000083f:	e8 a1 ff ff ff       	call   c00007e5 <terminal_write>
c0000844:	83 c4 10             	add    $0x10,%esp
}
c0000847:	90                   	nop
c0000848:	c9                   	leave  
c0000849:	c3                   	ret    

c000084a <kprint>:
unsigned int numdigits_uint(unsigned int value, unsigned int base);

int format_uint(unsigned int value, char* str, unsigned int base, int precision, int cap);

int kprint(const char* str)
{
c000084a:	55                   	push   %ebp
c000084b:	89 e5                	mov    %esp,%ebp
c000084d:	83 ec 08             	sub    $0x8,%esp
    terminal_writestring(&stdout, str);
c0000850:	83 ec 08             	sub    $0x8,%esp
c0000853:	ff 75 08             	pushl  0x8(%ebp)
c0000856:	68 00 70 00 c0       	push   $0xc0007000
c000085b:	e8 c1 ff ff ff       	call   c0000821 <terminal_writestring>
c0000860:	83 c4 10             	add    $0x10,%esp
    return strlen(str);
c0000863:	83 ec 0c             	sub    $0xc,%esp
c0000866:	ff 75 08             	pushl  0x8(%ebp)
c0000869:	e8 aa 0e 00 00       	call   c0001718 <strlen>
c000086e:	83 c4 10             	add    $0x10,%esp
}
c0000871:	c9                   	leave  
c0000872:	c3                   	ret    

c0000873 <kprintn>:

int kprintn(const char* str, size_t len)
{
c0000873:	55                   	push   %ebp
c0000874:	89 e5                	mov    %esp,%ebp
c0000876:	83 ec 08             	sub    $0x8,%esp
    terminal_write(&stdout, str, len);
c0000879:	83 ec 04             	sub    $0x4,%esp
c000087c:	ff 75 0c             	pushl  0xc(%ebp)
c000087f:	ff 75 08             	pushl  0x8(%ebp)
c0000882:	68 00 70 00 c0       	push   $0xc0007000
c0000887:	e8 59 ff ff ff       	call   c00007e5 <terminal_write>
c000088c:	83 c4 10             	add    $0x10,%esp
    return len;
c000088f:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c0000892:	c9                   	leave  
c0000893:	c3                   	ret    

c0000894 <kprint_char>:

int kprint_char(char c)
{
c0000894:	55                   	push   %ebp
c0000895:	89 e5                	mov    %esp,%ebp
c0000897:	83 ec 18             	sub    $0x18,%esp
c000089a:	8b 45 08             	mov    0x8(%ebp),%eax
c000089d:	88 45 f4             	mov    %al,-0xc(%ebp)
    terminal_putchar(&stdout, c); 
c00008a0:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c00008a4:	83 ec 08             	sub    $0x8,%esp
c00008a7:	50                   	push   %eax
c00008a8:	68 00 70 00 c0       	push   $0xc0007000
c00008ad:	e8 a6 fd ff ff       	call   c0000658 <terminal_putchar>
c00008b2:	83 c4 10             	add    $0x10,%esp
    return 1;
c00008b5:	b8 01 00 00 00       	mov    $0x1,%eax
}
c00008ba:	c9                   	leave  
c00008bb:	c3                   	ret    

c00008bc <kprintn_char>:

int kprintn_char(char c, size_t rpt)
{
c00008bc:	55                   	push   %ebp
c00008bd:	89 e5                	mov    %esp,%ebp
c00008bf:	83 ec 18             	sub    $0x18,%esp
c00008c2:	8b 45 08             	mov    0x8(%ebp),%eax
c00008c5:	88 45 f4             	mov    %al,-0xc(%ebp)
    terminal_putcharn(&stdout, c, rpt); 
c00008c8:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c00008cc:	83 ec 04             	sub    $0x4,%esp
c00008cf:	ff 75 0c             	pushl  0xc(%ebp)
c00008d2:	50                   	push   %eax
c00008d3:	68 00 70 00 c0       	push   $0xc0007000
c00008d8:	e8 f6 fd ff ff       	call   c00006d3 <terminal_putcharn>
c00008dd:	83 c4 10             	add    $0x10,%esp
    return rpt;
c00008e0:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c00008e3:	c9                   	leave  
c00008e4:	c3                   	ret    

c00008e5 <kprintf>:


int kprintf(const char* format, ...)
{
c00008e5:	55                   	push   %ebp
c00008e6:	89 e5                	mov    %esp,%ebp
c00008e8:	81 ec a8 02 00 00    	sub    $0x2a8,%esp
    /* initialize valist for num number of arguments */
    va_list valist;
    va_start(valist, format);
c00008ee:	8d 45 0c             	lea    0xc(%ebp),%eax
c00008f1:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)

    // parse format into str
    const char* f = format;
c00008f7:	8b 45 08             	mov    0x8(%ebp),%eax
c00008fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int nchar = 0;
c00008fd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    while(f[0] != 0)
c0000904:	e9 9e 0a 00 00       	jmp    c00013a7 <kprintf+0xac2>
    {
        if(f[0] == '\\' && f[1] == '%')
c0000909:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000090c:	0f b6 00             	movzbl (%eax),%eax
c000090f:	3c 5c                	cmp    $0x5c,%al
c0000911:	75 22                	jne    c0000935 <kprintf+0x50>
c0000913:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000916:	83 c0 01             	add    $0x1,%eax
c0000919:	0f b6 00             	movzbl (%eax),%eax
c000091c:	3c 25                	cmp    $0x25,%al
c000091e:	75 15                	jne    c0000935 <kprintf+0x50>
        {
            //write escaped "%%" as '%'
            kprint_char('%');
c0000920:	83 ec 0c             	sub    $0xc,%esp
c0000923:	6a 25                	push   $0x25
c0000925:	e8 6a ff ff ff       	call   c0000894 <kprint_char>
c000092a:	83 c4 10             	add    $0x10,%esp
            nchar++;
c000092d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
            f += 2;
c0000931:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
        }

        if(f[0] == '%')
c0000935:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000938:	0f b6 00             	movzbl (%eax),%eax
c000093b:	3c 25                	cmp    $0x25,%al
c000093d:	0f 85 45 0a 00 00    	jne    c0001388 <kprintf+0xaa3>
        {
            // found new field

            // parse flags
            struct format_flags flags = {0};
c0000943:	c7 85 77 ff ff ff 00 	movl   $0x0,-0x89(%ebp)
c000094a:	00 00 00 
c000094d:	c6 85 7b ff ff ff 00 	movb   $0x0,-0x85(%ebp)
            int check_flags = 1;
c0000954:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
            while(check_flags)
c000095b:	e9 ee 00 00 00       	jmp    c0000a4e <kprintf+0x169>
            {
                switch(*(++f))
c0000960:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0000964:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000967:	0f b6 00             	movzbl (%eax),%eax
c000096a:	0f be c0             	movsbl %al,%eax
c000096d:	85 c0                	test   %eax,%eax
c000096f:	0f 84 c8 00 00 00    	je     c0000a3d <kprintf+0x158>
c0000975:	85 c0                	test   %eax,%eax
c0000977:	0f 88 ca 00 00 00    	js     c0000a47 <kprintf+0x162>
c000097d:	83 f8 30             	cmp    $0x30,%eax
c0000980:	0f 8f c1 00 00 00    	jg     c0000a47 <kprintf+0x162>
c0000986:	83 f8 20             	cmp    $0x20,%eax
c0000989:	0f 8c b8 00 00 00    	jl     c0000a47 <kprintf+0x162>
c000098f:	83 e8 20             	sub    $0x20,%eax
c0000992:	83 f8 10             	cmp    $0x10,%eax
c0000995:	0f 87 ac 00 00 00    	ja     c0000a47 <kprintf+0x162>
c000099b:	8b 04 85 00 50 00 c0 	mov    -0x3fffb000(,%eax,4),%eax
c00009a2:	ff e0                	jmp    *%eax
                {
                    case '#':
                        if(flags.alt) return 0;
c00009a4:	0f b6 85 77 ff ff ff 	movzbl -0x89(%ebp),%eax
c00009ab:	84 c0                	test   %al,%al
c00009ad:	74 0a                	je     c00009b9 <kprintf+0xd4>
c00009af:	b8 00 00 00 00       	mov    $0x0,%eax
c00009b4:	e9 ff 09 00 00       	jmp    c00013b8 <kprintf+0xad3>
                        flags.alt = 1;
c00009b9:	c6 85 77 ff ff ff 01 	movb   $0x1,-0x89(%ebp)
                        break;
c00009c0:	e9 89 00 00 00       	jmp    c0000a4e <kprintf+0x169>
                    case '0':
                        if(flags.zero) return 0;
c00009c5:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c00009cc:	84 c0                	test   %al,%al
c00009ce:	74 0a                	je     c00009da <kprintf+0xf5>
c00009d0:	b8 00 00 00 00       	mov    $0x0,%eax
c00009d5:	e9 de 09 00 00       	jmp    c00013b8 <kprintf+0xad3>
                        flags.zero = 1;
c00009da:	c6 85 78 ff ff ff 01 	movb   $0x1,-0x88(%ebp)
                        break;
c00009e1:	eb 6b                	jmp    c0000a4e <kprintf+0x169>
                    case '-':
                        if(flags.left) return 0;
c00009e3:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c00009ea:	84 c0                	test   %al,%al
c00009ec:	74 0a                	je     c00009f8 <kprintf+0x113>
c00009ee:	b8 00 00 00 00       	mov    $0x0,%eax
c00009f3:	e9 c0 09 00 00       	jmp    c00013b8 <kprintf+0xad3>
                        flags.left = 1;
c00009f8:	c6 85 79 ff ff ff 01 	movb   $0x1,-0x87(%ebp)
                        break;
c00009ff:	eb 4d                	jmp    c0000a4e <kprintf+0x169>
                    case ' ':
                        if(flags.space) return 0;
c0000a01:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c0000a08:	84 c0                	test   %al,%al
c0000a0a:	74 0a                	je     c0000a16 <kprintf+0x131>
c0000a0c:	b8 00 00 00 00       	mov    $0x0,%eax
c0000a11:	e9 a2 09 00 00       	jmp    c00013b8 <kprintf+0xad3>
                        flags.space = 1;
c0000a16:	c6 85 7a ff ff ff 01 	movb   $0x1,-0x86(%ebp)
                        break;
c0000a1d:	eb 2f                	jmp    c0000a4e <kprintf+0x169>
                    case '+':
                        if(flags.sign) return 0;
c0000a1f:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c0000a26:	84 c0                	test   %al,%al
c0000a28:	74 0a                	je     c0000a34 <kprintf+0x14f>
c0000a2a:	b8 00 00 00 00       	mov    $0x0,%eax
c0000a2f:	e9 84 09 00 00       	jmp    c00013b8 <kprintf+0xad3>
                        flags.sign = 1;
c0000a34:	c6 85 7b ff ff ff 01 	movb   $0x1,-0x85(%ebp)
                        break;
c0000a3b:	eb 11                	jmp    c0000a4e <kprintf+0x169>
                    case '\0':
                        //unexpected string termination
                        return -1;
c0000a3d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000a42:	e9 71 09 00 00       	jmp    c00013b8 <kprintf+0xad3>
                        break;
                    default:
                        //no more flags
                        check_flags = 0;
c0000a47:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
            while(check_flags)
c0000a4e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0000a52:	0f 85 08 ff ff ff    	jne    c0000960 <kprintf+0x7b>
                }
            }

            if(flags.left) flags.zero = 0; //If the 0 and - flags both appear, the 0 flag is ignored
c0000a58:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000a5f:	84 c0                	test   %al,%al
c0000a61:	74 07                	je     c0000a6a <kprintf+0x185>
c0000a63:	c6 85 78 ff ff ff 00 	movb   $0x0,-0x88(%ebp)

            // parse field width
            int field_width=0;
c0000a6a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
            int nn=0;
c0000a71:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
            while(f[nn] >= '0' && f[nn] <= '9')
c0000a78:	eb 04                	jmp    c0000a7e <kprintf+0x199>
                nn++;            
c0000a7a:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
            while(f[nn] >= '0' && f[nn] <= '9')
c0000a7e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000a81:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000a84:	01 d0                	add    %edx,%eax
c0000a86:	0f b6 00             	movzbl (%eax),%eax
c0000a89:	3c 2f                	cmp    $0x2f,%al
c0000a8b:	7e 0f                	jle    c0000a9c <kprintf+0x1b7>
c0000a8d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000a90:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000a93:	01 d0                	add    %edx,%eax
c0000a95:	0f b6 00             	movzbl (%eax),%eax
c0000a98:	3c 39                	cmp    $0x39,%al
c0000a9a:	7e de                	jle    c0000a7a <kprintf+0x195>
            if(nn>0)
c0000a9c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0000aa0:	7e 17                	jle    c0000ab9 <kprintf+0x1d4>
            {
                field_width = atoi(f);
c0000aa2:	83 ec 0c             	sub    $0xc,%esp
c0000aa5:	ff 75 f4             	pushl  -0xc(%ebp)
c0000aa8:	e8 6a 0d 00 00       	call   c0001817 <atoi>
c0000aad:	83 c4 10             	add    $0x10,%esp
c0000ab0:	89 45 e8             	mov    %eax,-0x18(%ebp)
                f += nn;
c0000ab3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0000ab6:	01 45 f4             	add    %eax,-0xc(%ebp)
            }

            // parse field precision
            int field_prec=-1; //default is -1
c0000ab9:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
            if(f[0] == '.')
c0000ac0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000ac3:	0f b6 00             	movzbl (%eax),%eax
c0000ac6:	3c 2e                	cmp    $0x2e,%al
c0000ac8:	75 59                	jne    c0000b23 <kprintf+0x23e>
            {
                f++;
c0000aca:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                nn=0;
c0000ace:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
                while(f[nn] >= '0' && f[nn] <= '9')
c0000ad5:	eb 04                	jmp    c0000adb <kprintf+0x1f6>
                    nn++;            
c0000ad7:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                while(f[nn] >= '0' && f[nn] <= '9')
c0000adb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000ade:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000ae1:	01 d0                	add    %edx,%eax
c0000ae3:	0f b6 00             	movzbl (%eax),%eax
c0000ae6:	3c 2f                	cmp    $0x2f,%al
c0000ae8:	7e 0f                	jle    c0000af9 <kprintf+0x214>
c0000aea:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000aed:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000af0:	01 d0                	add    %edx,%eax
c0000af2:	0f b6 00             	movzbl (%eax),%eax
c0000af5:	3c 39                	cmp    $0x39,%al
c0000af7:	7e de                	jle    c0000ad7 <kprintf+0x1f2>
                if(nn>0)
c0000af9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0000afd:	7e 24                	jle    c0000b23 <kprintf+0x23e>
                {
                    field_prec = atoi(f);
c0000aff:	83 ec 0c             	sub    $0xc,%esp
c0000b02:	ff 75 f4             	pushl  -0xc(%ebp)
c0000b05:	e8 0d 0d 00 00       	call   c0001817 <atoi>
c0000b0a:	83 c4 10             	add    $0x10,%esp
c0000b0d:	89 45 e0             	mov    %eax,-0x20(%ebp)
                    if(field_prec<0) field_prec = 0;
c0000b10:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000b14:	79 07                	jns    c0000b1d <kprintf+0x238>
c0000b16:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
                    f += nn;
c0000b1d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0000b20:	01 45 f4             	add    %eax,-0xc(%ebp)

            //parse type
            enum length_mod_t {DEFAULT, CHARINT, SHORTINT, LONGINT, LONGLONGINT,
                            LONGDOUBLE, INTMAX, SIZE, PTRDIFF} length_mod;

            switch(*(f++))
c0000b23:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000b26:	8d 50 01             	lea    0x1(%eax),%edx
c0000b29:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0000b2c:	0f b6 00             	movzbl (%eax),%eax
c0000b2f:	0f be c0             	movsbl %al,%eax
c0000b32:	83 e8 4c             	sub    $0x4c,%eax
c0000b35:	83 f8 2e             	cmp    $0x2e,%eax
c0000b38:	77 6d                	ja     c0000ba7 <kprintf+0x2c2>
c0000b3a:	8b 04 85 44 50 00 c0 	mov    -0x3fffafbc(,%eax,4),%eax
c0000b41:	ff e0                	jmp    *%eax
            {
                case 'h':
                    if(*f == 'h')
c0000b43:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000b46:	0f b6 00             	movzbl (%eax),%eax
c0000b49:	3c 68                	cmp    $0x68,%al
c0000b4b:	75 0d                	jne    c0000b5a <kprintf+0x275>
                    {
                        f++;
c0000b4d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                        length_mod = CHARINT;
c0000b51:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
                    }
                    else
                        length_mod = SHORTINT;
                    break;
c0000b58:	eb 58                	jmp    c0000bb2 <kprintf+0x2cd>
                        length_mod = SHORTINT;
c0000b5a:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
                    break;
c0000b61:	eb 4f                	jmp    c0000bb2 <kprintf+0x2cd>
                case 'l':
                    if(*f == 'l')
c0000b63:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000b66:	0f b6 00             	movzbl (%eax),%eax
c0000b69:	3c 6c                	cmp    $0x6c,%al
c0000b6b:	75 0d                	jne    c0000b7a <kprintf+0x295>
                    {
                        f++;
c0000b6d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                        length_mod = LONGLONGINT;
c0000b71:	c7 45 dc 04 00 00 00 	movl   $0x4,-0x24(%ebp)
                    }
                    else
                        length_mod = LONGINT;
                    break;
c0000b78:	eb 38                	jmp    c0000bb2 <kprintf+0x2cd>
                        length_mod = LONGINT;
c0000b7a:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
                    break;
c0000b81:	eb 2f                	jmp    c0000bb2 <kprintf+0x2cd>
                case 'q':
                case 'L':
                    length_mod = LONGDOUBLE;
c0000b83:	c7 45 dc 05 00 00 00 	movl   $0x5,-0x24(%ebp)
                    break;
c0000b8a:	eb 26                	jmp    c0000bb2 <kprintf+0x2cd>
                case 'j':
                    length_mod = INTMAX;
c0000b8c:	c7 45 dc 06 00 00 00 	movl   $0x6,-0x24(%ebp)
                    break;
c0000b93:	eb 1d                	jmp    c0000bb2 <kprintf+0x2cd>
                case 'Z':
                case 'z':
                    length_mod = SIZE;
c0000b95:	c7 45 dc 07 00 00 00 	movl   $0x7,-0x24(%ebp)
                    break;
c0000b9c:	eb 14                	jmp    c0000bb2 <kprintf+0x2cd>
                case 't':
                    length_mod = PTRDIFF;
c0000b9e:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
                    break;
c0000ba5:	eb 0b                	jmp    c0000bb2 <kprintf+0x2cd>
                default:
                    f--; //no length mod, back up a char...
c0000ba7:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
                    length_mod = DEFAULT;
c0000bab:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
            }

            //parse field
            char val_buf[512]; //assuming here that numberical values cannot exceed 512 chars 
            if(field_width>511)
c0000bb2:	81 7d e8 ff 01 00 00 	cmpl   $0x1ff,-0x18(%ebp)
c0000bb9:	7e 0a                	jle    c0000bc5 <kprintf+0x2e0>
                return -1;
c0000bbb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000bc0:	e9 f3 07 00 00       	jmp    c00013b8 <kprintf+0xad3>

            switch(*f)
c0000bc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000bc8:	0f b6 00             	movzbl (%eax),%eax
c0000bcb:	0f be c0             	movsbl %al,%eax
c0000bce:	83 e8 45             	sub    $0x45,%eax
c0000bd1:	83 f8 33             	cmp    $0x33,%eax
c0000bd4:	0f 87 97 07 00 00    	ja     c0001371 <kprintf+0xa8c>
c0000bda:	8b 04 85 00 51 00 c0 	mov    -0x3fffaf00(,%eax,4),%eax
c0000be1:	ff e0                	jmp    *%eax
c0000be3:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000be7:	0f 87 67 01 00 00    	ja     c0000d54 <kprintf+0x46f>
                        case(LONGINT):
                        case(LONGLONGINT):
                        case(DEFAULT):
                            {
                                int i_value;
                                if(length_mod == LONGLONGINT)
c0000bed:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000bf1:	75 19                	jne    c0000c0c <kprintf+0x327>
                                    i_value = (int) va_arg(valist, long long int); //TODO: implement actual longlong handling
c0000bf3:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000bf9:	8d 50 08             	lea    0x8(%eax),%edx
c0000bfc:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000c02:	8b 50 04             	mov    0x4(%eax),%edx
c0000c05:	8b 00                	mov    (%eax),%eax
c0000c07:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0000c0a:	eb 14                	jmp    c0000c20 <kprintf+0x33b>
                                else
                                    i_value = va_arg(valist, int);
c0000c0c:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000c12:	8d 50 04             	lea    0x4(%eax),%edx
c0000c15:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000c1b:	8b 00                	mov    (%eax),%eax
c0000c1d:	89 45 d8             	mov    %eax,-0x28(%ebp)

                                char sign_char = 0; //sign character or 0 if none
c0000c20:	c6 45 d7 00          	movb   $0x0,-0x29(%ebp)
                                unsigned int ui_value; //unsigned value (abs value)
                                if(i_value<0)
c0000c24:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c0000c28:	79 0e                	jns    c0000c38 <kprintf+0x353>
                                {
                                    ui_value = -i_value;
c0000c2a:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0000c2d:	f7 d8                	neg    %eax
c0000c2f:	89 45 d0             	mov    %eax,-0x30(%ebp)
                                    sign_char = '-';
c0000c32:	c6 45 d7 2d          	movb   $0x2d,-0x29(%ebp)
c0000c36:	eb 26                	jmp    c0000c5e <kprintf+0x379>
                                }
                                else
                                {
                                    ui_value = i_value;
c0000c38:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0000c3b:	89 45 d0             	mov    %eax,-0x30(%ebp)
                                    if(flags.sign)
c0000c3e:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c0000c45:	84 c0                	test   %al,%al
c0000c47:	74 06                	je     c0000c4f <kprintf+0x36a>
                                        sign_char = '+';
c0000c49:	c6 45 d7 2b          	movb   $0x2b,-0x29(%ebp)
c0000c4d:	eb 0f                	jmp    c0000c5e <kprintf+0x379>
                                    else if(flags.space)
c0000c4f:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c0000c56:	84 c0                	test   %al,%al
c0000c58:	74 04                	je     c0000c5e <kprintf+0x379>
                                        sign_char = ' ';
c0000c5a:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
                                    
                                    //else positive number has no sign character
                                }

                                //convert value into string
                                int len = format_uint(ui_value, val_buf, 10, field_prec, 0);
c0000c5e:	83 ec 0c             	sub    $0xc,%esp
c0000c61:	6a 00                	push   $0x0
c0000c63:	ff 75 e0             	pushl  -0x20(%ebp)
c0000c66:	6a 0a                	push   $0xa
c0000c68:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000c6e:	50                   	push   %eax
c0000c6f:	ff 75 d0             	pushl  -0x30(%ebp)
c0000c72:	e8 43 07 00 00       	call   c00013ba <format_uint>
c0000c77:	83 c4 20             	add    $0x20,%esp
c0000c7a:	89 45 9c             	mov    %eax,-0x64(%ebp)
                                //amount of padding required to meet requested width
                                int lenpad = field_width - len; 
c0000c7d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000c80:	2b 45 9c             	sub    -0x64(%ebp),%eax
c0000c83:	89 45 cc             	mov    %eax,-0x34(%ebp)

                                if(sign_char)
c0000c86:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
c0000c8a:	74 22                	je     c0000cae <kprintf+0x3c9>
                                {
                                    lenpad--; //remove one char of padding to account for sign
c0000c8c:	83 6d cc 01          	subl   $0x1,-0x34(%ebp)
                                    if(flags.zero)
c0000c90:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000c97:	84 c0                	test   %al,%al
c0000c99:	74 13                	je     c0000cae <kprintf+0x3c9>
                                        nchar += kprint_char(sign_char); //if zero padding, sign is at beginning
c0000c9b:	0f be 45 d7          	movsbl -0x29(%ebp),%eax
c0000c9f:	83 ec 0c             	sub    $0xc,%esp
c0000ca2:	50                   	push   %eax
c0000ca3:	e8 ec fb ff ff       	call   c0000894 <kprint_char>
c0000ca8:	83 c4 10             	add    $0x10,%esp
c0000cab:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                if(!flags.left && lenpad>0)
c0000cae:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000cb5:	84 c0                	test   %al,%al
c0000cb7:	75 3b                	jne    c0000cf4 <kprintf+0x40f>
c0000cb9:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
c0000cbd:	7e 35                	jle    c0000cf4 <kprintf+0x40f>
                                {
                                    if(flags.zero)
c0000cbf:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000cc6:	84 c0                	test   %al,%al
c0000cc8:	74 16                	je     c0000ce0 <kprintf+0x3fb>
                                        nchar += kprintn_char('0', lenpad);
c0000cca:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0000ccd:	83 ec 08             	sub    $0x8,%esp
c0000cd0:	50                   	push   %eax
c0000cd1:	6a 30                	push   $0x30
c0000cd3:	e8 e4 fb ff ff       	call   c00008bc <kprintn_char>
c0000cd8:	83 c4 10             	add    $0x10,%esp
c0000cdb:	01 45 f0             	add    %eax,-0x10(%ebp)
c0000cde:	eb 14                	jmp    c0000cf4 <kprintf+0x40f>
                                    else
                                        nchar += kprintn_char(' ', lenpad);
c0000ce0:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0000ce3:	83 ec 08             	sub    $0x8,%esp
c0000ce6:	50                   	push   %eax
c0000ce7:	6a 20                	push   $0x20
c0000ce9:	e8 ce fb ff ff       	call   c00008bc <kprintn_char>
c0000cee:	83 c4 10             	add    $0x10,%esp
c0000cf1:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                if(!flags.zero && sign_char)
c0000cf4:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000cfb:	84 c0                	test   %al,%al
c0000cfd:	75 19                	jne    c0000d18 <kprintf+0x433>
c0000cff:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
c0000d03:	74 13                	je     c0000d18 <kprintf+0x433>
                                    nchar += kprint_char(sign_char); //if not zero padding, write sign here
c0000d05:	0f be 45 d7          	movsbl -0x29(%ebp),%eax
c0000d09:	83 ec 0c             	sub    $0xc,%esp
c0000d0c:	50                   	push   %eax
c0000d0d:	e8 82 fb ff ff       	call   c0000894 <kprint_char>
c0000d12:	83 c4 10             	add    $0x10,%esp
c0000d15:	01 45 f0             	add    %eax,-0x10(%ebp)

                                nchar += kprint(val_buf);
c0000d18:	83 ec 0c             	sub    $0xc,%esp
c0000d1b:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000d21:	50                   	push   %eax
c0000d22:	e8 23 fb ff ff       	call   c000084a <kprint>
c0000d27:	83 c4 10             	add    $0x10,%esp
c0000d2a:	01 45 f0             	add    %eax,-0x10(%ebp)

                                if(flags.left && lenpad>0)
c0000d2d:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000d34:	84 c0                	test   %al,%al
c0000d36:	74 26                	je     c0000d5e <kprintf+0x479>
c0000d38:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
c0000d3c:	7e 20                	jle    c0000d5e <kprintf+0x479>
                                    nchar += kprintn_char(' ', lenpad);
c0000d3e:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0000d41:	83 ec 08             	sub    $0x8,%esp
c0000d44:	50                   	push   %eax
c0000d45:	6a 20                	push   $0x20
c0000d47:	e8 70 fb ff ff       	call   c00008bc <kprintn_char>
c0000d4c:	83 c4 10             	add    $0x10,%esp
c0000d4f:	01 45 f0             	add    %eax,-0x10(%ebp)


                            }
                            break;
c0000d52:	eb 0a                	jmp    c0000d5e <kprintf+0x479>
                        default:
                            return -1; //invalid length mod
c0000d54:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000d59:	e9 5a 06 00 00       	jmp    c00013b8 <kprintf+0xad3>
                            break;
c0000d5e:	90                   	nop
                    }
                    break;
c0000d5f:	e9 1e 06 00 00       	jmp    c0001382 <kprintf+0xa9d>
c0000d64:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000d68:	0f 87 03 02 00 00    	ja     c0000f71 <kprintf+0x68c>
                        case(SHORTINT):
                        case(LONGINT):
                        case(LONGLONGINT):
                        case(DEFAULT):
                            {
                                unsigned int base = 10;
c0000d6e:	c7 45 c8 0a 00 00 00 	movl   $0xa,-0x38(%ebp)
                                unsigned int ui_value;
                                if(length_mod == LONGLONGINT)
c0000d75:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000d79:	75 19                	jne    c0000d94 <kprintf+0x4af>
                                    ui_value = (unsigned int) va_arg(valist, long long unsigned int); //TODO: implement actual longlong handling
c0000d7b:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000d81:	8d 50 08             	lea    0x8(%eax),%edx
c0000d84:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000d8a:	8b 50 04             	mov    0x4(%eax),%edx
c0000d8d:	8b 00                	mov    (%eax),%eax
c0000d8f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
c0000d92:	eb 14                	jmp    c0000da8 <kprintf+0x4c3>
                                else
                                    ui_value = va_arg(valist, unsigned int);
c0000d94:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000d9a:	8d 50 04             	lea    0x4(%eax),%edx
c0000d9d:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000da3:	8b 00                	mov    (%eax),%eax
c0000da5:	89 45 c4             	mov    %eax,-0x3c(%ebp)

                                if(*f == 'o')
c0000da8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000dab:	0f b6 00             	movzbl (%eax),%eax
c0000dae:	3c 6f                	cmp    $0x6f,%al
c0000db0:	75 09                	jne    c0000dbb <kprintf+0x4d6>
                                    base = 8;
c0000db2:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
c0000db9:	eb 3e                	jmp    c0000df9 <kprintf+0x514>
                                else if(*f == 'x' || *f == 'X')
c0000dbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000dbe:	0f b6 00             	movzbl (%eax),%eax
c0000dc1:	3c 78                	cmp    $0x78,%al
c0000dc3:	74 0a                	je     c0000dcf <kprintf+0x4ea>
c0000dc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000dc8:	0f b6 00             	movzbl (%eax),%eax
c0000dcb:	3c 58                	cmp    $0x58,%al
c0000dcd:	75 09                	jne    c0000dd8 <kprintf+0x4f3>
                                    base = 16;
c0000dcf:	c7 45 c8 10 00 00 00 	movl   $0x10,-0x38(%ebp)
c0000dd6:	eb 21                	jmp    c0000df9 <kprintf+0x514>
                                else if(*f == 'p')
c0000dd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000ddb:	0f b6 00             	movzbl (%eax),%eax
c0000dde:	3c 70                	cmp    $0x70,%al
c0000de0:	75 10                	jne    c0000df2 <kprintf+0x50d>
                                {
                                    //print as hex with 0x prefix
                                    base = 16;
c0000de2:	c7 45 c8 10 00 00 00 	movl   $0x10,-0x38(%ebp)
                                    flags.alt = 1; 
c0000de9:	c6 85 77 ff ff ff 01 	movb   $0x1,-0x89(%ebp)
c0000df0:	eb 07                	jmp    c0000df9 <kprintf+0x514>
                                }
                                else
                                    flags.alt = 0;
c0000df2:	c6 85 77 ff ff ff 00 	movb   $0x0,-0x89(%ebp)
                                
                                int cap = (*f == 'X') ? 1 : 0;
c0000df9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000dfc:	0f b6 00             	movzbl (%eax),%eax
c0000dff:	3c 58                	cmp    $0x58,%al
c0000e01:	0f 94 c0             	sete   %al
c0000e04:	0f b6 c0             	movzbl %al,%eax
c0000e07:	89 45 94             	mov    %eax,-0x6c(%ebp)

                                //convert value into string
                                int len = format_uint(ui_value, val_buf, base, field_prec, cap);
c0000e0a:	83 ec 0c             	sub    $0xc,%esp
c0000e0d:	ff 75 94             	pushl  -0x6c(%ebp)
c0000e10:	ff 75 e0             	pushl  -0x20(%ebp)
c0000e13:	ff 75 c8             	pushl  -0x38(%ebp)
c0000e16:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000e1c:	50                   	push   %eax
c0000e1d:	ff 75 c4             	pushl  -0x3c(%ebp)
c0000e20:	e8 95 05 00 00       	call   c00013ba <format_uint>
c0000e25:	83 c4 20             	add    $0x20,%esp
c0000e28:	89 45 90             	mov    %eax,-0x70(%ebp)
                                //amount of padding required to meet requested width
                                int lenpad = field_width - len; 
c0000e2b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000e2e:	2b 45 90             	sub    -0x70(%ebp),%eax
c0000e31:	89 45 c0             	mov    %eax,-0x40(%ebp)


                                //format radix prefix for oct and hex with alt flag
                                char radix[3]="";
c0000e34:	66 c7 85 74 ff ff ff 	movw   $0x0,-0x8c(%ebp)
c0000e3b:	00 00 
c0000e3d:	c6 85 76 ff ff ff 00 	movb   $0x0,-0x8a(%ebp)
                                if(flags.alt)
c0000e44:	0f b6 85 77 ff ff ff 	movzbl -0x89(%ebp),%eax
c0000e4b:	84 c0                	test   %al,%al
c0000e4d:	74 75                	je     c0000ec4 <kprintf+0x5df>
                                {
                                    if(base==16)
c0000e4f:	83 7d c8 10          	cmpl   $0x10,-0x38(%ebp)
c0000e53:	75 2c                	jne    c0000e81 <kprintf+0x59c>
                                    {
                                        lenpad -= 2;
c0000e55:	83 6d c0 02          	subl   $0x2,-0x40(%ebp)
                                        radix[0] = '0';
c0000e59:	c6 85 74 ff ff ff 30 	movb   $0x30,-0x8c(%ebp)
                                        radix[1] = cap ? 'X' : 'x';
c0000e60:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
c0000e64:	74 07                	je     c0000e6d <kprintf+0x588>
c0000e66:	b8 58 00 00 00       	mov    $0x58,%eax
c0000e6b:	eb 05                	jmp    c0000e72 <kprintf+0x58d>
c0000e6d:	b8 78 00 00 00       	mov    $0x78,%eax
c0000e72:	88 85 75 ff ff ff    	mov    %al,-0x8b(%ebp)
                                        radix[2] = 0;
c0000e78:	c6 85 76 ff ff ff 00 	movb   $0x0,-0x8a(%ebp)
c0000e7f:	eb 23                	jmp    c0000ea4 <kprintf+0x5bf>
                                    }
                                    else if(base==8 && val_buf[0] != '0')
c0000e81:	83 7d c8 08          	cmpl   $0x8,-0x38(%ebp)
c0000e85:	75 1d                	jne    c0000ea4 <kprintf+0x5bf>
c0000e87:	0f b6 85 74 fd ff ff 	movzbl -0x28c(%ebp),%eax
c0000e8e:	3c 30                	cmp    $0x30,%al
c0000e90:	74 12                	je     c0000ea4 <kprintf+0x5bf>
                                    {
                                        lenpad -= 1;
c0000e92:	83 6d c0 01          	subl   $0x1,-0x40(%ebp)
                                        radix[0] = '0';
c0000e96:	c6 85 74 ff ff ff 30 	movb   $0x30,-0x8c(%ebp)
                                        radix[1] = 0;
c0000e9d:	c6 85 75 ff ff ff 00 	movb   $0x0,-0x8b(%ebp)
                                    }

                                    //if zero padding, radix is printed first
                                    if(flags.zero)
c0000ea4:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000eab:	84 c0                	test   %al,%al
c0000ead:	74 15                	je     c0000ec4 <kprintf+0x5df>
                                        nchar += kprint(radix);
c0000eaf:	83 ec 0c             	sub    $0xc,%esp
c0000eb2:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
c0000eb8:	50                   	push   %eax
c0000eb9:	e8 8c f9 ff ff       	call   c000084a <kprint>
c0000ebe:	83 c4 10             	add    $0x10,%esp
c0000ec1:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }


                                //print leading padding, if any
                                if(!flags.left && lenpad>0)
c0000ec4:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000ecb:	84 c0                	test   %al,%al
c0000ecd:	75 3b                	jne    c0000f0a <kprintf+0x625>
c0000ecf:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
c0000ed3:	7e 35                	jle    c0000f0a <kprintf+0x625>
                                {
                                    if(flags.zero)
c0000ed5:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000edc:	84 c0                	test   %al,%al
c0000ede:	74 16                	je     c0000ef6 <kprintf+0x611>
                                        nchar += kprintn_char('0', lenpad);
c0000ee0:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000ee3:	83 ec 08             	sub    $0x8,%esp
c0000ee6:	50                   	push   %eax
c0000ee7:	6a 30                	push   $0x30
c0000ee9:	e8 ce f9 ff ff       	call   c00008bc <kprintn_char>
c0000eee:	83 c4 10             	add    $0x10,%esp
c0000ef1:	01 45 f0             	add    %eax,-0x10(%ebp)
c0000ef4:	eb 14                	jmp    c0000f0a <kprintf+0x625>
                                    else
                                        nchar += kprintn_char(' ', lenpad);
c0000ef6:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000ef9:	83 ec 08             	sub    $0x8,%esp
c0000efc:	50                   	push   %eax
c0000efd:	6a 20                	push   $0x20
c0000eff:	e8 b8 f9 ff ff       	call   c00008bc <kprintn_char>
c0000f04:	83 c4 10             	add    $0x10,%esp
c0000f07:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                //print radix prefix if valid and not leading zeros
                                if(!flags.zero && radix[0])
c0000f0a:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000f11:	84 c0                	test   %al,%al
c0000f13:	75 20                	jne    c0000f35 <kprintf+0x650>
c0000f15:	0f b6 85 74 ff ff ff 	movzbl -0x8c(%ebp),%eax
c0000f1c:	84 c0                	test   %al,%al
c0000f1e:	74 15                	je     c0000f35 <kprintf+0x650>
                                    nchar += kprint(radix);
c0000f20:	83 ec 0c             	sub    $0xc,%esp
c0000f23:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
c0000f29:	50                   	push   %eax
c0000f2a:	e8 1b f9 ff ff       	call   c000084a <kprint>
c0000f2f:	83 c4 10             	add    $0x10,%esp
c0000f32:	01 45 f0             	add    %eax,-0x10(%ebp)

                                //print number itself
                                nchar += kprint(val_buf);
c0000f35:	83 ec 0c             	sub    $0xc,%esp
c0000f38:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000f3e:	50                   	push   %eax
c0000f3f:	e8 06 f9 ff ff       	call   c000084a <kprint>
c0000f44:	83 c4 10             	add    $0x10,%esp
c0000f47:	01 45 f0             	add    %eax,-0x10(%ebp)

                                //print trailing padding if left justified
                                if(flags.left && lenpad>0)
c0000f4a:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000f51:	84 c0                	test   %al,%al
c0000f53:	74 26                	je     c0000f7b <kprintf+0x696>
c0000f55:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
c0000f59:	7e 20                	jle    c0000f7b <kprintf+0x696>
                                    nchar += kprintn_char(' ', lenpad);
c0000f5b:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000f5e:	83 ec 08             	sub    $0x8,%esp
c0000f61:	50                   	push   %eax
c0000f62:	6a 20                	push   $0x20
c0000f64:	e8 53 f9 ff ff       	call   c00008bc <kprintn_char>
c0000f69:	83 c4 10             	add    $0x10,%esp
c0000f6c:	01 45 f0             	add    %eax,-0x10(%ebp)

                            }
                            break;
c0000f6f:	eb 0a                	jmp    c0000f7b <kprintf+0x696>
                        default:
                            return -1; //invalid length mod
c0000f71:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000f76:	e9 3d 04 00 00       	jmp    c00013b8 <kprintf+0xad3>
                            break;
c0000f7b:	90                   	nop
                    }

                    break;
c0000f7c:	e9 01 04 00 00       	jmp    c0001382 <kprintf+0xa9d>

                case 'f':
                case 'F':
                    {
                        float f_value = (float) va_arg(valist, double);
c0000f81:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000f87:	8d 50 08             	lea    0x8(%eax),%edx
c0000f8a:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000f90:	dd 00                	fldl   (%eax)
c0000f92:	d9 5d 8c             	fstps  -0x74(%ebp)

                        //When 0 is printed with an explicit precision 0, the output is empty.
                        if(f_value==0 && field_prec==0)
c0000f95:	d9 45 8c             	flds   -0x74(%ebp)
c0000f98:	d9 ee                	fldz   
c0000f9a:	df e9                	fucomip %st(1),%st
c0000f9c:	dd d8                	fstp   %st(0)
c0000f9e:	7a 15                	jp     c0000fb5 <kprintf+0x6d0>
c0000fa0:	d9 45 8c             	flds   -0x74(%ebp)
c0000fa3:	d9 ee                	fldz   
c0000fa5:	df e9                	fucomip %st(1),%st
c0000fa7:	dd d8                	fstp   %st(0)
c0000fa9:	75 0a                	jne    c0000fb5 <kprintf+0x6d0>
c0000fab:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000faf:	0f 84 c3 03 00 00    	je     c0001378 <kprintf+0xa93>
                            break;
                        if(field_prec<0) field_prec = 6;  //default is prec = 6
c0000fb5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000fb9:	79 07                	jns    c0000fc2 <kprintf+0x6dd>
c0000fbb:	c7 45 e0 06 00 00 00 	movl   $0x6,-0x20(%ebp)

                        unsigned int ui_part;
                        char sign_char = 0;
c0000fc2:	c6 45 bb 00          	movb   $0x0,-0x45(%ebp)
                        if(f_value<0)
c0000fc6:	d9 45 8c             	flds   -0x74(%ebp)
c0000fc9:	d9 ee                	fldz   
c0000fcb:	df f1                	fcomip %st(1),%st
c0000fcd:	dd d8                	fstp   %st(0)
c0000fcf:	76 3d                	jbe    c000100e <kprintf+0x729>
                        {
                            ui_part = (unsigned int) -f_value;
c0000fd1:	d9 45 8c             	flds   -0x74(%ebp)
c0000fd4:	d9 e0                	fchs   
c0000fd6:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c0000fdc:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c0000fe3:	80 cc 0c             	or     $0xc,%ah
c0000fe6:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c0000fed:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c0000ff3:	df bd 58 fd ff ff    	fistpll -0x2a8(%ebp)
c0000ff9:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
c0000fff:	8b 85 58 fd ff ff    	mov    -0x2a8(%ebp),%eax
c0001005:	89 45 bc             	mov    %eax,-0x44(%ebp)
                            sign_char = '-';
c0001008:	c6 45 bb 2d          	movb   $0x2d,-0x45(%ebp)
c000100c:	eb 55                	jmp    c0001063 <kprintf+0x77e>
                        }
                        else
                        {
                            ui_part = (unsigned int) f_value;
c000100e:	d9 45 8c             	flds   -0x74(%ebp)
c0001011:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c0001017:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c000101e:	80 cc 0c             	or     $0xc,%ah
c0001021:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c0001028:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c000102e:	df bd 58 fd ff ff    	fistpll -0x2a8(%ebp)
c0001034:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
c000103a:	8b 85 58 fd ff ff    	mov    -0x2a8(%ebp),%eax
c0001040:	89 45 bc             	mov    %eax,-0x44(%ebp)
                            if(flags.sign)
c0001043:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c000104a:	84 c0                	test   %al,%al
c000104c:	74 06                	je     c0001054 <kprintf+0x76f>
                                sign_char = '+';
c000104e:	c6 45 bb 2b          	movb   $0x2b,-0x45(%ebp)
c0001052:	eb 0f                	jmp    c0001063 <kprintf+0x77e>
                            else if(flags.space)
c0001054:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c000105b:	84 c0                	test   %al,%al
c000105d:	74 04                	je     c0001063 <kprintf+0x77e>
                                sign_char = ' ';
c000105f:	c6 45 bb 20          	movb   $0x20,-0x45(%ebp)
                            
                            //else positive number has no sign character
                        }

                        int int_len = format_uint(ui_part,val_buf,10,-1,0);
c0001063:	83 ec 0c             	sub    $0xc,%esp
c0001066:	6a 00                	push   $0x0
c0001068:	6a ff                	push   $0xffffffff
c000106a:	6a 0a                	push   $0xa
c000106c:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0001072:	50                   	push   %eax
c0001073:	ff 75 bc             	pushl  -0x44(%ebp)
c0001076:	e8 3f 03 00 00       	call   c00013ba <format_uint>
c000107b:	83 c4 20             	add    $0x20,%esp
c000107e:	89 45 88             	mov    %eax,-0x78(%ebp)

                        int f_len = int_len + 1 + field_prec;
c0001081:	8b 45 88             	mov    -0x78(%ebp),%eax
c0001084:	8d 50 01             	lea    0x1(%eax),%edx
c0001087:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000108a:	01 d0                	add    %edx,%eax
c000108c:	89 45 84             	mov    %eax,-0x7c(%ebp)

                        //amount of padding required to meet requested width
                        int lenpad = field_width - f_len; 
c000108f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001092:	2b 45 84             	sub    -0x7c(%ebp),%eax
c0001095:	89 45 b4             	mov    %eax,-0x4c(%ebp)

                        if(sign_char)
c0001098:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
c000109c:	74 22                	je     c00010c0 <kprintf+0x7db>
                        {
                            lenpad--; //remove one char of padding to account for sign
c000109e:	83 6d b4 01          	subl   $0x1,-0x4c(%ebp)
                            if(flags.zero)
c00010a2:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c00010a9:	84 c0                	test   %al,%al
c00010ab:	74 13                	je     c00010c0 <kprintf+0x7db>
                                nchar += kprint_char(sign_char); //if zero padding, sign is at beginning
c00010ad:	0f be 45 bb          	movsbl -0x45(%ebp),%eax
c00010b1:	83 ec 0c             	sub    $0xc,%esp
c00010b4:	50                   	push   %eax
c00010b5:	e8 da f7 ff ff       	call   c0000894 <kprint_char>
c00010ba:	83 c4 10             	add    $0x10,%esp
c00010bd:	01 45 f0             	add    %eax,-0x10(%ebp)
                        }

                        if(!flags.left && lenpad>0)
c00010c0:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c00010c7:	84 c0                	test   %al,%al
c00010c9:	75 3b                	jne    c0001106 <kprintf+0x821>
c00010cb:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
c00010cf:	7e 35                	jle    c0001106 <kprintf+0x821>
                        {
                            if(flags.zero)
c00010d1:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c00010d8:	84 c0                	test   %al,%al
c00010da:	74 16                	je     c00010f2 <kprintf+0x80d>
                                nchar += kprintn_char('0', lenpad);
c00010dc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c00010df:	83 ec 08             	sub    $0x8,%esp
c00010e2:	50                   	push   %eax
c00010e3:	6a 30                	push   $0x30
c00010e5:	e8 d2 f7 ff ff       	call   c00008bc <kprintn_char>
c00010ea:	83 c4 10             	add    $0x10,%esp
c00010ed:	01 45 f0             	add    %eax,-0x10(%ebp)
c00010f0:	eb 14                	jmp    c0001106 <kprintf+0x821>
                            else
                                nchar += kprintn_char(' ', lenpad);
c00010f2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c00010f5:	83 ec 08             	sub    $0x8,%esp
c00010f8:	50                   	push   %eax
c00010f9:	6a 20                	push   $0x20
c00010fb:	e8 bc f7 ff ff       	call   c00008bc <kprintn_char>
c0001100:	83 c4 10             	add    $0x10,%esp
c0001103:	01 45 f0             	add    %eax,-0x10(%ebp)
                        }

                        if(!flags.zero && sign_char)
c0001106:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c000110d:	84 c0                	test   %al,%al
c000110f:	75 19                	jne    c000112a <kprintf+0x845>
c0001111:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
c0001115:	74 13                	je     c000112a <kprintf+0x845>
                            nchar += kprint_char(sign_char); //if not zero padding, write sign here
c0001117:	0f be 45 bb          	movsbl -0x45(%ebp),%eax
c000111b:	83 ec 0c             	sub    $0xc,%esp
c000111e:	50                   	push   %eax
c000111f:	e8 70 f7 ff ff       	call   c0000894 <kprint_char>
c0001124:	83 c4 10             	add    $0x10,%esp
c0001127:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprint(val_buf);
c000112a:	83 ec 0c             	sub    $0xc,%esp
c000112d:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0001133:	50                   	push   %eax
c0001134:	e8 11 f7 ff ff       	call   c000084a <kprint>
c0001139:	83 c4 10             	add    $0x10,%esp
c000113c:	01 45 f0             	add    %eax,-0x10(%ebp)
                        nchar += kprint_char('.');
c000113f:	83 ec 0c             	sub    $0xc,%esp
c0001142:	6a 2e                	push   $0x2e
c0001144:	e8 4b f7 ff ff       	call   c0000894 <kprint_char>
c0001149:	83 c4 10             	add    $0x10,%esp
c000114c:	01 45 f0             	add    %eax,-0x10(%ebp)

                        //compute fractional digits.
                        float frac = f_value<0 ? -f_value - ui_part : f_value - ui_part;
c000114f:	d9 45 8c             	flds   -0x74(%ebp)
c0001152:	d9 ee                	fldz   
c0001154:	df f1                	fcomip %st(1),%st
c0001156:	dd d8                	fstp   %st(0)
c0001158:	76 23                	jbe    c000117d <kprintf+0x898>
c000115a:	d9 45 8c             	flds   -0x74(%ebp)
c000115d:	d9 e0                	fchs   
c000115f:	8b 45 bc             	mov    -0x44(%ebp),%eax
c0001162:	ba 00 00 00 00       	mov    $0x0,%edx
c0001167:	89 85 58 fd ff ff    	mov    %eax,-0x2a8(%ebp)
c000116d:	89 95 5c fd ff ff    	mov    %edx,-0x2a4(%ebp)
c0001173:	df ad 58 fd ff ff    	fildll -0x2a8(%ebp)
c0001179:	de e9                	fsubrp %st,%st(1)
c000117b:	eb 1f                	jmp    c000119c <kprintf+0x8b7>
c000117d:	8b 45 bc             	mov    -0x44(%ebp),%eax
c0001180:	ba 00 00 00 00       	mov    $0x0,%edx
c0001185:	89 85 58 fd ff ff    	mov    %eax,-0x2a8(%ebp)
c000118b:	89 95 5c fd ff ff    	mov    %edx,-0x2a4(%ebp)
c0001191:	df ad 58 fd ff ff    	fildll -0x2a8(%ebp)
c0001197:	d9 45 8c             	flds   -0x74(%ebp)
c000119a:	de e1                	fsubp  %st,%st(1)
c000119c:	d9 5d b0             	fstps  -0x50(%ebp)
                        int d;
                        for(int nn=0;nn<field_prec; nn++)
c000119f:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
c00011a6:	eb 5e                	jmp    c0001206 <kprintf+0x921>
                        {
                            frac *= 10.;
c00011a8:	d9 45 b0             	flds   -0x50(%ebp)
c00011ab:	d9 05 1c 54 00 c0    	flds   0xc000541c
c00011b1:	de c9                	fmulp  %st,%st(1)
c00011b3:	d9 5d b0             	fstps  -0x50(%ebp)
                            d = (int) frac;
c00011b6:	d9 45 b0             	flds   -0x50(%ebp)
c00011b9:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c00011bf:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c00011c6:	80 cc 0c             	or     $0xc,%ah
c00011c9:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c00011d0:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c00011d6:	db 5d 80             	fistpl -0x80(%ebp)
c00011d9:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
                            frac -= d;
c00011df:	db 45 80             	fildl  -0x80(%ebp)
c00011e2:	d9 45 b0             	flds   -0x50(%ebp)
c00011e5:	de e1                	fsubp  %st,%st(1)
c00011e7:	d9 5d b0             	fstps  -0x50(%ebp)
                            nchar += kprint_char('0' + d);
c00011ea:	8b 45 80             	mov    -0x80(%ebp),%eax
c00011ed:	83 c0 30             	add    $0x30,%eax
c00011f0:	0f be c0             	movsbl %al,%eax
c00011f3:	83 ec 0c             	sub    $0xc,%esp
c00011f6:	50                   	push   %eax
c00011f7:	e8 98 f6 ff ff       	call   c0000894 <kprint_char>
c00011fc:	83 c4 10             	add    $0x10,%esp
c00011ff:	01 45 f0             	add    %eax,-0x10(%ebp)
                        for(int nn=0;nn<field_prec; nn++)
c0001202:	83 45 ac 01          	addl   $0x1,-0x54(%ebp)
c0001206:	8b 45 ac             	mov    -0x54(%ebp),%eax
c0001209:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c000120c:	7c 9a                	jl     c00011a8 <kprintf+0x8c3>
                        }

                        if(flags.left && lenpad>0)
c000120e:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0001215:	84 c0                	test   %al,%al
c0001217:	0f 84 5e 01 00 00    	je     c000137b <kprintf+0xa96>
c000121d:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
c0001221:	0f 8e 54 01 00 00    	jle    c000137b <kprintf+0xa96>
                            nchar += kprintn_char(' ', lenpad);
c0001227:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c000122a:	83 ec 08             	sub    $0x8,%esp
c000122d:	50                   	push   %eax
c000122e:	6a 20                	push   $0x20
c0001230:	e8 87 f6 ff ff       	call   c00008bc <kprintn_char>
c0001235:	83 c4 10             	add    $0x10,%esp
c0001238:	01 45 f0             	add    %eax,-0x10(%ebp)

                    }
                    break;
c000123b:	e9 3b 01 00 00       	jmp    c000137b <kprintf+0xa96>
                case 'e':
                case 'E':
                case 'g':
                case 'G':
                    return -1; // not yet implemented
c0001240:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0001245:	e9 6e 01 00 00       	jmp    c00013b8 <kprintf+0xad3>
                case 'c':
                    {
                        char c = (char) va_arg(valist, int);
c000124a:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0001250:	8d 50 04             	lea    0x4(%eax),%edx
c0001253:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0001259:	8b 00                	mov    (%eax),%eax
c000125b:	88 45 9b             	mov    %al,-0x65(%ebp)

                        if(field_width>1 && !flags.left)    
c000125e:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
c0001262:	7e 22                	jle    c0001286 <kprintf+0x9a1>
c0001264:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c000126b:	84 c0                	test   %al,%al
c000126d:	75 17                	jne    c0001286 <kprintf+0x9a1>
                            nchar += kprintn_char(' ', field_width-1);
c000126f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001272:	83 e8 01             	sub    $0x1,%eax
c0001275:	83 ec 08             	sub    $0x8,%esp
c0001278:	50                   	push   %eax
c0001279:	6a 20                	push   $0x20
c000127b:	e8 3c f6 ff ff       	call   c00008bc <kprintn_char>
c0001280:	83 c4 10             	add    $0x10,%esp
c0001283:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprint_char(c);
c0001286:	0f be 45 9b          	movsbl -0x65(%ebp),%eax
c000128a:	83 ec 0c             	sub    $0xc,%esp
c000128d:	50                   	push   %eax
c000128e:	e8 01 f6 ff ff       	call   c0000894 <kprint_char>
c0001293:	83 c4 10             	add    $0x10,%esp
c0001296:	01 45 f0             	add    %eax,-0x10(%ebp)

                        if(field_width>1 && flags.left)    
c0001299:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
c000129d:	0f 8e db 00 00 00    	jle    c000137e <kprintf+0xa99>
c00012a3:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c00012aa:	84 c0                	test   %al,%al
c00012ac:	0f 84 cc 00 00 00    	je     c000137e <kprintf+0xa99>
                            nchar += kprintn_char(' ', field_width-1);
c00012b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00012b5:	83 e8 01             	sub    $0x1,%eax
c00012b8:	83 ec 08             	sub    $0x8,%esp
c00012bb:	50                   	push   %eax
c00012bc:	6a 20                	push   $0x20
c00012be:	e8 f9 f5 ff ff       	call   c00008bc <kprintn_char>
c00012c3:	83 c4 10             	add    $0x10,%esp
c00012c6:	01 45 f0             	add    %eax,-0x10(%ebp)
                    }                    
                    break;
c00012c9:	e9 b0 00 00 00       	jmp    c000137e <kprintf+0xa99>

                case 's':
                    {
                        char* str = va_arg(valist, char*);
c00012ce:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c00012d4:	8d 50 04             	lea    0x4(%eax),%edx
c00012d7:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c00012dd:	8b 00                	mov    (%eax),%eax
c00012df:	89 45 a4             	mov    %eax,-0x5c(%ebp)
                        int len = strlen(str);
c00012e2:	83 ec 0c             	sub    $0xc,%esp
c00012e5:	ff 75 a4             	pushl  -0x5c(%ebp)
c00012e8:	e8 2b 04 00 00       	call   c0001718 <strlen>
c00012ed:	83 c4 10             	add    $0x10,%esp
c00012f0:	89 45 a8             	mov    %eax,-0x58(%ebp)
                        if(field_prec > 0 && field_prec < len)
c00012f3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c00012f7:	7e 0e                	jle    c0001307 <kprintf+0xa22>
c00012f9:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00012fc:	3b 45 a8             	cmp    -0x58(%ebp),%eax
c00012ff:	7d 06                	jge    c0001307 <kprintf+0xa22>
                            len = field_prec;
c0001301:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001304:	89 45 a8             	mov    %eax,-0x58(%ebp)

                        int lenpad = field_width - len; 
c0001307:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000130a:	2b 45 a8             	sub    -0x58(%ebp),%eax
c000130d:	89 45 a0             	mov    %eax,-0x60(%ebp)

                        if(lenpad>0 && !flags.left)    
c0001310:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
c0001314:	7e 1f                	jle    c0001335 <kprintf+0xa50>
c0001316:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c000131d:	84 c0                	test   %al,%al
c000131f:	75 14                	jne    c0001335 <kprintf+0xa50>
                            nchar += kprintn_char(' ', lenpad);
c0001321:	8b 45 a0             	mov    -0x60(%ebp),%eax
c0001324:	83 ec 08             	sub    $0x8,%esp
c0001327:	50                   	push   %eax
c0001328:	6a 20                	push   $0x20
c000132a:	e8 8d f5 ff ff       	call   c00008bc <kprintn_char>
c000132f:	83 c4 10             	add    $0x10,%esp
c0001332:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprintn(str,len);
c0001335:	8b 45 a8             	mov    -0x58(%ebp),%eax
c0001338:	83 ec 08             	sub    $0x8,%esp
c000133b:	50                   	push   %eax
c000133c:	ff 75 a4             	pushl  -0x5c(%ebp)
c000133f:	e8 2f f5 ff ff       	call   c0000873 <kprintn>
c0001344:	83 c4 10             	add    $0x10,%esp
c0001347:	01 45 f0             	add    %eax,-0x10(%ebp)

                        if(lenpad>0 && flags.left)
c000134a:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
c000134e:	7e 31                	jle    c0001381 <kprintf+0xa9c>
c0001350:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0001357:	84 c0                	test   %al,%al
c0001359:	74 26                	je     c0001381 <kprintf+0xa9c>
                            nchar += kprintn_char(' ', lenpad);
c000135b:	8b 45 a0             	mov    -0x60(%ebp),%eax
c000135e:	83 ec 08             	sub    $0x8,%esp
c0001361:	50                   	push   %eax
c0001362:	6a 20                	push   $0x20
c0001364:	e8 53 f5 ff ff       	call   c00008bc <kprintn_char>
c0001369:	83 c4 10             	add    $0x10,%esp
c000136c:	01 45 f0             	add    %eax,-0x10(%ebp)
                        
                    }
                    break;
c000136f:	eb 10                	jmp    c0001381 <kprintf+0xa9c>
                default:
                    //unsupported type
                    return -1;
c0001371:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0001376:	eb 40                	jmp    c00013b8 <kprintf+0xad3>
                            break;
c0001378:	90                   	nop
c0001379:	eb 07                	jmp    c0001382 <kprintf+0xa9d>
                    break;
c000137b:	90                   	nop
c000137c:	eb 04                	jmp    c0001382 <kprintf+0xa9d>
                    break;
c000137e:	90                   	nop
c000137f:	eb 01                	jmp    c0001382 <kprintf+0xa9d>
                    break;
c0001381:	90                   	nop
                
            }
            f++;
c0001382:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0001386:	eb 1f                	jmp    c00013a7 <kprintf+0xac2>
        }
        else
        {
            //this isnt part of a format code, just copy char to string and increment pointers
            kprint_char(*(f++));
c0001388:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000138b:	8d 50 01             	lea    0x1(%eax),%edx
c000138e:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0001391:	0f b6 00             	movzbl (%eax),%eax
c0001394:	0f be c0             	movsbl %al,%eax
c0001397:	83 ec 0c             	sub    $0xc,%esp
c000139a:	50                   	push   %eax
c000139b:	e8 f4 f4 ff ff       	call   c0000894 <kprint_char>
c00013a0:	83 c4 10             	add    $0x10,%esp
            nchar++;
c00013a3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    while(f[0] != 0)
c00013a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00013aa:	0f b6 00             	movzbl (%eax),%eax
c00013ad:	84 c0                	test   %al,%al
c00013af:	0f 85 54 f5 ff ff    	jne    c0000909 <kprintf+0x24>
    }

   /* clean memory reserved for valist */
   va_end(valist);

   return nchar; //number of characters copied to str
c00013b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c00013b8:	c9                   	leave  
c00013b9:	c3                   	ret    

c00013ba <format_uint>:
// base may be 2-32
// precision is per printf format, precision<0 represents default (unspecified) 
// cap = 0, alpha-numbers are capitalized [base>10 only]
// returns length of string (not counting null termination)
int format_uint(unsigned int value, char* str, unsigned int base, int precision, int cap)
{
c00013ba:	55                   	push   %ebp
c00013bb:	89 e5                	mov    %esp,%ebp
c00013bd:	83 ec 18             	sub    $0x18,%esp
    if(base < 2 || base > 32)
c00013c0:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c00013c4:	76 06                	jbe    c00013cc <format_uint+0x12>
c00013c6:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
c00013ca:	76 0a                	jbe    c00013d6 <format_uint+0x1c>
        return -1;
c00013cc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00013d1:	e9 d1 00 00 00       	jmp    c00014a7 <format_uint+0xed>

    //When 0 is printed with an explicit precision 0, the output is empty.
    if(value==0 && precision==0)
c00013d6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00013da:	75 16                	jne    c00013f2 <format_uint+0x38>
c00013dc:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c00013e0:	75 10                	jne    c00013f2 <format_uint+0x38>
    {
        str[0] = 0;
c00013e2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00013e5:	c6 00 00             	movb   $0x0,(%eax)
        return 0;
c00013e8:	b8 00 00 00 00       	mov    $0x0,%eax
c00013ed:	e9 b5 00 00 00       	jmp    c00014a7 <format_uint+0xed>
    }

    // find number of digits
    int num_digits = numdigits_uint(value, base);
c00013f2:	83 ec 08             	sub    $0x8,%esp
c00013f5:	ff 75 10             	pushl  0x10(%ebp)
c00013f8:	ff 75 08             	pushl  0x8(%ebp)
c00013fb:	e8 a9 00 00 00       	call   c00014a9 <numdigits_uint>
c0001400:	83 c4 10             	add    $0x10,%esp
c0001403:	89 45 ec             	mov    %eax,-0x14(%ebp)
    num_digits = num_digits>precision ? num_digits : precision;
c0001406:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001409:	39 45 14             	cmp    %eax,0x14(%ebp)
c000140c:	0f 4d 45 14          	cmovge 0x14(%ebp),%eax
c0001410:	89 45 ec             	mov    %eax,-0x14(%ebp)

    //write formatted number out in reverse order
    char* s = str + num_digits;
c0001413:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0001416:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001419:	01 d0                	add    %edx,%eax
c000141b:	89 45 f4             	mov    %eax,-0xc(%ebp)

    *(s--) = '\0'; //null termination
c000141e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001421:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001424:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0001427:	c6 00 00             	movb   $0x0,(%eax)

    //compute each digit from lowest to highest.
    unsigned int d;
    for(int nn=0;nn<num_digits; nn++)
c000142a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0001431:	eb 69                	jmp    c000149c <format_uint+0xe2>
    {
        d = value % base;
c0001433:	8b 45 08             	mov    0x8(%ebp),%eax
c0001436:	ba 00 00 00 00       	mov    $0x0,%edx
c000143b:	f7 75 10             	divl   0x10(%ebp)
c000143e:	89 55 e8             	mov    %edx,-0x18(%ebp)
        value /= base;
c0001441:	8b 45 08             	mov    0x8(%ebp),%eax
c0001444:	ba 00 00 00 00       	mov    $0x0,%edx
c0001449:	f7 75 10             	divl   0x10(%ebp)
c000144c:	89 45 08             	mov    %eax,0x8(%ebp)

        //write digit into string and decrement pointer
        if(d < 10)
c000144f:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
c0001453:	77 15                	ja     c000146a <format_uint+0xb0>
            *(s--) = d + '0';
c0001455:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001458:	8d 48 30             	lea    0x30(%eax),%ecx
c000145b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000145e:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001461:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0001464:	89 ca                	mov    %ecx,%edx
c0001466:	88 10                	mov    %dl,(%eax)
c0001468:	eb 2e                	jmp    c0001498 <format_uint+0xde>
        else if(cap == 0)
c000146a:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
c000146e:	75 15                	jne    c0001485 <format_uint+0xcb>
            *(s--) = d - 10 + 'a';
c0001470:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001473:	8d 48 57             	lea    0x57(%eax),%ecx
c0001476:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001479:	8d 50 ff             	lea    -0x1(%eax),%edx
c000147c:	89 55 f4             	mov    %edx,-0xc(%ebp)
c000147f:	89 ca                	mov    %ecx,%edx
c0001481:	88 10                	mov    %dl,(%eax)
c0001483:	eb 13                	jmp    c0001498 <format_uint+0xde>
        else
            *(s--) = d - 10 + 'A';
c0001485:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001488:	8d 48 37             	lea    0x37(%eax),%ecx
c000148b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000148e:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001491:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0001494:	89 ca                	mov    %ecx,%edx
c0001496:	88 10                	mov    %dl,(%eax)
    for(int nn=0;nn<num_digits; nn++)
c0001498:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c000149c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000149f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00014a2:	7c 8f                	jl     c0001433 <format_uint+0x79>
    }

    return num_digits;
c00014a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c00014a7:	c9                   	leave  
c00014a8:	c3                   	ret    

c00014a9 <numdigits_uint>:


//returns number of digits of unsigned int represented in given base
//num_digits is always >= 1
unsigned int numdigits_uint(unsigned int value, unsigned int base)
{
c00014a9:	55                   	push   %ebp
c00014aa:	89 e5                	mov    %esp,%ebp
c00014ac:	83 ec 10             	sub    $0x10,%esp
    unsigned int num_digits = 1;
c00014af:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
    while(value >= base)
c00014b6:	eb 12                	jmp    c00014ca <numdigits_uint+0x21>
    {
        num_digits++;
c00014b8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        value /= base;
c00014bc:	8b 45 08             	mov    0x8(%ebp),%eax
c00014bf:	ba 00 00 00 00       	mov    $0x0,%edx
c00014c4:	f7 75 0c             	divl   0xc(%ebp)
c00014c7:	89 45 08             	mov    %eax,0x8(%ebp)
    while(value >= base)
c00014ca:	8b 45 08             	mov    0x8(%ebp),%eax
c00014cd:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00014d0:	73 e6                	jae    c00014b8 <numdigits_uint+0xf>
    }
    return num_digits;
c00014d2:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00014d5:	c9                   	leave  
c00014d6:	c3                   	ret    

c00014d7 <kprintf_test>:



void kprintf_test()
{
c00014d7:	55                   	push   %ebp
c00014d8:	89 e5                	mov    %esp,%ebp
c00014da:	83 ec 18             	sub    $0x18,%esp
    int num = 12345678;    
c00014dd:	c7 45 f4 4e 61 bc 00 	movl   $0xbc614e,-0xc(%ebp)
    kprintf("\nkprintf() tests...\n", num);
c00014e4:	83 ec 08             	sub    $0x8,%esp
c00014e7:	ff 75 f4             	pushl  -0xc(%ebp)
c00014ea:	68 d0 51 00 c0       	push   $0xc00051d0
c00014ef:	e8 f1 f3 ff ff       	call   c00008e5 <kprintf>
c00014f4:	83 c4 10             	add    $0x10,%esp
    kprintf("Fixed width, right justify:\n");
c00014f7:	83 ec 0c             	sub    $0xc,%esp
c00014fa:	68 e5 51 00 c0       	push   $0xc00051e5
c00014ff:	e8 e1 f3 ff ff       	call   c00008e5 <kprintf>
c0001504:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%15d]\n", num);
c0001507:	83 ec 08             	sub    $0x8,%esp
c000150a:	ff 75 f4             	pushl  -0xc(%ebp)
c000150d:	68 02 52 00 c0       	push   $0xc0005202
c0001512:	e8 ce f3 ff ff       	call   c00008e5 <kprintf>
c0001517:	83 c4 10             	add    $0x10,%esp
    kprintf("Hex:     [%#15x]\n", num);
c000151a:	83 ec 08             	sub    $0x8,%esp
c000151d:	ff 75 f4             	pushl  -0xc(%ebp)
c0001520:	68 13 52 00 c0       	push   $0xc0005213
c0001525:	e8 bb f3 ff ff       	call   c00008e5 <kprintf>
c000152a:	83 c4 10             	add    $0x10,%esp
    kprintf("Oct:     [%#15o]\n", num);
c000152d:	83 ec 08             	sub    $0x8,%esp
c0001530:	ff 75 f4             	pushl  -0xc(%ebp)
c0001533:	68 25 52 00 c0       	push   $0xc0005225
c0001538:	e8 a8 f3 ff ff       	call   c00008e5 <kprintf>
c000153d:	83 c4 10             	add    $0x10,%esp
    kprintf("String:  [%15s]\n", "Hello World!");
c0001540:	83 ec 08             	sub    $0x8,%esp
c0001543:	68 37 52 00 c0       	push   $0xc0005237
c0001548:	68 44 52 00 c0       	push   $0xc0005244
c000154d:	e8 93 f3 ff ff       	call   c00008e5 <kprintf>
c0001552:	83 c4 10             	add    $0x10,%esp
    kprintf("Char:    [%15c]\n", '!');
c0001555:	83 ec 08             	sub    $0x8,%esp
c0001558:	6a 21                	push   $0x21
c000155a:	68 55 52 00 c0       	push   $0xc0005255
c000155f:	e8 81 f3 ff ff       	call   c00008e5 <kprintf>
c0001564:	83 c4 10             	add    $0x10,%esp

    kprintf("\nFixed width, left justify:\n");
c0001567:	83 ec 0c             	sub    $0xc,%esp
c000156a:	68 66 52 00 c0       	push   $0xc0005266
c000156f:	e8 71 f3 ff ff       	call   c00008e5 <kprintf>
c0001574:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%-15d]\n", num);
c0001577:	83 ec 08             	sub    $0x8,%esp
c000157a:	ff 75 f4             	pushl  -0xc(%ebp)
c000157d:	68 83 52 00 c0       	push   $0xc0005283
c0001582:	e8 5e f3 ff ff       	call   c00008e5 <kprintf>
c0001587:	83 c4 10             	add    $0x10,%esp
    kprintf("Hex:     [%-#15x]\n", num);
c000158a:	83 ec 08             	sub    $0x8,%esp
c000158d:	ff 75 f4             	pushl  -0xc(%ebp)
c0001590:	68 95 52 00 c0       	push   $0xc0005295
c0001595:	e8 4b f3 ff ff       	call   c00008e5 <kprintf>
c000159a:	83 c4 10             	add    $0x10,%esp
    kprintf("String:  [%-15s]\n", "Hello World!");
c000159d:	83 ec 08             	sub    $0x8,%esp
c00015a0:	68 37 52 00 c0       	push   $0xc0005237
c00015a5:	68 a8 52 00 c0       	push   $0xc00052a8
c00015aa:	e8 36 f3 ff ff       	call   c00008e5 <kprintf>
c00015af:	83 c4 10             	add    $0x10,%esp

    kprintf("\nFixed Precision:\n");
c00015b2:	83 ec 0c             	sub    $0xc,%esp
c00015b5:	68 ba 52 00 c0       	push   $0xc00052ba
c00015ba:	e8 26 f3 ff ff       	call   c00008e5 <kprintf>
c00015bf:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%15.10d]\nHex:     [%#15.10x]\nOct:     [%#15.10o]\nString:  [%15.10s]\n", 
c00015c2:	83 ec 0c             	sub    $0xc,%esp
c00015c5:	68 37 52 00 c0       	push   $0xc0005237
c00015ca:	ff 75 f4             	pushl  -0xc(%ebp)
c00015cd:	ff 75 f4             	pushl  -0xc(%ebp)
c00015d0:	ff 75 f4             	pushl  -0xc(%ebp)
c00015d3:	68 d0 52 00 c0       	push   $0xc00052d0
c00015d8:	e8 08 f3 ff ff       	call   c00008e5 <kprintf>
c00015dd:	83 c4 20             	add    $0x20,%esp
        num, num, num, "Hello World!");

    kprintf("\nLeading Zeros:\n");
c00015e0:	83 ec 0c             	sub    $0xc,%esp
c00015e3:	68 1f 53 00 c0       	push   $0xc000531f
c00015e8:	e8 f8 f2 ff ff       	call   c00008e5 <kprintf>
c00015ed:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%015.10d]\nHex:     [%#015.10x]\nOct:     [%#015.10o]\n",num, num, num);
c00015f0:	ff 75 f4             	pushl  -0xc(%ebp)
c00015f3:	ff 75 f4             	pushl  -0xc(%ebp)
c00015f6:	ff 75 f4             	pushl  -0xc(%ebp)
c00015f9:	68 30 53 00 c0       	push   $0xc0005330
c00015fe:	e8 e2 f2 ff ff       	call   c00008e5 <kprintf>
c0001603:	83 c4 10             	add    $0x10,%esp

    kprintf("Signed (none):  [%d], [%d]\n",num, -num);
c0001606:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001609:	f7 d8                	neg    %eax
c000160b:	83 ec 04             	sub    $0x4,%esp
c000160e:	50                   	push   %eax
c000160f:	ff 75 f4             	pushl  -0xc(%ebp)
c0001612:	68 6f 53 00 c0       	push   $0xc000536f
c0001617:	e8 c9 f2 ff ff       	call   c00008e5 <kprintf>
c000161c:	83 c4 10             	add    $0x10,%esp
    kprintf("Signed (space): [% d], [% d]\n",num, -num);
c000161f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001622:	f7 d8                	neg    %eax
c0001624:	83 ec 04             	sub    $0x4,%esp
c0001627:	50                   	push   %eax
c0001628:	ff 75 f4             	pushl  -0xc(%ebp)
c000162b:	68 8b 53 00 c0       	push   $0xc000538b
c0001630:	e8 b0 f2 ff ff       	call   c00008e5 <kprintf>
c0001635:	83 c4 10             	add    $0x10,%esp
    kprintf("Signed (+):     [%+d], [%+d]\n",num, -num);
c0001638:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000163b:	f7 d8                	neg    %eax
c000163d:	83 ec 04             	sub    $0x4,%esp
c0001640:	50                   	push   %eax
c0001641:	ff 75 f4             	pushl  -0xc(%ebp)
c0001644:	68 a9 53 00 c0       	push   $0xc00053a9
c0001649:	e8 97 f2 ff ff       	call   c00008e5 <kprintf>
c000164e:	83 c4 10             	add    $0x10,%esp

    float f = 1.23456789;
c0001651:	d9 05 20 54 00 c0    	flds   0xc0005420
c0001657:	d9 5d f0             	fstps  -0x10(%ebp)
    kprintf("\nfloat:     [%15.f]\n",f);
c000165a:	d9 45 f0             	flds   -0x10(%ebp)
c000165d:	83 ec 04             	sub    $0x4,%esp
c0001660:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001664:	dd 1c 24             	fstpl  (%esp)
c0001667:	68 c7 53 00 c0       	push   $0xc00053c7
c000166c:	e8 74 f2 ff ff       	call   c00008e5 <kprintf>
c0001671:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.3f]\n",f);
c0001674:	d9 45 f0             	flds   -0x10(%ebp)
c0001677:	83 ec 04             	sub    $0x4,%esp
c000167a:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c000167e:	dd 1c 24             	fstpl  (%esp)
c0001681:	68 dc 53 00 c0       	push   $0xc00053dc
c0001686:	e8 5a f2 ff ff       	call   c00008e5 <kprintf>
c000168b:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.10f]\n",f);
c000168e:	d9 45 f0             	flds   -0x10(%ebp)
c0001691:	83 ec 04             	sub    $0x4,%esp
c0001694:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001698:	dd 1c 24             	fstpl  (%esp)
c000169b:	68 f1 53 00 c0       	push   $0xc00053f1
c00016a0:	e8 40 f2 ff ff       	call   c00008e5 <kprintf>
c00016a5:	83 c4 10             	add    $0x10,%esp

    f = -12345.6789;
c00016a8:	d9 05 24 54 00 c0    	flds   0xc0005424
c00016ae:	d9 5d f0             	fstps  -0x10(%ebp)
    kprintf("float:     [%15f]\n",f);
c00016b1:	d9 45 f0             	flds   -0x10(%ebp)
c00016b4:	83 ec 04             	sub    $0x4,%esp
c00016b7:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c00016bb:	dd 1c 24             	fstpl  (%esp)
c00016be:	68 07 54 00 c0       	push   $0xc0005407
c00016c3:	e8 1d f2 ff ff       	call   c00008e5 <kprintf>
c00016c8:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.3f]\n",f);
c00016cb:	d9 45 f0             	flds   -0x10(%ebp)
c00016ce:	83 ec 04             	sub    $0x4,%esp
c00016d1:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c00016d5:	dd 1c 24             	fstpl  (%esp)
c00016d8:	68 dc 53 00 c0       	push   $0xc00053dc
c00016dd:	e8 03 f2 ff ff       	call   c00008e5 <kprintf>
c00016e2:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.10f]\n",f);
c00016e5:	d9 45 f0             	flds   -0x10(%ebp)
c00016e8:	83 ec 04             	sub    $0x4,%esp
c00016eb:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c00016ef:	dd 1c 24             	fstpl  (%esp)
c00016f2:	68 f1 53 00 c0       	push   $0xc00053f1
c00016f7:	e8 e9 f1 ff ff       	call   c00008e5 <kprintf>
c00016fc:	83 c4 10             	add    $0x10,%esp
}
c00016ff:	90                   	nop
c0001700:	c9                   	leave  
c0001701:	c3                   	ret    

c0001702 <panic>:
#include "common.h"
#include "kprintf.h"

void panic(char* str)
{
c0001702:	55                   	push   %ebp
c0001703:	89 e5                	mov    %esp,%ebp
c0001705:	83 ec 08             	sub    $0x8,%esp
    kprintf(str);
c0001708:	83 ec 0c             	sub    $0xc,%esp
c000170b:	ff 75 08             	pushl  0x8(%ebp)
c000170e:	e8 d2 f1 ff ff       	call   c00008e5 <kprintf>
c0001713:	83 c4 10             	add    $0x10,%esp
    while(true);
c0001716:	eb fe                	jmp    c0001716 <panic+0x14>

c0001718 <strlen>:
}

size_t strlen(const char* str) 
{
c0001718:	55                   	push   %ebp
c0001719:	89 e5                	mov    %esp,%ebp
c000171b:	83 ec 10             	sub    $0x10,%esp
	size_t len = 0;
c000171e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while (str[len])
c0001725:	eb 04                	jmp    c000172b <strlen+0x13>
		len++;
c0001727:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
	while (str[len])
c000172b:	8b 55 08             	mov    0x8(%ebp),%edx
c000172e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001731:	01 d0                	add    %edx,%eax
c0001733:	0f b6 00             	movzbl (%eax),%eax
c0001736:	84 c0                	test   %al,%al
c0001738:	75 ed                	jne    c0001727 <strlen+0xf>
	return len;
c000173a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c000173d:	c9                   	leave  
c000173e:	c3                   	ret    

c000173f <memcpy>:

// copy n bytes from src to dest
void *memcpy(void *dest, const void *src, size_t n)
{
c000173f:	55                   	push   %ebp
c0001740:	89 e5                	mov    %esp,%ebp
c0001742:	83 ec 20             	sub    $0x20,%esp
    //system wordsize is equal to length of size_t
    size_t n_words = n/sizeof(size_t);
c0001745:	8b 45 10             	mov    0x10(%ebp),%eax
c0001748:	c1 e8 02             	shr    $0x2,%eax
c000174b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t* dest_word = (size_t *) dest;
c000174e:	8b 45 08             	mov    0x8(%ebp),%eax
c0001751:	89 45 f0             	mov    %eax,-0x10(%ebp)
    size_t* src_word = (size_t *) src;
c0001754:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001757:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for(size_t nn=0; nn<n_words; nn++)
c000175a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0001761:	eb 26                	jmp    c0001789 <memcpy+0x4a>
        dest_word[nn]=src_word[nn];
c0001763:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001766:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000176d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001770:	01 d0                	add    %edx,%eax
c0001772:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0001775:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
c000177c:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000177f:	01 ca                	add    %ecx,%edx
c0001781:	8b 00                	mov    (%eax),%eax
c0001783:	89 02                	mov    %eax,(%edx)
    for(size_t nn=0; nn<n_words; nn++)
c0001785:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0001789:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000178c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c000178f:	72 d2                	jb     c0001763 <memcpy+0x24>
    
    //copy remaining bytes
    size_t n_bytes = n - n_words*sizeof(size_t);
c0001791:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001794:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000179b:	8b 45 10             	mov    0x10(%ebp),%eax
c000179e:	29 d0                	sub    %edx,%eax
c00017a0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(n_bytes > 0)
c00017a3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c00017a7:	74 36                	je     c00017df <memcpy+0xa0>
    {
        char* dest_byte = (char *) dest;
c00017a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00017ac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        char* src_byte = (char *) src;
c00017af:	8b 45 0c             	mov    0xc(%ebp),%eax
c00017b2:	89 45 e0             	mov    %eax,-0x20(%ebp)
        for(size_t nn=0; nn<n_bytes; nn++)
c00017b5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c00017bc:	eb 19                	jmp    c00017d7 <memcpy+0x98>
            dest_byte[nn]=src_byte[nn];
c00017be:	8b 55 e0             	mov    -0x20(%ebp),%edx
c00017c1:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00017c4:	01 d0                	add    %edx,%eax
c00017c6:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c00017c9:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00017cc:	01 ca                	add    %ecx,%edx
c00017ce:	0f b6 00             	movzbl (%eax),%eax
c00017d1:	88 02                	mov    %al,(%edx)
        for(size_t nn=0; nn<n_bytes; nn++)
c00017d3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c00017d7:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00017da:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c00017dd:	72 df                	jb     c00017be <memcpy+0x7f>
    }

    return dest;
c00017df:	8b 45 08             	mov    0x8(%ebp),%eax
}
c00017e2:	c9                   	leave  
c00017e3:	c3                   	ret    

c00017e4 <memset>:

void* memset(void* addr, int val, size_t cnt)
{
c00017e4:	55                   	push   %ebp
c00017e5:	89 e5                	mov    %esp,%ebp
c00017e7:	83 ec 10             	sub    $0x10,%esp
    char* m = (char*) addr;
c00017ea:	8b 45 08             	mov    0x8(%ebp),%eax
c00017ed:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for(size_t nn=0;nn<cnt; nn++)
c00017f0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00017f7:	eb 11                	jmp    c000180a <memset+0x26>
        m[nn] = val;
c00017f9:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00017fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00017ff:	01 d0                	add    %edx,%eax
c0001801:	8b 55 0c             	mov    0xc(%ebp),%edx
c0001804:	88 10                	mov    %dl,(%eax)
    for(size_t nn=0;nn<cnt; nn++)
c0001806:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c000180a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000180d:	3b 45 10             	cmp    0x10(%ebp),%eax
c0001810:	72 e7                	jb     c00017f9 <memset+0x15>

    return addr;
c0001812:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0001815:	c9                   	leave  
c0001816:	c3                   	ret    

c0001817 <atoi>:


int atoi(const char* str)
{
c0001817:	55                   	push   %ebp
c0001818:	89 e5                	mov    %esp,%ebp
c000181a:	83 ec 20             	sub    $0x20,%esp
    int p = 0;
c000181d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    int neg = 0;
c0001824:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    //find start of number string, ignore whitespace
    while(str[p] == '-' || str[p] == ' ' || (str[p] >= 9 && str[p] <= 13))
c000182b:	eb 41                	jmp    c000186e <atoi+0x57>
    {
        if(str[p++] == '-')
c000182d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001830:	8d 50 01             	lea    0x1(%eax),%edx
c0001833:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001836:	89 c2                	mov    %eax,%edx
c0001838:	8b 45 08             	mov    0x8(%ebp),%eax
c000183b:	01 d0                	add    %edx,%eax
c000183d:	0f b6 00             	movzbl (%eax),%eax
c0001840:	3c 2d                	cmp    $0x2d,%al
c0001842:	75 09                	jne    c000184d <atoi+0x36>
        {
            neg=1;
c0001844:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
            break;
c000184b:	eb 5d                	jmp    c00018aa <atoi+0x93>
        }
        if(str[p++] == '\0')
c000184d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001850:	8d 50 01             	lea    0x1(%eax),%edx
c0001853:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001856:	89 c2                	mov    %eax,%edx
c0001858:	8b 45 08             	mov    0x8(%ebp),%eax
c000185b:	01 d0                	add    %edx,%eax
c000185d:	0f b6 00             	movzbl (%eax),%eax
c0001860:	84 c0                	test   %al,%al
c0001862:	75 0a                	jne    c000186e <atoi+0x57>
            return 0; //invalid string (only whitespace found)
c0001864:	b8 00 00 00 00       	mov    $0x0,%eax
c0001869:	e9 ee 00 00 00       	jmp    c000195c <atoi+0x145>
    while(str[p] == '-' || str[p] == ' ' || (str[p] >= 9 && str[p] <= 13))
c000186e:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0001871:	8b 45 08             	mov    0x8(%ebp),%eax
c0001874:	01 d0                	add    %edx,%eax
c0001876:	0f b6 00             	movzbl (%eax),%eax
c0001879:	3c 2d                	cmp    $0x2d,%al
c000187b:	74 b0                	je     c000182d <atoi+0x16>
c000187d:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0001880:	8b 45 08             	mov    0x8(%ebp),%eax
c0001883:	01 d0                	add    %edx,%eax
c0001885:	0f b6 00             	movzbl (%eax),%eax
c0001888:	3c 20                	cmp    $0x20,%al
c000188a:	74 a1                	je     c000182d <atoi+0x16>
c000188c:	8b 55 fc             	mov    -0x4(%ebp),%edx
c000188f:	8b 45 08             	mov    0x8(%ebp),%eax
c0001892:	01 d0                	add    %edx,%eax
c0001894:	0f b6 00             	movzbl (%eax),%eax
c0001897:	3c 08                	cmp    $0x8,%al
c0001899:	7e 0f                	jle    c00018aa <atoi+0x93>
c000189b:	8b 55 fc             	mov    -0x4(%ebp),%edx
c000189e:	8b 45 08             	mov    0x8(%ebp),%eax
c00018a1:	01 d0                	add    %edx,%eax
c00018a3:	0f b6 00             	movzbl (%eax),%eax
c00018a6:	3c 0d                	cmp    $0xd,%al
c00018a8:	7e 83                	jle    c000182d <atoi+0x16>
    }

    int num_start = p;
c00018aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00018ad:	89 45 e8             	mov    %eax,-0x18(%ebp)

    //find end of integer string (ints only, no decimal point)
    while(str[p] >= '0' && str[p] <= '9')
c00018b0:	eb 21                	jmp    c00018d3 <atoi+0xbc>
    {
        if(str[p++] == '\0')
c00018b2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00018b5:	8d 50 01             	lea    0x1(%eax),%edx
c00018b8:	89 55 fc             	mov    %edx,-0x4(%ebp)
c00018bb:	89 c2                	mov    %eax,%edx
c00018bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00018c0:	01 d0                	add    %edx,%eax
c00018c2:	0f b6 00             	movzbl (%eax),%eax
c00018c5:	84 c0                	test   %al,%al
c00018c7:	75 0a                	jne    c00018d3 <atoi+0xbc>
            return 0; //invalid string (only whitespace found)
c00018c9:	b8 00 00 00 00       	mov    $0x0,%eax
c00018ce:	e9 89 00 00 00       	jmp    c000195c <atoi+0x145>
    while(str[p] >= '0' && str[p] <= '9')
c00018d3:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00018d6:	8b 45 08             	mov    0x8(%ebp),%eax
c00018d9:	01 d0                	add    %edx,%eax
c00018db:	0f b6 00             	movzbl (%eax),%eax
c00018de:	3c 2f                	cmp    $0x2f,%al
c00018e0:	7e 0f                	jle    c00018f1 <atoi+0xda>
c00018e2:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00018e5:	8b 45 08             	mov    0x8(%ebp),%eax
c00018e8:	01 d0                	add    %edx,%eax
c00018ea:	0f b6 00             	movzbl (%eax),%eax
c00018ed:	3c 39                	cmp    $0x39,%al
c00018ef:	7e c1                	jle    c00018b2 <atoi+0x9b>
    }

    if(num_start == p) return 0; //length 0 string
c00018f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00018f4:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c00018f7:	75 07                	jne    c0001900 <atoi+0xe9>
c00018f9:	b8 00 00 00 00       	mov    $0x0,%eax
c00018fe:	eb 5c                	jmp    c000195c <atoi+0x145>

    int number = 0;
c0001900:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    int place = 1;
c0001907:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    //iterate backwards through number to add each digit
    for(int digit = p-1; digit >= num_start; digit--)
c000190e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001911:	83 e8 01             	sub    $0x1,%eax
c0001914:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0001917:	eb 2b                	jmp    c0001944 <atoi+0x12d>
    {
        number += (int) (str[digit] - '0') * place;
c0001919:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000191c:	8b 45 08             	mov    0x8(%ebp),%eax
c000191f:	01 d0                	add    %edx,%eax
c0001921:	0f b6 00             	movzbl (%eax),%eax
c0001924:	0f be c0             	movsbl %al,%eax
c0001927:	83 e8 30             	sub    $0x30,%eax
c000192a:	0f af 45 f0          	imul   -0x10(%ebp),%eax
c000192e:	01 45 f4             	add    %eax,-0xc(%ebp)
        place *= 10;
c0001931:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001934:	89 d0                	mov    %edx,%eax
c0001936:	c1 e0 02             	shl    $0x2,%eax
c0001939:	01 d0                	add    %edx,%eax
c000193b:	01 c0                	add    %eax,%eax
c000193d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for(int digit = p-1; digit >= num_start; digit--)
c0001940:	83 6d ec 01          	subl   $0x1,-0x14(%ebp)
c0001944:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001947:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c000194a:	7d cd                	jge    c0001919 <atoi+0x102>
    }

    if(neg)
c000194c:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0001950:	74 07                	je     c0001959 <atoi+0x142>
        return -1*number;
c0001952:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001955:	f7 d8                	neg    %eax
c0001957:	eb 03                	jmp    c000195c <atoi+0x145>
    else
        return number;
c0001959:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c000195c:	c9                   	leave  
c000195d:	c3                   	ret    

c000195e <itoa>:

char* itoa( int value, char* str, int base)
{
c000195e:	55                   	push   %ebp
c000195f:	89 e5                	mov    %esp,%ebp
c0001961:	83 ec 20             	sub    $0x20,%esp
    if(base < 2 || base > 32)
c0001964:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c0001968:	7e 06                	jle    c0001970 <itoa+0x12>
c000196a:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
c000196e:	7e 0a                	jle    c000197a <itoa+0x1c>
        return NULL;
c0001970:	b8 00 00 00 00       	mov    $0x0,%eax
c0001975:	e9 df 00 00 00       	jmp    c0001a59 <itoa+0xfb>

    //handle zero as special case 
    if(value == 0)
c000197a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c000197e:	75 17                	jne    c0001997 <itoa+0x39>
    {
        str[0] = '0';
c0001980:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001983:	c6 00 30             	movb   $0x30,(%eax)
        str[1] = '\0';
c0001986:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001989:	83 c0 01             	add    $0x1,%eax
c000198c:	c6 00 00             	movb   $0x0,(%eax)
        return str;
c000198f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001992:	e9 c2 00 00 00       	jmp    c0001a59 <itoa+0xfb>
    }

    char* s = str;
c0001997:	8b 45 0c             	mov    0xc(%ebp),%eax
c000199a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    unsigned int residual; //holds the unsigned value still to be parsed
    if(base == 10 && value < 0)
c000199d:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
c00019a1:	75 1c                	jne    c00019bf <itoa+0x61>
c00019a3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00019a7:	79 16                	jns    c00019bf <itoa+0x61>
    {
        residual = -value;
c00019a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00019ac:	f7 d8                	neg    %eax
c00019ae:	89 45 f8             	mov    %eax,-0x8(%ebp)
        *(s++) = '-';
c00019b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00019b4:	8d 50 01             	lea    0x1(%eax),%edx
c00019b7:	89 55 fc             	mov    %edx,-0x4(%ebp)
c00019ba:	c6 00 2d             	movb   $0x2d,(%eax)
c00019bd:	eb 06                	jmp    c00019c5 <itoa+0x67>
    }
    else
    {
        //all non-decimal numbers are treated as unsigned
        residual = (unsigned int) value;
c00019bf:	8b 45 08             	mov    0x8(%ebp),%eax
c00019c2:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    
    // find number of digits so that we can parse number
    // directly into string from lowest to highest digit    
    unsigned int num_digits = 0;
c00019c5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    unsigned int temp = residual;
c00019cc:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00019cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(temp>0)
c00019d2:	eb 14                	jmp    c00019e8 <itoa+0x8a>
    {
        num_digits++;
c00019d4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
        temp /= base;
c00019d8:	8b 4d 10             	mov    0x10(%ebp),%ecx
c00019db:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00019de:	ba 00 00 00 00       	mov    $0x0,%edx
c00019e3:	f7 f1                	div    %ecx
c00019e5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(temp>0)
c00019e8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00019ec:	75 e6                	jne    c00019d4 <itoa+0x76>
    }

    //point at end of string
    s += num_digits;
c00019ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00019f1:	01 45 fc             	add    %eax,-0x4(%ebp)
    *(s--) = '\0'; //null termination
c00019f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00019f7:	8d 50 ff             	lea    -0x1(%eax),%edx
c00019fa:	89 55 fc             	mov    %edx,-0x4(%ebp)
c00019fd:	c6 00 00             	movb   $0x0,(%eax)

    //compute each digit from lowest to highest.
    unsigned int digit;
    while(residual>0)
c0001a00:	eb 4e                	jmp    c0001a50 <itoa+0xf2>
    {
        digit = residual % base;
c0001a02:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0001a05:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0001a08:	ba 00 00 00 00       	mov    $0x0,%edx
c0001a0d:	f7 f1                	div    %ecx
c0001a0f:	89 55 ec             	mov    %edx,-0x14(%ebp)
        residual /= base;
c0001a12:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0001a15:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0001a18:	ba 00 00 00 00       	mov    $0x0,%edx
c0001a1d:	f7 f1                	div    %ecx
c0001a1f:	89 45 f8             	mov    %eax,-0x8(%ebp)

        //write digit into string and decrement pointer
        if(digit < 10)
c0001a22:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
c0001a26:	77 15                	ja     c0001a3d <itoa+0xdf>
            *(s--) = digit + '0';
c0001a28:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001a2b:	8d 48 30             	lea    0x30(%eax),%ecx
c0001a2e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001a31:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001a34:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001a37:	89 ca                	mov    %ecx,%edx
c0001a39:	88 10                	mov    %dl,(%eax)
c0001a3b:	eb 13                	jmp    c0001a50 <itoa+0xf2>
        else
            *(s--) = digit - 10 + 'A';        
c0001a3d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001a40:	8d 48 37             	lea    0x37(%eax),%ecx
c0001a43:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001a46:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001a49:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001a4c:	89 ca                	mov    %ecx,%edx
c0001a4e:	88 10                	mov    %dl,(%eax)
    while(residual>0)
c0001a50:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0001a54:	75 ac                	jne    c0001a02 <itoa+0xa4>
    }

    return str;
c0001a56:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c0001a59:	c9                   	leave  
c0001a5a:	c3                   	ret    

c0001a5b <printregs>:
#include "regs.h"
#include "kprintf.h"

void printregs(const reg_t* regs)
{
c0001a5b:	55                   	push   %ebp
c0001a5c:	89 e5                	mov    %esp,%ebp
c0001a5e:	57                   	push   %edi
c0001a5f:	56                   	push   %esi
c0001a60:	53                   	push   %ebx
c0001a61:	83 ec 0c             	sub    $0xc,%esp
    kprintf("Registers:\n");
c0001a64:	83 ec 0c             	sub    $0xc,%esp
c0001a67:	68 28 54 00 c0       	push   $0xc0005428
c0001a6c:	e8 74 ee ff ff       	call   c00008e5 <kprintf>
c0001a71:	83 c4 10             	add    $0x10,%esp
    kprintf("eax: 0x%x\n", regs->eax);
c0001a74:	8b 45 08             	mov    0x8(%ebp),%eax
c0001a77:	8b 00                	mov    (%eax),%eax
c0001a79:	83 ec 08             	sub    $0x8,%esp
c0001a7c:	50                   	push   %eax
c0001a7d:	68 34 54 00 c0       	push   $0xc0005434
c0001a82:	e8 5e ee ff ff       	call   c00008e5 <kprintf>
c0001a87:	83 c4 10             	add    $0x10,%esp
    kprintf("ebx: 0x%x\n", regs->ebx);
c0001a8a:	8b 45 08             	mov    0x8(%ebp),%eax
c0001a8d:	8b 40 04             	mov    0x4(%eax),%eax
c0001a90:	83 ec 08             	sub    $0x8,%esp
c0001a93:	50                   	push   %eax
c0001a94:	68 3f 54 00 c0       	push   $0xc000543f
c0001a99:	e8 47 ee ff ff       	call   c00008e5 <kprintf>
c0001a9e:	83 c4 10             	add    $0x10,%esp
    kprintf("ecx: 0x%x\n", regs->ecx);
c0001aa1:	8b 45 08             	mov    0x8(%ebp),%eax
c0001aa4:	8b 40 08             	mov    0x8(%eax),%eax
c0001aa7:	83 ec 08             	sub    $0x8,%esp
c0001aaa:	50                   	push   %eax
c0001aab:	68 4a 54 00 c0       	push   $0xc000544a
c0001ab0:	e8 30 ee ff ff       	call   c00008e5 <kprintf>
c0001ab5:	83 c4 10             	add    $0x10,%esp
    kprintf("edx: 0x%x\n", regs->edx);
c0001ab8:	8b 45 08             	mov    0x8(%ebp),%eax
c0001abb:	8b 40 0c             	mov    0xc(%eax),%eax
c0001abe:	83 ec 08             	sub    $0x8,%esp
c0001ac1:	50                   	push   %eax
c0001ac2:	68 55 54 00 c0       	push   $0xc0005455
c0001ac7:	e8 19 ee ff ff       	call   c00008e5 <kprintf>
c0001acc:	83 c4 10             	add    $0x10,%esp
    kprintf("esi: 0x%x\n", regs->esi);
c0001acf:	8b 45 08             	mov    0x8(%ebp),%eax
c0001ad2:	8b 40 10             	mov    0x10(%eax),%eax
c0001ad5:	83 ec 08             	sub    $0x8,%esp
c0001ad8:	50                   	push   %eax
c0001ad9:	68 60 54 00 c0       	push   $0xc0005460
c0001ade:	e8 02 ee ff ff       	call   c00008e5 <kprintf>
c0001ae3:	83 c4 10             	add    $0x10,%esp
    kprintf("edi: 0x%x\n", regs->edi);
c0001ae6:	8b 45 08             	mov    0x8(%ebp),%eax
c0001ae9:	8b 40 14             	mov    0x14(%eax),%eax
c0001aec:	83 ec 08             	sub    $0x8,%esp
c0001aef:	50                   	push   %eax
c0001af0:	68 6b 54 00 c0       	push   $0xc000546b
c0001af5:	e8 eb ed ff ff       	call   c00008e5 <kprintf>
c0001afa:	83 c4 10             	add    $0x10,%esp
    kprintf("ebp: 0x%x\n", regs->ebp);
c0001afd:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b00:	8b 40 1c             	mov    0x1c(%eax),%eax
c0001b03:	83 ec 08             	sub    $0x8,%esp
c0001b06:	50                   	push   %eax
c0001b07:	68 76 54 00 c0       	push   $0xc0005476
c0001b0c:	e8 d4 ed ff ff       	call   c00008e5 <kprintf>
c0001b11:	83 c4 10             	add    $0x10,%esp
    kprintf("esp: 0x%x\n", regs->esp);
c0001b14:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b17:	8b 40 18             	mov    0x18(%eax),%eax
c0001b1a:	83 ec 08             	sub    $0x8,%esp
c0001b1d:	50                   	push   %eax
c0001b1e:	68 81 54 00 c0       	push   $0xc0005481
c0001b23:	e8 bd ed ff ff       	call   c00008e5 <kprintf>
c0001b28:	83 c4 10             	add    $0x10,%esp
    kprintf("eip: 0x%x\n", regs->eip);
c0001b2b:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b2e:	8b 40 20             	mov    0x20(%eax),%eax
c0001b31:	83 ec 08             	sub    $0x8,%esp
c0001b34:	50                   	push   %eax
c0001b35:	68 8c 54 00 c0       	push   $0xc000548c
c0001b3a:	e8 a6 ed ff ff       	call   c00008e5 <kprintf>
c0001b3f:	83 c4 10             	add    $0x10,%esp
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
                                                            (regs->eflags&EFLAGS_PF) == EFLAGS_PF,
                                                            (regs->eflags&EFLAGS_AF) == EFLAGS_AF,
                                                            (regs->eflags&EFLAGS_ZF) == EFLAGS_ZF,
                                                            (regs->eflags&EFLAGS_SF) == EFLAGS_SF,
                                                            (regs->eflags&EFLAGS_TF) == EFLAGS_TF);
c0001b42:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b45:	8b 40 24             	mov    0x24(%eax),%eax
c0001b48:	25 00 01 00 00       	and    $0x100,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c0001b4d:	85 c0                	test   %eax,%eax
c0001b4f:	0f 95 c0             	setne  %al
c0001b52:	0f b6 f8             	movzbl %al,%edi
                                                            (regs->eflags&EFLAGS_SF) == EFLAGS_SF,
c0001b55:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b58:	8b 40 24             	mov    0x24(%eax),%eax
c0001b5b:	25 80 00 00 00       	and    $0x80,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c0001b60:	85 c0                	test   %eax,%eax
c0001b62:	0f 95 c0             	setne  %al
c0001b65:	0f b6 f0             	movzbl %al,%esi
                                                            (regs->eflags&EFLAGS_ZF) == EFLAGS_ZF,
c0001b68:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b6b:	8b 40 24             	mov    0x24(%eax),%eax
c0001b6e:	83 e0 40             	and    $0x40,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c0001b71:	85 c0                	test   %eax,%eax
c0001b73:	0f 95 c0             	setne  %al
c0001b76:	0f b6 d8             	movzbl %al,%ebx
                                                            (regs->eflags&EFLAGS_AF) == EFLAGS_AF,
c0001b79:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b7c:	8b 40 24             	mov    0x24(%eax),%eax
c0001b7f:	83 e0 10             	and    $0x10,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c0001b82:	85 c0                	test   %eax,%eax
c0001b84:	0f 95 c0             	setne  %al
c0001b87:	0f b6 c8             	movzbl %al,%ecx
                                                            (regs->eflags&EFLAGS_PF) == EFLAGS_PF,
c0001b8a:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b8d:	8b 40 24             	mov    0x24(%eax),%eax
c0001b90:	83 e0 04             	and    $0x4,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c0001b93:	85 c0                	test   %eax,%eax
c0001b95:	0f 95 c0             	setne  %al
c0001b98:	0f b6 d0             	movzbl %al,%edx
c0001b9b:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b9e:	8b 40 24             	mov    0x24(%eax),%eax
c0001ba1:	83 e0 01             	and    $0x1,%eax
c0001ba4:	85 c0                	test   %eax,%eax
c0001ba6:	0f 95 c0             	setne  %al
c0001ba9:	0f b6 c0             	movzbl %al,%eax
c0001bac:	83 ec 04             	sub    $0x4,%esp
c0001baf:	57                   	push   %edi
c0001bb0:	56                   	push   %esi
c0001bb1:	53                   	push   %ebx
c0001bb2:	51                   	push   %ecx
c0001bb3:	52                   	push   %edx
c0001bb4:	50                   	push   %eax
c0001bb5:	68 98 54 00 c0       	push   $0xc0005498
c0001bba:	e8 26 ed ff ff       	call   c00008e5 <kprintf>
c0001bbf:	83 c4 20             	add    $0x20,%esp
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
                                                            (regs->eflags&EFLAGS_DF) == EFLAGS_DF,
                                                            (regs->eflags&EFLAGS_OF) == EFLAGS_OF,
                                                            (regs->eflags&EFLAGS_IOPL) >> 12,
                                                            (regs->eflags&EFLAGS_NT) == EFLAGS_NT,
                                                            (regs->eflags&EFLAGS_RF) == EFLAGS_RF);
c0001bc2:	8b 45 08             	mov    0x8(%ebp),%eax
c0001bc5:	8b 40 24             	mov    0x24(%eax),%eax
c0001bc8:	25 00 00 01 00       	and    $0x10000,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001bcd:	85 c0                	test   %eax,%eax
c0001bcf:	0f 95 c0             	setne  %al
c0001bd2:	0f b6 f0             	movzbl %al,%esi
                                                            (regs->eflags&EFLAGS_NT) == EFLAGS_NT,
c0001bd5:	8b 45 08             	mov    0x8(%ebp),%eax
c0001bd8:	8b 40 24             	mov    0x24(%eax),%eax
c0001bdb:	25 00 40 00 00       	and    $0x4000,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001be0:	85 c0                	test   %eax,%eax
c0001be2:	0f 95 c0             	setne  %al
c0001be5:	0f b6 d8             	movzbl %al,%ebx
                                                            (regs->eflags&EFLAGS_IOPL) >> 12,
c0001be8:	8b 45 08             	mov    0x8(%ebp),%eax
c0001beb:	8b 40 24             	mov    0x24(%eax),%eax
c0001bee:	c1 e8 0c             	shr    $0xc,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001bf1:	83 e0 03             	and    $0x3,%eax
c0001bf4:	89 c7                	mov    %eax,%edi
                                                            (regs->eflags&EFLAGS_OF) == EFLAGS_OF,
c0001bf6:	8b 45 08             	mov    0x8(%ebp),%eax
c0001bf9:	8b 40 24             	mov    0x24(%eax),%eax
c0001bfc:	25 00 08 00 00       	and    $0x800,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001c01:	85 c0                	test   %eax,%eax
c0001c03:	0f 95 c0             	setne  %al
c0001c06:	0f b6 c8             	movzbl %al,%ecx
                                                            (regs->eflags&EFLAGS_DF) == EFLAGS_DF,
c0001c09:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c0c:	8b 40 24             	mov    0x24(%eax),%eax
c0001c0f:	25 00 04 00 00       	and    $0x400,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001c14:	85 c0                	test   %eax,%eax
c0001c16:	0f 95 c0             	setne  %al
c0001c19:	0f b6 d0             	movzbl %al,%edx
c0001c1c:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c1f:	8b 40 24             	mov    0x24(%eax),%eax
c0001c22:	25 00 02 00 00       	and    $0x200,%eax
c0001c27:	85 c0                	test   %eax,%eax
c0001c29:	0f 95 c0             	setne  %al
c0001c2c:	0f b6 c0             	movzbl %al,%eax
c0001c2f:	83 ec 04             	sub    $0x4,%esp
c0001c32:	56                   	push   %esi
c0001c33:	53                   	push   %ebx
c0001c34:	57                   	push   %edi
c0001c35:	51                   	push   %ecx
c0001c36:	52                   	push   %edx
c0001c37:	50                   	push   %eax
c0001c38:	68 c8 54 00 c0       	push   $0xc00054c8
c0001c3d:	e8 a3 ec ff ff       	call   c00008e5 <kprintf>
c0001c42:	83 c4 20             	add    $0x20,%esp
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
                                                            (regs->eflags&EFLAGS_AC) == EFLAGS_AC,
                                                            (regs->eflags&EFLAGS_VIF) == EFLAGS_VIF,
                                                            (regs->eflags&EFLAGS_VIP) == EFLAGS_VIP,
                                                            (regs->eflags&EFLAGS_ID) == EFLAGS_ID);
c0001c45:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c48:	8b 40 24             	mov    0x24(%eax),%eax
c0001c4b:	25 00 00 20 00       	and    $0x200000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c0001c50:	85 c0                	test   %eax,%eax
c0001c52:	0f 95 c0             	setne  %al
c0001c55:	0f b6 f0             	movzbl %al,%esi
                                                            (regs->eflags&EFLAGS_VIP) == EFLAGS_VIP,
c0001c58:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c5b:	8b 40 24             	mov    0x24(%eax),%eax
c0001c5e:	25 00 00 10 00       	and    $0x100000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c0001c63:	85 c0                	test   %eax,%eax
c0001c65:	0f 95 c0             	setne  %al
c0001c68:	0f b6 d8             	movzbl %al,%ebx
                                                            (regs->eflags&EFLAGS_VIF) == EFLAGS_VIF,
c0001c6b:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c6e:	8b 40 24             	mov    0x24(%eax),%eax
c0001c71:	25 00 00 08 00       	and    $0x80000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c0001c76:	85 c0                	test   %eax,%eax
c0001c78:	0f 95 c0             	setne  %al
c0001c7b:	0f b6 c8             	movzbl %al,%ecx
                                                            (regs->eflags&EFLAGS_AC) == EFLAGS_AC,
c0001c7e:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c81:	8b 40 24             	mov    0x24(%eax),%eax
c0001c84:	25 00 00 04 00       	and    $0x40000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c0001c89:	85 c0                	test   %eax,%eax
c0001c8b:	0f 95 c0             	setne  %al
c0001c8e:	0f b6 d0             	movzbl %al,%edx
c0001c91:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c94:	8b 40 24             	mov    0x24(%eax),%eax
c0001c97:	25 00 00 02 00       	and    $0x20000,%eax
c0001c9c:	85 c0                	test   %eax,%eax
c0001c9e:	0f 95 c0             	setne  %al
c0001ca1:	0f b6 c0             	movzbl %al,%eax
c0001ca4:	83 ec 08             	sub    $0x8,%esp
c0001ca7:	56                   	push   %esi
c0001ca8:	53                   	push   %ebx
c0001ca9:	51                   	push   %ecx
c0001caa:	52                   	push   %edx
c0001cab:	50                   	push   %eax
c0001cac:	68 f8 54 00 c0       	push   $0xc00054f8
c0001cb1:	e8 2f ec ff ff       	call   c00008e5 <kprintf>
c0001cb6:	83 c4 20             	add    $0x20,%esp
    kprintf("cr0: 0x%x\n", regs->cr0);
c0001cb9:	8b 45 08             	mov    0x8(%ebp),%eax
c0001cbc:	8b 40 28             	mov    0x28(%eax),%eax
c0001cbf:	83 ec 08             	sub    $0x8,%esp
c0001cc2:	50                   	push   %eax
c0001cc3:	68 21 55 00 c0       	push   $0xc0005521
c0001cc8:	e8 18 ec ff ff       	call   c00008e5 <kprintf>
c0001ccd:	83 c4 10             	add    $0x10,%esp
    kprintf("cr2: 0x%x\n", regs->cr2);
c0001cd0:	8b 45 08             	mov    0x8(%ebp),%eax
c0001cd3:	8b 40 2c             	mov    0x2c(%eax),%eax
c0001cd6:	83 ec 08             	sub    $0x8,%esp
c0001cd9:	50                   	push   %eax
c0001cda:	68 2c 55 00 c0       	push   $0xc000552c
c0001cdf:	e8 01 ec ff ff       	call   c00008e5 <kprintf>
c0001ce4:	83 c4 10             	add    $0x10,%esp
    kprintf("cr3: 0x%x\n", regs->cr3);
c0001ce7:	8b 45 08             	mov    0x8(%ebp),%eax
c0001cea:	8b 40 30             	mov    0x30(%eax),%eax
c0001ced:	83 ec 08             	sub    $0x8,%esp
c0001cf0:	50                   	push   %eax
c0001cf1:	68 37 55 00 c0       	push   $0xc0005537
c0001cf6:	e8 ea eb ff ff       	call   c00008e5 <kprintf>
c0001cfb:	83 c4 10             	add    $0x10,%esp
    kprintf("cr4: 0x%x\n", regs->cr4);
c0001cfe:	8b 45 08             	mov    0x8(%ebp),%eax
c0001d01:	8b 40 34             	mov    0x34(%eax),%eax
c0001d04:	83 ec 08             	sub    $0x8,%esp
c0001d07:	50                   	push   %eax
c0001d08:	68 42 55 00 c0       	push   $0xc0005542
c0001d0d:	e8 d3 eb ff ff       	call   c00008e5 <kprintf>
c0001d12:	83 c4 10             	add    $0x10,%esp
}
c0001d15:	90                   	nop
c0001d16:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0001d19:	5b                   	pop    %ebx
c0001d1a:	5e                   	pop    %esi
c0001d1b:	5f                   	pop    %edi
c0001d1c:	5d                   	pop    %ebp
c0001d1d:	c3                   	ret    

c0001d1e <memory_table>:
#include "multiboot.h"
#include "kprintf.h"

size_t memory_table(multiboot_info_t* mbd)
{
c0001d1e:	55                   	push   %ebp
c0001d1f:	89 e5                	mov    %esp,%ebp
c0001d21:	56                   	push   %esi
c0001d22:	53                   	push   %ebx
c0001d23:	83 ec 10             	sub    $0x10,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c0001d26:	8b 45 08             	mov    0x8(%ebp),%eax
c0001d29:	8b 40 30             	mov    0x30(%eax),%eax
c0001d2c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    size_t available_mem = 0;
c0001d2f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001d36:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0001d3d:	e9 83 00 00 00       	jmp    c0001dc5 <memory_table+0xa7>
	{
		if(mmap_table[nn].len>0 && mmap_table[nn].size>0)
c0001d42:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001d45:	89 d0                	mov    %edx,%eax
c0001d47:	01 c0                	add    %eax,%eax
c0001d49:	01 d0                	add    %edx,%eax
c0001d4b:	c1 e0 03             	shl    $0x3,%eax
c0001d4e:	89 c2                	mov    %eax,%edx
c0001d50:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001d53:	01 d0                	add    %edx,%eax
c0001d55:	8b 50 10             	mov    0x10(%eax),%edx
c0001d58:	8b 40 0c             	mov    0xc(%eax),%eax
c0001d5b:	89 c6                	mov    %eax,%esi
c0001d5d:	83 f6 00             	xor    $0x0,%esi
c0001d60:	89 f1                	mov    %esi,%ecx
c0001d62:	89 d0                	mov    %edx,%eax
c0001d64:	80 f4 00             	xor    $0x0,%ah
c0001d67:	89 c3                	mov    %eax,%ebx
c0001d69:	89 d8                	mov    %ebx,%eax
c0001d6b:	09 c8                	or     %ecx,%eax
c0001d6d:	85 c0                	test   %eax,%eax
c0001d6f:	74 50                	je     c0001dc1 <memory_table+0xa3>
c0001d71:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001d74:	89 d0                	mov    %edx,%eax
c0001d76:	01 c0                	add    %eax,%eax
c0001d78:	01 d0                	add    %edx,%eax
c0001d7a:	c1 e0 03             	shl    $0x3,%eax
c0001d7d:	89 c2                	mov    %eax,%edx
c0001d7f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001d82:	01 d0                	add    %edx,%eax
c0001d84:	8b 00                	mov    (%eax),%eax
c0001d86:	85 c0                	test   %eax,%eax
c0001d88:	74 37                	je     c0001dc1 <memory_table+0xa3>
        {
            if(mmap_table[nn].type == 1)
c0001d8a:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001d8d:	89 d0                	mov    %edx,%eax
c0001d8f:	01 c0                	add    %eax,%eax
c0001d91:	01 d0                	add    %edx,%eax
c0001d93:	c1 e0 03             	shl    $0x3,%eax
c0001d96:	89 c2                	mov    %eax,%edx
c0001d98:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001d9b:	01 d0                	add    %edx,%eax
c0001d9d:	8b 40 14             	mov    0x14(%eax),%eax
c0001da0:	83 f8 01             	cmp    $0x1,%eax
c0001da3:	75 1c                	jne    c0001dc1 <memory_table+0xa3>
            available_mem += mmap_table[nn].len;
c0001da5:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001da8:	89 d0                	mov    %edx,%eax
c0001daa:	01 c0                	add    %eax,%eax
c0001dac:	01 d0                	add    %edx,%eax
c0001dae:	c1 e0 03             	shl    $0x3,%eax
c0001db1:	89 c2                	mov    %eax,%edx
c0001db3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001db6:	01 d0                	add    %edx,%eax
c0001db8:	8b 50 10             	mov    0x10(%eax),%edx
c0001dbb:	8b 40 0c             	mov    0xc(%eax),%eax
c0001dbe:	01 45 f4             	add    %eax,-0xc(%ebp)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001dc1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0001dc5:	8b 45 08             	mov    0x8(%ebp),%eax
c0001dc8:	8b 40 2c             	mov    0x2c(%eax),%eax
c0001dcb:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0001dce:	0f 82 6e ff ff ff    	jb     c0001d42 <memory_table+0x24>
        }
		
	}

    return available_mem;
c0001dd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0001dd7:	83 c4 10             	add    $0x10,%esp
c0001dda:	5b                   	pop    %ebx
c0001ddb:	5e                   	pop    %esi
c0001ddc:	5d                   	pop    %ebp
c0001ddd:	c3                   	ret    

c0001dde <print_memory_table>:

int print_memory_table(multiboot_info_t* mbd)
{
c0001dde:	55                   	push   %ebp
c0001ddf:	89 e5                	mov    %esp,%ebp
c0001de1:	57                   	push   %edi
c0001de2:	56                   	push   %esi
c0001de3:	53                   	push   %ebx
c0001de4:	83 ec 2c             	sub    $0x2c,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c0001de7:	8b 45 08             	mov    0x8(%ebp),%eax
c0001dea:	8b 40 30             	mov    0x30(%eax),%eax
c0001ded:	89 45 e0             	mov    %eax,-0x20(%ebp)
	kprintf("Memory Table:\n");
c0001df0:	83 ec 0c             	sub    $0xc,%esp
c0001df3:	68 50 55 00 c0       	push   $0xc0005550
c0001df8:	e8 e8 ea ff ff       	call   c00008e5 <kprintf>
c0001dfd:	83 c4 10             	add    $0x10,%esp
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001e00:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c0001e07:	e9 a6 01 00 00       	jmp    c0001fb2 <print_memory_table+0x1d4>
	{
        if(mmap_table[nn].size == 0)
c0001e0c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001e0f:	89 d0                	mov    %edx,%eax
c0001e11:	01 c0                	add    %eax,%eax
c0001e13:	01 d0                	add    %edx,%eax
c0001e15:	c1 e0 03             	shl    $0x3,%eax
c0001e18:	89 c2                	mov    %eax,%edx
c0001e1a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001e1d:	01 d0                	add    %edx,%eax
c0001e1f:	8b 00                	mov    (%eax),%eax
c0001e21:	85 c0                	test   %eax,%eax
c0001e23:	0f 84 9a 01 00 00    	je     c0001fc3 <print_memory_table+0x1e5>
            break;

		if(mmap_table[nn].len>0)
c0001e29:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001e2c:	89 d0                	mov    %edx,%eax
c0001e2e:	01 c0                	add    %eax,%eax
c0001e30:	01 d0                	add    %edx,%eax
c0001e32:	c1 e0 03             	shl    $0x3,%eax
c0001e35:	89 c2                	mov    %eax,%edx
c0001e37:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001e3a:	01 d0                	add    %edx,%eax
c0001e3c:	8b 50 10             	mov    0x10(%eax),%edx
c0001e3f:	8b 40 0c             	mov    0xc(%eax),%eax
c0001e42:	89 c7                	mov    %eax,%edi
c0001e44:	83 f7 00             	xor    $0x0,%edi
c0001e47:	89 7d d0             	mov    %edi,-0x30(%ebp)
c0001e4a:	89 d0                	mov    %edx,%eax
c0001e4c:	80 f4 00             	xor    $0x0,%ah
c0001e4f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
c0001e52:	8b 5d d0             	mov    -0x30(%ebp),%ebx
c0001e55:	8b 75 d4             	mov    -0x2c(%ebp),%esi
c0001e58:	89 f0                	mov    %esi,%eax
c0001e5a:	09 d8                	or     %ebx,%eax
c0001e5c:	85 c0                	test   %eax,%eax
c0001e5e:	0f 84 4a 01 00 00    	je     c0001fae <print_memory_table+0x1d0>
		{
			if(mmap_table[nn].type == MULTIBOOT_MEMORY_AVAILABLE)
c0001e64:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001e67:	89 d0                	mov    %edx,%eax
c0001e69:	01 c0                	add    %eax,%eax
c0001e6b:	01 d0                	add    %edx,%eax
c0001e6d:	c1 e0 03             	shl    $0x3,%eax
c0001e70:	89 c2                	mov    %eax,%edx
c0001e72:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001e75:	01 d0                	add    %edx,%eax
c0001e77:	8b 40 14             	mov    0x14(%eax),%eax
c0001e7a:	83 f8 01             	cmp    $0x1,%eax
c0001e7d:	0f 85 98 00 00 00    	jne    c0001f1b <print_memory_table+0x13d>
				kprintf("%.8llp - %.8llp [AVAILABLE] (%6llu kiB)\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c0001e83:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001e86:	89 d0                	mov    %edx,%eax
c0001e88:	01 c0                	add    %eax,%eax
c0001e8a:	01 d0                	add    %edx,%eax
c0001e8c:	c1 e0 03             	shl    $0x3,%eax
c0001e8f:	89 c2                	mov    %eax,%edx
c0001e91:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001e94:	01 d0                	add    %edx,%eax
c0001e96:	8b 50 10             	mov    0x10(%eax),%edx
c0001e99:	8b 40 0c             	mov    0xc(%eax),%eax
c0001e9c:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c0001ea0:	c1 ea 0a             	shr    $0xa,%edx
c0001ea3:	89 c6                	mov    %eax,%esi
c0001ea5:	89 d7                	mov    %edx,%edi
c0001ea7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001eaa:	89 d0                	mov    %edx,%eax
c0001eac:	01 c0                	add    %eax,%eax
c0001eae:	01 d0                	add    %edx,%eax
c0001eb0:	c1 e0 03             	shl    $0x3,%eax
c0001eb3:	89 c2                	mov    %eax,%edx
c0001eb5:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001eb8:	01 d0                	add    %edx,%eax
c0001eba:	8b 48 04             	mov    0x4(%eax),%ecx
c0001ebd:	8b 58 08             	mov    0x8(%eax),%ebx
c0001ec0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001ec3:	89 d0                	mov    %edx,%eax
c0001ec5:	01 c0                	add    %eax,%eax
c0001ec7:	01 d0                	add    %edx,%eax
c0001ec9:	c1 e0 03             	shl    $0x3,%eax
c0001ecc:	89 c2                	mov    %eax,%edx
c0001ece:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001ed1:	01 d0                	add    %edx,%eax
c0001ed3:	8b 50 10             	mov    0x10(%eax),%edx
c0001ed6:	8b 40 0c             	mov    0xc(%eax),%eax
c0001ed9:	01 c8                	add    %ecx,%eax
c0001edb:	11 da                	adc    %ebx,%edx
c0001edd:	83 c0 ff             	add    $0xffffffff,%eax
c0001ee0:	83 d2 ff             	adc    $0xffffffff,%edx
c0001ee3:	89 c1                	mov    %eax,%ecx
c0001ee5:	89 d3                	mov    %edx,%ebx
c0001ee7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001eea:	89 d0                	mov    %edx,%eax
c0001eec:	01 c0                	add    %eax,%eax
c0001eee:	01 d0                	add    %edx,%eax
c0001ef0:	c1 e0 03             	shl    $0x3,%eax
c0001ef3:	89 c2                	mov    %eax,%edx
c0001ef5:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001ef8:	01 d0                	add    %edx,%eax
c0001efa:	8b 50 08             	mov    0x8(%eax),%edx
c0001efd:	8b 40 04             	mov    0x4(%eax),%eax
c0001f00:	83 ec 04             	sub    $0x4,%esp
c0001f03:	57                   	push   %edi
c0001f04:	56                   	push   %esi
c0001f05:	53                   	push   %ebx
c0001f06:	51                   	push   %ecx
c0001f07:	52                   	push   %edx
c0001f08:	50                   	push   %eax
c0001f09:	68 60 55 00 c0       	push   $0xc0005560
c0001f0e:	e8 d2 e9 ff ff       	call   c00008e5 <kprintf>
c0001f13:	83 c4 20             	add    $0x20,%esp
c0001f16:	e9 93 00 00 00       	jmp    c0001fae <print_memory_table+0x1d0>
			else
				kprintf("%.8llp - %.8llp [RESERVED]\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c0001f1b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001f1e:	89 d0                	mov    %edx,%eax
c0001f20:	01 c0                	add    %eax,%eax
c0001f22:	01 d0                	add    %edx,%eax
c0001f24:	c1 e0 03             	shl    $0x3,%eax
c0001f27:	89 c2                	mov    %eax,%edx
c0001f29:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001f2c:	01 d0                	add    %edx,%eax
c0001f2e:	8b 50 10             	mov    0x10(%eax),%edx
c0001f31:	8b 40 0c             	mov    0xc(%eax),%eax
c0001f34:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c0001f38:	c1 ea 0a             	shr    $0xa,%edx
c0001f3b:	89 c6                	mov    %eax,%esi
c0001f3d:	89 d7                	mov    %edx,%edi
c0001f3f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001f42:	89 d0                	mov    %edx,%eax
c0001f44:	01 c0                	add    %eax,%eax
c0001f46:	01 d0                	add    %edx,%eax
c0001f48:	c1 e0 03             	shl    $0x3,%eax
c0001f4b:	89 c2                	mov    %eax,%edx
c0001f4d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001f50:	01 d0                	add    %edx,%eax
c0001f52:	8b 48 04             	mov    0x4(%eax),%ecx
c0001f55:	8b 58 08             	mov    0x8(%eax),%ebx
c0001f58:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001f5b:	89 d0                	mov    %edx,%eax
c0001f5d:	01 c0                	add    %eax,%eax
c0001f5f:	01 d0                	add    %edx,%eax
c0001f61:	c1 e0 03             	shl    $0x3,%eax
c0001f64:	89 c2                	mov    %eax,%edx
c0001f66:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001f69:	01 d0                	add    %edx,%eax
c0001f6b:	8b 50 10             	mov    0x10(%eax),%edx
c0001f6e:	8b 40 0c             	mov    0xc(%eax),%eax
c0001f71:	01 c8                	add    %ecx,%eax
c0001f73:	11 da                	adc    %ebx,%edx
c0001f75:	83 c0 ff             	add    $0xffffffff,%eax
c0001f78:	83 d2 ff             	adc    $0xffffffff,%edx
c0001f7b:	89 c1                	mov    %eax,%ecx
c0001f7d:	89 d3                	mov    %edx,%ebx
c0001f7f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001f82:	89 d0                	mov    %edx,%eax
c0001f84:	01 c0                	add    %eax,%eax
c0001f86:	01 d0                	add    %edx,%eax
c0001f88:	c1 e0 03             	shl    $0x3,%eax
c0001f8b:	89 c2                	mov    %eax,%edx
c0001f8d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001f90:	01 d0                	add    %edx,%eax
c0001f92:	8b 50 08             	mov    0x8(%eax),%edx
c0001f95:	8b 40 04             	mov    0x4(%eax),%eax
c0001f98:	83 ec 04             	sub    $0x4,%esp
c0001f9b:	57                   	push   %edi
c0001f9c:	56                   	push   %esi
c0001f9d:	53                   	push   %ebx
c0001f9e:	51                   	push   %ecx
c0001f9f:	52                   	push   %edx
c0001fa0:	50                   	push   %eax
c0001fa1:	68 89 55 00 c0       	push   $0xc0005589
c0001fa6:	e8 3a e9 ff ff       	call   c00008e5 <kprintf>
c0001fab:	83 c4 20             	add    $0x20,%esp
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001fae:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c0001fb2:	8b 45 08             	mov    0x8(%ebp),%eax
c0001fb5:	8b 40 2c             	mov    0x2c(%eax),%eax
c0001fb8:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c0001fbb:	0f 82 4b fe ff ff    	jb     c0001e0c <print_memory_table+0x2e>
c0001fc1:	eb 01                	jmp    c0001fc4 <print_memory_table+0x1e6>
            break;
c0001fc3:	90                   	nop
		}
		
	}

    return 0;
c0001fc4:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0001fc9:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0001fcc:	5b                   	pop    %ebx
c0001fcd:	5e                   	pop    %esi
c0001fce:	5f                   	pop    %edi
c0001fcf:	5d                   	pop    %ebp
c0001fd0:	c3                   	ret    

c0001fd1 <inb>:
{
c0001fd1:	55                   	push   %ebp
c0001fd2:	89 e5                	mov    %esp,%ebp
c0001fd4:	83 ec 14             	sub    $0x14,%esp
c0001fd7:	8b 45 08             	mov    0x8(%ebp),%eax
c0001fda:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  __asm__ __volatile__ ("inb %w1,%0":"=a" (_v):"Nd" (__port));
c0001fde:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0001fe2:	89 c2                	mov    %eax,%edx
c0001fe4:	ec                   	in     (%dx),%al
c0001fe5:	88 45 ff             	mov    %al,-0x1(%ebp)
  return _v;
c0001fe8:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0001fec:	c9                   	leave  
c0001fed:	c3                   	ret    

c0001fee <outb>:
{
c0001fee:	55                   	push   %ebp
c0001fef:	89 e5                	mov    %esp,%ebp
c0001ff1:	83 ec 08             	sub    $0x8,%esp
c0001ff4:	8b 55 08             	mov    0x8(%ebp),%edx
c0001ff7:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001ffa:	88 55 fc             	mov    %dl,-0x4(%ebp)
c0001ffd:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
c0002001:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0002005:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
c0002009:	ee                   	out    %al,(%dx)
}
c000200a:	90                   	nop
c000200b:	c9                   	leave  
c000200c:	c3                   	ret    

c000200d <init_interrupts>:

idt_entry_t __aligned idt[NUM_INTERRUPT_HANDLERS] = {0};
idt_descriptor_t __aligned idtd;

int init_interrupts()
{
c000200d:	55                   	push   %ebp
c000200e:	89 e5                	mov    %esp,%ebp
c0002010:	83 ec 08             	sub    $0x8,%esp
    /* init the PIC */
	outb(PIC_INIT, PIC1_CMD);  // init PIC 1
c0002013:	6a 20                	push   $0x20
c0002015:	6a 11                	push   $0x11
c0002017:	e8 d2 ff ff ff       	call   c0001fee <outb>
c000201c:	83 c4 08             	add    $0x8,%esp
    outb(PIC_INIT, PIC2_CMD);  // init PIC 2
c000201f:	68 a0 00 00 00       	push   $0xa0
c0002024:	6a 11                	push   $0x11
c0002026:	e8 c3 ff ff ff       	call   c0001fee <outb>
c000202b:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_OFFSET, PIC1_DATA); // map irq 0x0-0x7 to int 0x20-0x27
c000202e:	6a 21                	push   $0x21
c0002030:	6a 20                	push   $0x20
c0002032:	e8 b7 ff ff ff       	call   c0001fee <outb>
c0002037:	83 c4 08             	add    $0x8,%esp
    outb(PIC2_OFFSET, PIC2_DATA); // map irq 0x8-0xf to int 0x28-0x2f
c000203a:	68 a1 00 00 00       	push   $0xa1
c000203f:	6a 28                	push   $0x28
c0002041:	e8 a8 ff ff ff       	call   c0001fee <outb>
c0002046:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_MS, PIC1_DATA);     // pic1 is master, with slave at irq 2
c0002049:	6a 21                	push   $0x21
c000204b:	6a 04                	push   $0x4
c000204d:	e8 9c ff ff ff       	call   c0001fee <outb>
c0002052:	83 c4 08             	add    $0x8,%esp
    outb(PIC2_MS, PIC2_DATA);     // pic2 is slave with id 2
c0002055:	68 a1 00 00 00       	push   $0xa1
c000205a:	6a 02                	push   $0x2
c000205c:	e8 8d ff ff ff       	call   c0001fee <outb>
c0002061:	83 c4 08             	add    $0x8,%esp
    outb(PIC_8086MODE, PIC1_DATA); //enable 8086 mode
c0002064:	6a 21                	push   $0x21
c0002066:	6a 01                	push   $0x1
c0002068:	e8 81 ff ff ff       	call   c0001fee <outb>
c000206d:	83 c4 08             	add    $0x8,%esp
    outb(PIC_8086MODE, PIC2_DATA); //enable 8086 mode
c0002070:	68 a1 00 00 00       	push   $0xa1
c0002075:	6a 01                	push   $0x1
c0002077:	e8 72 ff ff ff       	call   c0001fee <outb>
c000207c:	83 c4 08             	add    $0x8,%esp
    // interrupt mask
    outb( ~(1<<1) , PIC1_DATA); //enable irq1 (keyboard)
c000207f:	6a 21                	push   $0x21
c0002081:	68 fd 00 00 00       	push   $0xfd
c0002086:	e8 63 ff ff ff       	call   c0001fee <outb>
c000208b:	83 c4 08             	add    $0x8,%esp
    outb(0xff, PIC2_DATA); //disable interrupts from slave
c000208e:	68 a1 00 00 00       	push   $0xa1
c0002093:	68 ff 00 00 00       	push   $0xff
c0002098:	e8 51 ff ff ff       	call   c0001fee <outb>
c000209d:	83 c4 08             	add    $0x8,%esp


    // individual handler routines defined in interrupt.S
    // these call back to exception_handler() and irq_handler()
    set_interrupt_handler(0,except_0);
c00020a0:	83 ec 08             	sub    $0x8,%esp
c00020a3:	68 8c 3e 00 c0       	push   $0xc0003e8c
c00020a8:	6a 00                	push   $0x0
c00020aa:	e8 98 02 00 00       	call   c0002347 <set_interrupt_handler>
c00020af:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(1,except_1);
c00020b2:	83 ec 08             	sub    $0x8,%esp
c00020b5:	68 ac 3e 00 c0       	push   $0xc0003eac
c00020ba:	6a 01                	push   $0x1
c00020bc:	e8 86 02 00 00       	call   c0002347 <set_interrupt_handler>
c00020c1:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(2,except_2);
c00020c4:	83 ec 08             	sub    $0x8,%esp
c00020c7:	68 cc 3e 00 c0       	push   $0xc0003ecc
c00020cc:	6a 02                	push   $0x2
c00020ce:	e8 74 02 00 00       	call   c0002347 <set_interrupt_handler>
c00020d3:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(3,except_3);
c00020d6:	83 ec 08             	sub    $0x8,%esp
c00020d9:	68 ec 3e 00 c0       	push   $0xc0003eec
c00020de:	6a 03                	push   $0x3
c00020e0:	e8 62 02 00 00       	call   c0002347 <set_interrupt_handler>
c00020e5:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(4,except_4);
c00020e8:	83 ec 08             	sub    $0x8,%esp
c00020eb:	68 0c 3f 00 c0       	push   $0xc0003f0c
c00020f0:	6a 04                	push   $0x4
c00020f2:	e8 50 02 00 00       	call   c0002347 <set_interrupt_handler>
c00020f7:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(5,except_5);
c00020fa:	83 ec 08             	sub    $0x8,%esp
c00020fd:	68 2c 3f 00 c0       	push   $0xc0003f2c
c0002102:	6a 05                	push   $0x5
c0002104:	e8 3e 02 00 00       	call   c0002347 <set_interrupt_handler>
c0002109:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(6,except_6);
c000210c:	83 ec 08             	sub    $0x8,%esp
c000210f:	68 4c 3f 00 c0       	push   $0xc0003f4c
c0002114:	6a 06                	push   $0x6
c0002116:	e8 2c 02 00 00       	call   c0002347 <set_interrupt_handler>
c000211b:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(7,except_7);
c000211e:	83 ec 08             	sub    $0x8,%esp
c0002121:	68 6c 3f 00 c0       	push   $0xc0003f6c
c0002126:	6a 07                	push   $0x7
c0002128:	e8 1a 02 00 00       	call   c0002347 <set_interrupt_handler>
c000212d:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(8,except_8);
c0002130:	83 ec 08             	sub    $0x8,%esp
c0002133:	68 8c 3f 00 c0       	push   $0xc0003f8c
c0002138:	6a 08                	push   $0x8
c000213a:	e8 08 02 00 00       	call   c0002347 <set_interrupt_handler>
c000213f:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(10,except_10);
c0002142:	83 ec 08             	sub    $0x8,%esp
c0002145:	68 ac 3f 00 c0       	push   $0xc0003fac
c000214a:	6a 0a                	push   $0xa
c000214c:	e8 f6 01 00 00       	call   c0002347 <set_interrupt_handler>
c0002151:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(11,except_11);
c0002154:	83 ec 08             	sub    $0x8,%esp
c0002157:	68 cc 3f 00 c0       	push   $0xc0003fcc
c000215c:	6a 0b                	push   $0xb
c000215e:	e8 e4 01 00 00       	call   c0002347 <set_interrupt_handler>
c0002163:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(12,except_12);
c0002166:	83 ec 08             	sub    $0x8,%esp
c0002169:	68 ec 3f 00 c0       	push   $0xc0003fec
c000216e:	6a 0c                	push   $0xc
c0002170:	e8 d2 01 00 00       	call   c0002347 <set_interrupt_handler>
c0002175:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(13,except_13);
c0002178:	83 ec 08             	sub    $0x8,%esp
c000217b:	68 0c 40 00 c0       	push   $0xc000400c
c0002180:	6a 0d                	push   $0xd
c0002182:	e8 c0 01 00 00       	call   c0002347 <set_interrupt_handler>
c0002187:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(14,except_14);
c000218a:	83 ec 08             	sub    $0x8,%esp
c000218d:	68 2c 40 00 c0       	push   $0xc000402c
c0002192:	6a 0e                	push   $0xe
c0002194:	e8 ae 01 00 00       	call   c0002347 <set_interrupt_handler>
c0002199:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(16,except_16);
c000219c:	83 ec 08             	sub    $0x8,%esp
c000219f:	68 4c 40 00 c0       	push   $0xc000404c
c00021a4:	6a 10                	push   $0x10
c00021a6:	e8 9c 01 00 00       	call   c0002347 <set_interrupt_handler>
c00021ab:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(17,except_17);
c00021ae:	83 ec 08             	sub    $0x8,%esp
c00021b1:	68 6c 40 00 c0       	push   $0xc000406c
c00021b6:	6a 11                	push   $0x11
c00021b8:	e8 8a 01 00 00       	call   c0002347 <set_interrupt_handler>
c00021bd:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(18,except_18);
c00021c0:	83 ec 08             	sub    $0x8,%esp
c00021c3:	68 8c 40 00 c0       	push   $0xc000408c
c00021c8:	6a 12                	push   $0x12
c00021ca:	e8 78 01 00 00       	call   c0002347 <set_interrupt_handler>
c00021cf:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(19,except_19);
c00021d2:	83 ec 08             	sub    $0x8,%esp
c00021d5:	68 ac 40 00 c0       	push   $0xc00040ac
c00021da:	6a 13                	push   $0x13
c00021dc:	e8 66 01 00 00       	call   c0002347 <set_interrupt_handler>
c00021e1:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(20,except_20);
c00021e4:	83 ec 08             	sub    $0x8,%esp
c00021e7:	68 cc 40 00 c0       	push   $0xc00040cc
c00021ec:	6a 14                	push   $0x14
c00021ee:	e8 54 01 00 00       	call   c0002347 <set_interrupt_handler>
c00021f3:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(30,except_30);
c00021f6:	83 ec 08             	sub    $0x8,%esp
c00021f9:	68 ec 40 00 c0       	push   $0xc00040ec
c00021fe:	6a 1e                	push   $0x1e
c0002200:	e8 42 01 00 00       	call   c0002347 <set_interrupt_handler>
c0002205:	83 c4 10             	add    $0x10,%esp

    set_interrupt_handler(32,irq_0);
c0002208:	83 ec 08             	sub    $0x8,%esp
c000220b:	68 0c 41 00 c0       	push   $0xc000410c
c0002210:	6a 20                	push   $0x20
c0002212:	e8 30 01 00 00       	call   c0002347 <set_interrupt_handler>
c0002217:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(33,irq_1);
c000221a:	83 ec 08             	sub    $0x8,%esp
c000221d:	68 20 41 00 c0       	push   $0xc0004120
c0002222:	6a 21                	push   $0x21
c0002224:	e8 1e 01 00 00       	call   c0002347 <set_interrupt_handler>
c0002229:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(34,irq_2);
c000222c:	83 ec 08             	sub    $0x8,%esp
c000222f:	68 34 41 00 c0       	push   $0xc0004134
c0002234:	6a 22                	push   $0x22
c0002236:	e8 0c 01 00 00       	call   c0002347 <set_interrupt_handler>
c000223b:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(35,irq_3);
c000223e:	83 ec 08             	sub    $0x8,%esp
c0002241:	68 48 41 00 c0       	push   $0xc0004148
c0002246:	6a 23                	push   $0x23
c0002248:	e8 fa 00 00 00       	call   c0002347 <set_interrupt_handler>
c000224d:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(36,irq_4);
c0002250:	83 ec 08             	sub    $0x8,%esp
c0002253:	68 5c 41 00 c0       	push   $0xc000415c
c0002258:	6a 24                	push   $0x24
c000225a:	e8 e8 00 00 00       	call   c0002347 <set_interrupt_handler>
c000225f:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(37,irq_5);
c0002262:	83 ec 08             	sub    $0x8,%esp
c0002265:	68 70 41 00 c0       	push   $0xc0004170
c000226a:	6a 25                	push   $0x25
c000226c:	e8 d6 00 00 00       	call   c0002347 <set_interrupt_handler>
c0002271:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(38,irq_6);
c0002274:	83 ec 08             	sub    $0x8,%esp
c0002277:	68 84 41 00 c0       	push   $0xc0004184
c000227c:	6a 26                	push   $0x26
c000227e:	e8 c4 00 00 00       	call   c0002347 <set_interrupt_handler>
c0002283:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(39,irq_7);
c0002286:	83 ec 08             	sub    $0x8,%esp
c0002289:	68 98 41 00 c0       	push   $0xc0004198
c000228e:	6a 27                	push   $0x27
c0002290:	e8 b2 00 00 00       	call   c0002347 <set_interrupt_handler>
c0002295:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(40,irq_8);
c0002298:	83 ec 08             	sub    $0x8,%esp
c000229b:	68 ac 41 00 c0       	push   $0xc00041ac
c00022a0:	6a 28                	push   $0x28
c00022a2:	e8 a0 00 00 00       	call   c0002347 <set_interrupt_handler>
c00022a7:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(41,irq_9);
c00022aa:	83 ec 08             	sub    $0x8,%esp
c00022ad:	68 c0 41 00 c0       	push   $0xc00041c0
c00022b2:	6a 29                	push   $0x29
c00022b4:	e8 8e 00 00 00       	call   c0002347 <set_interrupt_handler>
c00022b9:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(42,irq_10);
c00022bc:	83 ec 08             	sub    $0x8,%esp
c00022bf:	68 d4 41 00 c0       	push   $0xc00041d4
c00022c4:	6a 2a                	push   $0x2a
c00022c6:	e8 7c 00 00 00       	call   c0002347 <set_interrupt_handler>
c00022cb:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(43,irq_11);
c00022ce:	83 ec 08             	sub    $0x8,%esp
c00022d1:	68 e8 41 00 c0       	push   $0xc00041e8
c00022d6:	6a 2b                	push   $0x2b
c00022d8:	e8 6a 00 00 00       	call   c0002347 <set_interrupt_handler>
c00022dd:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(44,irq_12);
c00022e0:	83 ec 08             	sub    $0x8,%esp
c00022e3:	68 fc 41 00 c0       	push   $0xc00041fc
c00022e8:	6a 2c                	push   $0x2c
c00022ea:	e8 58 00 00 00       	call   c0002347 <set_interrupt_handler>
c00022ef:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(45,irq_13);
c00022f2:	83 ec 08             	sub    $0x8,%esp
c00022f5:	68 10 42 00 c0       	push   $0xc0004210
c00022fa:	6a 2d                	push   $0x2d
c00022fc:	e8 46 00 00 00       	call   c0002347 <set_interrupt_handler>
c0002301:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(46,irq_14);
c0002304:	83 ec 08             	sub    $0x8,%esp
c0002307:	68 24 42 00 c0       	push   $0xc0004224
c000230c:	6a 2e                	push   $0x2e
c000230e:	e8 34 00 00 00       	call   c0002347 <set_interrupt_handler>
c0002313:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(47,irq_15);
c0002316:	83 ec 08             	sub    $0x8,%esp
c0002319:	68 38 42 00 c0       	push   $0xc0004238
c000231e:	6a 2f                	push   $0x2f
c0002320:	e8 22 00 00 00       	call   c0002347 <set_interrupt_handler>
c0002325:	83 c4 10             	add    $0x10,%esp



    idtd.base = (uint32_t) idt;
c0002328:	b8 20 70 00 c0       	mov    $0xc0007020,%eax
c000232d:	a3 22 78 00 c0       	mov    %eax,0xc0007822
    idtd.limit = sizeof(idt_entry_t) * NUM_INTERRUPT_HANDLERS - 1;
c0002332:	66 c7 05 20 78 00 c0 	movw   $0x7ff,0xc0007820
c0002339:	ff 07 
    load_idt();
c000233b:	e8 3c 1b 00 00       	call   c0003e7c <load_idt>

    return 0;
c0002340:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002345:	c9                   	leave  
c0002346:	c3                   	ret    

c0002347 <set_interrupt_handler>:

void set_interrupt_handler(int int_num, void* handler)
{
c0002347:	55                   	push   %ebp
c0002348:	89 e5                	mov    %esp,%ebp
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c000234a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000234d:	89 c2                	mov    %eax,%edx
c000234f:	8b 45 08             	mov    0x8(%ebp),%eax
c0002352:	66 89 14 c5 20 70 00 	mov    %dx,-0x3fff8fe0(,%eax,8)
c0002359:	c0 
	idt[int_num].segment = KERNEL_CODE_SEGMENT;
c000235a:	8b 45 08             	mov    0x8(%ebp),%eax
c000235d:	66 c7 04 c5 22 70 00 	movw   $0x8,-0x3fff8fde(,%eax,8)
c0002364:	c0 08 00 
	idt[int_num].zero = 0;
c0002367:	8b 45 08             	mov    0x8(%ebp),%eax
c000236a:	c6 04 c5 24 70 00 c0 	movb   $0x0,-0x3fff8fdc(,%eax,8)
c0002371:	00 
	idt[int_num].type = 0x8e; /* INTERRUPT_GATE */
c0002372:	8b 45 08             	mov    0x8(%ebp),%eax
c0002375:	c6 04 c5 25 70 00 c0 	movb   $0x8e,-0x3fff8fdb(,%eax,8)
c000237c:	8e 
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c000237d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002380:	c1 e8 10             	shr    $0x10,%eax
c0002383:	89 c2                	mov    %eax,%edx
c0002385:	8b 45 08             	mov    0x8(%ebp),%eax
c0002388:	66 89 14 c5 26 70 00 	mov    %dx,-0x3fff8fda(,%eax,8)
c000238f:	c0 
}
c0002390:	90                   	nop
c0002391:	5d                   	pop    %ebp
c0002392:	c3                   	ret    

c0002393 <page_fault_handler>:

void page_fault_handler(uint32_t code, void* fault_ip)
{
c0002393:	55                   	push   %ebp
c0002394:	89 e5                	mov    %esp,%ebp
c0002396:	83 ec 08             	sub    $0x8,%esp

    if(code & PF_CODE_WRITE)
c0002399:	8b 45 08             	mov    0x8(%ebp),%eax
c000239c:	83 e0 02             	and    $0x2,%eax
c000239f:	85 c0                	test   %eax,%eax
c00023a1:	74 1b                	je     c00023be <page_fault_handler+0x2b>
        kprintf("\n\nPage Fault writing to 0x%x (instruction 0x%x)\n", pf_addr(), fault_ip);
c00023a3:	e8 e0 1a 00 00       	call   c0003e88 <pf_addr>
c00023a8:	83 ec 04             	sub    $0x4,%esp
c00023ab:	ff 75 0c             	pushl  0xc(%ebp)
c00023ae:	50                   	push   %eax
c00023af:	68 a8 55 00 c0       	push   $0xc00055a8
c00023b4:	e8 2c e5 ff ff       	call   c00008e5 <kprintf>
c00023b9:	83 c4 10             	add    $0x10,%esp
c00023bc:	eb 19                	jmp    c00023d7 <page_fault_handler+0x44>
    else        
        kprintf("\n\nPage Fault reading from 0x%x (instruction 0x%x)\n", pf_addr(), fault_ip);
c00023be:	e8 c5 1a 00 00       	call   c0003e88 <pf_addr>
c00023c3:	83 ec 04             	sub    $0x4,%esp
c00023c6:	ff 75 0c             	pushl  0xc(%ebp)
c00023c9:	50                   	push   %eax
c00023ca:	68 dc 55 00 c0       	push   $0xc00055dc
c00023cf:	e8 11 e5 ff ff       	call   c00008e5 <kprintf>
c00023d4:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_PGPROT)
c00023d7:	8b 45 08             	mov    0x8(%ebp),%eax
c00023da:	83 e0 01             	and    $0x1,%eax
c00023dd:	85 c0                	test   %eax,%eax
c00023df:	74 12                	je     c00023f3 <page_fault_handler+0x60>
        kprintf("Page protection violation\n");
c00023e1:	83 ec 0c             	sub    $0xc,%esp
c00023e4:	68 0f 56 00 c0       	push   $0xc000560f
c00023e9:	e8 f7 e4 ff ff       	call   c00008e5 <kprintf>
c00023ee:	83 c4 10             	add    $0x10,%esp
c00023f1:	eb 10                	jmp    c0002403 <page_fault_handler+0x70>
    else
        kprintf("Page not present\n");
c00023f3:	83 ec 0c             	sub    $0xc,%esp
c00023f6:	68 2a 56 00 c0       	push   $0xc000562a
c00023fb:	e8 e5 e4 ff ff       	call   c00008e5 <kprintf>
c0002400:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_USER)
c0002403:	8b 45 08             	mov    0x8(%ebp),%eax
c0002406:	83 e0 04             	and    $0x4,%eax
c0002409:	85 c0                	test   %eax,%eax
c000240b:	74 10                	je     c000241d <page_fault_handler+0x8a>
        kprintf("\n\nFault caused by user code\n");
c000240d:	83 ec 0c             	sub    $0xc,%esp
c0002410:	68 3c 56 00 c0       	push   $0xc000563c
c0002415:	e8 cb e4 ff ff       	call   c00008e5 <kprintf>
c000241a:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_RES)
c000241d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002420:	83 e0 08             	and    $0x8,%eax
c0002423:	85 c0                	test   %eax,%eax
c0002425:	74 10                	je     c0002437 <page_fault_handler+0xa4>
        kprintf("Page reserved bit set\n");
c0002427:	83 ec 0c             	sub    $0xc,%esp
c000242a:	68 59 56 00 c0       	push   $0xc0005659
c000242f:	e8 b1 e4 ff ff       	call   c00008e5 <kprintf>
c0002434:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_IF)
c0002437:	8b 45 08             	mov    0x8(%ebp),%eax
c000243a:	83 e0 10             	and    $0x10,%eax
c000243d:	85 c0                	test   %eax,%eax
c000243f:	74 10                	je     c0002451 <page_fault_handler+0xbe>
        kprintf("Fault caused by instruction fetch\n");
c0002441:	83 ec 0c             	sub    $0xc,%esp
c0002444:	68 70 56 00 c0       	push   $0xc0005670
c0002449:	e8 97 e4 ff ff       	call   c00008e5 <kprintf>
c000244e:	83 c4 10             	add    $0x10,%esp

    while(1);
c0002451:	eb fe                	jmp    c0002451 <page_fault_handler+0xbe>

c0002453 <exception_handler>:
}


void exception_handler(uint32_t exception_num, uint32_t code, void* fault_ip)
{
c0002453:	55                   	push   %ebp
c0002454:	89 e5                	mov    %esp,%ebp
c0002456:	83 ec 08             	sub    $0x8,%esp
    if(exception_num==14)
c0002459:	83 7d 08 0e          	cmpl   $0xe,0x8(%ebp)
c000245d:	75 13                	jne    c0002472 <exception_handler+0x1f>
        page_fault_handler(code, fault_ip);
c000245f:	83 ec 08             	sub    $0x8,%esp
c0002462:	ff 75 10             	pushl  0x10(%ebp)
c0002465:	ff 75 0c             	pushl  0xc(%ebp)
c0002468:	e8 26 ff ff ff       	call   c0002393 <page_fault_handler>
c000246d:	83 c4 10             	add    $0x10,%esp
c0002470:	eb 16                	jmp    c0002488 <exception_handler+0x35>
    else
        kprintf("\n\nException %u with code 0x%x at instruction 0x%x\n", exception_num, code, fault_ip);
c0002472:	ff 75 10             	pushl  0x10(%ebp)
c0002475:	ff 75 0c             	pushl  0xc(%ebp)
c0002478:	ff 75 08             	pushl  0x8(%ebp)
c000247b:	68 94 56 00 c0       	push   $0xc0005694
c0002480:	e8 60 e4 ff ff       	call   c00008e5 <kprintf>
c0002485:	83 c4 10             	add    $0x10,%esp
    while(1);
c0002488:	eb fe                	jmp    c0002488 <exception_handler+0x35>

c000248a <irq_handler>:
}

void irq_handler(uint32_t irq_num)
{
c000248a:	55                   	push   %ebp
c000248b:	89 e5                	mov    %esp,%ebp
c000248d:	83 ec 18             	sub    $0x18,%esp
    if(irq_num == 1)
c0002490:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0002494:	75 36                	jne    c00024cc <irq_handler+0x42>
    {
        unsigned char scan_code = inb(0x60);
c0002496:	6a 60                	push   $0x60
c0002498:	e8 34 fb ff ff       	call   c0001fd1 <inb>
c000249d:	83 c4 04             	add    $0x4,%esp
c00024a0:	88 45 f7             	mov    %al,-0x9(%ebp)
        char key_ascii = scancode_to_ascii(scan_code);
c00024a3:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c00024a7:	83 ec 0c             	sub    $0xc,%esp
c00024aa:	50                   	push   %eax
c00024ab:	e8 bd 15 00 00       	call   c0003a6d <scancode_to_ascii>
c00024b0:	83 c4 10             	add    $0x10,%esp
c00024b3:	88 45 f6             	mov    %al,-0xa(%ebp)
        // kprintf("code: 0x%x, ascii:%c\n", scan_code, key_ascii);
        if(key_ascii>0)
c00024b6:	80 7d f6 00          	cmpb   $0x0,-0xa(%ebp)
c00024ba:	7e 10                	jle    c00024cc <irq_handler+0x42>
            kprint_char(key_ascii);
c00024bc:	0f be 45 f6          	movsbl -0xa(%ebp),%eax
c00024c0:	83 ec 0c             	sub    $0xc,%esp
c00024c3:	50                   	push   %eax
c00024c4:	e8 cb e3 ff ff       	call   c0000894 <kprint_char>
c00024c9:	83 c4 10             	add    $0x10,%esp
    
    }

    // notify PIC that interrupt handling is complete
    if(irq_num >= 8)
c00024cc:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
c00024d0:	76 12                	jbe    c00024e4 <irq_handler+0x5a>
        outb(PIC_EOI, PIC2_CMD);
c00024d2:	83 ec 08             	sub    $0x8,%esp
c00024d5:	68 a0 00 00 00       	push   $0xa0
c00024da:	6a 20                	push   $0x20
c00024dc:	e8 0d fb ff ff       	call   c0001fee <outb>
c00024e1:	83 c4 10             	add    $0x10,%esp

    outb(PIC_EOI, PIC1_CMD);
c00024e4:	83 ec 08             	sub    $0x8,%esp
c00024e7:	6a 20                	push   $0x20
c00024e9:	6a 20                	push   $0x20
c00024eb:	e8 fe fa ff ff       	call   c0001fee <outb>
c00024f0:	83 c4 10             	add    $0x10,%esp

    return;
c00024f3:	90                   	nop
}
c00024f4:	c9                   	leave  
c00024f5:	c3                   	ret    

c00024f6 <initialize_multitasking>:

uint32_t pid_counter;


int initialize_multitasking()
{   
c00024f6:	55                   	push   %ebp
c00024f7:	89 e5                	mov    %esp,%ebp
c00024f9:	83 ec 08             	sub    $0x8,%esp
    boot_task.pid = pid_counter = 0;
c00024fc:	c7 05 04 d0 00 c0 00 	movl   $0x0,0xc000d004
c0002503:	00 00 00 
c0002506:	a1 04 d0 00 c0       	mov    0xc000d004,%eax
c000250b:	a3 00 80 00 c0       	mov    %eax,0xc0008000
    boot_task.state = RUNNING;
c0002510:	c7 05 04 80 00 c0 00 	movl   $0x0,0xc0008004
c0002517:	00 00 00 

    //this is initialized only on task switch
    boot_task.esp = NULL;
c000251a:	c7 05 08 80 00 c0 00 	movl   $0x0,0xc0008008
c0002521:	00 00 00 
    boot_task.esp0 = NULL;
c0002524:	c7 05 0c 80 00 c0 00 	movl   $0x0,0xc000800c
c000252b:	00 00 00 

    boot_task.cr3 = get_physaddr(&boot_task.pd);
c000252e:	83 ec 0c             	sub    $0xc,%esp
c0002531:	68 00 90 00 c0       	push   $0xc0009000
c0002536:	e8 06 03 00 00       	call   c0002841 <get_physaddr>
c000253b:	83 c4 10             	add    $0x10,%esp
c000253e:	a3 10 80 00 c0       	mov    %eax,0xc0008010

    // this is the only task so far
    //as we add tasks this becomes circular linked list
    boot_task.next_task = &boot_task;
c0002543:	c7 05 14 80 00 c0 00 	movl   $0xc0008000,0xc0008014
c000254a:	80 00 c0 
    current_task = &boot_task;
c000254d:	c7 05 00 d0 00 c0 00 	movl   $0xc0008000,0xc000d000
c0002554:	80 00 c0 

    return 0;
c0002557:	b8 00 00 00 00       	mov    $0x0,%eax
}
c000255c:	c9                   	leave  
c000255d:	c3                   	ret    

c000255e <new_kernel_task>:

task_control_block_t* new_kernel_task(int32_t (*task_entry) (void))
{
c000255e:	55                   	push   %ebp
c000255f:	89 e5                	mov    %esp,%ebp
c0002561:	83 ec 18             	sub    $0x18,%esp
    task_control_block_t* new_task = new_tcb();
c0002564:	e8 f2 07 00 00       	call   c0002d5b <new_tcb>
c0002569:	89 45 f4             	mov    %eax,-0xc(%ebp)

    uint32_t* esp = (uint32_t*) (new_task->kstacks + 1); //set esp at the end of the stack (stack is empty)
c000256c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000256f:	05 00 20 00 00       	add    $0x2000,%eax
c0002574:	05 00 30 00 00       	add    $0x3000,%eax
c0002579:	89 45 f0             	mov    %eax,-0x10(%ebp)
    new_task->cr3 = get_physaddr(&new_task->pd);
c000257c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000257f:	05 00 10 00 00       	add    $0x1000,%eax
c0002584:	83 ec 0c             	sub    $0xc,%esp
c0002587:	50                   	push   %eax
c0002588:	e8 b4 02 00 00       	call   c0002841 <get_physaddr>
c000258d:	83 c4 10             	add    $0x10,%esp
c0002590:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002593:	89 42 10             	mov    %eax,0x10(%edx)

    // init new stack with valid context to launch new task
    *(--esp) = (uint32_t) new_task; //argument to launch_task
c0002596:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
c000259a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000259d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00025a0:	89 10                	mov    %edx,(%eax)
    *(--esp) = (uint32_t) terminate_task; // launch_task() returns to here, to close out task
c00025a2:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
c00025a6:	ba 81 42 00 c0       	mov    $0xc0004281,%edx
c00025ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00025ae:	89 10                	mov    %edx,(%eax)
    *(--esp) = (uint32_t) launch_task; //common entry function for new tasks
c00025b0:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
c00025b4:	ba 15 27 00 c0       	mov    $0xc0002715,%edx
c00025b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00025bc:	89 10                	mov    %edx,(%eax)
    *(--esp) = 0; //push ebx
c00025be:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
c00025c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00025c5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp) = 0; //push esi
c00025cb:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
c00025cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00025d2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp) = 0; //push edi
c00025d8:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
c00025dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00025df:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp) = 0; //push ebp
c00025e5:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
c00025e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00025ec:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    // update_kstack(new_stack); //update tss with esp0

    //create copy of kernel page_dir
    memcpy((void*) &new_task->pd, (void*) &paging->dir,PAGE_SIZE);
c00025f2:	a1 00 60 00 c0       	mov    0xc0006000,%eax
c00025f7:	8d 90 00 f0 3f 00    	lea    0x3ff000(%eax),%edx
c00025fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002600:	05 00 10 00 00       	add    $0x1000,%eax
c0002605:	83 ec 04             	sub    $0x4,%esp
c0002608:	68 00 10 00 00       	push   $0x1000
c000260d:	52                   	push   %edx
c000260e:	50                   	push   %eax
c000260f:	e8 2b f1 ff ff       	call   c000173f <memcpy>
c0002614:	83 c4 10             	add    $0x10,%esp

    new_task->pid = ++pid_counter;
c0002617:	a1 04 d0 00 c0       	mov    0xc000d004,%eax
c000261c:	83 c0 01             	add    $0x1,%eax
c000261f:	a3 04 d0 00 c0       	mov    %eax,0xc000d004
c0002624:	8b 15 04 d0 00 c0    	mov    0xc000d004,%edx
c000262a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000262d:	89 10                	mov    %edx,(%eax)
    new_task->state = WAITING;
c000262f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002632:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
    new_task->esp = esp;
c0002639:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000263c:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000263f:	89 50 08             	mov    %edx,0x8(%eax)
    new_task->esp0 = NULL; //we are already in ring0, so no syscalls...?
c0002642:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002645:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    new_task->task_entry = task_entry;
c000264c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000264f:	8b 55 08             	mov    0x8(%ebp),%edx
c0002652:	89 50 18             	mov    %edx,0x18(%eax)
    new_task->return_val = -1;
c0002655:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002658:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%eax)

    //insert task into the ll
    new_task->next_task = current_task->next_task;
c000265f:	a1 00 d0 00 c0       	mov    0xc000d000,%eax
c0002664:	8b 50 14             	mov    0x14(%eax),%edx
c0002667:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000266a:	89 50 14             	mov    %edx,0x14(%eax)
    current_task->next_task = new_task;
c000266d:	a1 00 d0 00 c0       	mov    0xc000d000,%eax
c0002672:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002675:	89 50 14             	mov    %edx,0x14(%eax)

    return new_task;
c0002678:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c000267b:	c9                   	leave  
c000267c:	c3                   	ret    

c000267d <yield>:

void yield(void)
{
c000267d:	55                   	push   %ebp
c000267e:	89 e5                	mov    %esp,%ebp
c0002680:	83 ec 08             	sub    $0x8,%esp
    current_task->state = WAITING;
c0002683:	a1 00 d0 00 c0       	mov    0xc000d000,%eax
c0002688:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
    current_task->next_task->state = RUNNING;    
c000268f:	a1 00 d0 00 c0       	mov    0xc000d000,%eax
c0002694:	8b 40 14             	mov    0x14(%eax),%eax
c0002697:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    switch_to_task(current_task->next_task);
c000269e:	a1 00 d0 00 c0       	mov    0xc000d000,%eax
c00026a3:	8b 40 14             	mov    0x14(%eax),%eax
c00026a6:	83 ec 0c             	sub    $0xc,%esp
c00026a9:	50                   	push   %eax
c00026aa:	e8 9d 1b 00 00       	call   c000424c <switch_to_task>
c00026af:	83 c4 10             	add    $0x10,%esp
}
c00026b2:	90                   	nop
c00026b3:	c9                   	leave  
c00026b4:	c3                   	ret    

c00026b5 <join>:

int32_t join(task_control_block_t* task, int* ret_val)
{
c00026b5:	55                   	push   %ebp
c00026b6:	89 e5                	mov    %esp,%ebp
c00026b8:	83 ec 08             	sub    $0x8,%esp
    // make sure we are not trying to join the current task or the main kernel task
    if(task == current_task || task == &boot_task)
c00026bb:	a1 00 d0 00 c0       	mov    0xc000d000,%eax
c00026c0:	39 45 08             	cmp    %eax,0x8(%ebp)
c00026c3:	74 09                	je     c00026ce <join+0x19>
c00026c5:	81 7d 08 00 80 00 c0 	cmpl   $0xc0008000,0x8(%ebp)
c00026cc:	75 0c                	jne    c00026da <join+0x25>
        return -1; 
c00026ce:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00026d3:	eb 3e                	jmp    c0002713 <join+0x5e>

    while(task->state == WAITING || task->state == RUNNING)
        yield();
c00026d5:	e8 a3 ff ff ff       	call   c000267d <yield>
    while(task->state == WAITING || task->state == RUNNING)
c00026da:	8b 45 08             	mov    0x8(%ebp),%eax
c00026dd:	8b 40 04             	mov    0x4(%eax),%eax
c00026e0:	83 f8 02             	cmp    $0x2,%eax
c00026e3:	74 f0                	je     c00026d5 <join+0x20>
c00026e5:	8b 45 08             	mov    0x8(%ebp),%eax
c00026e8:	8b 40 04             	mov    0x4(%eax),%eax
c00026eb:	85 c0                	test   %eax,%eax
c00026ed:	74 e6                	je     c00026d5 <join+0x20>

    if(ret_val)
c00026ef:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00026f3:	74 0b                	je     c0002700 <join+0x4b>
        *ret_val = task->return_val;
c00026f5:	8b 45 08             	mov    0x8(%ebp),%eax
c00026f8:	8b 50 1c             	mov    0x1c(%eax),%edx
c00026fb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00026fe:	89 10                	mov    %edx,(%eax)

    free_tcb(task);
c0002700:	83 ec 0c             	sub    $0xc,%esp
c0002703:	ff 75 08             	pushl  0x8(%ebp)
c0002706:	e8 68 07 00 00       	call   c0002e73 <free_tcb>
c000270b:	83 c4 10             	add    $0x10,%esp
    return 0;
c000270e:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002713:	c9                   	leave  
c0002714:	c3                   	ret    

c0002715 <launch_task>:


void launch_task(task_control_block_t* task)
{
c0002715:	55                   	push   %ebp
c0002716:	89 e5                	mov    %esp,%ebp
c0002718:	83 ec 18             	sub    $0x18,%esp
    task->state = RUNNING;
c000271b:	8b 45 08             	mov    0x8(%ebp),%eax
c000271e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

   // call task main function
    task->return_val = (*task->task_entry)();
c0002725:	8b 45 08             	mov    0x8(%ebp),%eax
c0002728:	8b 40 18             	mov    0x18(%eax),%eax
c000272b:	ff d0                	call   *%eax
c000272d:	8b 55 08             	mov    0x8(%ebp),%edx
c0002730:	89 42 1c             	mov    %eax,0x1c(%edx)

    // back from task

    //remove this task from active task list
    task_control_block_t* t = task->next_task;
c0002733:	8b 45 08             	mov    0x8(%ebp),%eax
c0002736:	8b 40 14             	mov    0x14(%eax),%eax
c0002739:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while( t->next_task != task)
c000273c:	eb 09                	jmp    c0002747 <launch_task+0x32>
        t = t->next_task;
c000273e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002741:	8b 40 14             	mov    0x14(%eax),%eax
c0002744:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while( t->next_task != task)
c0002747:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000274a:	8b 40 14             	mov    0x14(%eax),%eax
c000274d:	39 45 08             	cmp    %eax,0x8(%ebp)
c0002750:	75 ec                	jne    c000273e <launch_task+0x29>
    t->next_task = t->next_task->next_task;
c0002752:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002755:	8b 40 14             	mov    0x14(%eax),%eax
c0002758:	8b 50 14             	mov    0x14(%eax),%edx
c000275b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000275e:	89 50 14             	mov    %edx,0x14(%eax)

    task->state = COMPLETE;
c0002761:	8b 45 08             	mov    0x8(%ebp),%eax
c0002764:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)

    // this will "return" to terminite_task 
}
c000276b:	90                   	nop
c000276c:	c9                   	leave  
c000276d:	c3                   	ret    

c000276e <num_tasks>:

int num_tasks()
{
c000276e:	55                   	push   %ebp
c000276f:	89 e5                	mov    %esp,%ebp
c0002771:	83 ec 10             	sub    $0x10,%esp
    task_control_block_t* t = current_task;
c0002774:	a1 00 d0 00 c0       	mov    0xc000d000,%eax
c0002779:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int nn = 1;
c000277c:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    while( t->next_task != current_task)
c0002783:	eb 0d                	jmp    c0002792 <num_tasks+0x24>
    {
        t = t->next_task;
c0002785:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002788:	8b 40 14             	mov    0x14(%eax),%eax
c000278b:	89 45 fc             	mov    %eax,-0x4(%ebp)
        nn++;
c000278e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while( t->next_task != current_task)
c0002792:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002795:	8b 50 14             	mov    0x14(%eax),%edx
c0002798:	a1 00 d0 00 c0       	mov    0xc000d000,%eax
c000279d:	39 c2                	cmp    %eax,%edx
c000279f:	75 e4                	jne    c0002785 <num_tasks+0x17>
    }
    return nn;
c00027a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c00027a4:	c9                   	leave  
c00027a5:	c3                   	ret    

c00027a6 <user_test>:
int user_test()
{
c00027a6:	55                   	push   %ebp
c00027a7:	89 e5                	mov    %esp,%ebp
c00027a9:	83 ec 10             	sub    $0x10,%esp
    int a = 1;
c00027ac:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
    int b = 2;
c00027b3:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
    int c = b/a;
c00027ba:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00027bd:	99                   	cltd   
c00027be:	f7 7d fc             	idivl  -0x4(%ebp)
c00027c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return c;
c00027c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00027c7:	c9                   	leave  
c00027c8:	c3                   	ret    

c00027c9 <get_ptindex>:
//global pointer to page directory
extern paging_t* paging;

// return page table index for virtual address
static inline uint32_t get_ptindex(void* addr)
{
c00027c9:	55                   	push   %ebp
c00027ca:	89 e5                	mov    %esp,%ebp
    return (((uint32_t) addr) & PAGE_PTE_MASK ) >> 12;
c00027cc:	8b 45 08             	mov    0x8(%ebp),%eax
c00027cf:	c1 e8 0c             	shr    $0xc,%eax
c00027d2:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c00027d7:	5d                   	pop    %ebp
c00027d8:	c3                   	ret    

c00027d9 <get_pdindex>:

// return page directory index for virtual address
static inline uint32_t get_pdindex(void* addr)
{
c00027d9:	55                   	push   %ebp
c00027da:	89 e5                	mov    %esp,%ebp
    return ((uint32_t) addr) >> 22;
c00027dc:	8b 45 08             	mov    0x8(%ebp),%eax
c00027df:	c1 e8 16             	shr    $0x16,%eax
}
c00027e2:	5d                   	pop    %ebp
c00027e3:	c3                   	ret    

c00027e4 <get_page_offset>:

// return offset into page
static inline uint32_t get_page_offset(void* addr)
{
c00027e4:	55                   	push   %ebp
c00027e5:	89 e5                	mov    %esp,%ebp
    return ((uint32_t) addr) & ~PAGE_ADDRMASK;
c00027e7:	8b 45 08             	mov    0x8(%ebp),%eax
c00027ea:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c00027ef:	5d                   	pop    %ebp
c00027f0:	c3                   	ret    

c00027f1 <get_table>:

paging_t* paging = (paging_t*) PAGING_ADDR;

// return page directory index for virtual address
page_table_t* get_table(void* addr)
{
c00027f1:	55                   	push   %ebp
c00027f2:	89 e5                	mov    %esp,%ebp
c00027f4:	53                   	push   %ebx
c00027f5:	83 ec 10             	sub    $0x10,%esp
    uint32_t idx = get_pdindex(addr);
c00027f8:	ff 75 08             	pushl  0x8(%ebp)
c00027fb:	e8 d9 ff ff ff       	call   c00027d9 <get_pdindex>
c0002800:	83 c4 04             	add    $0x4,%esp
c0002803:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(paging->dir.pde[idx] & PAGE_FLAG_PRESENT)
c0002806:	a1 00 60 00 c0       	mov    0xc0006000,%eax
c000280b:	8b 55 f8             	mov    -0x8(%ebp),%edx
c000280e:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c0002814:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0002817:	83 e0 01             	and    $0x1,%eax
c000281a:	85 c0                	test   %eax,%eax
c000281c:	74 19                	je     c0002837 <get_table+0x46>
        return paging->tables + get_pdindex(addr);
c000281e:	a1 00 60 00 c0       	mov    0xc0006000,%eax
c0002823:	89 c3                	mov    %eax,%ebx
c0002825:	ff 75 08             	pushl  0x8(%ebp)
c0002828:	e8 ac ff ff ff       	call   c00027d9 <get_pdindex>
c000282d:	83 c4 04             	add    $0x4,%esp
c0002830:	c1 e0 0c             	shl    $0xc,%eax
c0002833:	01 d8                	add    %ebx,%eax
c0002835:	eb 05                	jmp    c000283c <get_table+0x4b>
    else 
        return NULL;
c0002837:	b8 00 00 00 00       	mov    $0x0,%eax
}
c000283c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000283f:	c9                   	leave  
c0002840:	c3                   	ret    

c0002841 <get_physaddr>:

// return physical addr from virt addr
void* get_physaddr(void* addr)
{
c0002841:	55                   	push   %ebp
c0002842:	89 e5                	mov    %esp,%ebp
c0002844:	53                   	push   %ebx
c0002845:	83 ec 10             	sub    $0x10,%esp
    //check paging entry is present
    uint32_t pdi = get_pdindex(addr);
c0002848:	ff 75 08             	pushl  0x8(%ebp)
c000284b:	e8 89 ff ff ff       	call   c00027d9 <get_pdindex>
c0002850:	83 c4 04             	add    $0x4,%esp
c0002853:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(! paging->dir.pde[pdi] & PAGE_FLAG_PRESENT)
c0002856:	a1 00 60 00 c0       	mov    0xc0006000,%eax
c000285b:	8b 55 f8             	mov    -0x8(%ebp),%edx
c000285e:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c0002864:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0002867:	85 c0                	test   %eax,%eax
c0002869:	75 07                	jne    c0002872 <get_physaddr+0x31>
        return NULL;
c000286b:	b8 00 00 00 00       	mov    $0x0,%eax
c0002870:	eb 45                	jmp    c00028b7 <get_physaddr+0x76>

    //check pt entry is present
    uint32_t pte = paging->tables[pdi].pte[get_ptindex(addr)];
c0002872:	8b 1d 00 60 00 c0    	mov    0xc0006000,%ebx
c0002878:	ff 75 08             	pushl  0x8(%ebp)
c000287b:	e8 49 ff ff ff       	call   c00027c9 <get_ptindex>
c0002880:	83 c4 04             	add    $0x4,%esp
c0002883:	89 c2                	mov    %eax,%edx
c0002885:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0002888:	c1 e0 0a             	shl    $0xa,%eax
c000288b:	01 d0                	add    %edx,%eax
c000288d:	8b 04 83             	mov    (%ebx,%eax,4),%eax
c0002890:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(! pte & PAGE_FLAG_PRESENT)
c0002893:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002897:	75 07                	jne    c00028a0 <get_physaddr+0x5f>
        return NULL;
c0002899:	b8 00 00 00 00       	mov    $0x0,%eax
c000289e:	eb 17                	jmp    c00028b7 <get_physaddr+0x76>

    return (void*) ((pte & PAGE_ADDRMASK) +  get_page_offset(addr) );
c00028a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00028a3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00028a8:	89 c3                	mov    %eax,%ebx
c00028aa:	ff 75 08             	pushl  0x8(%ebp)
c00028ad:	e8 32 ff ff ff       	call   c00027e4 <get_page_offset>
c00028b2:	83 c4 04             	add    $0x4,%esp
c00028b5:	01 d8                	add    %ebx,%eax
}
c00028b7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00028ba:	c9                   	leave  
c00028bb:	c3                   	ret    

c00028bc <get_ptindex>:
{
c00028bc:	55                   	push   %ebp
c00028bd:	89 e5                	mov    %esp,%ebp
    return (((uint32_t) addr) & PAGE_PTE_MASK ) >> 12;
c00028bf:	8b 45 08             	mov    0x8(%ebp),%eax
c00028c2:	c1 e8 0c             	shr    $0xc,%eax
c00028c5:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c00028ca:	5d                   	pop    %ebp
c00028cb:	c3                   	ret    

c00028cc <get_pdindex>:
{
c00028cc:	55                   	push   %ebp
c00028cd:	89 e5                	mov    %esp,%ebp
    return ((uint32_t) addr) >> 22;
c00028cf:	8b 45 08             	mov    0x8(%ebp),%eax
c00028d2:	c1 e8 16             	shr    $0x16,%eax
}
c00028d5:	5d                   	pop    %ebp
c00028d6:	c3                   	ret    

c00028d7 <align_int>:
{
c00028d7:	55                   	push   %ebp
c00028d8:	89 e5                	mov    %esp,%ebp
c00028da:	83 ec 10             	sub    $0x10,%esp
    size_t am = alignment - 1;
c00028dd:	8b 45 0c             	mov    0xc(%ebp),%eax
c00028e0:	83 e8 01             	sub    $0x1,%eax
c00028e3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (((size_t)len + am) & ~am);
c00028e6:	8b 55 08             	mov    0x8(%ebp),%edx
c00028e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00028ec:	01 c2                	add    %eax,%edx
c00028ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00028f1:	f7 d0                	not    %eax
c00028f3:	21 d0                	and    %edx,%eax
}
c00028f5:	c9                   	leave  
c00028f6:	c3                   	ret    

c00028f7 <align_ptr>:

static inline void* align_ptr(void* addr, size_t alignment)
{
c00028f7:	55                   	push   %ebp
c00028f8:	89 e5                	mov    %esp,%ebp
    // alignment must be increment of 4
    if(alignment % sizeof(void*) != 0 ) return NULL;
c00028fa:	8b 45 0c             	mov    0xc(%ebp),%eax
c00028fd:	83 e0 03             	and    $0x3,%eax
c0002900:	85 c0                	test   %eax,%eax
c0002902:	74 07                	je     c000290b <align_ptr+0x14>
c0002904:	b8 00 00 00 00       	mov    $0x0,%eax
c0002909:	eb 0f                	jmp    c000291a <align_ptr+0x23>
    return (void*) align_int((size_t) addr, alignment);
c000290b:	8b 45 08             	mov    0x8(%ebp),%eax
c000290e:	ff 75 0c             	pushl  0xc(%ebp)
c0002911:	50                   	push   %eax
c0002912:	e8 c0 ff ff ff       	call   c00028d7 <align_int>
c0002917:	83 c4 08             	add    $0x8,%esp
}
c000291a:	c9                   	leave  
c000291b:	c3                   	ret    

c000291c <pop_free_frame>:
page_t* kheap_base;   // just above page stack


// allocate a physical page from the stack
page_t* pop_free_frame()
{
c000291c:	55                   	push   %ebp
c000291d:	89 e5                	mov    %esp,%ebp
c000291f:	83 ec 10             	sub    $0x10,%esp
    page_t* free_frame = *(frame_stack_top++);
c0002922:	a1 0c d0 00 c0       	mov    0xc000d00c,%eax
c0002927:	8d 50 04             	lea    0x4(%eax),%edx
c000292a:	89 15 0c d0 00 c0    	mov    %edx,0xc000d00c
c0002930:	8b 00                	mov    (%eax),%eax
c0002932:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(frame_stack_top<frame_stack_base)
c0002935:	8b 15 0c d0 00 c0    	mov    0xc000d00c,%edx
c000293b:	a1 10 d0 00 c0       	mov    0xc000d010,%eax
c0002940:	39 c2                	cmp    %eax,%edx
c0002942:	73 05                	jae    c0002949 <pop_free_frame+0x2d>
        return free_frame;
c0002944:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002947:	eb 05                	jmp    c000294e <pop_free_frame+0x32>
    else
        return NULL; //out of memory!    
c0002949:	b8 00 00 00 00       	mov    $0x0,%eax
}
c000294e:	c9                   	leave  
c000294f:	c3                   	ret    

c0002950 <push_free_frame>:

// free a physical frame, by pushing it back onto the frame stack
int push_free_frame(page_t* free_frame)
{
c0002950:	55                   	push   %ebp
c0002951:	89 e5                	mov    %esp,%ebp
    //make sure we haven't filled up the frame stack
    //this really could only happen if we try to free frames that were never on the stack to begin with
    if(frame_stack_top<=frame_stack_start)
c0002953:	8b 15 0c d0 00 c0    	mov    0xc000d00c,%edx
c0002959:	a1 08 d0 00 c0       	mov    0xc000d008,%eax
c000295e:	39 c2                	cmp    %eax,%edx
c0002960:	77 07                	ja     c0002969 <push_free_frame+0x19>
        return -1;
c0002962:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002967:	eb 18                	jmp    c0002981 <push_free_frame+0x31>

    *(frame_stack_top--) = free_frame;
c0002969:	a1 0c d0 00 c0       	mov    0xc000d00c,%eax
c000296e:	8d 50 fc             	lea    -0x4(%eax),%edx
c0002971:	89 15 0c d0 00 c0    	mov    %edx,0xc000d00c
c0002977:	8b 55 08             	mov    0x8(%ebp),%edx
c000297a:	89 10                	mov    %edx,(%eax)
    return 0;
c000297c:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002981:	5d                   	pop    %ebp
c0002982:	c3                   	ret    

c0002983 <init_frame_stack>:

// set up a stack will all free pages of physical memory
void init_frame_stack(multiboot_info_t* mbd)
{
c0002983:	55                   	push   %ebp
c0002984:	89 e5                	mov    %esp,%ebp
c0002986:	57                   	push   %edi
c0002987:	56                   	push   %esi
c0002988:	83 ec 20             	sub    $0x20,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c000298b:	8b 45 08             	mov    0x8(%ebp),%eax
c000298e:	8b 40 30             	mov    0x30(%eax),%eax
c0002991:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // We will start looking for free physical memory just above the kernel
    page_t* first_free_frame = align_ptr( &_kernel_end_phys, PAGE_SIZE); //physical address of first free page after the kernel
c0002994:	68 00 10 00 00       	push   $0x1000
c0002999:	68 00 e0 20 00       	push   $0x20e000
c000299e:	e8 54 ff ff ff       	call   c00028f7 <align_ptr>
c00029a3:	83 c4 08             	add    $0x8,%esp
c00029a6:	89 45 e8             	mov    %eax,-0x18(%ebp)

    // Map the stack just past the end of the kernel in virtual mem

    // stack_break points to the end of the allocated region for the stack  
    frame_stack_brk = align_ptr( &_kernel_end, PAGE_SIZE);
c00029a9:	68 00 10 00 00       	push   $0x1000
c00029ae:	68 00 d0 10 c0       	push   $0xc010d000
c00029b3:	e8 3f ff ff ff       	call   c00028f7 <align_ptr>
c00029b8:	83 c4 08             	add    $0x8,%esp
c00029bb:	a3 14 d0 00 c0       	mov    %eax,0xc000d014

    // initialize stack pointers
    // we will initialize the stack by adding new pages to the base
    // first pages (in low mem) will be at top of the stack
    frame_stack_start = (page_t**) frame_stack_brk;
c00029c0:	a1 14 d0 00 c0       	mov    0xc000d014,%eax
c00029c5:	a3 08 d0 00 c0       	mov    %eax,0xc000d008
    frame_stack_top = frame_stack_start;
c00029ca:	a1 08 d0 00 c0       	mov    0xc000d008,%eax
c00029cf:	a3 0c d0 00 c0       	mov    %eax,0xc000d00c
    frame_stack_base = frame_stack_top;
c00029d4:	a1 0c d0 00 c0       	mov    0xc000d00c,%eax
c00029d9:	a3 10 d0 00 c0       	mov    %eax,0xc000d010

    // allocate one page for the stack, incrementing the stack_break and first_free_frame pointers
    // We will allocate more pages for the stack as we go as needed
    if(!map_page_at(frame_stack_brk++, first_free_frame++, PAGE_FLAG_WRITE))
c00029de:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00029e1:	8d 82 00 10 00 00    	lea    0x1000(%edx),%eax
c00029e7:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00029ea:	a1 14 d0 00 c0       	mov    0xc000d014,%eax
c00029ef:	8d 88 00 10 00 00    	lea    0x1000(%eax),%ecx
c00029f5:	89 0d 14 d0 00 c0    	mov    %ecx,0xc000d014
c00029fb:	83 ec 04             	sub    $0x4,%esp
c00029fe:	6a 02                	push   $0x2
c0002a00:	52                   	push   %edx
c0002a01:	50                   	push   %eax
c0002a02:	e8 b4 05 00 00       	call   c0002fbb <map_page_at>
c0002a07:	83 c4 10             	add    $0x10,%esp
c0002a0a:	85 c0                	test   %eax,%eax
c0002a0c:	75 10                	jne    c0002a1e <init_frame_stack+0x9b>
        panic("Error reserving memory for physical page allocation!");
c0002a0e:	83 ec 0c             	sub    $0xc,%esp
c0002a11:	68 c8 56 00 c0       	push   $0xc00056c8
c0002a16:	e8 e7 ec ff ff       	call   c0001702 <panic>
c0002a1b:	83 c4 10             	add    $0x10,%esp

    // loop through each block of memory defined in the multiboot record
    // for each block of memory, add free pages to stack
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0002a1e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0002a25:	e9 50 01 00 00       	jmp    c0002b7a <init_frame_stack+0x1f7>
	{
        if(mmap_table[nn].size == 0) // end of table
c0002a2a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002a2d:	89 d0                	mov    %edx,%eax
c0002a2f:	01 c0                	add    %eax,%eax
c0002a31:	01 d0                	add    %edx,%eax
c0002a33:	c1 e0 03             	shl    $0x3,%eax
c0002a36:	89 c2                	mov    %eax,%edx
c0002a38:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002a3b:	01 d0                	add    %edx,%eax
c0002a3d:	8b 00                	mov    (%eax),%eax
c0002a3f:	85 c0                	test   %eax,%eax
c0002a41:	0f 84 44 01 00 00    	je     c0002b8b <init_frame_stack+0x208>
            break;

        if(mmap_table[nn].addr >> 32) // ignore anything above 32bits
c0002a47:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002a4a:	89 d0                	mov    %edx,%eax
c0002a4c:	01 c0                	add    %eax,%eax
c0002a4e:	01 d0                	add    %edx,%eax
c0002a50:	c1 e0 03             	shl    $0x3,%eax
c0002a53:	89 c2                	mov    %eax,%edx
c0002a55:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002a58:	01 d0                	add    %edx,%eax
c0002a5a:	8b 50 08             	mov    0x8(%eax),%edx
c0002a5d:	8b 40 04             	mov    0x4(%eax),%eax
c0002a60:	89 d0                	mov    %edx,%eax
c0002a62:	31 d2                	xor    %edx,%edx
c0002a64:	89 c1                	mov    %eax,%ecx
c0002a66:	80 f5 00             	xor    $0x0,%ch
c0002a69:	89 ce                	mov    %ecx,%esi
c0002a6b:	89 d0                	mov    %edx,%eax
c0002a6d:	80 f4 00             	xor    $0x0,%ah
c0002a70:	89 c7                	mov    %eax,%edi
c0002a72:	89 f8                	mov    %edi,%eax
c0002a74:	09 f0                	or     %esi,%eax
c0002a76:	85 c0                	test   %eax,%eax
c0002a78:	0f 85 f7 00 00 00    	jne    c0002b75 <init_frame_stack+0x1f2>
            continue;

		if(mmap_table[nn].type == MULTIBOOT_MEMORY_AVAILABLE)
c0002a7e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002a81:	89 d0                	mov    %edx,%eax
c0002a83:	01 c0                	add    %eax,%eax
c0002a85:	01 d0                	add    %edx,%eax
c0002a87:	c1 e0 03             	shl    $0x3,%eax
c0002a8a:	89 c2                	mov    %eax,%edx
c0002a8c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002a8f:	01 d0                	add    %edx,%eax
c0002a91:	8b 40 14             	mov    0x14(%eax),%eax
c0002a94:	83 f8 01             	cmp    $0x1,%eax
c0002a97:	0f 85 d9 00 00 00    	jne    c0002b76 <init_frame_stack+0x1f3>
        {
            //pointers to the first and last page in this memory block 
            size_t block_addr = mmap_table[nn].addr;
c0002a9d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002aa0:	89 d0                	mov    %edx,%eax
c0002aa2:	01 c0                	add    %eax,%eax
c0002aa4:	01 d0                	add    %edx,%eax
c0002aa6:	c1 e0 03             	shl    $0x3,%eax
c0002aa9:	89 c2                	mov    %eax,%edx
c0002aab:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002aae:	01 d0                	add    %edx,%eax
c0002ab0:	8b 50 08             	mov    0x8(%eax),%edx
c0002ab3:	8b 40 04             	mov    0x4(%eax),%eax
c0002ab6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            size_t block_len = mmap_table[nn].len;
c0002ab9:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002abc:	89 d0                	mov    %edx,%eax
c0002abe:	01 c0                	add    %eax,%eax
c0002ac0:	01 d0                	add    %edx,%eax
c0002ac2:	c1 e0 03             	shl    $0x3,%eax
c0002ac5:	89 c2                	mov    %eax,%edx
c0002ac7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002aca:	01 d0                	add    %edx,%eax
c0002acc:	8b 50 10             	mov    0x10(%eax),%edx
c0002acf:	8b 40 0c             	mov    0xc(%eax),%eax
c0002ad2:	89 45 e0             	mov    %eax,-0x20(%ebp)
            page_t* pg = align_ptr( (char*) block_addr, PAGE_SIZE); // first whole page in block
c0002ad5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0002ad8:	83 ec 08             	sub    $0x8,%esp
c0002adb:	68 00 10 00 00       	push   $0x1000
c0002ae0:	50                   	push   %eax
c0002ae1:	e8 11 fe ff ff       	call   c00028f7 <align_ptr>
c0002ae6:	83 c4 10             	add    $0x10,%esp
c0002ae9:	89 45 f0             	mov    %eax,-0x10(%ebp)
            page_t* pg_end = (page_t*) ((block_addr+block_len) & PAGE_ADDRMASK); // first page *after* last whole page in block
c0002aec:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0002aef:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0002af2:	01 d0                	add    %edx,%eax
c0002af4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002af9:	89 45 dc             	mov    %eax,-0x24(%ebp)

            //don't map any memory before end of the kernel
            pg = pg<first_free_frame ? first_free_frame : pg; 
c0002afc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002aff:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0002b02:	0f 43 45 f0          	cmovae -0x10(%ebp),%eax
c0002b06:	89 45 f0             	mov    %eax,-0x10(%ebp)

            //fill stack with pointers to each page in the block
            for(; pg<pg_end; pg++)
c0002b09:	eb 60                	jmp    c0002b6b <init_frame_stack+0x1e8>
            {
                // extend end of stack and make sure we have allocated enough memory
                if( (void*) ++frame_stack_base >= (void*) frame_stack_brk)
c0002b0b:	a1 10 d0 00 c0       	mov    0xc000d010,%eax
c0002b10:	83 c0 04             	add    $0x4,%eax
c0002b13:	a3 10 d0 00 c0       	mov    %eax,0xc000d010
c0002b18:	8b 15 10 d0 00 c0    	mov    0xc000d010,%edx
c0002b1e:	a1 14 d0 00 c0       	mov    0xc000d014,%eax
c0002b23:	39 c2                	cmp    %eax,%edx
c0002b25:	72 33                	jb     c0002b5a <init_frame_stack+0x1d7>
                {
                    // map a new page at the end of the stack
                    // note that this will pop a free page off the top of the stack
                    if(!map_page(frame_stack_brk++, PAGE_FLAG_WRITE))
c0002b27:	a1 14 d0 00 c0       	mov    0xc000d014,%eax
c0002b2c:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c0002b32:	89 15 14 d0 00 c0    	mov    %edx,0xc000d014
c0002b38:	83 ec 08             	sub    $0x8,%esp
c0002b3b:	6a 02                	push   $0x2
c0002b3d:	50                   	push   %eax
c0002b3e:	e8 04 05 00 00       	call   c0003047 <map_page>
c0002b43:	83 c4 10             	add    $0x10,%esp
c0002b46:	85 c0                	test   %eax,%eax
c0002b48:	75 10                	jne    c0002b5a <init_frame_stack+0x1d7>
                        panic("Error reserving memory for physical page allocation!");
c0002b4a:	83 ec 0c             	sub    $0xc,%esp
c0002b4d:	68 c8 56 00 c0       	push   $0xc00056c8
c0002b52:	e8 ab eb ff ff       	call   c0001702 <panic>
c0002b57:	83 c4 10             	add    $0x10,%esp
                }

                //record physical page at end stack
                *frame_stack_base = pg;
c0002b5a:	a1 10 d0 00 c0       	mov    0xc000d010,%eax
c0002b5f:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0002b62:	89 10                	mov    %edx,(%eax)
            for(; pg<pg_end; pg++)
c0002b64:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
c0002b6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002b6e:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c0002b71:	72 98                	jb     c0002b0b <init_frame_stack+0x188>
c0002b73:	eb 01                	jmp    c0002b76 <init_frame_stack+0x1f3>
            continue;
c0002b75:	90                   	nop
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0002b76:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0002b7a:	8b 45 08             	mov    0x8(%ebp),%eax
c0002b7d:	8b 40 2c             	mov    0x2c(%eax),%eax
c0002b80:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0002b83:	0f 82 a1 fe ff ff    	jb     c0002a2a <init_frame_stack+0xa7>
	}

    // size_t free_frames = frame_stack_base-frame_stack_top;
	// kprintf("\nFound %d frames of RAM (%f MB)\n", free_frames, free_frames*PAGE_SIZE/1e6);

}
c0002b89:	eb 01                	jmp    c0002b8c <init_frame_stack+0x209>
            break;
c0002b8b:	90                   	nop
}
c0002b8c:	90                   	nop
c0002b8d:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0002b90:	5e                   	pop    %esi
c0002b91:	5f                   	pop    %edi
c0002b92:	5d                   	pop    %ebp
c0002b93:	c3                   	ret    

c0002b94 <init_kstack>:


int init_kstack(kstack_t* stack)
{
c0002b94:	55                   	push   %ebp
c0002b95:	89 e5                	mov    %esp,%ebp
c0002b97:	83 ec 18             	sub    $0x18,%esp
    //make sure guard page is unmapped
    unmap_page(&tcb_stack->guard);
c0002b9a:	a1 18 d0 00 c0       	mov    0xc000d018,%eax
c0002b9f:	83 ec 0c             	sub    $0xc,%esp
c0002ba2:	50                   	push   %eax
c0002ba3:	e8 be 04 00 00       	call   c0003066 <unmap_page>
c0002ba8:	83 c4 10             	add    $0x10,%esp

    //map stack pages
    for(int nn=0;nn<KSTACK_PAGES; nn++)
c0002bab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0002bb2:	eb 33                	jmp    c0002be7 <init_kstack+0x53>
    {
        if(!map_page_at(&stack->pg[nn], pop_free_frame(), PAGE_FLAG_WRITE))
c0002bb4:	e8 63 fd ff ff       	call   c000291c <pop_free_frame>
c0002bb9:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002bbc:	83 c2 01             	add    $0x1,%edx
c0002bbf:	89 d1                	mov    %edx,%ecx
c0002bc1:	c1 e1 0c             	shl    $0xc,%ecx
c0002bc4:	8b 55 08             	mov    0x8(%ebp),%edx
c0002bc7:	01 ca                	add    %ecx,%edx
c0002bc9:	83 ec 04             	sub    $0x4,%esp
c0002bcc:	6a 02                	push   $0x2
c0002bce:	50                   	push   %eax
c0002bcf:	52                   	push   %edx
c0002bd0:	e8 e6 03 00 00       	call   c0002fbb <map_page_at>
c0002bd5:	83 c4 10             	add    $0x10,%esp
c0002bd8:	85 c0                	test   %eax,%eax
c0002bda:	75 07                	jne    c0002be3 <init_kstack+0x4f>
            return -1;
c0002bdc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002be1:	eb 0f                	jmp    c0002bf2 <init_kstack+0x5e>
    for(int nn=0;nn<KSTACK_PAGES; nn++)
c0002be3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0002be7:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c0002beb:	7e c7                	jle    c0002bb4 <init_kstack+0x20>
    }
    return 0;
c0002bed:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002bf2:	c9                   	leave  
c0002bf3:	c3                   	ret    

c0002bf4 <init_tcb_stack>:


// set up a stack to manage tcbs
void init_tcb_stack()
{
c0002bf4:	55                   	push   %ebp
c0002bf5:	89 e5                	mov    %esp,%ebp
c0002bf7:	83 ec 08             	sub    $0x8,%esp
    //allocate a stack at top of kernel memory to manage list of available locations for new stacks
    tcb_stack = ((kstack_t*) align_ptr( (void*) KERNEL_TOP, sizeof(kstack_t))) - 1;
c0002bfa:	68 00 30 00 00       	push   $0x3000
c0002bff:	68 00 00 00 f8       	push   $0xf8000000
c0002c04:	e8 ee fc ff ff       	call   c00028f7 <align_ptr>
c0002c09:	83 c4 08             	add    $0x8,%esp
c0002c0c:	2d 00 30 00 00       	sub    $0x3000,%eax
c0002c11:	a3 18 d0 00 c0       	mov    %eax,0xc000d018
    if(init_kstack(tcb_stack))
c0002c16:	a1 18 d0 00 c0       	mov    0xc000d018,%eax
c0002c1b:	83 ec 0c             	sub    $0xc,%esp
c0002c1e:	50                   	push   %eax
c0002c1f:	e8 70 ff ff ff       	call   c0002b94 <init_kstack>
c0002c24:	83 c4 10             	add    $0x10,%esp
c0002c27:	85 c0                	test   %eax,%eax
c0002c29:	74 10                	je     c0002c3b <init_tcb_stack+0x47>
        panic("Error initializing kernel task memory");
c0002c2b:	83 ec 0c             	sub    $0xc,%esp
c0002c2e:	68 00 57 00 c0       	push   $0xc0005700
c0002c33:	e8 ca ea ff ff       	call   c0001702 <panic>
c0002c38:	83 c4 10             	add    $0x10,%esp

    tcb_stack_base = (task_control_block_t**) (tcb_stack+1); // base of stack is at end of stack struct
c0002c3b:	a1 18 d0 00 c0       	mov    0xc000d018,%eax
c0002c40:	05 00 30 00 00       	add    $0x3000,%eax
c0002c45:	a3 20 d0 00 c0       	mov    %eax,0xc000d020
    tcb_stack_top = tcb_stack_base; // stack is empty
c0002c4a:	a1 20 d0 00 c0       	mov    0xc000d020,%eax
c0002c4f:	a3 1c d0 00 c0       	mov    %eax,0xc000d01c

    task_brk = (task_control_block_t*) tcb_stack; // lower limit of task memory
c0002c54:	a1 18 d0 00 c0       	mov    0xc000d018,%eax
c0002c59:	a3 24 d0 00 c0       	mov    %eax,0xc000d024

}
c0002c5e:	90                   	nop
c0002c5f:	c9                   	leave  
c0002c60:	c3                   	ret    

c0002c61 <ksbrk>:



// increment heap size, return pointer to *old* break (beginning of newly allocated memory)
void* ksbrk(size_t increment)
{
c0002c61:	55                   	push   %ebp
c0002c62:	89 e5                	mov    %esp,%ebp
c0002c64:	83 ec 18             	sub    $0x18,%esp
    if(increment == 0) return kheap_brk;
c0002c67:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002c6b:	75 07                	jne    c0002c74 <ksbrk+0x13>
c0002c6d:	a1 28 d0 00 c0       	mov    0xc000d028,%eax
c0002c72:	eb 2d                	jmp    c0002ca1 <ksbrk+0x40>

    page_t* old_brk = kheap_brk;
c0002c74:	a1 28 d0 00 c0       	mov    0xc000d028,%eax
c0002c79:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(kbrk(((char*)kheap_brk) + increment)) return NULL;
c0002c7c:	8b 15 28 d0 00 c0    	mov    0xc000d028,%edx
c0002c82:	8b 45 08             	mov    0x8(%ebp),%eax
c0002c85:	01 d0                	add    %edx,%eax
c0002c87:	83 ec 0c             	sub    $0xc,%esp
c0002c8a:	50                   	push   %eax
c0002c8b:	e8 13 00 00 00       	call   c0002ca3 <kbrk>
c0002c90:	83 c4 10             	add    $0x10,%esp
c0002c93:	85 c0                	test   %eax,%eax
c0002c95:	74 07                	je     c0002c9e <ksbrk+0x3d>
c0002c97:	b8 00 00 00 00       	mov    $0x0,%eax
c0002c9c:	eb 03                	jmp    c0002ca1 <ksbrk+0x40>

    return old_brk;
c0002c9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0002ca1:	c9                   	leave  
c0002ca2:	c3                   	ret    

c0002ca3 <kbrk>:

// set kheap break to addr, growing or shrinking heap accordingly
// returns 0 on success
int kbrk(void* addr)
{
c0002ca3:	55                   	push   %ebp
c0002ca4:	89 e5                	mov    %esp,%ebp
c0002ca6:	83 ec 18             	sub    $0x18,%esp
    //make sure this is a valid break (not before heap begins or into stack)
    if(addr < (void*) kheap_base || addr >= (void*) task_brk)
c0002ca9:	a1 2c d0 00 c0       	mov    0xc000d02c,%eax
c0002cae:	39 45 08             	cmp    %eax,0x8(%ebp)
c0002cb1:	72 0a                	jb     c0002cbd <kbrk+0x1a>
c0002cb3:	a1 24 d0 00 c0       	mov    0xc000d024,%eax
c0002cb8:	39 45 08             	cmp    %eax,0x8(%ebp)
c0002cbb:	72 0a                	jb     c0002cc7 <kbrk+0x24>
        return -1; 
c0002cbd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002cc2:	e9 92 00 00 00       	jmp    c0002d59 <kbrk+0xb6>

    page_t* pg_addr = align_ptr(addr, PAGE_SIZE); // align addr to a page
c0002cc7:	68 00 10 00 00       	push   $0x1000
c0002ccc:	ff 75 08             	pushl  0x8(%ebp)
c0002ccf:	e8 23 fc ff ff       	call   c00028f7 <align_ptr>
c0002cd4:	83 c4 08             	add    $0x8,%esp
c0002cd7:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(pg_addr > kheap_brk)
c0002cda:	a1 28 d0 00 c0       	mov    0xc000d028,%eax
c0002cdf:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0002ce2:	76 66                	jbe    c0002d4a <kbrk+0xa7>
    {
        // we are increasing size of the heap
        while(pg_addr > kheap_brk)
c0002ce4:	eb 2d                	jmp    c0002d13 <kbrk+0x70>
        {
            // allocate a new page and map to end of heap
            if(!map_page(kheap_brk, PAGE_FLAG_WRITE))
c0002ce6:	a1 28 d0 00 c0       	mov    0xc000d028,%eax
c0002ceb:	83 ec 08             	sub    $0x8,%esp
c0002cee:	6a 02                	push   $0x2
c0002cf0:	50                   	push   %eax
c0002cf1:	e8 51 03 00 00       	call   c0003047 <map_page>
c0002cf6:	83 c4 10             	add    $0x10,%esp
c0002cf9:	85 c0                	test   %eax,%eax
c0002cfb:	75 07                	jne    c0002d04 <kbrk+0x61>
                return -1; // out of physical memory
c0002cfd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002d02:	eb 55                	jmp    c0002d59 <kbrk+0xb6>
            
            kheap_brk++;
c0002d04:	a1 28 d0 00 c0       	mov    0xc000d028,%eax
c0002d09:	05 00 10 00 00       	add    $0x1000,%eax
c0002d0e:	a3 28 d0 00 c0       	mov    %eax,0xc000d028
        while(pg_addr > kheap_brk)
c0002d13:	a1 28 d0 00 c0       	mov    0xc000d028,%eax
c0002d18:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0002d1b:	77 c9                	ja     c0002ce6 <kbrk+0x43>
c0002d1d:	eb 35                	jmp    c0002d54 <kbrk+0xb1>
    {
        // we are decreasing size of the heap
        while(pg_addr < kheap_brk)
        {
            //free page from end of heap
            if(unmap_page(--kheap_brk))
c0002d1f:	a1 28 d0 00 c0       	mov    0xc000d028,%eax
c0002d24:	2d 00 10 00 00       	sub    $0x1000,%eax
c0002d29:	a3 28 d0 00 c0       	mov    %eax,0xc000d028
c0002d2e:	a1 28 d0 00 c0       	mov    0xc000d028,%eax
c0002d33:	83 ec 0c             	sub    $0xc,%esp
c0002d36:	50                   	push   %eax
c0002d37:	e8 2a 03 00 00       	call   c0003066 <unmap_page>
c0002d3c:	83 c4 10             	add    $0x10,%esp
c0002d3f:	85 c0                	test   %eax,%eax
c0002d41:	74 07                	je     c0002d4a <kbrk+0xa7>
                return -1; // error!
c0002d43:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002d48:	eb 0f                	jmp    c0002d59 <kbrk+0xb6>
        while(pg_addr < kheap_brk)
c0002d4a:	a1 28 d0 00 c0       	mov    0xc000d028,%eax
c0002d4f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0002d52:	72 cb                	jb     c0002d1f <kbrk+0x7c>
        }
    }

	// kprintf("Setting kernel heap break to 0x%x\n", kheap_brk);
    
    return 0;
c0002d54:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002d59:	c9                   	leave  
c0002d5a:	c3                   	ret    

c0002d5b <new_tcb>:


task_control_block_t* new_tcb()
{
c0002d5b:	55                   	push   %ebp
c0002d5c:	89 e5                	mov    %esp,%ebp
c0002d5e:	83 ec 18             	sub    $0x18,%esp
    task_control_block_t* tcb;

    // are there free tcbs in the tcb stack?
    if(tcb_stack_base == tcb_stack_top)
c0002d61:	8b 15 20 d0 00 c0    	mov    0xc000d020,%edx
c0002d67:	a1 1c d0 00 c0       	mov    0xc000d01c,%eax
c0002d6c:	39 c2                	cmp    %eax,%edx
c0002d6e:	75 42                	jne    c0002db2 <new_tcb+0x57>
    {
        //no - we need to expand task memory
        if(task_brk < (task_control_block_t*) kheap_brk)
c0002d70:	8b 15 24 d0 00 c0    	mov    0xc000d024,%edx
c0002d76:	a1 28 d0 00 c0       	mov    0xc000d028,%eax
c0002d7b:	39 c2                	cmp    %eax,%edx
c0002d7d:	73 1a                	jae    c0002d99 <new_tcb+0x3e>
        {
            panic("OUT OF KERNEL VIRTUAL MEMORY SPACE!");
c0002d7f:	83 ec 0c             	sub    $0xc,%esp
c0002d82:	68 28 57 00 c0       	push   $0xc0005728
c0002d87:	e8 76 e9 ff ff       	call   c0001702 <panic>
c0002d8c:	83 c4 10             	add    $0x10,%esp
            return NULL;
c0002d8f:	b8 00 00 00 00       	mov    $0x0,%eax
c0002d94:	e9 d8 00 00 00       	jmp    c0002e71 <new_tcb+0x116>
        }

        tcb = --task_brk;
c0002d99:	a1 24 d0 00 c0       	mov    0xc000d024,%eax
c0002d9e:	2d 00 50 00 00       	sub    $0x5000,%eax
c0002da3:	a3 24 d0 00 c0       	mov    %eax,0xc000d024
c0002da8:	a1 24 d0 00 c0       	mov    0xc000d024,%eax
c0002dad:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002db0:	eb 13                	jmp    c0002dc5 <new_tcb+0x6a>
    }
    else
    {
        //yes, pop available tcb address off stack
        tcb = *(tcb_stack_top++);
c0002db2:	a1 1c d0 00 c0       	mov    0xc000d01c,%eax
c0002db7:	8d 50 04             	lea    0x4(%eax),%edx
c0002dba:	89 15 1c d0 00 c0    	mov    %edx,0xc000d01c
c0002dc0:	8b 00                	mov    (%eax),%eax
c0002dc2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    // allocate memory for tcb
    // 1st page: tcb data
    if(!map_page_at((page_t*) tcb, pop_free_frame(), PAGE_FLAG_WRITE))
c0002dc5:	e8 52 fb ff ff       	call   c000291c <pop_free_frame>
c0002dca:	83 ec 04             	sub    $0x4,%esp
c0002dcd:	6a 02                	push   $0x2
c0002dcf:	50                   	push   %eax
c0002dd0:	ff 75 f4             	pushl  -0xc(%ebp)
c0002dd3:	e8 e3 01 00 00       	call   c0002fbb <map_page_at>
c0002dd8:	83 c4 10             	add    $0x10,%esp
c0002ddb:	85 c0                	test   %eax,%eax
c0002ddd:	75 0a                	jne    c0002de9 <new_tcb+0x8e>
        return NULL;
c0002ddf:	b8 00 00 00 00       	mov    $0x0,%eax
c0002de4:	e9 88 00 00 00       	jmp    c0002e71 <new_tcb+0x116>
    // 2nd page: page directory
    if(!map_page_at( (page_t*) &tcb->pd, pop_free_frame(), PAGE_FLAG_WRITE))
c0002de9:	e8 2e fb ff ff       	call   c000291c <pop_free_frame>
c0002dee:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002df1:	81 c2 00 10 00 00    	add    $0x1000,%edx
c0002df7:	83 ec 04             	sub    $0x4,%esp
c0002dfa:	6a 02                	push   $0x2
c0002dfc:	50                   	push   %eax
c0002dfd:	52                   	push   %edx
c0002dfe:	e8 b8 01 00 00       	call   c0002fbb <map_page_at>
c0002e03:	83 c4 10             	add    $0x10,%esp
c0002e06:	85 c0                	test   %eax,%eax
c0002e08:	75 15                	jne    c0002e1f <new_tcb+0xc4>
    {
        free_tcb(tcb);
c0002e0a:	83 ec 0c             	sub    $0xc,%esp
c0002e0d:	ff 75 f4             	pushl  -0xc(%ebp)
c0002e10:	e8 5e 00 00 00       	call   c0002e73 <free_tcb>
c0002e15:	83 c4 10             	add    $0x10,%esp
        return NULL;        
c0002e18:	b8 00 00 00 00       	mov    $0x0,%eax
c0002e1d:	eb 52                	jmp    c0002e71 <new_tcb+0x116>
    }
    // allocate kernel stacks. map stack pages, and *unmap* guard page
    for(int nn=0; nn<KSTACKS_PER_PROCESS; nn++)
c0002e1f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0002e26:	eb 40                	jmp    c0002e68 <new_tcb+0x10d>
    {
        if(init_kstack(&tcb->kstacks[nn]))
c0002e28:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0002e2b:	89 d0                	mov    %edx,%eax
c0002e2d:	01 c0                	add    %eax,%eax
c0002e2f:	01 d0                	add    %edx,%eax
c0002e31:	c1 e0 0c             	shl    $0xc,%eax
c0002e34:	8d 90 00 20 00 00    	lea    0x2000(%eax),%edx
c0002e3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002e3d:	01 d0                	add    %edx,%eax
c0002e3f:	83 ec 0c             	sub    $0xc,%esp
c0002e42:	50                   	push   %eax
c0002e43:	e8 4c fd ff ff       	call   c0002b94 <init_kstack>
c0002e48:	83 c4 10             	add    $0x10,%esp
c0002e4b:	85 c0                	test   %eax,%eax
c0002e4d:	74 15                	je     c0002e64 <new_tcb+0x109>
        {
            free_tcb(tcb);
c0002e4f:	83 ec 0c             	sub    $0xc,%esp
c0002e52:	ff 75 f4             	pushl  -0xc(%ebp)
c0002e55:	e8 19 00 00 00       	call   c0002e73 <free_tcb>
c0002e5a:	83 c4 10             	add    $0x10,%esp
            return NULL;
c0002e5d:	b8 00 00 00 00       	mov    $0x0,%eax
c0002e62:	eb 0d                	jmp    c0002e71 <new_tcb+0x116>
    for(int nn=0; nn<KSTACKS_PER_PROCESS; nn++)
c0002e64:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0002e68:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0002e6c:	7e ba                	jle    c0002e28 <new_tcb+0xcd>
        }
    }
    
    return tcb;
c0002e6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0002e71:	c9                   	leave  
c0002e72:	c3                   	ret    

c0002e73 <free_tcb>:

int free_tcb(task_control_block_t* tcb)
{
c0002e73:	55                   	push   %ebp
c0002e74:	89 e5                	mov    %esp,%ebp
c0002e76:	83 ec 18             	sub    $0x18,%esp
    //free the tcb pages
    page_t* tcb_page = (page_t*) tcb;
c0002e79:	8b 45 08             	mov    0x8(%ebp),%eax
c0002e7c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(size_t nn=0; nn<sizeof(task_control_block_t)/PAGE_SIZE; nn++)
c0002e7f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0002e86:	eb 1c                	jmp    c0002ea4 <free_tcb+0x31>
        unmap_page(tcb_page++);
c0002e88:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002e8b:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c0002e91:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0002e94:	83 ec 0c             	sub    $0xc,%esp
c0002e97:	50                   	push   %eax
c0002e98:	e8 c9 01 00 00       	call   c0003066 <unmap_page>
c0002e9d:	83 c4 10             	add    $0x10,%esp
    for(size_t nn=0; nn<sizeof(task_control_block_t)/PAGE_SIZE; nn++)
c0002ea0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0002ea4:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
c0002ea8:	76 de                	jbe    c0002e88 <free_tcb+0x15>

    //push address of tcb onto free tcb stack
    *(--tcb_stack_top) = tcb;
c0002eaa:	a1 1c d0 00 c0       	mov    0xc000d01c,%eax
c0002eaf:	83 e8 04             	sub    $0x4,%eax
c0002eb2:	a3 1c d0 00 c0       	mov    %eax,0xc000d01c
c0002eb7:	a1 1c d0 00 c0       	mov    0xc000d01c,%eax
c0002ebc:	8b 55 08             	mov    0x8(%ebp),%edx
c0002ebf:	89 10                	mov    %edx,(%eax)

    //if tcb_stack fills up, we will get a page fault...

    return 0;
c0002ec1:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002ec6:	c9                   	leave  
c0002ec7:	c3                   	ret    

c0002ec8 <init_kernel_memory>:



int init_kernel_memory(multiboot_info_t* mbd)
{
c0002ec8:	55                   	push   %ebp
c0002ec9:	89 e5                	mov    %esp,%ebp
c0002ecb:	83 ec 08             	sub    $0x8,%esp
    //set up stack of free physical frames available for dynamic allocation
    init_frame_stack(mbd);
c0002ece:	83 ec 0c             	sub    $0xc,%esp
c0002ed1:	ff 75 08             	pushl  0x8(%ebp)
c0002ed4:	e8 aa fa ff ff       	call   c0002983 <init_frame_stack>
c0002ed9:	83 c4 10             	add    $0x10,%esp

    //set up stack of free tcb addresses
    init_tcb_stack();
c0002edc:	e8 13 fd ff ff       	call   c0002bf4 <init_tcb_stack>

    //initialize kernel heap (empty) after the frame stack
    kheap_base = frame_stack_brk;
c0002ee1:	a1 14 d0 00 c0       	mov    0xc000d014,%eax
c0002ee6:	a3 2c d0 00 c0       	mov    %eax,0xc000d02c
    kheap_brk = kheap_base;
c0002eeb:	a1 2c d0 00 c0       	mov    0xc000d02c,%eax
c0002ef0:	a3 28 d0 00 c0       	mov    %eax,0xc000d028

    // we don't need the 1st MB anymore so unmap it
	// if( unmap_lowmem() )
    //     return -1;

    return 0;
c0002ef5:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002efa:	c9                   	leave  
c0002efb:	c3                   	ret    

c0002efc <unmap_lowmem>:

int unmap_lowmem()
{
c0002efc:	55                   	push   %ebp
c0002efd:	89 e5                	mov    %esp,%ebp
c0002eff:	83 ec 08             	sub    $0x8,%esp
    paging->dir.pde[0] = PAGE_FLAG_EMPTY;
c0002f02:	a1 00 60 00 c0       	mov    0xc0006000,%eax
c0002f07:	c7 80 00 f0 3f 00 00 	movl   $0x0,0x3ff000(%eax)
c0002f0e:	00 00 00 
    refresh_tlb();
c0002f11:	e8 ba 13 00 00       	call   c00042d0 <refresh_tlb>
    return 0;
c0002f16:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002f1b:	c9                   	leave  
c0002f1c:	c3                   	ret    

c0002f1d <map_hardware_buffer>:

int map_hardware_buffer(void* buffer_virtual, void* buffer_physical, size_t buffer_size, uint32_t page_flags)
{
c0002f1d:	55                   	push   %ebp
c0002f1e:	89 e5                	mov    %esp,%ebp
c0002f20:	83 ec 18             	sub    $0x18,%esp
    //ensure buffers are page-aligned
    if(((size_t) buffer_virtual & ~PAGE_ADDRMASK) || ((size_t) buffer_physical & ~PAGE_ADDRMASK) )
c0002f23:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f26:	25 ff 0f 00 00       	and    $0xfff,%eax
c0002f2b:	85 c0                	test   %eax,%eax
c0002f2d:	75 0c                	jne    c0002f3b <map_hardware_buffer+0x1e>
c0002f2f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002f32:	25 ff 0f 00 00       	and    $0xfff,%eax
c0002f37:	85 c0                	test   %eax,%eax
c0002f39:	74 07                	je     c0002f42 <map_hardware_buffer+0x25>
        return -1;
c0002f3b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002f40:	eb 77                	jmp    c0002fb9 <map_hardware_buffer+0x9c>

    //ensure virtual address is in kernel space
    if(buffer_virtual < (void*) KERNEL_BASE)
c0002f42:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
c0002f49:	77 07                	ja     c0002f52 <map_hardware_buffer+0x35>
        return -1;
c0002f4b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002f50:	eb 67                	jmp    c0002fb9 <map_hardware_buffer+0x9c>

    page_t* page = (page_t*) buffer_virtual;
c0002f52:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f55:	89 45 f4             	mov    %eax,-0xc(%ebp)
    page_t* frame = (page_t*) buffer_physical;
c0002f58:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002f5b:	89 45 f0             	mov    %eax,-0x10(%ebp)

    size_t Npages = (buffer_size + PAGE_SIZE - 1) >> 12;
c0002f5e:	8b 45 10             	mov    0x10(%ebp),%eax
c0002f61:	05 ff 0f 00 00       	add    $0xfff,%eax
c0002f66:	c1 e8 0c             	shr    $0xc,%eax
c0002f69:	89 45 e8             	mov    %eax,-0x18(%ebp)
    for(size_t nn = 0; nn < Npages; nn++)
c0002f6c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0002f73:	eb 37                	jmp    c0002fac <map_hardware_buffer+0x8f>
        if(!map_page_at(page++,frame++, page_flags)) return -1;
c0002f75:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0002f78:	8d 82 00 10 00 00    	lea    0x1000(%edx),%eax
c0002f7e:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0002f81:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002f84:	8d 88 00 10 00 00    	lea    0x1000(%eax),%ecx
c0002f8a:	89 4d f4             	mov    %ecx,-0xc(%ebp)
c0002f8d:	83 ec 04             	sub    $0x4,%esp
c0002f90:	ff 75 14             	pushl  0x14(%ebp)
c0002f93:	52                   	push   %edx
c0002f94:	50                   	push   %eax
c0002f95:	e8 21 00 00 00       	call   c0002fbb <map_page_at>
c0002f9a:	83 c4 10             	add    $0x10,%esp
c0002f9d:	85 c0                	test   %eax,%eax
c0002f9f:	75 07                	jne    c0002fa8 <map_hardware_buffer+0x8b>
c0002fa1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002fa6:	eb 11                	jmp    c0002fb9 <map_hardware_buffer+0x9c>
    for(size_t nn = 0; nn < Npages; nn++)
c0002fa8:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0002fac:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002faf:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0002fb2:	72 c1                	jb     c0002f75 <map_hardware_buffer+0x58>
    
    return 0;
c0002fb4:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002fb9:	c9                   	leave  
c0002fba:	c3                   	ret    

c0002fbb <map_page_at>:


page_t* map_page_at(page_t* page, page_t* frame, uint32_t flags)
{
c0002fbb:	55                   	push   %ebp
c0002fbc:	89 e5                	mov    %esp,%ebp
c0002fbe:	53                   	push   %ebx
c0002fbf:	83 ec 14             	sub    $0x14,%esp
    page_table_t* pt = get_table(page);
c0002fc2:	83 ec 0c             	sub    $0xc,%esp
c0002fc5:	ff 75 08             	pushl  0x8(%ebp)
c0002fc8:	e8 24 f8 ff ff       	call   c00027f1 <get_table>
c0002fcd:	83 c4 10             	add    $0x10,%esp
c0002fd0:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(!pt)
c0002fd3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002fd7:	75 10                	jne    c0002fe9 <map_page_at+0x2e>
    {
        // we are setting up all the page tables for kernel space (>0xc0000000) at boot,
        // so if a PT missing theres a problem
        panic("Kernel page table missing!");
c0002fd9:	83 ec 0c             	sub    $0xc,%esp
c0002fdc:	68 4c 57 00 c0       	push   $0xc000574c
c0002fe1:	e8 1c e7 ff ff       	call   c0001702 <panic>
c0002fe6:	83 c4 10             	add    $0x10,%esp
        // pt = new_page_table(page, flags); // page table is not present, allocate a new one
    }
    
    if(pt->pte[get_ptindex(page)] & PAGE_FLAG_PRESENT)
c0002fe9:	83 ec 0c             	sub    $0xc,%esp
c0002fec:	ff 75 08             	pushl  0x8(%ebp)
c0002fef:	e8 c8 f8 ff ff       	call   c00028bc <get_ptindex>
c0002ff4:	83 c4 10             	add    $0x10,%esp
c0002ff7:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002ffa:	8b 04 82             	mov    (%edx,%eax,4),%eax
c0002ffd:	83 e0 01             	and    $0x1,%eax
c0003000:	85 c0                	test   %eax,%eax
c0003002:	74 07                	je     c000300b <map_page_at+0x50>
        return NULL; //page already mapped
c0003004:	b8 00 00 00 00       	mov    $0x0,%eax
c0003009:	eb 37                	jmp    c0003042 <map_page_at+0x87>

    // map page
    pt->pte[get_ptindex(page)] = (((uint32_t) frame) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c000300b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000300e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0003013:	0b 45 10             	or     0x10(%ebp),%eax
c0003016:	89 c3                	mov    %eax,%ebx
c0003018:	83 ec 0c             	sub    $0xc,%esp
c000301b:	ff 75 08             	pushl  0x8(%ebp)
c000301e:	e8 99 f8 ff ff       	call   c00028bc <get_ptindex>
c0003023:	83 c4 10             	add    $0x10,%esp
c0003026:	89 d9                	mov    %ebx,%ecx
c0003028:	83 c9 01             	or     $0x1,%ecx
c000302b:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000302e:	89 0c 82             	mov    %ecx,(%edx,%eax,4)

    refresh_page(page);
c0003031:	83 ec 0c             	sub    $0xc,%esp
c0003034:	ff 75 08             	pushl  0x8(%ebp)
c0003037:	e8 9c 12 00 00       	call   c00042d8 <refresh_page>
c000303c:	83 c4 10             	add    $0x10,%esp
    return page;
c000303f:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0003042:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0003045:	c9                   	leave  
c0003046:	c3                   	ret    

c0003047 <map_page>:

page_t* map_page(page_t* page, uint32_t flags)
{
c0003047:	55                   	push   %ebp
c0003048:	89 e5                	mov    %esp,%ebp
c000304a:	83 ec 08             	sub    $0x8,%esp
    return map_page_at(page, pop_free_frame(), flags);
c000304d:	e8 ca f8 ff ff       	call   c000291c <pop_free_frame>
c0003052:	83 ec 04             	sub    $0x4,%esp
c0003055:	ff 75 0c             	pushl  0xc(%ebp)
c0003058:	50                   	push   %eax
c0003059:	ff 75 08             	pushl  0x8(%ebp)
c000305c:	e8 5a ff ff ff       	call   c0002fbb <map_page_at>
c0003061:	83 c4 10             	add    $0x10,%esp
}
c0003064:	c9                   	leave  
c0003065:	c3                   	ret    

c0003066 <unmap_page>:


// unmap page and return previous flags
uint32_t unmap_page(page_t* page)
{
c0003066:	55                   	push   %ebp
c0003067:	89 e5                	mov    %esp,%ebp
c0003069:	83 ec 18             	sub    $0x18,%esp
    page_table_t* pt = get_table(page);
c000306c:	83 ec 0c             	sub    $0xc,%esp
c000306f:	ff 75 08             	pushl  0x8(%ebp)
c0003072:	e8 7a f7 ff ff       	call   c00027f1 <get_table>
c0003077:	83 c4 10             	add    $0x10,%esp
c000307a:	89 45 f4             	mov    %eax,-0xc(%ebp)

    uint32_t pt_index = get_ptindex(page);
c000307d:	83 ec 0c             	sub    $0xc,%esp
c0003080:	ff 75 08             	pushl  0x8(%ebp)
c0003083:	e8 34 f8 ff ff       	call   c00028bc <get_ptindex>
c0003088:	83 c4 10             	add    $0x10,%esp
c000308b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint32_t pte = pt->pte[pt_index];
c000308e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003091:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0003094:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0003097:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // if the page had been allocated, push the physical frame address back onto the free frame stack
    if(pte & PAGE_FLAG_PRESENT)
c000309a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000309d:	83 e0 01             	and    $0x1,%eax
c00030a0:	85 c0                	test   %eax,%eax
c00030a2:	74 14                	je     c00030b8 <unmap_page+0x52>
        push_free_frame( (page_t*) (pte & PAGE_ADDRMASK));
c00030a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00030a7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00030ac:	83 ec 0c             	sub    $0xc,%esp
c00030af:	50                   	push   %eax
c00030b0:	e8 9b f8 ff ff       	call   c0002950 <push_free_frame>
c00030b5:	83 c4 10             	add    $0x10,%esp

    // unmap page
    pt->pte[pt_index] = 0;
c00030b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00030bb:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00030be:	c7 04 90 00 00 00 00 	movl   $0x0,(%eax,%edx,4)

    refresh_page(page);
c00030c5:	83 ec 0c             	sub    $0xc,%esp
c00030c8:	ff 75 08             	pushl  0x8(%ebp)
c00030cb:	e8 08 12 00 00       	call   c00042d8 <refresh_page>
c00030d0:	83 c4 10             	add    $0x10,%esp

    // return the previous page table flags
    return pte & PAGE_FLAGSMASK;
c00030d3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00030d6:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c00030db:	c9                   	leave  
c00030dc:	c3                   	ret    

c00030dd <new_page_table>:

page_table_t* new_page_table(void* addr, uint32_t flags)
{
c00030dd:	55                   	push   %ebp
c00030de:	89 e5                	mov    %esp,%ebp
c00030e0:	83 ec 18             	sub    $0x18,%esp
    uint32_t pdindex = get_pdindex(addr);      // index into page dir (which table does this address point to)
c00030e3:	ff 75 08             	pushl  0x8(%ebp)
c00030e6:	e8 e1 f7 ff ff       	call   c00028cc <get_pdindex>
c00030eb:	83 c4 04             	add    $0x4,%esp
c00030ee:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // is this table already mapped?
    if(paging->dir.pde[pdindex] & PAGE_FLAG_PRESENT)
c00030f1:	a1 00 60 00 c0       	mov    0xc0006000,%eax
c00030f6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00030f9:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c00030ff:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0003102:	83 e0 01             	and    $0x1,%eax
c0003105:	85 c0                	test   %eax,%eax
c0003107:	74 07                	je     c0003110 <new_page_table+0x33>
        return NULL;
c0003109:	b8 00 00 00 00       	mov    $0x0,%eax
c000310e:	eb 70                	jmp    c0003180 <new_page_table+0xa3>

    page_t* pp = pop_free_frame();         // find a free page in physical mem for page table
c0003110:	e8 07 f8 ff ff       	call   c000291c <pop_free_frame>
c0003115:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!pp) return NULL; // OOM
c0003118:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000311c:	75 07                	jne    c0003125 <new_page_table+0x48>
c000311e:	b8 00 00 00 00       	mov    $0x0,%eax
c0003123:	eb 5b                	jmp    c0003180 <new_page_table+0xa3>

    // we don't need to allocate virtual memory space, since table lives in our paging structure
    page_table_t* pv = paging->tables + pdindex;        // pointer to table (virtual)
c0003125:	a1 00 60 00 c0       	mov    0xc0006000,%eax
c000312a:	89 c2                	mov    %eax,%edx
c000312c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000312f:	c1 e0 0c             	shl    $0xc,%eax
c0003132:	01 d0                	add    %edx,%eax
c0003134:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // map table: point the paging entry at the physical page we just reserved, and set flags
    paging->dir.pde[pdindex] = (((uint32_t) pp) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0003137:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000313a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c000313f:	0b 45 0c             	or     0xc(%ebp),%eax
c0003142:	89 c2                	mov    %eax,%edx
c0003144:	a1 00 60 00 c0       	mov    0xc0006000,%eax
c0003149:	89 d1                	mov    %edx,%ecx
c000314b:	83 c9 01             	or     $0x1,%ecx
c000314e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0003151:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c0003157:	89 0c 90             	mov    %ecx,(%eax,%edx,4)

    // flush the tlb
    refresh_page(pv);
c000315a:	83 ec 0c             	sub    $0xc,%esp
c000315d:	ff 75 ec             	pushl  -0x14(%ebp)
c0003160:	e8 73 11 00 00       	call   c00042d8 <refresh_page>
c0003165:	83 c4 10             	add    $0x10,%esp

    //clear table
    memset((char*) pv, 0, PAGE_SIZE);     
c0003168:	83 ec 04             	sub    $0x4,%esp
c000316b:	68 00 10 00 00       	push   $0x1000
c0003170:	6a 00                	push   $0x0
c0003172:	ff 75 ec             	pushl  -0x14(%ebp)
c0003175:	e8 6a e6 ff ff       	call   c00017e4 <memset>
c000317a:	83 c4 10             	add    $0x10,%esp

    // return pointer to table (virtual)
    return pv;
c000317d:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c0003180:	c9                   	leave  
c0003181:	c3                   	ret    

c0003182 <print_testresult>:

#include "test.h"
#include "kprintf.h"

int print_testresult(int status, char* message)
{
c0003182:	55                   	push   %ebp
c0003183:	89 e5                	mov    %esp,%ebp
c0003185:	83 ec 18             	sub    $0x18,%esp
    uint8_t color = terminal_getcolor(&stdout);
c0003188:	83 ec 0c             	sub    $0xc,%esp
c000318b:	68 00 70 00 c0       	push   $0xc0007000
c0003190:	e8 f3 d3 ff ff       	call   c0000588 <terminal_getcolor>
c0003195:	83 c4 10             	add    $0x10,%esp
c0003198:	88 45 f7             	mov    %al,-0x9(%ebp)
    kprintf("[");
c000319b:	83 ec 0c             	sub    $0xc,%esp
c000319e:	68 67 57 00 c0       	push   $0xc0005767
c00031a3:	e8 3d d7 ff ff       	call   c00008e5 <kprintf>
c00031a8:	83 c4 10             	add    $0x10,%esp
    if(status)
c00031ab:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00031af:	74 24                	je     c00031d5 <print_testresult+0x53>
    {
        terminal_setcolor(&stdout, VGA_COLOR_RED);
c00031b1:	83 ec 08             	sub    $0x8,%esp
c00031b4:	6a 04                	push   $0x4
c00031b6:	68 00 70 00 c0       	push   $0xc0007000
c00031bb:	e8 af d3 ff ff       	call   c000056f <terminal_setcolor>
c00031c0:	83 c4 10             	add    $0x10,%esp
        kprintf("FAILED");
c00031c3:	83 ec 0c             	sub    $0xc,%esp
c00031c6:	68 69 57 00 c0       	push   $0xc0005769
c00031cb:	e8 15 d7 ff ff       	call   c00008e5 <kprintf>
c00031d0:	83 c4 10             	add    $0x10,%esp
c00031d3:	eb 22                	jmp    c00031f7 <print_testresult+0x75>
    }
    else
    {
        terminal_setcolor(&stdout, VGA_COLOR_GREEN);
c00031d5:	83 ec 08             	sub    $0x8,%esp
c00031d8:	6a 02                	push   $0x2
c00031da:	68 00 70 00 c0       	push   $0xc0007000
c00031df:	e8 8b d3 ff ff       	call   c000056f <terminal_setcolor>
c00031e4:	83 c4 10             	add    $0x10,%esp
        kprintf("SUCCESS");
c00031e7:	83 ec 0c             	sub    $0xc,%esp
c00031ea:	68 70 57 00 c0       	push   $0xc0005770
c00031ef:	e8 f1 d6 ff ff       	call   c00008e5 <kprintf>
c00031f4:	83 c4 10             	add    $0x10,%esp
    }

    terminal_setcolor(&stdout, color);
c00031f7:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c00031fb:	83 ec 08             	sub    $0x8,%esp
c00031fe:	50                   	push   %eax
c00031ff:	68 00 70 00 c0       	push   $0xc0007000
c0003204:	e8 66 d3 ff ff       	call   c000056f <terminal_setcolor>
c0003209:	83 c4 10             	add    $0x10,%esp
    kprintf("] ");
c000320c:	83 ec 0c             	sub    $0xc,%esp
c000320f:	68 78 57 00 c0       	push   $0xc0005778
c0003214:	e8 cc d6 ff ff       	call   c00008e5 <kprintf>
c0003219:	83 c4 10             	add    $0x10,%esp

    kprintf(message);
c000321c:	83 ec 0c             	sub    $0xc,%esp
c000321f:	ff 75 0c             	pushl  0xc(%ebp)
c0003222:	e8 be d6 ff ff       	call   c00008e5 <kprintf>
c0003227:	83 c4 10             	add    $0x10,%esp
    kprintf("\n");
c000322a:	83 ec 0c             	sub    $0xc,%esp
c000322d:	68 7b 57 00 c0       	push   $0xc000577b
c0003232:	e8 ae d6 ff ff       	call   c00008e5 <kprintf>
c0003237:	83 c4 10             	add    $0x10,%esp
    
    return status;
c000323a:	8b 45 08             	mov    0x8(%ebp),%eax
}
c000323d:	c9                   	leave  
c000323e:	c3                   	ret    

c000323f <run_unit_tests>:

// returns zero on all pass, or negative of number failed tests
int run_unit_tests()
{
c000323f:	55                   	push   %ebp
c0003240:	89 e5                	mov    %esp,%ebp
c0003242:	83 ec 18             	sub    $0x18,%esp
    kprintf("\nRunning Unit Tests...\n");
c0003245:	83 ec 0c             	sub    $0xc,%esp
c0003248:	68 7d 57 00 c0       	push   $0xc000577d
c000324d:	e8 93 d6 ff ff       	call   c00008e5 <kprintf>
c0003252:	83 c4 10             	add    $0x10,%esp
    int passed = 0;
c0003255:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    int total = 0;
c000325c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    passed = print_testresult(test_kmalloc(), "kmalloc") ? 0 : passed+1;
c0003263:	e8 3a cf ff ff       	call   c00001a2 <test_kmalloc>
c0003268:	83 ec 08             	sub    $0x8,%esp
c000326b:	68 95 57 00 c0       	push   $0xc0005795
c0003270:	50                   	push   %eax
c0003271:	e8 0c ff ff ff       	call   c0003182 <print_testresult>
c0003276:	83 c4 10             	add    $0x10,%esp
c0003279:	85 c0                	test   %eax,%eax
c000327b:	75 08                	jne    c0003285 <run_unit_tests+0x46>
c000327d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003280:	83 c0 01             	add    $0x1,%eax
c0003283:	eb 05                	jmp    c000328a <run_unit_tests+0x4b>
c0003285:	b8 00 00 00 00       	mov    $0x0,%eax
c000328a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    total++;
c000328d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    passed = print_testresult(test_multitasking(), "Multitasking") ? 0 : passed+1;
c0003291:	e8 31 08 00 00       	call   c0003ac7 <test_multitasking>
c0003296:	83 ec 08             	sub    $0x8,%esp
c0003299:	68 9d 57 00 c0       	push   $0xc000579d
c000329e:	50                   	push   %eax
c000329f:	e8 de fe ff ff       	call   c0003182 <print_testresult>
c00032a4:	83 c4 10             	add    $0x10,%esp
c00032a7:	85 c0                	test   %eax,%eax
c00032a9:	75 08                	jne    c00032b3 <run_unit_tests+0x74>
c00032ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00032ae:	83 c0 01             	add    $0x1,%eax
c00032b1:	eb 05                	jmp    c00032b8 <run_unit_tests+0x79>
c00032b3:	b8 00 00 00 00       	mov    $0x0,%eax
c00032b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    total++;
c00032bb:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

    kprintf("%d of %d Unit tests passed", passed, total);
c00032bf:	83 ec 04             	sub    $0x4,%esp
c00032c2:	ff 75 f0             	pushl  -0x10(%ebp)
c00032c5:	ff 75 f4             	pushl  -0xc(%ebp)
c00032c8:	68 aa 57 00 c0       	push   $0xc00057aa
c00032cd:	e8 13 d6 ff ff       	call   c00008e5 <kprintf>
c00032d2:	83 c4 10             	add    $0x10,%esp

    if(passed != total)
c00032d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00032d8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c00032db:	74 08                	je     c00032e5 <run_unit_tests+0xa6>
        return passed-total;
c00032dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00032e0:	2b 45 f0             	sub    -0x10(%ebp),%eax
c00032e3:	eb 05                	jmp    c00032ea <run_unit_tests+0xab>

    return 0;
c00032e5:	b8 00 00 00 00       	mov    $0x0,%eax
c00032ea:	c9                   	leave  
c00032eb:	c3                   	ret    

c00032ec <kheap_validate_block>:
int kheap_size(size_t* allocated, size_t* free);


// check magic number
static inline int kheap_validate_block(heap_block_t* b)
{
c00032ec:	55                   	push   %ebp
c00032ed:	89 e5                	mov    %esp,%ebp
    return b->magic != HEAP_BLOCK_MAGIC;
c00032ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00032f2:	8b 00                	mov    (%eax),%eax
c00032f4:	25 ff ff ff 0f       	and    $0xfffffff,%eax
c00032f9:	3d ef be 23 01       	cmp    $0x123beef,%eax
c00032fe:	0f 95 c0             	setne  %al
c0003301:	0f b6 c0             	movzbl %al,%eax
}
c0003304:	5d                   	pop    %ebp
c0003305:	c3                   	ret    

c0003306 <align_int>:
{
c0003306:	55                   	push   %ebp
c0003307:	89 e5                	mov    %esp,%ebp
c0003309:	83 ec 10             	sub    $0x10,%esp
    size_t am = alignment - 1;
c000330c:	8b 45 0c             	mov    0xc(%ebp),%eax
c000330f:	83 e8 01             	sub    $0x1,%eax
c0003312:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (((size_t)len + am) & ~am);
c0003315:	8b 55 08             	mov    0x8(%ebp),%edx
c0003318:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000331b:	01 c2                	add    %eax,%edx
c000331d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003320:	f7 d0                	not    %eax
c0003322:	21 d0                	and    %edx,%eax
}
c0003324:	c9                   	leave  
c0003325:	c3                   	ret    

c0003326 <align_ptr>:
{
c0003326:	55                   	push   %ebp
c0003327:	89 e5                	mov    %esp,%ebp
    if(alignment % sizeof(void*) != 0 ) return NULL;
c0003329:	8b 45 0c             	mov    0xc(%ebp),%eax
c000332c:	83 e0 03             	and    $0x3,%eax
c000332f:	85 c0                	test   %eax,%eax
c0003331:	74 07                	je     c000333a <align_ptr+0x14>
c0003333:	b8 00 00 00 00       	mov    $0x0,%eax
c0003338:	eb 0f                	jmp    c0003349 <align_ptr+0x23>
    return (void*) align_int((size_t) addr, alignment);
c000333a:	8b 45 08             	mov    0x8(%ebp),%eax
c000333d:	ff 75 0c             	pushl  0xc(%ebp)
c0003340:	50                   	push   %eax
c0003341:	e8 c0 ff ff ff       	call   c0003306 <align_int>
c0003346:	83 c4 08             	add    $0x8,%esp
}
c0003349:	c9                   	leave  
c000334a:	c3                   	ret    

c000334b <kmalloc_init>:
#include "common.h"

heap_block_t* kheap_head = NULL;

int kmalloc_init()
{
c000334b:	55                   	push   %ebp
c000334c:	89 e5                	mov    %esp,%ebp
c000334e:	83 ec 08             	sub    $0x8,%esp
    kheap_head = ksbrk(HEAP_INCREMENT);
c0003351:	83 ec 0c             	sub    $0xc,%esp
c0003354:	68 00 40 00 00       	push   $0x4000
c0003359:	e8 03 f9 ff ff       	call   c0002c61 <ksbrk>
c000335e:	83 c4 10             	add    $0x10,%esp
c0003361:	a3 30 d0 00 c0       	mov    %eax,0xc000d030
   
    if(!kheap_head)
c0003366:	a1 30 d0 00 c0       	mov    0xc000d030,%eax
c000336b:	85 c0                	test   %eax,%eax
c000336d:	75 0a                	jne    c0003379 <kmalloc_init+0x2e>
        return -1;
c000336f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003374:	e9 95 00 00 00       	jmp    c000340e <kmalloc_init+0xc3>

    kheap_head = align_ptr(kheap_head,HEAP_BLOCKSIZE_UNITS);
c0003379:	a1 30 d0 00 c0       	mov    0xc000d030,%eax
c000337e:	83 ec 08             	sub    $0x8,%esp
c0003381:	6a 10                	push   $0x10
c0003383:	50                   	push   %eax
c0003384:	e8 9d ff ff ff       	call   c0003326 <align_ptr>
c0003389:	83 c4 10             	add    $0x10,%esp
c000338c:	a3 30 d0 00 c0       	mov    %eax,0xc000d030

    kheap_head->magic = HEAP_BLOCK_MAGIC;
c0003391:	a1 30 d0 00 c0       	mov    0xc000d030,%eax
c0003396:	8b 10                	mov    (%eax),%edx
c0003398:	81 e2 00 00 00 f0    	and    $0xf0000000,%edx
c000339e:	81 ca ef be 23 01    	or     $0x123beef,%edx
c00033a4:	89 10                	mov    %edx,(%eax)
    kheap_head->status = HEAP_BLOCK_FREE;
c00033a6:	a1 30 d0 00 c0       	mov    0xc000d030,%eax
c00033ab:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c00033af:	83 e2 0f             	and    $0xf,%edx
c00033b2:	88 50 03             	mov    %dl,0x3(%eax)
    kheap_head->prev = kheap_head;
c00033b5:	a1 30 d0 00 c0       	mov    0xc000d030,%eax
c00033ba:	8b 15 30 d0 00 c0    	mov    0xc000d030,%edx
c00033c0:	89 50 04             	mov    %edx,0x4(%eax)
    kheap_head->next = kheap_head;
c00033c3:	a1 30 d0 00 c0       	mov    0xc000d030,%eax
c00033c8:	8b 15 30 d0 00 c0    	mov    0xc000d030,%edx
c00033ce:	89 50 08             	mov    %edx,0x8(%eax)

    kheap_head->size = ((heap_block_t*) ksbrk(0)) - kheap_head;
c00033d1:	83 ec 0c             	sub    $0xc,%esp
c00033d4:	6a 00                	push   $0x0
c00033d6:	e8 86 f8 ff ff       	call   c0002c61 <ksbrk>
c00033db:	83 c4 10             	add    $0x10,%esp
c00033de:	8b 15 30 d0 00 c0    	mov    0xc000d030,%edx
c00033e4:	29 d0                	sub    %edx,%eax
c00033e6:	c1 f8 04             	sar    $0x4,%eax
c00033e9:	89 c2                	mov    %eax,%edx
c00033eb:	a1 30 d0 00 c0       	mov    0xc000d030,%eax
c00033f0:	89 50 0c             	mov    %edx,0xc(%eax)

    if(kheap_head->size < HEAP_INCREMENT/HEAP_BLOCKSIZE_UNITS)
c00033f3:	a1 30 d0 00 c0       	mov    0xc000d030,%eax
c00033f8:	8b 40 0c             	mov    0xc(%eax),%eax
c00033fb:	3d ff 03 00 00       	cmp    $0x3ff,%eax
c0003400:	77 07                	ja     c0003409 <kmalloc_init+0xbe>
        return -1;    
c0003402:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003407:	eb 05                	jmp    c000340e <kmalloc_init+0xc3>

    return 0;    
c0003409:	b8 00 00 00 00       	mov    $0x0,%eax
}
c000340e:	c9                   	leave  
c000340f:	c3                   	ret    

c0003410 <kheap_insert_block>:

// insert new_block into LL between b and b->next
// return 0 on success 
int kheap_insert_block(heap_block_t* b, heap_block_t* new_block)
{
c0003410:	55                   	push   %ebp
c0003411:	89 e5                	mov    %esp,%ebp
c0003413:	83 ec 08             	sub    $0x8,%esp
    
    if(kheap_validate_block(b) || kheap_validate_block(new_block))
c0003416:	ff 75 08             	pushl  0x8(%ebp)
c0003419:	e8 ce fe ff ff       	call   c00032ec <kheap_validate_block>
c000341e:	83 c4 04             	add    $0x4,%esp
c0003421:	85 c0                	test   %eax,%eax
c0003423:	75 0f                	jne    c0003434 <kheap_insert_block+0x24>
c0003425:	ff 75 0c             	pushl  0xc(%ebp)
c0003428:	e8 bf fe ff ff       	call   c00032ec <kheap_validate_block>
c000342d:	83 c4 04             	add    $0x4,%esp
c0003430:	85 c0                	test   %eax,%eax
c0003432:	74 17                	je     c000344b <kheap_insert_block+0x3b>
    {
        panic("kernel heap corrupted");
c0003434:	83 ec 0c             	sub    $0xc,%esp
c0003437:	68 c8 57 00 c0       	push   $0xc00057c8
c000343c:	e8 c1 e2 ff ff       	call   c0001702 <panic>
c0003441:	83 c4 10             	add    $0x10,%esp
        return -1;
c0003444:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003449:	eb 2f                	jmp    c000347a <kheap_insert_block+0x6a>
    }

    new_block->prev = b;
c000344b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000344e:	8b 55 08             	mov    0x8(%ebp),%edx
c0003451:	89 50 04             	mov    %edx,0x4(%eax)
    new_block->next = b->next;            
c0003454:	8b 45 08             	mov    0x8(%ebp),%eax
c0003457:	8b 50 08             	mov    0x8(%eax),%edx
c000345a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000345d:	89 50 08             	mov    %edx,0x8(%eax)
    b->next->prev = new_block;
c0003460:	8b 45 08             	mov    0x8(%ebp),%eax
c0003463:	8b 40 08             	mov    0x8(%eax),%eax
c0003466:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003469:	89 50 04             	mov    %edx,0x4(%eax)
    b->next = new_block;
c000346c:	8b 45 08             	mov    0x8(%ebp),%eax
c000346f:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003472:	89 50 08             	mov    %edx,0x8(%eax)

    return 0;
c0003475:	b8 00 00 00 00       	mov    $0x0,%eax
}
c000347a:	c9                   	leave  
c000347b:	c3                   	ret    

c000347c <kheap_delete_block>:


// remove block b from LL
// return pointer to previous block, NULL on error
heap_block_t* kheap_delete_block(heap_block_t* b)
{
c000347c:	55                   	push   %ebp
c000347d:	89 e5                	mov    %esp,%ebp
c000347f:	83 ec 08             	sub    $0x8,%esp
    if(kheap_validate_block(b->prev) || kheap_validate_block(b->next))
c0003482:	8b 45 08             	mov    0x8(%ebp),%eax
c0003485:	8b 40 04             	mov    0x4(%eax),%eax
c0003488:	50                   	push   %eax
c0003489:	e8 5e fe ff ff       	call   c00032ec <kheap_validate_block>
c000348e:	83 c4 04             	add    $0x4,%esp
c0003491:	85 c0                	test   %eax,%eax
c0003493:	75 13                	jne    c00034a8 <kheap_delete_block+0x2c>
c0003495:	8b 45 08             	mov    0x8(%ebp),%eax
c0003498:	8b 40 08             	mov    0x8(%eax),%eax
c000349b:	50                   	push   %eax
c000349c:	e8 4b fe ff ff       	call   c00032ec <kheap_validate_block>
c00034a1:	83 c4 04             	add    $0x4,%esp
c00034a4:	85 c0                	test   %eax,%eax
c00034a6:	74 17                	je     c00034bf <kheap_delete_block+0x43>
    {
        panic("kernel heap corrupted");
c00034a8:	83 ec 0c             	sub    $0xc,%esp
c00034ab:	68 c8 57 00 c0       	push   $0xc00057c8
c00034b0:	e8 4d e2 ff ff       	call   c0001702 <panic>
c00034b5:	83 c4 10             	add    $0x10,%esp
        return NULL;
c00034b8:	b8 00 00 00 00       	mov    $0x0,%eax
c00034bd:	eb 24                	jmp    c00034e3 <kheap_delete_block+0x67>
    }

    b->prev->next = b->next;
c00034bf:	8b 45 08             	mov    0x8(%ebp),%eax
c00034c2:	8b 40 04             	mov    0x4(%eax),%eax
c00034c5:	8b 55 08             	mov    0x8(%ebp),%edx
c00034c8:	8b 52 08             	mov    0x8(%edx),%edx
c00034cb:	89 50 08             	mov    %edx,0x8(%eax)
    b->next->prev = b->prev;
c00034ce:	8b 45 08             	mov    0x8(%ebp),%eax
c00034d1:	8b 40 08             	mov    0x8(%eax),%eax
c00034d4:	8b 55 08             	mov    0x8(%ebp),%edx
c00034d7:	8b 52 04             	mov    0x4(%edx),%edx
c00034da:	89 50 04             	mov    %edx,0x4(%eax)

    return b->prev;
c00034dd:	8b 45 08             	mov    0x8(%ebp),%eax
c00034e0:	8b 40 04             	mov    0x4(%eax),%eax
}
c00034e3:	c9                   	leave  
c00034e4:	c3                   	ret    

c00034e5 <kheap_free_block>:

// free block and merge with free neighbors
// return ptr to new free block
heap_block_t* kheap_free_block(heap_block_t* b)
{
c00034e5:	55                   	push   %ebp
c00034e6:	89 e5                	mov    %esp,%ebp
c00034e8:	83 ec 08             	sub    $0x8,%esp
    //check magic numbers to make sure theres no overrun
    if(kheap_validate_block(b))
c00034eb:	ff 75 08             	pushl  0x8(%ebp)
c00034ee:	e8 f9 fd ff ff       	call   c00032ec <kheap_validate_block>
c00034f3:	83 c4 04             	add    $0x4,%esp
c00034f6:	85 c0                	test   %eax,%eax
c00034f8:	74 1a                	je     c0003514 <kheap_free_block+0x2f>
    {
        panic("kernel heap corrupted");
c00034fa:	83 ec 0c             	sub    $0xc,%esp
c00034fd:	68 c8 57 00 c0       	push   $0xc00057c8
c0003502:	e8 fb e1 ff ff       	call   c0001702 <panic>
c0003507:	83 c4 10             	add    $0x10,%esp
        return NULL;
c000350a:	b8 00 00 00 00       	mov    $0x0,%eax
c000350f:	e9 b4 00 00 00       	jmp    c00035c8 <kheap_free_block+0xe3>
    }

    // make sure this block isnt already free allocated
    if(b->status == HEAP_BLOCK_FREE)
c0003514:	8b 45 08             	mov    0x8(%ebp),%eax
c0003517:	0f b6 40 03          	movzbl 0x3(%eax),%eax
c000351b:	83 e0 f0             	and    $0xfffffff0,%eax
c000351e:	84 c0                	test   %al,%al
c0003520:	75 0a                	jne    c000352c <kheap_free_block+0x47>
        return NULL;
c0003522:	b8 00 00 00 00       	mov    $0x0,%eax
c0003527:	e9 9c 00 00 00       	jmp    c00035c8 <kheap_free_block+0xe3>

    b->status = HEAP_BLOCK_FREE;
c000352c:	8b 45 08             	mov    0x8(%ebp),%eax
c000352f:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c0003533:	83 e2 0f             	and    $0xf,%edx
c0003536:	88 50 03             	mov    %dl,0x3(%eax)

    //merge with next block if free
    if(b->next == HEAP_BLOCK_FREE && b->next != kheap_head)
c0003539:	8b 45 08             	mov    0x8(%ebp),%eax
c000353c:	8b 40 08             	mov    0x8(%eax),%eax
c000353f:	85 c0                	test   %eax,%eax
c0003541:	75 43                	jne    c0003586 <kheap_free_block+0xa1>
c0003543:	8b 45 08             	mov    0x8(%ebp),%eax
c0003546:	8b 50 08             	mov    0x8(%eax),%edx
c0003549:	a1 30 d0 00 c0       	mov    0xc000d030,%eax
c000354e:	39 c2                	cmp    %eax,%edx
c0003550:	74 34                	je     c0003586 <kheap_free_block+0xa1>
    {
        b->size += b->next->size;
c0003552:	8b 45 08             	mov    0x8(%ebp),%eax
c0003555:	8b 50 0c             	mov    0xc(%eax),%edx
c0003558:	8b 45 08             	mov    0x8(%ebp),%eax
c000355b:	8b 40 08             	mov    0x8(%eax),%eax
c000355e:	8b 40 0c             	mov    0xc(%eax),%eax
c0003561:	01 c2                	add    %eax,%edx
c0003563:	8b 45 08             	mov    0x8(%ebp),%eax
c0003566:	89 50 0c             	mov    %edx,0xc(%eax)
        if(!kheap_delete_block(b->next)) return NULL;
c0003569:	8b 45 08             	mov    0x8(%ebp),%eax
c000356c:	8b 40 08             	mov    0x8(%eax),%eax
c000356f:	83 ec 0c             	sub    $0xc,%esp
c0003572:	50                   	push   %eax
c0003573:	e8 04 ff ff ff       	call   c000347c <kheap_delete_block>
c0003578:	83 c4 10             	add    $0x10,%esp
c000357b:	85 c0                	test   %eax,%eax
c000357d:	75 07                	jne    c0003586 <kheap_free_block+0xa1>
c000357f:	b8 00 00 00 00       	mov    $0x0,%eax
c0003584:	eb 42                	jmp    c00035c8 <kheap_free_block+0xe3>
    }

    //merge with previous block if free, and set b = b->prev
    if(b->prev == HEAP_BLOCK_FREE && b != kheap_head)
c0003586:	8b 45 08             	mov    0x8(%ebp),%eax
c0003589:	8b 40 04             	mov    0x4(%eax),%eax
c000358c:	85 c0                	test   %eax,%eax
c000358e:	75 35                	jne    c00035c5 <kheap_free_block+0xe0>
c0003590:	a1 30 d0 00 c0       	mov    0xc000d030,%eax
c0003595:	39 45 08             	cmp    %eax,0x8(%ebp)
c0003598:	74 2b                	je     c00035c5 <kheap_free_block+0xe0>
    {
        b->prev->size += b->size;
c000359a:	8b 45 08             	mov    0x8(%ebp),%eax
c000359d:	8b 40 04             	mov    0x4(%eax),%eax
c00035a0:	8b 48 0c             	mov    0xc(%eax),%ecx
c00035a3:	8b 45 08             	mov    0x8(%ebp),%eax
c00035a6:	8b 50 0c             	mov    0xc(%eax),%edx
c00035a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00035ac:	8b 40 04             	mov    0x4(%eax),%eax
c00035af:	01 ca                	add    %ecx,%edx
c00035b1:	89 50 0c             	mov    %edx,0xc(%eax)
        b = kheap_delete_block(b);
c00035b4:	83 ec 0c             	sub    $0xc,%esp
c00035b7:	ff 75 08             	pushl  0x8(%ebp)
c00035ba:	e8 bd fe ff ff       	call   c000347c <kheap_delete_block>
c00035bf:	83 c4 10             	add    $0x10,%esp
c00035c2:	89 45 08             	mov    %eax,0x8(%ebp)
    }

    return b;
c00035c5:	8b 45 08             	mov    0x8(%ebp),%eax
}
c00035c8:	c9                   	leave  
c00035c9:	c3                   	ret    

c00035ca <kheap_split_block>:
// if there is enough extra room, split b into two
// return new size of block on successful split (in HEAP_BLOCKSIZE_UNITS)
// return 0 on insufficinet size for splitting into new block (b->size < size+1)
// return <0 on error
int kheap_split_block(heap_block_t* b, size_t size)
{
c00035ca:	55                   	push   %ebp
c00035cb:	89 e5                	mov    %esp,%ebp
c00035cd:	83 ec 18             	sub    $0x18,%esp
    //check magic numbers to make sure theres no overrun
    if(kheap_validate_block(b))
c00035d0:	ff 75 08             	pushl  0x8(%ebp)
c00035d3:	e8 14 fd ff ff       	call   c00032ec <kheap_validate_block>
c00035d8:	83 c4 04             	add    $0x4,%esp
c00035db:	85 c0                	test   %eax,%eax
c00035dd:	74 1a                	je     c00035f9 <kheap_split_block+0x2f>
    {
        panic("kernel heap corrupted");
c00035df:	83 ec 0c             	sub    $0xc,%esp
c00035e2:	68 c8 57 00 c0       	push   $0xc00057c8
c00035e7:	e8 16 e1 ff ff       	call   c0001702 <panic>
c00035ec:	83 c4 10             	add    $0x10,%esp
        return -1;
c00035ef:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00035f4:	e9 83 00 00 00       	jmp    c000367c <kheap_split_block+0xb2>
    }

    if(b->size < size + 1 ) return 0;
c00035f9:	8b 45 08             	mov    0x8(%ebp),%eax
c00035fc:	8b 40 0c             	mov    0xc(%eax),%eax
c00035ff:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003602:	83 c2 01             	add    $0x1,%edx
c0003605:	39 d0                	cmp    %edx,%eax
c0003607:	73 07                	jae    c0003610 <kheap_split_block+0x46>
c0003609:	b8 00 00 00 00       	mov    $0x0,%eax
c000360e:	eb 6c                	jmp    c000367c <kheap_split_block+0xb2>

    // create new empty block
    heap_block_t* new_block = b + size;
c0003610:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003613:	c1 e0 04             	shl    $0x4,%eax
c0003616:	89 c2                	mov    %eax,%edx
c0003618:	8b 45 08             	mov    0x8(%ebp),%eax
c000361b:	01 d0                	add    %edx,%eax
c000361d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    new_block->magic = HEAP_BLOCK_MAGIC;
c0003620:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003623:	8b 10                	mov    (%eax),%edx
c0003625:	81 e2 00 00 00 f0    	and    $0xf0000000,%edx
c000362b:	81 ca ef be 23 01    	or     $0x123beef,%edx
c0003631:	89 10                	mov    %edx,(%eax)
    new_block->status = HEAP_BLOCK_FREE;
c0003633:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003636:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c000363a:	83 e2 0f             	and    $0xf,%edx
c000363d:	88 50 03             	mov    %dl,0x3(%eax)
    new_block->size = b->size - size;
c0003640:	8b 45 08             	mov    0x8(%ebp),%eax
c0003643:	8b 40 0c             	mov    0xc(%eax),%eax
c0003646:	2b 45 0c             	sub    0xc(%ebp),%eax
c0003649:	89 c2                	mov    %eax,%edx
c000364b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000364e:	89 50 0c             	mov    %edx,0xc(%eax)

    // insert new block to into LL after b
    if(kheap_insert_block(b,new_block)) return -1;
c0003651:	83 ec 08             	sub    $0x8,%esp
c0003654:	ff 75 f4             	pushl  -0xc(%ebp)
c0003657:	ff 75 08             	pushl  0x8(%ebp)
c000365a:	e8 b1 fd ff ff       	call   c0003410 <kheap_insert_block>
c000365f:	83 c4 10             	add    $0x10,%esp
c0003662:	85 c0                	test   %eax,%eax
c0003664:	74 07                	je     c000366d <kheap_split_block+0xa3>
c0003666:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000366b:	eb 0f                	jmp    c000367c <kheap_split_block+0xb2>

    // shrink b and return new size
    return b->size = size;
c000366d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003670:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003673:	89 50 0c             	mov    %edx,0xc(%eax)
c0003676:	8b 45 08             	mov    0x8(%ebp),%eax
c0003679:	8b 40 0c             	mov    0xc(%eax),%eax
}
c000367c:	c9                   	leave  
c000367d:	c3                   	ret    

c000367e <grow_kheap>:

// grow the kernel heap by at least minimum_block_size*HEAP_BLOCKSIZE_UNITS bytes
// and return new tail block that is guaranteeed to be at least minimum_block_size
// return NULL on error or OOM
heap_block_t* grow_kheap(size_t minimum_block_size)
{
c000367e:	55                   	push   %ebp
c000367f:	89 e5                	mov    %esp,%ebp
c0003681:	83 ec 18             	sub    $0x18,%esp
    size_t grow_size = minimum_block_size*HEAP_BLOCKSIZE_UNITS > HEAP_INCREMENT ? minimum_block_size*HEAP_BLOCKSIZE_UNITS : HEAP_INCREMENT;
c0003684:	8b 45 08             	mov    0x8(%ebp),%eax
c0003687:	c1 e0 04             	shl    $0x4,%eax
c000368a:	ba 00 40 00 00       	mov    $0x4000,%edx
c000368f:	3d 00 40 00 00       	cmp    $0x4000,%eax
c0003694:	0f 42 c2             	cmovb  %edx,%eax
c0003697:	89 45 f4             	mov    %eax,-0xc(%ebp)
    heap_block_t* new_block = ksbrk(grow_size);
c000369a:	83 ec 0c             	sub    $0xc,%esp
c000369d:	ff 75 f4             	pushl  -0xc(%ebp)
c00036a0:	e8 bc f5 ff ff       	call   c0002c61 <ksbrk>
c00036a5:	83 c4 10             	add    $0x10,%esp
c00036a8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!new_block)
c00036ab:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00036af:	75 0a                	jne    c00036bb <grow_kheap+0x3d>
        return NULL; // error in ksbrk, e.g. out of memory
c00036b1:	b8 00 00 00 00       	mov    $0x0,%eax
c00036b6:	e9 81 00 00 00       	jmp    c000373c <grow_kheap+0xbe>

    //ksbrk doesnt guarantee properly aligned blocks, so make sure we are aligned
    new_block = align_ptr(new_block,HEAP_BLOCKSIZE_UNITS);
c00036bb:	83 ec 08             	sub    $0x8,%esp
c00036be:	6a 10                	push   $0x10
c00036c0:	ff 75 f0             	pushl  -0x10(%ebp)
c00036c3:	e8 5e fc ff ff       	call   c0003326 <align_ptr>
c00036c8:	83 c4 10             	add    $0x10,%esp
c00036cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    
    new_block->magic = HEAP_BLOCK_MAGIC;
c00036ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00036d1:	8b 10                	mov    (%eax),%edx
c00036d3:	81 e2 00 00 00 f0    	and    $0xf0000000,%edx
c00036d9:	81 ca ef be 23 01    	or     $0x123beef,%edx
c00036df:	89 10                	mov    %edx,(%eax)
    new_block->status = HEAP_BLOCK_FREE;
c00036e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00036e4:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c00036e8:	83 e2 0f             	and    $0xf,%edx
c00036eb:	88 50 03             	mov    %dl,0x3(%eax)

    // get end of block from ksbrk(0), and again make sure it is aligned.
    // this time align with a mask so that aligned address is <= ksbrk(0)
    new_block->size = new_block - (heap_block_t*) ( (uint32_t) ksbrk(0) & HEAP_BLOCKSIZE_MASK);
c00036ee:	83 ec 0c             	sub    $0xc,%esp
c00036f1:	6a 00                	push   $0x0
c00036f3:	e8 69 f5 ff ff       	call   c0002c61 <ksbrk>
c00036f8:	83 c4 10             	add    $0x10,%esp
c00036fb:	83 e0 f0             	and    $0xfffffff0,%eax
c00036fe:	89 c2                	mov    %eax,%edx
c0003700:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003703:	29 d0                	sub    %edx,%eax
c0003705:	c1 f8 04             	sar    $0x4,%eax
c0003708:	89 c2                	mov    %eax,%edx
c000370a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000370d:	89 50 0c             	mov    %edx,0xc(%eax)

    //doublecheck that new block is large enough
    if(new_block->size < minimum_block_size) return NULL;
c0003710:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003713:	8b 40 0c             	mov    0xc(%eax),%eax
c0003716:	39 45 08             	cmp    %eax,0x8(%ebp)
c0003719:	76 07                	jbe    c0003722 <grow_kheap+0xa4>
c000371b:	b8 00 00 00 00       	mov    $0x0,%eax
c0003720:	eb 1a                	jmp    c000373c <grow_kheap+0xbe>

    kheap_insert_block(kheap_head->prev, new_block); //add new block to tail
c0003722:	a1 30 d0 00 c0       	mov    0xc000d030,%eax
c0003727:	8b 40 04             	mov    0x4(%eax),%eax
c000372a:	83 ec 08             	sub    $0x8,%esp
c000372d:	ff 75 f0             	pushl  -0x10(%ebp)
c0003730:	50                   	push   %eax
c0003731:	e8 da fc ff ff       	call   c0003410 <kheap_insert_block>
c0003736:	83 c4 10             	add    $0x10,%esp
    return new_block;
c0003739:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c000373c:	c9                   	leave  
c000373d:	c3                   	ret    

c000373e <kmalloc>:

void* kmalloc(size_t sz)
{
c000373e:	55                   	push   %ebp
c000373f:	89 e5                	mov    %esp,%ebp
c0003741:	83 ec 18             	sub    $0x18,%esp
    //convert to HEAP_BLOCKSIZE_UNITS, rounding up, and add one for header
    size_t block_size = 1 + (sz+ HEAP_BLOCKSIZE_UNITS -1)/HEAP_BLOCKSIZE_UNITS;
c0003744:	8b 45 08             	mov    0x8(%ebp),%eax
c0003747:	83 c0 0f             	add    $0xf,%eax
c000374a:	c1 e8 04             	shr    $0x4,%eax
c000374d:	83 c0 01             	add    $0x1,%eax
c0003750:	89 45 f0             	mov    %eax,-0x10(%ebp)
    
    if(!kheap_head)
c0003753:	a1 30 d0 00 c0       	mov    0xc000d030,%eax
c0003758:	85 c0                	test   %eax,%eax
c000375a:	75 19                	jne    c0003775 <kmalloc+0x37>
    {
        //initialize the heap with some space
        if(kmalloc_init())
c000375c:	e8 ea fb ff ff       	call   c000334b <kmalloc_init>
c0003761:	85 c0                	test   %eax,%eax
c0003763:	74 10                	je     c0003775 <kmalloc+0x37>
            panic("Error initializing kernel heap");
c0003765:	83 ec 0c             	sub    $0xc,%esp
c0003768:	68 e0 57 00 c0       	push   $0xc00057e0
c000376d:	e8 90 df ff ff       	call   c0001702 <panic>
c0003772:	83 c4 10             	add    $0x10,%esp
    }

    heap_block_t* block = kheap_head;
c0003775:	a1 30 d0 00 c0       	mov    0xc000d030,%eax
c000377a:	89 45 f4             	mov    %eax,-0xc(%ebp)

    while(block->status != HEAP_BLOCK_FREE || block->size < block_size)
c000377d:	eb 36                	jmp    c00037b5 <kmalloc+0x77>
    {
        //if we've returned to the head, we have run through the entire list without finding a free block
        if(block->next == kheap_head)
c000377f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003782:	8b 50 08             	mov    0x8(%eax),%edx
c0003785:	a1 30 d0 00 c0       	mov    0xc000d030,%eax
c000378a:	39 c2                	cmp    %eax,%edx
c000378c:	75 1e                	jne    c00037ac <kmalloc+0x6e>
        {
            //we've reached the end of the heap, so add a new block at the end
            block = grow_kheap(block_size);
c000378e:	83 ec 0c             	sub    $0xc,%esp
c0003791:	ff 75 f0             	pushl  -0x10(%ebp)
c0003794:	e8 e5 fe ff ff       	call   c000367e <grow_kheap>
c0003799:	83 c4 10             	add    $0x10,%esp
c000379c:	89 45 f4             	mov    %eax,-0xc(%ebp)
            if(!block) return NULL; //grow_kheap() failed, e.g. OOM 
c000379f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00037a3:	75 10                	jne    c00037b5 <kmalloc+0x77>
c00037a5:	b8 00 00 00 00       	mov    $0x0,%eax
c00037aa:	eb 5d                	jmp    c0003809 <kmalloc+0xcb>
        }
        else
        {
            block = block->next;
c00037ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00037af:	8b 40 08             	mov    0x8(%eax),%eax
c00037b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(block->status != HEAP_BLOCK_FREE || block->size < block_size)
c00037b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00037b8:	0f b6 40 03          	movzbl 0x3(%eax),%eax
c00037bc:	83 e0 f0             	and    $0xfffffff0,%eax
c00037bf:	84 c0                	test   %al,%al
c00037c1:	75 bc                	jne    c000377f <kmalloc+0x41>
c00037c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00037c6:	8b 40 0c             	mov    0xc(%eax),%eax
c00037c9:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c00037cc:	77 b1                	ja     c000377f <kmalloc+0x41>
    }

    // block is a free block that is large enough for this allocation

    //split block if its big enough
    if(kheap_split_block(block, block_size)<0)
c00037ce:	83 ec 08             	sub    $0x8,%esp
c00037d1:	ff 75 f0             	pushl  -0x10(%ebp)
c00037d4:	ff 75 f4             	pushl  -0xc(%ebp)
c00037d7:	e8 ee fd ff ff       	call   c00035ca <kheap_split_block>
c00037dc:	83 c4 10             	add    $0x10,%esp
c00037df:	85 c0                	test   %eax,%eax
c00037e1:	79 10                	jns    c00037f3 <kmalloc+0xb5>
        panic("Critical error in malloc()");
c00037e3:	83 ec 0c             	sub    $0xc,%esp
c00037e6:	68 ff 57 00 c0       	push   $0xc00057ff
c00037eb:	e8 12 df ff ff       	call   c0001702 <panic>
c00037f0:	83 c4 10             	add    $0x10,%esp

    block->status = HEAP_BLOCK_USED;
c00037f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00037f6:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c00037fa:	83 e2 0f             	and    $0xf,%edx
c00037fd:	83 ca 10             	or     $0x10,%edx
c0003800:	88 50 03             	mov    %dl,0x3(%eax)
    return block+1; // return pointer after header
c0003803:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003806:	83 c0 10             	add    $0x10,%eax
}
c0003809:	c9                   	leave  
c000380a:	c3                   	ret    

c000380b <kmalloc_aligned>:

void* kmalloc_aligned(size_t sz, size_t alignment)
{
c000380b:	55                   	push   %ebp
c000380c:	89 e5                	mov    %esp,%ebp
c000380e:	83 ec 28             	sub    $0x28,%esp
    //alignement must be multiple of HEAP_BLOCKSIZE_UNITS
    if(alignment % HEAP_BLOCKSIZE_UNITS) return NULL;
c0003811:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003814:	83 e0 0f             	and    $0xf,%eax
c0003817:	85 c0                	test   %eax,%eax
c0003819:	74 0a                	je     c0003825 <kmalloc_aligned+0x1a>
c000381b:	b8 00 00 00 00       	mov    $0x0,%eax
c0003820:	e9 3d 01 00 00       	jmp    c0003962 <kmalloc_aligned+0x157>

    //convert alignment to HEAP_BLOCKSIZE_UNITS
    size_t block_alignment = alignment/HEAP_BLOCKSIZE_UNITS;
c0003825:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003828:	c1 e8 04             	shr    $0x4,%eax
c000382b:	89 45 f0             	mov    %eax,-0x10(%ebp)

    //convert sz to HEAP_BLOCKSIZE_UNITS, rounding up, and add one for header
    size_t block_size = 1 + (sz+ HEAP_BLOCKSIZE_UNITS -1)/HEAP_BLOCKSIZE_UNITS;
c000382e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003831:	83 c0 0f             	add    $0xf,%eax
c0003834:	c1 e8 04             	shr    $0x4,%eax
c0003837:	83 c0 01             	add    $0x1,%eax
c000383a:	89 45 ec             	mov    %eax,-0x14(%ebp)

    
    if(!kheap_head)
c000383d:	a1 30 d0 00 c0       	mov    0xc000d030,%eax
c0003842:	85 c0                	test   %eax,%eax
c0003844:	75 19                	jne    c000385f <kmalloc_aligned+0x54>
    {
        //initialize the heap with some space
        if(!kmalloc_init())
c0003846:	e8 00 fb ff ff       	call   c000334b <kmalloc_init>
c000384b:	85 c0                	test   %eax,%eax
c000384d:	75 10                	jne    c000385f <kmalloc_aligned+0x54>
            panic("Error initializing kernel heap");
c000384f:	83 ec 0c             	sub    $0xc,%esp
c0003852:	68 e0 57 00 c0       	push   $0xc00057e0
c0003857:	e8 a6 de ff ff       	call   c0001702 <panic>
c000385c:	83 c4 10             	add    $0x10,%esp
    }

    heap_block_t* block = kheap_head;
c000385f:	a1 30 d0 00 c0       	mov    0xc000d030,%eax
c0003864:	89 45 f4             	mov    %eax,-0xc(%ebp)
    //how many additional units are needed to align this block?
    size_t alignment_space;

    while(true)
    {
        if(block->status == HEAP_BLOCK_FREE)
c0003867:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000386a:	0f b6 40 03          	movzbl 0x3(%eax),%eax
c000386e:	83 e0 f0             	and    $0xfffffff0,%eax
c0003871:	84 c0                	test   %al,%al
c0003873:	75 42                	jne    c00038b7 <kmalloc_aligned+0xac>
        {
            // where would aligned data start in this block?
            size_t block_data = (size_t)block/HEAP_BLOCKSIZE_UNITS + 1;  //(unaligned) data starts after header
c0003875:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003878:	c1 e8 04             	shr    $0x4,%eax
c000387b:	83 c0 01             	add    $0x1,%eax
c000387e:	89 45 e8             	mov    %eax,-0x18(%ebp)
            size_t am = block_alignment - 1;
c0003881:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003884:	83 e8 01             	sub    $0x1,%eax
c0003887:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            size_t block_data_aligned = ((block_data + am) & ~am); //align data
c000388a:	8b 55 e8             	mov    -0x18(%ebp),%edx
c000388d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0003890:	01 c2                	add    %eax,%edx
c0003892:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0003895:	f7 d0                	not    %eax
c0003897:	21 d0                	and    %edx,%eax
c0003899:	89 45 e0             	mov    %eax,-0x20(%ebp)

            alignment_space = block_data_aligned-block_data; 
c000389c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000389f:	2b 45 e8             	sub    -0x18(%ebp),%eax
c00038a2:	89 45 dc             	mov    %eax,-0x24(%ebp)

            if(block->size >= block_size + alignment_space)
c00038a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00038a8:	8b 40 0c             	mov    0xc(%eax),%eax
c00038ab:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c00038ae:	8b 55 dc             	mov    -0x24(%ebp),%edx
c00038b1:	01 ca                	add    %ecx,%edx
c00038b3:	39 d0                	cmp    %edx,%eax
c00038b5:	73 3b                	jae    c00038f2 <kmalloc_aligned+0xe7>
                break;

        }

        //if we've returned to the head, we have run through the entire list without finding a free block
        if(block->next == kheap_head)
c00038b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00038ba:	8b 50 08             	mov    0x8(%eax),%edx
c00038bd:	a1 30 d0 00 c0       	mov    0xc000d030,%eax
c00038c2:	39 c2                	cmp    %eax,%edx
c00038c4:	75 1e                	jne    c00038e4 <kmalloc_aligned+0xd9>
        {
            //we've reached the end of the heap, so add a new block at the end
            block = grow_kheap(block_size);
c00038c6:	83 ec 0c             	sub    $0xc,%esp
c00038c9:	ff 75 ec             	pushl  -0x14(%ebp)
c00038cc:	e8 ad fd ff ff       	call   c000367e <grow_kheap>
c00038d1:	83 c4 10             	add    $0x10,%esp
c00038d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
            if(!block) return NULL; //grow_kheap() failed, e.g. OOM 
c00038d7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00038db:	75 8a                	jne    c0003867 <kmalloc_aligned+0x5c>
c00038dd:	b8 00 00 00 00       	mov    $0x0,%eax
c00038e2:	eb 7e                	jmp    c0003962 <kmalloc_aligned+0x157>
        }
        else
        {
            block = block->next;
c00038e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00038e7:	8b 40 08             	mov    0x8(%eax),%eax
c00038ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(block->status == HEAP_BLOCK_FREE)
c00038ed:	e9 75 ff ff ff       	jmp    c0003867 <kmalloc_aligned+0x5c>
                break;
c00038f2:	90                   	nop
    }

    // block is a free block that is large enough for this allocation

    //if we need to realign, split off the first part of the block
    if(alignment_space>0)
c00038f3:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c00038f7:	74 2e                	je     c0003927 <kmalloc_aligned+0x11c>
    {
        if(kheap_split_block(block, alignment_space)<0)
c00038f9:	83 ec 08             	sub    $0x8,%esp
c00038fc:	ff 75 dc             	pushl  -0x24(%ebp)
c00038ff:	ff 75 f4             	pushl  -0xc(%ebp)
c0003902:	e8 c3 fc ff ff       	call   c00035ca <kheap_split_block>
c0003907:	83 c4 10             	add    $0x10,%esp
c000390a:	85 c0                	test   %eax,%eax
c000390c:	79 10                	jns    c000391e <kmalloc_aligned+0x113>
            panic("Critical error in malloc()");
c000390e:	83 ec 0c             	sub    $0xc,%esp
c0003911:	68 ff 57 00 c0       	push   $0xc00057ff
c0003916:	e8 e7 dd ff ff       	call   c0001702 <panic>
c000391b:	83 c4 10             	add    $0x10,%esp
        block = block->next;
c000391e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003921:	8b 40 08             	mov    0x8(%eax),%eax
c0003924:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    
    //split end of block off its big enough
    if(kheap_split_block(block, block_size)<0)
c0003927:	83 ec 08             	sub    $0x8,%esp
c000392a:	ff 75 ec             	pushl  -0x14(%ebp)
c000392d:	ff 75 f4             	pushl  -0xc(%ebp)
c0003930:	e8 95 fc ff ff       	call   c00035ca <kheap_split_block>
c0003935:	83 c4 10             	add    $0x10,%esp
c0003938:	85 c0                	test   %eax,%eax
c000393a:	79 10                	jns    c000394c <kmalloc_aligned+0x141>
        panic("Critical error in malloc()");
c000393c:	83 ec 0c             	sub    $0xc,%esp
c000393f:	68 ff 57 00 c0       	push   $0xc00057ff
c0003944:	e8 b9 dd ff ff       	call   c0001702 <panic>
c0003949:	83 c4 10             	add    $0x10,%esp

    block->status = HEAP_BLOCK_USED;
c000394c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000394f:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c0003953:	83 e2 0f             	and    $0xf,%edx
c0003956:	83 ca 10             	or     $0x10,%edx
c0003959:	88 50 03             	mov    %dl,0x3(%eax)
    return block+1; // return pointer after header
c000395c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000395f:	83 c0 10             	add    $0x10,%eax
}
c0003962:	c9                   	leave  
c0003963:	c3                   	ret    

c0003964 <kfree>:

// free memory previously allocated with kmalloc
// return 0 on success.
// return -1 on fail (e.g. if p was not allocated with malloc, or memory corruption detected)
int kfree(void* p)
{
c0003964:	55                   	push   %ebp
c0003965:	89 e5                	mov    %esp,%ebp
c0003967:	83 ec 18             	sub    $0x18,%esp
    //get pointer to block header
    heap_block_t* b = ((heap_block_t*) p) - 1;
c000396a:	8b 45 08             	mov    0x8(%ebp),%eax
c000396d:	83 e8 10             	sub    $0x10,%eax
c0003970:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(kheap_validate_block(b))
c0003973:	ff 75 f4             	pushl  -0xc(%ebp)
c0003976:	e8 71 f9 ff ff       	call   c00032ec <kheap_validate_block>
c000397b:	83 c4 04             	add    $0x4,%esp
c000397e:	85 c0                	test   %eax,%eax
c0003980:	74 17                	je     c0003999 <kfree+0x35>
    {
        panic("kernel heap corrupted");
c0003982:	83 ec 0c             	sub    $0xc,%esp
c0003985:	68 c8 57 00 c0       	push   $0xc00057c8
c000398a:	e8 73 dd ff ff       	call   c0001702 <panic>
c000398f:	83 c4 10             	add    $0x10,%esp
        return -1;
c0003992:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003997:	eb 1e                	jmp    c00039b7 <kfree+0x53>
    }

    if(kheap_free_block(b)) return 0;
c0003999:	83 ec 0c             	sub    $0xc,%esp
c000399c:	ff 75 f4             	pushl  -0xc(%ebp)
c000399f:	e8 41 fb ff ff       	call   c00034e5 <kheap_free_block>
c00039a4:	83 c4 10             	add    $0x10,%esp
c00039a7:	85 c0                	test   %eax,%eax
c00039a9:	74 07                	je     c00039b2 <kfree+0x4e>
c00039ab:	b8 00 00 00 00       	mov    $0x0,%eax
c00039b0:	eb 05                	jmp    c00039b7 <kfree+0x53>

    return -1;
c00039b2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c00039b7:	c9                   	leave  
c00039b8:	c3                   	ret    

c00039b9 <kheap_size>:


// size of allocated and free mem in heap
// returns 0 on success
int kheap_size(size_t* allocated, size_t* free)
{
c00039b9:	55                   	push   %ebp
c00039ba:	89 e5                	mov    %esp,%ebp
c00039bc:	83 ec 10             	sub    $0x10,%esp
    *allocated = 0;
c00039bf:	8b 45 08             	mov    0x8(%ebp),%eax
c00039c2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *free = 0;
c00039c8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00039cb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    // make sure heap is initilialized
    if(!kheap_head)
c00039d1:	a1 30 d0 00 c0       	mov    0xc000d030,%eax
c00039d6:	85 c0                	test   %eax,%eax
c00039d8:	75 0a                	jne    c00039e4 <kheap_size+0x2b>
        return -1;
c00039da:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00039df:	e9 87 00 00 00       	jmp    c0003a6b <kheap_size+0xb2>

    heap_block_t* block = kheap_head;
c00039e4:	a1 30 d0 00 c0       	mov    0xc000d030,%eax
c00039e9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while(true)
    {        
        if(kheap_validate_block(block))
c00039ec:	ff 75 fc             	pushl  -0x4(%ebp)
c00039ef:	e8 f8 f8 ff ff       	call   c00032ec <kheap_validate_block>
c00039f4:	83 c4 04             	add    $0x4,%esp
c00039f7:	85 c0                	test   %eax,%eax
c00039f9:	74 07                	je     c0003a02 <kheap_size+0x49>
            return -1;        
c00039fb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003a00:	eb 69                	jmp    c0003a6b <kheap_size+0xb2>

        if(block->status == HEAP_BLOCK_FREE)
c0003a02:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003a05:	0f b6 40 03          	movzbl 0x3(%eax),%eax
c0003a09:	83 e0 f0             	and    $0xfffffff0,%eax
c0003a0c:	84 c0                	test   %al,%al
c0003a0e:	75 17                	jne    c0003a27 <kheap_size+0x6e>
            *free += block->size*HEAP_BLOCKSIZE_UNITS;
c0003a10:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003a13:	8b 10                	mov    (%eax),%edx
c0003a15:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003a18:	8b 40 0c             	mov    0xc(%eax),%eax
c0003a1b:	c1 e0 04             	shl    $0x4,%eax
c0003a1e:	01 c2                	add    %eax,%edx
c0003a20:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003a23:	89 10                	mov    %edx,(%eax)
c0003a25:	eb 2c                	jmp    c0003a53 <kheap_size+0x9a>
        else if(block->status == HEAP_BLOCK_USED)
c0003a27:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003a2a:	0f b6 40 03          	movzbl 0x3(%eax),%eax
c0003a2e:	83 e0 f0             	and    $0xfffffff0,%eax
c0003a31:	3c 10                	cmp    $0x10,%al
c0003a33:	75 17                	jne    c0003a4c <kheap_size+0x93>
            *allocated += block->size*HEAP_BLOCKSIZE_UNITS;
c0003a35:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a38:	8b 10                	mov    (%eax),%edx
c0003a3a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003a3d:	8b 40 0c             	mov    0xc(%eax),%eax
c0003a40:	c1 e0 04             	shl    $0x4,%eax
c0003a43:	01 c2                	add    %eax,%edx
c0003a45:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a48:	89 10                	mov    %edx,(%eax)
c0003a4a:	eb 07                	jmp    c0003a53 <kheap_size+0x9a>
        else
            return -1;        
c0003a4c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003a51:	eb 18                	jmp    c0003a6b <kheap_size+0xb2>

        block = block->next;
c0003a53:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003a56:	8b 40 08             	mov    0x8(%eax),%eax
c0003a59:	89 45 fc             	mov    %eax,-0x4(%ebp)
        if(block == kheap_head)
c0003a5c:	a1 30 d0 00 c0       	mov    0xc000d030,%eax
c0003a61:	39 45 fc             	cmp    %eax,-0x4(%ebp)
c0003a64:	75 86                	jne    c00039ec <kheap_size+0x33>
            return 0;
c0003a66:	b8 00 00 00 00       	mov    $0x0,%eax
    }

}
c0003a6b:	c9                   	leave  
c0003a6c:	c3                   	ret    

c0003a6d <scancode_to_ascii>:
    0,  /* F12 Key */
    0,  /* All other keys are undefined */
};

char scancode_to_ascii(uint8_t scancode)
{
c0003a6d:	55                   	push   %ebp
c0003a6e:	89 e5                	mov    %esp,%ebp
c0003a70:	83 ec 04             	sub    $0x4,%esp
c0003a73:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a76:	88 45 fc             	mov    %al,-0x4(%ebp)
    return kbd_US[scancode];
c0003a79:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0003a7d:	0f b6 80 20 60 00 c0 	movzbl -0x3fff9fe0(%eax),%eax
}
c0003a84:	c9                   	leave  
c0003a85:	c3                   	ret    

c0003a86 <mytask>:
#define MUTLITASKING_LOOPS 32

int shared_value;  // tasks share the same kernel memory

int32_t mytask()
{
c0003a86:	55                   	push   %ebp
c0003a87:	89 e5                	mov    %esp,%ebp
c0003a89:	83 ec 18             	sub    $0x18,%esp
	int nn;
	for(nn=0;nn<MUTLITASKING_LOOPS;nn++)
c0003a8c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0003a93:	eb 27                	jmp    c0003abc <mytask+0x36>
	{
		// check that shared_value has been updated by the other task
		if(shared_value != nn)
c0003a95:	a1 34 d0 00 c0       	mov    0xc000d034,%eax
c0003a9a:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0003a9d:	74 07                	je     c0003aa6 <mytask+0x20>
			return  -1;
c0003a9f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003aa4:	eb 1f                	jmp    c0003ac5 <mytask+0x3f>

		shared_value--;	//increment, check in other task
c0003aa6:	a1 34 d0 00 c0       	mov    0xc000d034,%eax
c0003aab:	83 e8 01             	sub    $0x1,%eax
c0003aae:	a3 34 d0 00 c0       	mov    %eax,0xc000d034
		yield();
c0003ab3:	e8 c5 eb ff ff       	call   c000267d <yield>
	for(nn=0;nn<MUTLITASKING_LOOPS;nn++)
c0003ab8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0003abc:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%ebp)
c0003ac0:	7e d3                	jle    c0003a95 <mytask+0xf>
	}
	return nn;
c0003ac2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0003ac5:	c9                   	leave  
c0003ac6:	c3                   	ret    

c0003ac7 <test_multitasking>:

int test_multitasking()
{
c0003ac7:	55                   	push   %ebp
c0003ac8:	89 e5                	mov    %esp,%ebp
c0003aca:	83 ec 18             	sub    $0x18,%esp
	task_control_block_t* task2 = new_kernel_task( &mytask );
c0003acd:	83 ec 0c             	sub    $0xc,%esp
c0003ad0:	68 86 3a 00 c0       	push   $0xc0003a86
c0003ad5:	e8 84 ea ff ff       	call   c000255e <new_kernel_task>
c0003ada:	83 c4 10             	add    $0x10,%esp
c0003add:	89 45 f0             	mov    %eax,-0x10(%ebp)

	int nn;
	for(nn=0;nn<MUTLITASKING_LOOPS;nn++)
c0003ae0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0003ae7:	eb 27                	jmp    c0003b10 <test_multitasking+0x49>
	{
		//set value that will be checked in other task
		shared_value = nn;
c0003ae9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003aec:	a3 34 d0 00 c0       	mov    %eax,0xc000d034

		yield();
c0003af1:	e8 87 eb ff ff       	call   c000267d <yield>

		// confirm that other task decremented this...
		if(shared_value != nn-1)
c0003af6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003af9:	8d 50 ff             	lea    -0x1(%eax),%edx
c0003afc:	a1 34 d0 00 c0       	mov    0xc000d034,%eax
c0003b01:	39 c2                	cmp    %eax,%edx
c0003b03:	74 07                	je     c0003b0c <test_multitasking+0x45>
			return  -1;
c0003b05:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003b0a:	eb 3b                	jmp    c0003b47 <test_multitasking+0x80>
	for(nn=0;nn<MUTLITASKING_LOOPS;nn++)
c0003b0c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0003b10:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%ebp)
c0003b14:	7e d3                	jle    c0003ae9 <test_multitasking+0x22>
	}

	int ret_val;
	if(join(task2, &ret_val))
c0003b16:	83 ec 08             	sub    $0x8,%esp
c0003b19:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0003b1c:	50                   	push   %eax
c0003b1d:	ff 75 f0             	pushl  -0x10(%ebp)
c0003b20:	e8 90 eb ff ff       	call   c00026b5 <join>
c0003b25:	83 c4 10             	add    $0x10,%esp
c0003b28:	85 c0                	test   %eax,%eax
c0003b2a:	74 07                	je     c0003b33 <test_multitasking+0x6c>
		return -1;
c0003b2c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003b31:	eb 14                	jmp    c0003b47 <test_multitasking+0x80>

    if(ret_val != MUTLITASKING_LOOPS) return -1;
c0003b33:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0003b36:	83 f8 20             	cmp    $0x20,%eax
c0003b39:	74 07                	je     c0003b42 <test_multitasking+0x7b>
c0003b3b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003b40:	eb 05                	jmp    c0003b47 <test_multitasking+0x80>

    return 0;
c0003b42:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0003b47:	c9                   	leave  
c0003b48:	c3                   	ret    

c0003b49 <kernel_main>:
#endif

#define RUN_UNIT_TESTS

void kernel_main(multiboot_info_t* mbd)
{
c0003b49:	55                   	push   %ebp
c0003b4a:	89 e5                	mov    %esp,%ebp
c0003b4c:	83 ec 18             	sub    $0x18,%esp
    //this relocates the stack, so this needs to be one of the first calls
    init_kernel_memory(mbd);
c0003b4f:	83 ec 0c             	sub    $0xc,%esp
c0003b52:	ff 75 08             	pushl  0x8(%ebp)
c0003b55:	e8 6e f3 ff ff       	call   c0002ec8 <init_kernel_memory>
c0003b5a:	83 c4 10             	add    $0x10,%esp

	terminal_init(&stdout);
c0003b5d:	83 ec 0c             	sub    $0xc,%esp
c0003b60:	68 00 70 00 c0       	push   $0xc0007000
c0003b65:	e8 23 c9 ff ff       	call   c000048d <terminal_init>
c0003b6a:	83 c4 10             	add    $0x10,%esp
    // terminal_setcolor(&stdout, VGA_COLOR_WHITE);
	kprintf("Let's learn about Operating Systems!\n");
c0003b6d:	83 ec 0c             	sub    $0xc,%esp
c0003b70:	68 1c 58 00 c0       	push   $0xc000581c
c0003b75:	e8 6b cd ff ff       	call   c00008e5 <kprintf>
c0003b7a:	83 c4 10             	add    $0x10,%esp
	kprintf("Jon Doane, 2020\n\n");
c0003b7d:	83 ec 0c             	sub    $0xc,%esp
c0003b80:	68 42 58 00 c0       	push   $0xc0005842
c0003b85:	e8 5b cd ff ff       	call   c00008e5 <kprintf>
c0003b8a:	83 c4 10             	add    $0x10,%esp
	
    int result = 0;
c0003b8d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    result = result || print_testresult(init_gdt(), "Initialize descriptor tables");
c0003b94:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0003b98:	75 1a                	jne    c0003bb4 <kernel_main+0x6b>
c0003b9a:	e8 88 01 00 00       	call   c0003d27 <init_gdt>
c0003b9f:	83 ec 08             	sub    $0x8,%esp
c0003ba2:	68 54 58 00 c0       	push   $0xc0005854
c0003ba7:	50                   	push   %eax
c0003ba8:	e8 d5 f5 ff ff       	call   c0003182 <print_testresult>
c0003bad:	83 c4 10             	add    $0x10,%esp
c0003bb0:	85 c0                	test   %eax,%eax
c0003bb2:	74 07                	je     c0003bbb <kernel_main+0x72>
c0003bb4:	b8 01 00 00 00       	mov    $0x1,%eax
c0003bb9:	eb 05                	jmp    c0003bc0 <kernel_main+0x77>
c0003bbb:	b8 00 00 00 00       	mov    $0x0,%eax
c0003bc0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    result = result || print_testresult(init_interrupts(), "Initialize interrupts");
c0003bc3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0003bc7:	75 1a                	jne    c0003be3 <kernel_main+0x9a>
c0003bc9:	e8 3f e4 ff ff       	call   c000200d <init_interrupts>
c0003bce:	83 ec 08             	sub    $0x8,%esp
c0003bd1:	68 71 58 00 c0       	push   $0xc0005871
c0003bd6:	50                   	push   %eax
c0003bd7:	e8 a6 f5 ff ff       	call   c0003182 <print_testresult>
c0003bdc:	83 c4 10             	add    $0x10,%esp
c0003bdf:	85 c0                	test   %eax,%eax
c0003be1:	74 07                	je     c0003bea <kernel_main+0xa1>
c0003be3:	b8 01 00 00 00       	mov    $0x1,%eax
c0003be8:	eb 05                	jmp    c0003bef <kernel_main+0xa6>
c0003bea:	b8 00 00 00 00       	mov    $0x0,%eax
c0003bef:	89 45 f4             	mov    %eax,-0xc(%ebp)
    result = result || print_testresult(initialize_multitasking(), "Initialize multitasking");
c0003bf2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0003bf6:	75 1a                	jne    c0003c12 <kernel_main+0xc9>
c0003bf8:	e8 f9 e8 ff ff       	call   c00024f6 <initialize_multitasking>
c0003bfd:	83 ec 08             	sub    $0x8,%esp
c0003c00:	68 87 58 00 c0       	push   $0xc0005887
c0003c05:	50                   	push   %eax
c0003c06:	e8 77 f5 ff ff       	call   c0003182 <print_testresult>
c0003c0b:	83 c4 10             	add    $0x10,%esp
c0003c0e:	85 c0                	test   %eax,%eax
c0003c10:	74 07                	je     c0003c19 <kernel_main+0xd0>
c0003c12:	b8 01 00 00 00       	mov    $0x1,%eax
c0003c17:	eb 05                	jmp    c0003c1e <kernel_main+0xd5>
c0003c19:	b8 00 00 00 00       	mov    $0x0,%eax
c0003c1e:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(result)
c0003c21:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0003c25:	74 15                	je     c0003c3c <kernel_main+0xf3>
        print_testresult(result, "Errors during startup");
c0003c27:	83 ec 08             	sub    $0x8,%esp
c0003c2a:	68 9f 58 00 c0       	push   $0xc000589f
c0003c2f:	ff 75 f4             	pushl  -0xc(%ebp)
c0003c32:	e8 4b f5 ff ff       	call   c0003182 <print_testresult>
c0003c37:	83 c4 10             	add    $0x10,%esp
c0003c3a:	eb 13                	jmp    c0003c4f <kernel_main+0x106>
    else
        print_testresult(result, "Startup successful");
c0003c3c:	83 ec 08             	sub    $0x8,%esp
c0003c3f:	68 b5 58 00 c0       	push   $0xc00058b5
c0003c44:	ff 75 f4             	pushl  -0xc(%ebp)
c0003c47:	e8 36 f5 ff ff       	call   c0003182 <print_testresult>
c0003c4c:	83 c4 10             	add    $0x10,%esp


#ifdef RUN_UNIT_TESTS
    run_unit_tests();
c0003c4f:	e8 eb f5 ff ff       	call   c000323f <run_unit_tests>
#endif

    
	while(1);
c0003c54:	eb fe                	jmp    c0003c54 <kernel_main+0x10b>

c0003c56 <populate_gdt_entry>:
   uint16_t iomap_base;
} tss_entry_t;


static inline void populate_gdt_entry(gdt_entry_t* sd, uint32_t base, uint32_t limit, uint8_t access, uint8_t flags)
{
c0003c56:	55                   	push   %ebp
c0003c57:	89 e5                	mov    %esp,%ebp
c0003c59:	53                   	push   %ebx
c0003c5a:	83 ec 08             	sub    $0x8,%esp
c0003c5d:	8b 55 14             	mov    0x14(%ebp),%edx
c0003c60:	8b 45 18             	mov    0x18(%ebp),%eax
c0003c63:	88 55 f8             	mov    %dl,-0x8(%ebp)
c0003c66:	88 45 f4             	mov    %al,-0xc(%ebp)
    sd->limit_low = limit & SEGMENT_LIMIT_LOW_MASK;
c0003c69:	8b 45 10             	mov    0x10(%ebp),%eax
c0003c6c:	89 c2                	mov    %eax,%edx
c0003c6e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c71:	0f b7 ca             	movzwl %dx,%ecx
c0003c74:	0f b6 d9             	movzbl %cl,%ebx
c0003c77:	0f b6 08             	movzbl (%eax),%ecx
c0003c7a:	83 e1 00             	and    $0x0,%ecx
c0003c7d:	09 d9                	or     %ebx,%ecx
c0003c7f:	88 08                	mov    %cl,(%eax)
c0003c81:	66 c1 ea 08          	shr    $0x8,%dx
c0003c85:	0f b7 ca             	movzwl %dx,%ecx
c0003c88:	0f b6 50 01          	movzbl 0x1(%eax),%edx
c0003c8c:	83 e2 00             	and    $0x0,%edx
c0003c8f:	09 ca                	or     %ecx,%edx
c0003c91:	88 50 01             	mov    %dl,0x1(%eax)
    sd->limit_high = (limit & SEGMENT_LIMIT_HIGH_MASK) >> 16;
c0003c94:	8b 45 10             	mov    0x10(%ebp),%eax
c0003c97:	c1 e8 10             	shr    $0x10,%eax
c0003c9a:	83 e0 0f             	and    $0xf,%eax
c0003c9d:	8b 55 08             	mov    0x8(%ebp),%edx
c0003ca0:	83 e0 0f             	and    $0xf,%eax
c0003ca3:	89 c1                	mov    %eax,%ecx
c0003ca5:	0f b6 42 06          	movzbl 0x6(%edx),%eax
c0003ca9:	83 e0 f0             	and    $0xfffffff0,%eax
c0003cac:	09 c8                	or     %ecx,%eax
c0003cae:	88 42 06             	mov    %al,0x6(%edx)
    sd->base_low = base & SEGMENT_BASE_LOW_MASK;
c0003cb1:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003cb4:	89 c2                	mov    %eax,%edx
c0003cb6:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cb9:	0f b7 ca             	movzwl %dx,%ecx
c0003cbc:	0f b6 d9             	movzbl %cl,%ebx
c0003cbf:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
c0003cc3:	83 e1 00             	and    $0x0,%ecx
c0003cc6:	09 d9                	or     %ebx,%ecx
c0003cc8:	88 48 02             	mov    %cl,0x2(%eax)
c0003ccb:	66 c1 ea 08          	shr    $0x8,%dx
c0003ccf:	0f b7 ca             	movzwl %dx,%ecx
c0003cd2:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c0003cd6:	83 e2 00             	and    $0x0,%edx
c0003cd9:	09 ca                	or     %ecx,%edx
c0003cdb:	88 50 03             	mov    %dl,0x3(%eax)
    sd->base_mid = (base & SEGMENT_BASE_MID_MASK) >> 16;
c0003cde:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003ce1:	c1 e8 10             	shr    $0x10,%eax
c0003ce4:	89 c2                	mov    %eax,%edx
c0003ce6:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ce9:	88 50 04             	mov    %dl,0x4(%eax)
    sd->base_high = (base & SEGMENT_BASE_HIGH_MASK) >> 24;
c0003cec:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003cef:	c1 e8 18             	shr    $0x18,%eax
c0003cf2:	89 c2                	mov    %eax,%edx
c0003cf4:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cf7:	88 50 07             	mov    %dl,0x7(%eax)
    sd->access = access;
c0003cfa:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cfd:	0f b6 55 f8          	movzbl -0x8(%ebp),%edx
c0003d01:	88 50 05             	mov    %dl,0x5(%eax)
    sd->flags = flags;
c0003d04:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0003d08:	83 e0 0f             	and    $0xf,%eax
c0003d0b:	89 c2                	mov    %eax,%edx
c0003d0d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d10:	89 d1                	mov    %edx,%ecx
c0003d12:	c1 e1 04             	shl    $0x4,%ecx
c0003d15:	0f b6 50 06          	movzbl 0x6(%eax),%edx
c0003d19:	83 e2 0f             	and    $0xf,%edx
c0003d1c:	09 ca                	or     %ecx,%edx
c0003d1e:	88 50 06             	mov    %dl,0x6(%eax)
}
c0003d21:	90                   	nop
c0003d22:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0003d25:	c9                   	leave  
c0003d26:	c3                   	ret    

c0003d27 <init_gdt>:
gdt_description_t __aligned  gdtd;

tss_entry_t tss = {0};

int init_gdt()
{
c0003d27:	55                   	push   %ebp
c0003d28:	89 e5                	mov    %esp,%ebp
c0003d2a:	83 ec 08             	sub    $0x8,%esp
    // gdt[0] unused
    populate_gdt_entry(&gdt[1], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(0) | SEG_DESCTYPE(1) | SEG_CODE_EXRD, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // priv code, seg 0x008
c0003d2d:	6a 0c                	push   $0xc
c0003d2f:	68 9a 00 00 00       	push   $0x9a
c0003d34:	6a ff                	push   $0xffffffff
c0003d36:	6a 00                	push   $0x0
c0003d38:	68 48 d0 00 c0       	push   $0xc000d048
c0003d3d:	e8 14 ff ff ff       	call   c0003c56 <populate_gdt_entry>
c0003d42:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[2], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(0) | SEG_DESCTYPE(1) | SEG_DATA_RDWR, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // priv data, seg 0x010
c0003d45:	6a 0c                	push   $0xc
c0003d47:	68 92 00 00 00       	push   $0x92
c0003d4c:	6a ff                	push   $0xffffffff
c0003d4e:	6a 00                	push   $0x0
c0003d50:	68 50 d0 00 c0       	push   $0xc000d050
c0003d55:	e8 fc fe ff ff       	call   c0003c56 <populate_gdt_entry>
c0003d5a:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[3], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(3) | SEG_DESCTYPE(1) | SEG_CODE_EXRD, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // user code, seg 0x018
c0003d5d:	6a 0c                	push   $0xc
c0003d5f:	68 fa 00 00 00       	push   $0xfa
c0003d64:	6a ff                	push   $0xffffffff
c0003d66:	6a 00                	push   $0x0
c0003d68:	68 58 d0 00 c0       	push   $0xc000d058
c0003d6d:	e8 e4 fe ff ff       	call   c0003c56 <populate_gdt_entry>
c0003d72:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[4], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(3) | SEG_DESCTYPE(1) | SEG_DATA_RDWR, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // user data  seg 0x020
c0003d75:	6a 0c                	push   $0xc
c0003d77:	68 f2 00 00 00       	push   $0xf2
c0003d7c:	6a ff                	push   $0xffffffff
c0003d7e:	6a 00                	push   $0x0
c0003d80:	68 60 d0 00 c0       	push   $0xc000d060
c0003d85:	e8 cc fe ff ff       	call   c0003c56 <populate_gdt_entry>
c0003d8a:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[5], (uint32_t) &tss, sizeof(tss_entry_t), SEG_TSS, SEG_FLAG_TSS); // tss, seg 0x028
c0003d8d:	b8 a0 d0 00 c0       	mov    $0xc000d0a0,%eax
c0003d92:	6a 04                	push   $0x4
c0003d94:	68 89 00 00 00       	push   $0x89
c0003d99:	6a 68                	push   $0x68
c0003d9b:	50                   	push   %eax
c0003d9c:	68 68 d0 00 c0       	push   $0xc000d068
c0003da1:	e8 b0 fe ff ff       	call   c0003c56 <populate_gdt_entry>
c0003da6:	83 c4 14             	add    $0x14,%esp

    //tss.esp0 = XXXXX
    tss.ss0 = KERNEL_DATA_SEGMENT; //kernel data segment    
c0003da9:	c7 05 a8 d0 00 c0 10 	movl   $0x10,0xc000d0a8
c0003db0:	00 00 00 
    tss.iomap_base = sizeof(tss_entry_t);
c0003db3:	66 c7 05 06 d1 00 c0 	movw   $0x68,0xc000d106
c0003dba:	68 00 
    // before we can actually switch tasks, we must first set the kernel stack pointer, with update_tss()

    gdtd.addr = (uint32_t) gdt;
c0003dbc:	b8 40 d0 00 c0       	mov    $0xc000d040,%eax
c0003dc1:	a3 82 d0 00 c0       	mov    %eax,0xc000d082
    gdtd.size = sizeof(gdt);    
c0003dc6:	66 c7 05 80 d0 00 c0 	movw   $0x30,0xc000d080
c0003dcd:	30 00 
    load_gdt(&gdtd);
c0003dcf:	83 ec 0c             	sub    $0xc,%esp
c0003dd2:	68 80 d0 00 c0       	push   $0xc000d080
c0003dd7:	e8 20 00 00 00       	call   c0003dfc <load_gdt>
c0003ddc:	83 c4 10             	add    $0x10,%esp
    return 0;
c0003ddf:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0003de4:	c9                   	leave  
c0003de5:	c3                   	ret    

c0003de6 <update_kstack>:

void update_kstack(void* kernel_stack_ptr)
{
c0003de6:	55                   	push   %ebp
c0003de7:	89 e5                	mov    %esp,%ebp
c0003de9:	83 ec 08             	sub    $0x8,%esp
    tss.esp0 = (uint32_t) kernel_stack_ptr; //kernel stack ptr
c0003dec:	8b 45 08             	mov    0x8(%ebp),%eax
c0003def:	a3 a4 d0 00 c0       	mov    %eax,0xc000d0a4
    load_tss();
c0003df4:	e8 23 00 00 00       	call   c0003e1c <load_tss>
}
c0003df9:	90                   	nop
c0003dfa:	c9                   	leave  
c0003dfb:	c3                   	ret    

c0003dfc <load_gdt>:
c0003dfc:	0f 01 15 80 d0 00 c0 	lgdtl  0xc000d080
c0003e03:	ea 0a 3e 00 c0 08 00 	ljmp   $0x8,$0xc0003e0a

c0003e0a <complete_flush>:
c0003e0a:	66 b8 10 00          	mov    $0x10,%ax
c0003e0e:	8e d8                	mov    %eax,%ds
c0003e10:	8e c0                	mov    %eax,%es
c0003e12:	8e e0                	mov    %eax,%fs
c0003e14:	8e e8                	mov    %eax,%gs
c0003e16:	8e d0                	mov    %eax,%ss
c0003e18:	c3                   	ret    
c0003e19:	8d 76 00             	lea    0x0(%esi),%esi

c0003e1c <load_tss>:
c0003e1c:	66 b8 28 00          	mov    $0x28,%ax
c0003e20:	66 83 c8 03          	or     $0x3,%ax
c0003e24:	0f 00 d8             	ltr    %ax
c0003e27:	c3                   	ret    

c0003e28 <getregs>:
c0003e28:	55                   	push   %ebp
c0003e29:	89 e5                	mov    %esp,%ebp
c0003e2b:	53                   	push   %ebx
c0003e2c:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0003e2f:	89 03                	mov    %eax,(%ebx)
c0003e31:	8b 04 24             	mov    (%esp),%eax
c0003e34:	89 43 04             	mov    %eax,0x4(%ebx)
c0003e37:	89 4b 08             	mov    %ecx,0x8(%ebx)
c0003e3a:	89 53 0c             	mov    %edx,0xc(%ebx)
c0003e3d:	89 73 10             	mov    %esi,0x10(%ebx)
c0003e40:	89 7b 14             	mov    %edi,0x14(%ebx)
c0003e43:	89 e8                	mov    %ebp,%eax
c0003e45:	83 c0 0c             	add    $0xc,%eax
c0003e48:	89 43 18             	mov    %eax,0x18(%ebx)
c0003e4b:	8b 45 00             	mov    0x0(%ebp),%eax
c0003e4e:	89 43 1c             	mov    %eax,0x1c(%ebx)
c0003e51:	8b 45 04             	mov    0x4(%ebp),%eax
c0003e54:	89 43 20             	mov    %eax,0x20(%ebx)
c0003e57:	b8 00 00 00 00       	mov    $0x0,%eax
c0003e5c:	9f                   	lahf   
c0003e5d:	89 43 24             	mov    %eax,0x24(%ebx)
c0003e60:	0f 20 c0             	mov    %cr0,%eax
c0003e63:	89 43 28             	mov    %eax,0x28(%ebx)
c0003e66:	0f 20 d0             	mov    %cr2,%eax
c0003e69:	89 43 2c             	mov    %eax,0x2c(%ebx)
c0003e6c:	0f 20 d8             	mov    %cr3,%eax
c0003e6f:	89 43 30             	mov    %eax,0x30(%ebx)
c0003e72:	0f 20 e0             	mov    %cr4,%eax
c0003e75:	89 43 34             	mov    %eax,0x34(%ebx)
c0003e78:	5b                   	pop    %ebx
c0003e79:	5d                   	pop    %ebp
c0003e7a:	c3                   	ret    
c0003e7b:	90                   	nop

c0003e7c <load_idt>:
c0003e7c:	0f 01 1d 20 78 00 c0 	lidtl  0xc0007820
c0003e83:	fb                   	sti    
c0003e84:	c3                   	ret    
c0003e85:	8d 76 00             	lea    0x0(%esi),%esi

c0003e88 <pf_addr>:
c0003e88:	0f 20 d0             	mov    %cr2,%eax
c0003e8b:	c3                   	ret    

c0003e8c <except_0>:
c0003e8c:	55                   	push   %ebp
c0003e8d:	89 e5                	mov    %esp,%ebp
c0003e8f:	60                   	pusha  
c0003e90:	8b 45 04             	mov    0x4(%ebp),%eax
c0003e93:	50                   	push   %eax
c0003e94:	b8 00 00 00 00       	mov    $0x0,%eax
c0003e99:	50                   	push   %eax
c0003e9a:	b8 00 00 00 00       	mov    $0x0,%eax
c0003e9f:	50                   	push   %eax
c0003ea0:	e8 ae e5 ff ff       	call   c0002453 <exception_handler>
c0003ea5:	83 c4 0c             	add    $0xc,%esp
c0003ea8:	61                   	popa   
c0003ea9:	5d                   	pop    %ebp
c0003eaa:	cf                   	iret   
c0003eab:	90                   	nop

c0003eac <except_1>:
c0003eac:	55                   	push   %ebp
c0003ead:	89 e5                	mov    %esp,%ebp
c0003eaf:	60                   	pusha  
c0003eb0:	8b 45 04             	mov    0x4(%ebp),%eax
c0003eb3:	50                   	push   %eax
c0003eb4:	b8 00 00 00 00       	mov    $0x0,%eax
c0003eb9:	50                   	push   %eax
c0003eba:	b8 01 00 00 00       	mov    $0x1,%eax
c0003ebf:	50                   	push   %eax
c0003ec0:	e8 8e e5 ff ff       	call   c0002453 <exception_handler>
c0003ec5:	83 c4 0c             	add    $0xc,%esp
c0003ec8:	61                   	popa   
c0003ec9:	5d                   	pop    %ebp
c0003eca:	cf                   	iret   
c0003ecb:	90                   	nop

c0003ecc <except_2>:
c0003ecc:	55                   	push   %ebp
c0003ecd:	89 e5                	mov    %esp,%ebp
c0003ecf:	60                   	pusha  
c0003ed0:	8b 45 04             	mov    0x4(%ebp),%eax
c0003ed3:	50                   	push   %eax
c0003ed4:	b8 00 00 00 00       	mov    $0x0,%eax
c0003ed9:	50                   	push   %eax
c0003eda:	b8 02 00 00 00       	mov    $0x2,%eax
c0003edf:	50                   	push   %eax
c0003ee0:	e8 6e e5 ff ff       	call   c0002453 <exception_handler>
c0003ee5:	83 c4 0c             	add    $0xc,%esp
c0003ee8:	61                   	popa   
c0003ee9:	5d                   	pop    %ebp
c0003eea:	cf                   	iret   
c0003eeb:	90                   	nop

c0003eec <except_3>:
c0003eec:	55                   	push   %ebp
c0003eed:	89 e5                	mov    %esp,%ebp
c0003eef:	60                   	pusha  
c0003ef0:	8b 45 04             	mov    0x4(%ebp),%eax
c0003ef3:	50                   	push   %eax
c0003ef4:	b8 00 00 00 00       	mov    $0x0,%eax
c0003ef9:	50                   	push   %eax
c0003efa:	b8 03 00 00 00       	mov    $0x3,%eax
c0003eff:	50                   	push   %eax
c0003f00:	e8 4e e5 ff ff       	call   c0002453 <exception_handler>
c0003f05:	83 c4 0c             	add    $0xc,%esp
c0003f08:	61                   	popa   
c0003f09:	5d                   	pop    %ebp
c0003f0a:	cf                   	iret   
c0003f0b:	90                   	nop

c0003f0c <except_4>:
c0003f0c:	55                   	push   %ebp
c0003f0d:	89 e5                	mov    %esp,%ebp
c0003f0f:	60                   	pusha  
c0003f10:	8b 45 04             	mov    0x4(%ebp),%eax
c0003f13:	50                   	push   %eax
c0003f14:	b8 00 00 00 00       	mov    $0x0,%eax
c0003f19:	50                   	push   %eax
c0003f1a:	b8 04 00 00 00       	mov    $0x4,%eax
c0003f1f:	50                   	push   %eax
c0003f20:	e8 2e e5 ff ff       	call   c0002453 <exception_handler>
c0003f25:	83 c4 0c             	add    $0xc,%esp
c0003f28:	61                   	popa   
c0003f29:	5d                   	pop    %ebp
c0003f2a:	cf                   	iret   
c0003f2b:	90                   	nop

c0003f2c <except_5>:
c0003f2c:	55                   	push   %ebp
c0003f2d:	89 e5                	mov    %esp,%ebp
c0003f2f:	60                   	pusha  
c0003f30:	8b 45 04             	mov    0x4(%ebp),%eax
c0003f33:	50                   	push   %eax
c0003f34:	b8 00 00 00 00       	mov    $0x0,%eax
c0003f39:	50                   	push   %eax
c0003f3a:	b8 05 00 00 00       	mov    $0x5,%eax
c0003f3f:	50                   	push   %eax
c0003f40:	e8 0e e5 ff ff       	call   c0002453 <exception_handler>
c0003f45:	83 c4 0c             	add    $0xc,%esp
c0003f48:	61                   	popa   
c0003f49:	5d                   	pop    %ebp
c0003f4a:	cf                   	iret   
c0003f4b:	90                   	nop

c0003f4c <except_6>:
c0003f4c:	55                   	push   %ebp
c0003f4d:	89 e5                	mov    %esp,%ebp
c0003f4f:	60                   	pusha  
c0003f50:	8b 45 04             	mov    0x4(%ebp),%eax
c0003f53:	50                   	push   %eax
c0003f54:	b8 00 00 00 00       	mov    $0x0,%eax
c0003f59:	50                   	push   %eax
c0003f5a:	b8 06 00 00 00       	mov    $0x6,%eax
c0003f5f:	50                   	push   %eax
c0003f60:	e8 ee e4 ff ff       	call   c0002453 <exception_handler>
c0003f65:	83 c4 0c             	add    $0xc,%esp
c0003f68:	61                   	popa   
c0003f69:	5d                   	pop    %ebp
c0003f6a:	cf                   	iret   
c0003f6b:	90                   	nop

c0003f6c <except_7>:
c0003f6c:	55                   	push   %ebp
c0003f6d:	89 e5                	mov    %esp,%ebp
c0003f6f:	60                   	pusha  
c0003f70:	8b 45 04             	mov    0x4(%ebp),%eax
c0003f73:	50                   	push   %eax
c0003f74:	b8 00 00 00 00       	mov    $0x0,%eax
c0003f79:	50                   	push   %eax
c0003f7a:	b8 07 00 00 00       	mov    $0x7,%eax
c0003f7f:	50                   	push   %eax
c0003f80:	e8 ce e4 ff ff       	call   c0002453 <exception_handler>
c0003f85:	83 c4 0c             	add    $0xc,%esp
c0003f88:	61                   	popa   
c0003f89:	5d                   	pop    %ebp
c0003f8a:	cf                   	iret   
c0003f8b:	90                   	nop

c0003f8c <except_8>:
c0003f8c:	55                   	push   %ebp
c0003f8d:	89 e5                	mov    %esp,%ebp
c0003f8f:	60                   	pusha  
c0003f90:	8b 45 08             	mov    0x8(%ebp),%eax
c0003f93:	50                   	push   %eax
c0003f94:	8b 45 04             	mov    0x4(%ebp),%eax
c0003f97:	50                   	push   %eax
c0003f98:	b8 08 00 00 00       	mov    $0x8,%eax
c0003f9d:	50                   	push   %eax
c0003f9e:	e8 b0 e4 ff ff       	call   c0002453 <exception_handler>
c0003fa3:	83 c4 0c             	add    $0xc,%esp
c0003fa6:	61                   	popa   
c0003fa7:	5d                   	pop    %ebp
c0003fa8:	83 c4 04             	add    $0x4,%esp
c0003fab:	cf                   	iret   

c0003fac <except_10>:
c0003fac:	55                   	push   %ebp
c0003fad:	89 e5                	mov    %esp,%ebp
c0003faf:	60                   	pusha  
c0003fb0:	8b 45 08             	mov    0x8(%ebp),%eax
c0003fb3:	50                   	push   %eax
c0003fb4:	8b 45 04             	mov    0x4(%ebp),%eax
c0003fb7:	50                   	push   %eax
c0003fb8:	b8 0a 00 00 00       	mov    $0xa,%eax
c0003fbd:	50                   	push   %eax
c0003fbe:	e8 90 e4 ff ff       	call   c0002453 <exception_handler>
c0003fc3:	83 c4 0c             	add    $0xc,%esp
c0003fc6:	61                   	popa   
c0003fc7:	5d                   	pop    %ebp
c0003fc8:	83 c4 04             	add    $0x4,%esp
c0003fcb:	cf                   	iret   

c0003fcc <except_11>:
c0003fcc:	55                   	push   %ebp
c0003fcd:	89 e5                	mov    %esp,%ebp
c0003fcf:	60                   	pusha  
c0003fd0:	8b 45 08             	mov    0x8(%ebp),%eax
c0003fd3:	50                   	push   %eax
c0003fd4:	8b 45 04             	mov    0x4(%ebp),%eax
c0003fd7:	50                   	push   %eax
c0003fd8:	b8 0b 00 00 00       	mov    $0xb,%eax
c0003fdd:	50                   	push   %eax
c0003fde:	e8 70 e4 ff ff       	call   c0002453 <exception_handler>
c0003fe3:	83 c4 0c             	add    $0xc,%esp
c0003fe6:	61                   	popa   
c0003fe7:	5d                   	pop    %ebp
c0003fe8:	83 c4 04             	add    $0x4,%esp
c0003feb:	cf                   	iret   

c0003fec <except_12>:
c0003fec:	55                   	push   %ebp
c0003fed:	89 e5                	mov    %esp,%ebp
c0003fef:	60                   	pusha  
c0003ff0:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ff3:	50                   	push   %eax
c0003ff4:	8b 45 04             	mov    0x4(%ebp),%eax
c0003ff7:	50                   	push   %eax
c0003ff8:	b8 0c 00 00 00       	mov    $0xc,%eax
c0003ffd:	50                   	push   %eax
c0003ffe:	e8 50 e4 ff ff       	call   c0002453 <exception_handler>
c0004003:	83 c4 0c             	add    $0xc,%esp
c0004006:	61                   	popa   
c0004007:	5d                   	pop    %ebp
c0004008:	83 c4 04             	add    $0x4,%esp
c000400b:	cf                   	iret   

c000400c <except_13>:
c000400c:	55                   	push   %ebp
c000400d:	89 e5                	mov    %esp,%ebp
c000400f:	60                   	pusha  
c0004010:	8b 45 08             	mov    0x8(%ebp),%eax
c0004013:	50                   	push   %eax
c0004014:	8b 45 04             	mov    0x4(%ebp),%eax
c0004017:	50                   	push   %eax
c0004018:	b8 0d 00 00 00       	mov    $0xd,%eax
c000401d:	50                   	push   %eax
c000401e:	e8 30 e4 ff ff       	call   c0002453 <exception_handler>
c0004023:	83 c4 0c             	add    $0xc,%esp
c0004026:	61                   	popa   
c0004027:	5d                   	pop    %ebp
c0004028:	83 c4 04             	add    $0x4,%esp
c000402b:	cf                   	iret   

c000402c <except_14>:
c000402c:	55                   	push   %ebp
c000402d:	89 e5                	mov    %esp,%ebp
c000402f:	60                   	pusha  
c0004030:	8b 45 08             	mov    0x8(%ebp),%eax
c0004033:	50                   	push   %eax
c0004034:	8b 45 04             	mov    0x4(%ebp),%eax
c0004037:	50                   	push   %eax
c0004038:	b8 0e 00 00 00       	mov    $0xe,%eax
c000403d:	50                   	push   %eax
c000403e:	e8 10 e4 ff ff       	call   c0002453 <exception_handler>
c0004043:	83 c4 0c             	add    $0xc,%esp
c0004046:	61                   	popa   
c0004047:	5d                   	pop    %ebp
c0004048:	83 c4 04             	add    $0x4,%esp
c000404b:	cf                   	iret   

c000404c <except_16>:
c000404c:	55                   	push   %ebp
c000404d:	89 e5                	mov    %esp,%ebp
c000404f:	60                   	pusha  
c0004050:	8b 45 08             	mov    0x8(%ebp),%eax
c0004053:	50                   	push   %eax
c0004054:	8b 45 04             	mov    0x4(%ebp),%eax
c0004057:	50                   	push   %eax
c0004058:	b8 10 00 00 00       	mov    $0x10,%eax
c000405d:	50                   	push   %eax
c000405e:	e8 f0 e3 ff ff       	call   c0002453 <exception_handler>
c0004063:	83 c4 0c             	add    $0xc,%esp
c0004066:	61                   	popa   
c0004067:	5d                   	pop    %ebp
c0004068:	83 c4 04             	add    $0x4,%esp
c000406b:	cf                   	iret   

c000406c <except_17>:
c000406c:	55                   	push   %ebp
c000406d:	89 e5                	mov    %esp,%ebp
c000406f:	60                   	pusha  
c0004070:	8b 45 08             	mov    0x8(%ebp),%eax
c0004073:	50                   	push   %eax
c0004074:	8b 45 04             	mov    0x4(%ebp),%eax
c0004077:	50                   	push   %eax
c0004078:	b8 11 00 00 00       	mov    $0x11,%eax
c000407d:	50                   	push   %eax
c000407e:	e8 d0 e3 ff ff       	call   c0002453 <exception_handler>
c0004083:	83 c4 0c             	add    $0xc,%esp
c0004086:	61                   	popa   
c0004087:	5d                   	pop    %ebp
c0004088:	83 c4 04             	add    $0x4,%esp
c000408b:	cf                   	iret   

c000408c <except_18>:
c000408c:	55                   	push   %ebp
c000408d:	89 e5                	mov    %esp,%ebp
c000408f:	60                   	pusha  
c0004090:	8b 45 08             	mov    0x8(%ebp),%eax
c0004093:	50                   	push   %eax
c0004094:	8b 45 04             	mov    0x4(%ebp),%eax
c0004097:	50                   	push   %eax
c0004098:	b8 12 00 00 00       	mov    $0x12,%eax
c000409d:	50                   	push   %eax
c000409e:	e8 b0 e3 ff ff       	call   c0002453 <exception_handler>
c00040a3:	83 c4 0c             	add    $0xc,%esp
c00040a6:	61                   	popa   
c00040a7:	5d                   	pop    %ebp
c00040a8:	83 c4 04             	add    $0x4,%esp
c00040ab:	cf                   	iret   

c00040ac <except_19>:
c00040ac:	55                   	push   %ebp
c00040ad:	89 e5                	mov    %esp,%ebp
c00040af:	60                   	pusha  
c00040b0:	8b 45 08             	mov    0x8(%ebp),%eax
c00040b3:	50                   	push   %eax
c00040b4:	8b 45 04             	mov    0x4(%ebp),%eax
c00040b7:	50                   	push   %eax
c00040b8:	b8 13 00 00 00       	mov    $0x13,%eax
c00040bd:	50                   	push   %eax
c00040be:	e8 90 e3 ff ff       	call   c0002453 <exception_handler>
c00040c3:	83 c4 0c             	add    $0xc,%esp
c00040c6:	61                   	popa   
c00040c7:	5d                   	pop    %ebp
c00040c8:	83 c4 04             	add    $0x4,%esp
c00040cb:	cf                   	iret   

c00040cc <except_20>:
c00040cc:	55                   	push   %ebp
c00040cd:	89 e5                	mov    %esp,%ebp
c00040cf:	60                   	pusha  
c00040d0:	8b 45 08             	mov    0x8(%ebp),%eax
c00040d3:	50                   	push   %eax
c00040d4:	8b 45 04             	mov    0x4(%ebp),%eax
c00040d7:	50                   	push   %eax
c00040d8:	b8 14 00 00 00       	mov    $0x14,%eax
c00040dd:	50                   	push   %eax
c00040de:	e8 70 e3 ff ff       	call   c0002453 <exception_handler>
c00040e3:	83 c4 0c             	add    $0xc,%esp
c00040e6:	61                   	popa   
c00040e7:	5d                   	pop    %ebp
c00040e8:	83 c4 04             	add    $0x4,%esp
c00040eb:	cf                   	iret   

c00040ec <except_30>:
c00040ec:	55                   	push   %ebp
c00040ed:	89 e5                	mov    %esp,%ebp
c00040ef:	60                   	pusha  
c00040f0:	8b 45 08             	mov    0x8(%ebp),%eax
c00040f3:	50                   	push   %eax
c00040f4:	8b 45 04             	mov    0x4(%ebp),%eax
c00040f7:	50                   	push   %eax
c00040f8:	b8 1e 00 00 00       	mov    $0x1e,%eax
c00040fd:	50                   	push   %eax
c00040fe:	e8 50 e3 ff ff       	call   c0002453 <exception_handler>
c0004103:	83 c4 0c             	add    $0xc,%esp
c0004106:	61                   	popa   
c0004107:	5d                   	pop    %ebp
c0004108:	83 c4 04             	add    $0x4,%esp
c000410b:	cf                   	iret   

c000410c <irq_0>:
c000410c:	60                   	pusha  
c000410d:	b8 00 00 00 00       	mov    $0x0,%eax
c0004112:	50                   	push   %eax
c0004113:	e8 72 e3 ff ff       	call   c000248a <irq_handler>
c0004118:	83 c4 04             	add    $0x4,%esp
c000411b:	61                   	popa   
c000411c:	cf                   	iret   
c000411d:	8d 76 00             	lea    0x0(%esi),%esi

c0004120 <irq_1>:
c0004120:	60                   	pusha  
c0004121:	b8 01 00 00 00       	mov    $0x1,%eax
c0004126:	50                   	push   %eax
c0004127:	e8 5e e3 ff ff       	call   c000248a <irq_handler>
c000412c:	83 c4 04             	add    $0x4,%esp
c000412f:	61                   	popa   
c0004130:	cf                   	iret   
c0004131:	8d 76 00             	lea    0x0(%esi),%esi

c0004134 <irq_2>:
c0004134:	60                   	pusha  
c0004135:	b8 02 00 00 00       	mov    $0x2,%eax
c000413a:	50                   	push   %eax
c000413b:	e8 4a e3 ff ff       	call   c000248a <irq_handler>
c0004140:	83 c4 04             	add    $0x4,%esp
c0004143:	61                   	popa   
c0004144:	cf                   	iret   
c0004145:	8d 76 00             	lea    0x0(%esi),%esi

c0004148 <irq_3>:
c0004148:	60                   	pusha  
c0004149:	b8 03 00 00 00       	mov    $0x3,%eax
c000414e:	50                   	push   %eax
c000414f:	e8 36 e3 ff ff       	call   c000248a <irq_handler>
c0004154:	83 c4 04             	add    $0x4,%esp
c0004157:	61                   	popa   
c0004158:	cf                   	iret   
c0004159:	8d 76 00             	lea    0x0(%esi),%esi

c000415c <irq_4>:
c000415c:	60                   	pusha  
c000415d:	b8 04 00 00 00       	mov    $0x4,%eax
c0004162:	50                   	push   %eax
c0004163:	e8 22 e3 ff ff       	call   c000248a <irq_handler>
c0004168:	83 c4 04             	add    $0x4,%esp
c000416b:	61                   	popa   
c000416c:	cf                   	iret   
c000416d:	8d 76 00             	lea    0x0(%esi),%esi

c0004170 <irq_5>:
c0004170:	60                   	pusha  
c0004171:	b8 05 00 00 00       	mov    $0x5,%eax
c0004176:	50                   	push   %eax
c0004177:	e8 0e e3 ff ff       	call   c000248a <irq_handler>
c000417c:	83 c4 04             	add    $0x4,%esp
c000417f:	61                   	popa   
c0004180:	cf                   	iret   
c0004181:	8d 76 00             	lea    0x0(%esi),%esi

c0004184 <irq_6>:
c0004184:	60                   	pusha  
c0004185:	b8 06 00 00 00       	mov    $0x6,%eax
c000418a:	50                   	push   %eax
c000418b:	e8 fa e2 ff ff       	call   c000248a <irq_handler>
c0004190:	83 c4 04             	add    $0x4,%esp
c0004193:	61                   	popa   
c0004194:	cf                   	iret   
c0004195:	8d 76 00             	lea    0x0(%esi),%esi

c0004198 <irq_7>:
c0004198:	60                   	pusha  
c0004199:	b8 07 00 00 00       	mov    $0x7,%eax
c000419e:	50                   	push   %eax
c000419f:	e8 e6 e2 ff ff       	call   c000248a <irq_handler>
c00041a4:	83 c4 04             	add    $0x4,%esp
c00041a7:	61                   	popa   
c00041a8:	cf                   	iret   
c00041a9:	8d 76 00             	lea    0x0(%esi),%esi

c00041ac <irq_8>:
c00041ac:	60                   	pusha  
c00041ad:	b8 08 00 00 00       	mov    $0x8,%eax
c00041b2:	50                   	push   %eax
c00041b3:	e8 d2 e2 ff ff       	call   c000248a <irq_handler>
c00041b8:	83 c4 04             	add    $0x4,%esp
c00041bb:	61                   	popa   
c00041bc:	cf                   	iret   
c00041bd:	8d 76 00             	lea    0x0(%esi),%esi

c00041c0 <irq_9>:
c00041c0:	60                   	pusha  
c00041c1:	b8 09 00 00 00       	mov    $0x9,%eax
c00041c6:	50                   	push   %eax
c00041c7:	e8 be e2 ff ff       	call   c000248a <irq_handler>
c00041cc:	83 c4 04             	add    $0x4,%esp
c00041cf:	61                   	popa   
c00041d0:	cf                   	iret   
c00041d1:	8d 76 00             	lea    0x0(%esi),%esi

c00041d4 <irq_10>:
c00041d4:	60                   	pusha  
c00041d5:	b8 0a 00 00 00       	mov    $0xa,%eax
c00041da:	50                   	push   %eax
c00041db:	e8 aa e2 ff ff       	call   c000248a <irq_handler>
c00041e0:	83 c4 04             	add    $0x4,%esp
c00041e3:	61                   	popa   
c00041e4:	cf                   	iret   
c00041e5:	8d 76 00             	lea    0x0(%esi),%esi

c00041e8 <irq_11>:
c00041e8:	60                   	pusha  
c00041e9:	b8 0b 00 00 00       	mov    $0xb,%eax
c00041ee:	50                   	push   %eax
c00041ef:	e8 96 e2 ff ff       	call   c000248a <irq_handler>
c00041f4:	83 c4 04             	add    $0x4,%esp
c00041f7:	61                   	popa   
c00041f8:	cf                   	iret   
c00041f9:	8d 76 00             	lea    0x0(%esi),%esi

c00041fc <irq_12>:
c00041fc:	60                   	pusha  
c00041fd:	b8 0c 00 00 00       	mov    $0xc,%eax
c0004202:	50                   	push   %eax
c0004203:	e8 82 e2 ff ff       	call   c000248a <irq_handler>
c0004208:	83 c4 04             	add    $0x4,%esp
c000420b:	61                   	popa   
c000420c:	cf                   	iret   
c000420d:	8d 76 00             	lea    0x0(%esi),%esi

c0004210 <irq_13>:
c0004210:	60                   	pusha  
c0004211:	b8 0d 00 00 00       	mov    $0xd,%eax
c0004216:	50                   	push   %eax
c0004217:	e8 6e e2 ff ff       	call   c000248a <irq_handler>
c000421c:	83 c4 04             	add    $0x4,%esp
c000421f:	61                   	popa   
c0004220:	cf                   	iret   
c0004221:	8d 76 00             	lea    0x0(%esi),%esi

c0004224 <irq_14>:
c0004224:	60                   	pusha  
c0004225:	b8 0e 00 00 00       	mov    $0xe,%eax
c000422a:	50                   	push   %eax
c000422b:	e8 5a e2 ff ff       	call   c000248a <irq_handler>
c0004230:	83 c4 04             	add    $0x4,%esp
c0004233:	61                   	popa   
c0004234:	cf                   	iret   
c0004235:	8d 76 00             	lea    0x0(%esi),%esi

c0004238 <irq_15>:
c0004238:	60                   	pusha  
c0004239:	b8 0f 00 00 00       	mov    $0xf,%eax
c000423e:	50                   	push   %eax
c000423f:	e8 46 e2 ff ff       	call   c000248a <irq_handler>
c0004244:	83 c4 04             	add    $0x4,%esp
c0004247:	61                   	popa   
c0004248:	cf                   	iret   
c0004249:	66 90                	xchg   %ax,%ax
c000424b:	90                   	nop

c000424c <switch_to_task>:
c000424c:	53                   	push   %ebx
c000424d:	56                   	push   %esi
c000424e:	57                   	push   %edi
c000424f:	55                   	push   %ebp
c0004250:	8b 3d 00 d0 00 c0    	mov    0xc000d000,%edi
c0004256:	89 67 08             	mov    %esp,0x8(%edi)
c0004259:	8b 74 24 14          	mov    0x14(%esp),%esi
c000425d:	89 35 00 d0 00 c0    	mov    %esi,0xc000d000
c0004263:	8b 66 08             	mov    0x8(%esi),%esp
c0004266:	8b 5e 0c             	mov    0xc(%esi),%ebx
c0004269:	8b 46 10             	mov    0x10(%esi),%eax
c000426c:	89 1d a4 d0 00 c0    	mov    %ebx,0xc000d0a4
c0004272:	0f 20 d9             	mov    %cr3,%ecx
c0004275:	39 c8                	cmp    %ecx,%eax
c0004277:	74 03                	je     c000427c <.done>
c0004279:	0f 22 d8             	mov    %eax,%cr3

c000427c <.done>:
c000427c:	5d                   	pop    %ebp
c000427d:	5f                   	pop    %edi
c000427e:	5e                   	pop    %esi
c000427f:	5b                   	pop    %ebx
c0004280:	c3                   	ret    

c0004281 <terminate_task>:
c0004281:	8d 35 00 80 00 c0    	lea    0xc0008000,%esi
c0004287:	89 35 00 d0 00 c0    	mov    %esi,0xc000d000
c000428d:	8b 66 08             	mov    0x8(%esi),%esp
c0004290:	8b 5e 0c             	mov    0xc(%esi),%ebx
c0004293:	8b 46 10             	mov    0x10(%esi),%eax
c0004296:	89 1d a4 d0 00 c0    	mov    %ebx,0xc000d0a4
c000429c:	0f 20 d9             	mov    %cr3,%ecx
c000429f:	39 c8                	cmp    %ecx,%eax
c00042a1:	74 d9                	je     c000427c <.done>
c00042a3:	0f 22 d8             	mov    %eax,%cr3

c00042a6 <.done2>:
c00042a6:	5d                   	pop    %ebp
c00042a7:	5f                   	pop    %edi
c00042a8:	5e                   	pop    %esi
c00042a9:	5b                   	pop    %ebx
c00042aa:	c3                   	ret    
c00042ab:	90                   	nop

c00042ac <enable_paging>:
c00042ac:	55                   	push   %ebp
c00042ad:	89 e5                	mov    %esp,%ebp
c00042af:	8b 45 08             	mov    0x8(%ebp),%eax
c00042b2:	0f 22 d8             	mov    %eax,%cr3
c00042b5:	0f 20 c0             	mov    %cr0,%eax
c00042b8:	0d 01 00 00 80       	or     $0x80000001,%eax
c00042bd:	0f 22 c0             	mov    %eax,%cr0
c00042c0:	89 ec                	mov    %ebp,%esp
c00042c2:	5d                   	pop    %ebp
c00042c3:	c3                   	ret    

c00042c4 <set_page_dir>:
c00042c4:	8b 44 24 04          	mov    0x4(%esp),%eax
c00042c8:	0f 22 d8             	mov    %eax,%cr3
c00042cb:	c3                   	ret    

c00042cc <get_page_dir>:
c00042cc:	0f 20 d8             	mov    %cr3,%eax
c00042cf:	c3                   	ret    

c00042d0 <refresh_tlb>:
c00042d0:	0f 20 d8             	mov    %cr3,%eax
c00042d3:	0f 22 d8             	mov    %eax,%cr3
c00042d6:	c3                   	ret    
c00042d7:	90                   	nop

c00042d8 <refresh_page>:
c00042d8:	8b 44 24 04          	mov    0x4(%esp),%eax
c00042dc:	0f 01 38             	invlpg (%eax)
c00042df:	c3                   	ret    

c00042e0 <relocate_stack>:
c00042e0:	55                   	push   %ebp
c00042e1:	89 e5                	mov    %esp,%ebp
c00042e3:	8b 4d 08             	mov    0x8(%ebp),%ecx
c00042e6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00042e9:	29 c8                	sub    %ecx,%eax
c00042eb:	50                   	push   %eax
c00042ec:	01 c4                	add    %eax,%esp
c00042ee:	5b                   	pop    %ebx
c00042ef:	5d                   	pop    %ebp
c00042f0:	01 c5                	add    %eax,%ebp
c00042f2:	29 d8                	sub    %ebx,%eax
c00042f4:	c3                   	ret    
