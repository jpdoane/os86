
build/kernel:     file format elf32-i386


Disassembly of section .text.boot:

00100000 <_start-0xc>:
  100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fb                   	sti    
  100009:	4f                   	dec    %edi
  10000a:	52                   	push   %edx
  10000b:	e4                   	.byte 0xe4

0010000c <_start>:
  10000c:	fa                   	cli    
  10000d:	3d 02 b0 ad 2b       	cmp    $0x2badb002,%eax
  100012:	0f 85 c1 00 00 00    	jne    1000d9 <kpanic>
  100018:	8d 25 00 a0 10 00    	lea    0x10a000,%esp
  10001e:	53                   	push   %ebx
  10001f:	8d 3d 00 a0 10 00    	lea    0x10a000,%edi
  100025:	b8 83 00 00 00       	mov    $0x83,%eax
  10002a:	89 07                	mov    %eax,(%edi)
  10002c:	0f 20 e0             	mov    %cr4,%eax
  10002f:	83 c8 10             	or     $0x10,%eax
  100032:	0f 22 e0             	mov    %eax,%cr4
  100035:	8d 35 00 b0 10 00    	lea    0x10b000,%esi
  10003b:	83 ce 03             	or     $0x3,%esi
  10003e:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  100044:	c1 e8 16             	shr    $0x16,%eax
  100047:	bb 04 00 00 00       	mov    $0x4,%ebx
  10004c:	f7 e3                	mul    %ebx
  10004e:	8d 3d 00 a0 10 00    	lea    0x10a000,%edi
  100054:	01 c7                	add    %eax,%edi
  100056:	89 37                	mov    %esi,(%edi)
  100058:	8d 1d 00 00 00 c0    	lea    0xc0000000,%ebx
  10005e:	c1 eb 0c             	shr    $0xc,%ebx
  100061:	8d 0d 30 b9 00 c0    	lea    0xc000b930,%ecx
  100067:	81 c1 ff 0f 00 00    	add    $0xfff,%ecx
  10006d:	c1 e9 0c             	shr    $0xc,%ecx
  100070:	29 d9                	sub    %ebx,%ecx
  100072:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  100078:	25 00 f0 3f 00       	and    $0x3ff000,%eax
  10007d:	c1 e8 0c             	shr    $0xc,%eax
  100080:	bb 04 00 00 00       	mov    $0x4,%ebx
  100085:	f7 e3                	mul    %ebx
  100087:	8d 3d 00 b0 10 00    	lea    0x10b000,%edi
  10008d:	01 c7                	add    %eax,%edi
  10008f:	8d 05 00 10 10 00    	lea    0x101000,%eax
  100095:	83 c8 03             	or     $0x3,%eax
  100098:	fc                   	cld    

00100099 <.nextpte>:
  100099:	ab                   	stos   %eax,%es:(%edi)
  10009a:	05 00 10 00 00       	add    $0x1000,%eax
  10009f:	e2 f8                	loop   100099 <.nextpte>
  1000a1:	8d 35 00 a0 10 00    	lea    0x10a000,%esi
  1000a7:	89 f7                	mov    %esi,%edi
  1000a9:	81 c7 fc 0f 00 00    	add    $0xffc,%edi
  1000af:	83 ce 03             	or     $0x3,%esi
  1000b2:	89 37                	mov    %esi,(%edi)
  1000b4:	5b                   	pop    %ebx

001000b5 <_enable_paging>:
  1000b5:	8d 05 00 a0 10 00    	lea    0x10a000,%eax
  1000bb:	0f 22 d8             	mov    %eax,%cr3
  1000be:	0f 20 c0             	mov    %cr0,%eax
  1000c1:	0d 00 00 01 80       	or     $0x80010000,%eax
  1000c6:	0f 22 c0             	mov    %eax,%cr0
  1000c9:	8d 25 00 90 00 c0    	lea    0xc0009000,%esp
  1000cf:	50                   	push   %eax
  1000d0:	50                   	push   %eax
  1000d1:	50                   	push   %eax
  1000d2:	53                   	push   %ebx
  1000d3:	e8 d8 27 f0 bf       	call   c00028b0 <kernel_main>
  1000d8:	fa                   	cli    

001000d9 <kpanic>:
  1000d9:	f4                   	hlt    
  1000da:	eb fd                	jmp    1000d9 <kpanic>

Disassembly of section .text:

c0000000 <kprint>:
unsigned int numdigits_uint(unsigned int value, unsigned int base);

int format_uint(unsigned int value, char* str, unsigned int base, int precision, int cap);

int kprint(const char* str)
{
c0000000:	55                   	push   %ebp
c0000001:	89 e5                	mov    %esp,%ebp
c0000003:	53                   	push   %ebx
c0000004:	83 ec 0c             	sub    $0xc,%esp
c0000007:	8b 5d 08             	mov    0x8(%ebp),%ebx
    terminal_writestring(&stdout, str);
c000000a:	53                   	push   %ebx
c000000b:	68 20 b8 00 c0       	push   $0xc000b820
c0000010:	e8 db 1f 00 00       	call   c0001ff0 <terminal_writestring>
    return strlen(str);
c0000015:	89 5d 08             	mov    %ebx,0x8(%ebp)
c0000018:	83 c4 10             	add    $0x10,%esp
}
c000001b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000001e:	c9                   	leave  
    return strlen(str);
c000001f:	e9 dc 11 00 00       	jmp    c0001200 <strlen>
c0000024:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000002b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c000002f:	90                   	nop

c0000030 <kprintn>:

int kprintn(const char* str, size_t len)
{
c0000030:	55                   	push   %ebp
c0000031:	89 e5                	mov    %esp,%ebp
c0000033:	53                   	push   %ebx
c0000034:	83 ec 08             	sub    $0x8,%esp
c0000037:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    terminal_write(&stdout, str, len);
c000003a:	53                   	push   %ebx
c000003b:	ff 75 08             	pushl  0x8(%ebp)
c000003e:	68 20 b8 00 c0       	push   $0xc000b820
c0000043:	e8 48 1e 00 00       	call   c0001e90 <terminal_write>
    return len;
}
c0000048:	89 d8                	mov    %ebx,%eax
c000004a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000004d:	c9                   	leave  
c000004e:	c3                   	ret    
c000004f:	90                   	nop

c0000050 <kprint_char>:

int kprint_char(char c)
{
c0000050:	55                   	push   %ebp
c0000051:	89 e5                	mov    %esp,%ebp
c0000053:	83 ec 10             	sub    $0x10,%esp
    terminal_putchar(&stdout, c); 
c0000056:	0f be 45 08          	movsbl 0x8(%ebp),%eax
c000005a:	50                   	push   %eax
c000005b:	68 20 b8 00 c0       	push   $0xc000b820
c0000060:	e8 3b 1d 00 00       	call   c0001da0 <terminal_putchar>
    return 1;
}
c0000065:	b8 01 00 00 00       	mov    $0x1,%eax
c000006a:	c9                   	leave  
c000006b:	c3                   	ret    
c000006c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

c0000070 <kprintn_char>:

int kprintn_char(char c, size_t rpt)
{
c0000070:	55                   	push   %ebp
c0000071:	89 e5                	mov    %esp,%ebp
c0000073:	53                   	push   %ebx
c0000074:	83 ec 08             	sub    $0x8,%esp
c0000077:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    terminal_putcharn(&stdout, c, rpt); 
c000007a:	0f be 45 08          	movsbl 0x8(%ebp),%eax
c000007e:	53                   	push   %ebx
c000007f:	50                   	push   %eax
c0000080:	68 20 b8 00 c0       	push   $0xc000b820
c0000085:	e8 36 1b 00 00       	call   c0001bc0 <terminal_putcharn>
    return rpt;
}
c000008a:	89 d8                	mov    %ebx,%eax
c000008c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000008f:	c9                   	leave  
c0000090:	c3                   	ret    
c0000091:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0000098:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000009f:	90                   	nop

c00000a0 <format_uint>:
// base may be 2-32
// precision is per printf format, precision<0 represents default (unspecified) 
// cap = 0, alpha-numbers are capitalized [base>10 only]
// returns length of string (not counting null termination)
int format_uint(unsigned int value, char* str, unsigned int base, int precision, int cap)
{
c00000a0:	55                   	push   %ebp
c00000a1:	89 e5                	mov    %esp,%ebp
c00000a3:	57                   	push   %edi
c00000a4:	56                   	push   %esi
c00000a5:	53                   	push   %ebx
c00000a6:	83 ec 04             	sub    $0x4,%esp
c00000a9:	8b 4d 10             	mov    0x10(%ebp),%ecx
c00000ac:	8b 75 08             	mov    0x8(%ebp),%esi
c00000af:	8b 7d 14             	mov    0x14(%ebp),%edi
    if(base < 2 || base > 32)
c00000b2:	8d 41 fe             	lea    -0x2(%ecx),%eax
c00000b5:	83 f8 1e             	cmp    $0x1e,%eax
c00000b8:	0f 87 ca 00 00 00    	ja     c0000188 <format_uint+0xe8>
        return -1;

    //When 0 is printed with an explicit precision 0, the output is empty.
    if(value==0 && precision==0)
c00000be:	89 f8                	mov    %edi,%eax
c00000c0:	09 f0                	or     %esi,%eax
c00000c2:	0f 84 88 00 00 00    	je     c0000150 <format_uint+0xb0>
//returns number of digits of unsigned int represented in given base
//num_digits is always >= 1
unsigned int numdigits_uint(unsigned int value, unsigned int base)
{
    unsigned int num_digits = 1;
    while(value >= base)
c00000c8:	89 f0                	mov    %esi,%eax
    unsigned int num_digits = 1;
c00000ca:	bb 01 00 00 00       	mov    $0x1,%ebx
    while(value >= base)
c00000cf:	39 f1                	cmp    %esi,%ecx
c00000d1:	0f 87 99 00 00 00    	ja     c0000170 <format_uint+0xd0>
c00000d7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00000de:	66 90                	xchg   %ax,%ax
    {
        num_digits++;
        value /= base;
c00000e0:	31 d2                	xor    %edx,%edx
        num_digits++;
c00000e2:	83 c3 01             	add    $0x1,%ebx
        value /= base;
c00000e5:	f7 f1                	div    %ecx
    while(value >= base)
c00000e7:	39 c1                	cmp    %eax,%ecx
c00000e9:	76 f5                	jbe    c00000e0 <format_uint+0x40>
    num_digits = num_digits>precision ? num_digits : precision;
c00000eb:	39 df                	cmp    %ebx,%edi
    char* s = str + num_digits;
c00000ed:	8b 45 0c             	mov    0xc(%ebp),%eax
    num_digits = num_digits>precision ? num_digits : precision;
c00000f0:	0f 4c fb             	cmovl  %ebx,%edi
    char* s = str + num_digits;
c00000f3:	01 f8                	add    %edi,%eax
    *(s--) = '\0'; //null termination
c00000f5:	8d 58 ff             	lea    -0x1(%eax),%ebx
c00000f8:	c6 00 00             	movb   $0x0,(%eax)
c00000fb:	89 5d f0             	mov    %ebx,-0x10(%ebp)
    for(int nn=0;nn<num_digits; nn++)
c00000fe:	85 ff                	test   %edi,%edi
c0000100:	7e 42                	jle    c0000144 <format_uint+0xa4>
    unsigned int num_digits = 1;
c0000102:	8b 5d f0             	mov    -0x10(%ebp),%ebx
c0000105:	89 f0                	mov    %esi,%eax
c0000107:	eb 16                	jmp    c000011f <format_uint+0x7f>
c0000109:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
            *(s--) = d + '0';
c0000110:	83 c2 30             	add    $0x30,%edx
c0000113:	88 53 01             	mov    %dl,0x1(%ebx)
    for(int nn=0;nn<num_digits; nn++)
c0000116:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0000119:	29 da                	sub    %ebx,%edx
c000011b:	39 d7                	cmp    %edx,%edi
c000011d:	7e 25                	jle    c0000144 <format_uint+0xa4>
        value /= base;
c000011f:	31 d2                	xor    %edx,%edx
            *(s--) = d + '0';
c0000121:	83 eb 01             	sub    $0x1,%ebx
        value /= base;
c0000124:	f7 f1                	div    %ecx
        if(d < 10)
c0000126:	83 fa 09             	cmp    $0x9,%edx
c0000129:	76 e5                	jbe    c0000110 <format_uint+0x70>
            *(s--) = d - 10 + 'a';
c000012b:	8d 72 37             	lea    0x37(%edx),%esi
c000012e:	83 c2 57             	add    $0x57,%edx
c0000131:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
c0000135:	0f 45 d6             	cmovne %esi,%edx
c0000138:	88 53 01             	mov    %dl,0x1(%ebx)
    for(int nn=0;nn<num_digits; nn++)
c000013b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000013e:	29 da                	sub    %ebx,%edx
c0000140:	39 d7                	cmp    %edx,%edi
c0000142:	7f db                	jg     c000011f <format_uint+0x7f>
}
c0000144:	83 c4 04             	add    $0x4,%esp
c0000147:	89 f8                	mov    %edi,%eax
c0000149:	5b                   	pop    %ebx
c000014a:	5e                   	pop    %esi
c000014b:	5f                   	pop    %edi
c000014c:	5d                   	pop    %ebp
c000014d:	c3                   	ret    
c000014e:	66 90                	xchg   %ax,%ax
        str[0] = 0;
c0000150:	8b 45 0c             	mov    0xc(%ebp),%eax
        return 0;
c0000153:	31 ff                	xor    %edi,%edi
        str[0] = 0;
c0000155:	c6 00 00             	movb   $0x0,(%eax)
}
c0000158:	83 c4 04             	add    $0x4,%esp
c000015b:	89 f8                	mov    %edi,%eax
c000015d:	5b                   	pop    %ebx
c000015e:	5e                   	pop    %esi
c000015f:	5f                   	pop    %edi
c0000160:	5d                   	pop    %ebp
c0000161:	c3                   	ret    
c0000162:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0000169:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    num_digits = num_digits>precision ? num_digits : precision;
c0000170:	85 ff                	test   %edi,%edi
    char* s = str + num_digits;
c0000172:	8b 45 0c             	mov    0xc(%ebp),%eax
    num_digits = num_digits>precision ? num_digits : precision;
c0000175:	0f 4e fb             	cmovle %ebx,%edi
    char* s = str + num_digits;
c0000178:	01 f8                	add    %edi,%eax
    *(s--) = '\0'; //null termination
c000017a:	8d 58 ff             	lea    -0x1(%eax),%ebx
c000017d:	c6 00 00             	movb   $0x0,(%eax)
c0000180:	89 5d f0             	mov    %ebx,-0x10(%ebp)
    for(int nn=0;nn<num_digits; nn++)
c0000183:	e9 7a ff ff ff       	jmp    c0000102 <format_uint+0x62>
        return -1;
c0000188:	bf ff ff ff ff       	mov    $0xffffffff,%edi
c000018d:	eb b5                	jmp    c0000144 <format_uint+0xa4>
c000018f:	90                   	nop

c0000190 <kprintf>:
{
c0000190:	55                   	push   %ebp
c0000191:	89 e5                	mov    %esp,%ebp
c0000193:	57                   	push   %edi
    int nchar = 0;
c0000194:	31 ff                	xor    %edi,%edi
{
c0000196:	56                   	push   %esi
    va_start(valist, format);
c0000197:	8d 45 0c             	lea    0xc(%ebp),%eax
{
c000019a:	53                   	push   %ebx
c000019b:	81 ec 5c 02 00 00    	sub    $0x25c,%esp
c00001a1:	8b 5d 08             	mov    0x8(%ebp),%ebx
    va_start(valist, format);
c00001a4:	89 85 b4 fd ff ff    	mov    %eax,-0x24c(%ebp)
    while(f[0] != 0)
c00001aa:	0f b6 03             	movzbl (%ebx),%eax
c00001ad:	84 c0                	test   %al,%al
c00001af:	74 29                	je     c00001da <kprintf+0x4a>
        if(f[0] == '\\' && f[1] == '%')
c00001b1:	3c 5c                	cmp    $0x5c,%al
c00001b3:	74 3b                	je     c00001f0 <kprintf+0x60>
        if(f[0] == '%')
c00001b5:	0f be 03             	movsbl (%ebx),%eax
c00001b8:	3c 25                	cmp    $0x25,%al
c00001ba:	74 64                	je     c0000220 <kprintf+0x90>
    terminal_putchar(&stdout, c); 
c00001bc:	83 ec 08             	sub    $0x8,%esp
            kprint_char(*(f++));
c00001bf:	83 c3 01             	add    $0x1,%ebx
            nchar++;
c00001c2:	83 c7 01             	add    $0x1,%edi
    terminal_putchar(&stdout, c); 
c00001c5:	50                   	push   %eax
c00001c6:	68 20 b8 00 c0       	push   $0xc000b820
c00001cb:	e8 d0 1b 00 00       	call   c0001da0 <terminal_putchar>
            nchar++;
c00001d0:	83 c4 10             	add    $0x10,%esp
    while(f[0] != 0)
c00001d3:	0f b6 03             	movzbl (%ebx),%eax
c00001d6:	84 c0                	test   %al,%al
c00001d8:	75 d7                	jne    c00001b1 <kprintf+0x21>
}
c00001da:	8d 65 f4             	lea    -0xc(%ebp),%esp
c00001dd:	89 f8                	mov    %edi,%eax
c00001df:	5b                   	pop    %ebx
c00001e0:	5e                   	pop    %esi
c00001e1:	5f                   	pop    %edi
c00001e2:	5d                   	pop    %ebp
c00001e3:	c3                   	ret    
c00001e4:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00001eb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c00001ef:	90                   	nop
        if(f[0] == '\\' && f[1] == '%')
c00001f0:	80 7b 01 25          	cmpb   $0x25,0x1(%ebx)
c00001f4:	75 bf                	jne    c00001b5 <kprintf+0x25>
    terminal_putchar(&stdout, c); 
c00001f6:	83 ec 08             	sub    $0x8,%esp
            f += 2;
c00001f9:	83 c3 02             	add    $0x2,%ebx
            nchar++;
c00001fc:	83 c7 01             	add    $0x1,%edi
    terminal_putchar(&stdout, c); 
c00001ff:	6a 25                	push   $0x25
c0000201:	68 20 b8 00 c0       	push   $0xc000b820
c0000206:	e8 95 1b 00 00       	call   c0001da0 <terminal_putchar>
        if(f[0] == '%')
c000020b:	0f be 03             	movsbl (%ebx),%eax
            f += 2;
c000020e:	83 c4 10             	add    $0x10,%esp
        if(f[0] == '%')
c0000211:	3c 25                	cmp    $0x25,%al
c0000213:	75 a7                	jne    c00001bc <kprintf+0x2c>
c0000215:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000021c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                switch(*(++f))
c0000220:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
            struct format_flags flags = {0};
c0000224:	c6 85 c0 fd ff ff 00 	movb   $0x0,-0x240(%ebp)
c000022b:	31 f6                	xor    %esi,%esi
                switch(*(++f))
c000022d:	8d 4b 01             	lea    0x1(%ebx),%ecx
            struct format_flags flags = {0};
c0000230:	c6 85 bf fd ff ff 00 	movb   $0x0,-0x241(%ebp)
c0000237:	c6 85 d0 fd ff ff 00 	movb   $0x0,-0x230(%ebp)
c000023e:	c6 85 c8 fd ff ff 00 	movb   $0x0,-0x238(%ebp)
                switch(*(++f))
c0000245:	84 d2                	test   %dl,%dl
c0000247:	0f 84 b3 00 00 00    	je     c0000300 <kprintf+0x170>
c000024d:	8d 42 e0             	lea    -0x20(%edx),%eax
c0000250:	3c 10                	cmp    $0x10,%al
c0000252:	77 0c                	ja     c0000260 <kprintf+0xd0>
c0000254:	0f b6 c0             	movzbl %al,%eax
c0000257:	ff 24 85 00 30 00 c0 	jmp    *-0x3fffd000(,%eax,4)
c000025e:	66 90                	xchg   %ax,%ax
            if(flags.left) flags.zero = 0; //If the 0 and - flags both appear, the 0 flag is ignored
c0000260:	b8 00 00 00 00       	mov    $0x0,%eax
c0000265:	80 bd d0 fd ff ff 00 	cmpb   $0x0,-0x230(%ebp)
c000026c:	0f 45 f0             	cmovne %eax,%esi
            while(f[nn] >= '0' && f[nn] <= '9')
c000026f:	8d 42 d0             	lea    -0x30(%edx),%eax
c0000272:	3c 09                	cmp    $0x9,%al
c0000274:	0f 87 36 05 00 00    	ja     c00007b0 <kprintf+0x620>
c000027a:	8d 53 02             	lea    0x2(%ebx),%edx
c000027d:	8d 76 00             	lea    0x0(%esi),%esi
c0000280:	89 d3                	mov    %edx,%ebx
c0000282:	8d 52 01             	lea    0x1(%edx),%edx
c0000285:	0f b6 03             	movzbl (%ebx),%eax
c0000288:	83 e8 30             	sub    $0x30,%eax
c000028b:	3c 09                	cmp    $0x9,%al
c000028d:	76 f1                	jbe    c0000280 <kprintf+0xf0>
                field_width = atoi(f);
c000028f:	83 ec 0c             	sub    $0xc,%esp
c0000292:	51                   	push   %ecx
c0000293:	e8 e8 0f 00 00       	call   c0001280 <atoi>
            if(f[0] == '.')
c0000298:	0f b6 13             	movzbl (%ebx),%edx
c000029b:	83 c4 10             	add    $0x10,%esp
                field_width = atoi(f);
c000029e:	89 85 b0 fd ff ff    	mov    %eax,-0x250(%ebp)
            int field_prec=-1; //default is -1
c00002a4:	c7 85 ac fd ff ff ff 	movl   $0xffffffff,-0x254(%ebp)
c00002ab:	ff ff ff 
                f++;
c00002ae:	8d 43 01             	lea    0x1(%ebx),%eax
c00002b1:	89 85 b8 fd ff ff    	mov    %eax,-0x248(%ebp)
            if(f[0] == '.')
c00002b7:	80 fa 2e             	cmp    $0x2e,%dl
c00002ba:	0f 84 80 04 00 00    	je     c0000740 <kprintf+0x5b0>
            switch(*(f++))
c00002c0:	83 ea 4c             	sub    $0x4c,%edx
c00002c3:	80 fa 2e             	cmp    $0x2e,%dl
c00002c6:	0f 87 c4 00 00 00    	ja     c0000390 <kprintf+0x200>
c00002cc:	0f b6 d2             	movzbl %dl,%edx
c00002cf:	ff 24 95 44 30 00 c0 	jmp    *-0x3fffcfbc(,%edx,4)
c00002d6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00002dd:	8d 76 00             	lea    0x0(%esi),%esi
                        if(flags.zero) return 0;
c00002e0:	89 f0                	mov    %esi,%eax
c00002e2:	84 c0                	test   %al,%al
c00002e4:	0f 85 e6 04 00 00    	jne    c00007d0 <kprintf+0x640>
                        flags.zero = 1;
c00002ea:	be 01 00 00 00       	mov    $0x1,%esi
                        flags.sign = 1;
c00002ef:	89 cb                	mov    %ecx,%ebx
                switch(*(++f))
c00002f1:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
c00002f5:	8d 4b 01             	lea    0x1(%ebx),%ecx
c00002f8:	84 d2                	test   %dl,%dl
c00002fa:	0f 85 4d ff ff ff    	jne    c000024d <kprintf+0xbd>
}
c0000300:	8d 65 f4             	lea    -0xc(%ebp),%esp
                return -1;
c0000303:	bf ff ff ff ff       	mov    $0xffffffff,%edi
}
c0000308:	5b                   	pop    %ebx
c0000309:	89 f8                	mov    %edi,%eax
c000030b:	5e                   	pop    %esi
c000030c:	5f                   	pop    %edi
c000030d:	5d                   	pop    %ebp
c000030e:	c3                   	ret    
c000030f:	90                   	nop
                        if(flags.left) return 0;
c0000310:	80 bd d0 fd ff ff 00 	cmpb   $0x0,-0x230(%ebp)
c0000317:	0f 85 b3 04 00 00    	jne    c00007d0 <kprintf+0x640>
                        flags.left = 1;
c000031d:	c6 85 d0 fd ff ff 01 	movb   $0x1,-0x230(%ebp)
                        flags.sign = 1;
c0000324:	89 cb                	mov    %ecx,%ebx
c0000326:	eb c9                	jmp    c00002f1 <kprintf+0x161>
c0000328:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000032f:	90                   	nop
                        if(flags.sign) return 0;
c0000330:	80 bd c0 fd ff ff 00 	cmpb   $0x0,-0x240(%ebp)
c0000337:	0f 85 93 04 00 00    	jne    c00007d0 <kprintf+0x640>
                        flags.sign = 1;
c000033d:	c6 85 c0 fd ff ff 01 	movb   $0x1,-0x240(%ebp)
c0000344:	89 cb                	mov    %ecx,%ebx
c0000346:	eb a9                	jmp    c00002f1 <kprintf+0x161>
c0000348:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000034f:	90                   	nop
                        if(flags.alt) return 0;
c0000350:	80 bd c8 fd ff ff 00 	cmpb   $0x0,-0x238(%ebp)
c0000357:	0f 85 73 04 00 00    	jne    c00007d0 <kprintf+0x640>
                        flags.alt = 1;
c000035d:	c6 85 c8 fd ff ff 01 	movb   $0x1,-0x238(%ebp)
                        flags.sign = 1;
c0000364:	89 cb                	mov    %ecx,%ebx
c0000366:	eb 89                	jmp    c00002f1 <kprintf+0x161>
c0000368:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000036f:	90                   	nop
                        if(flags.space) return 0;
c0000370:	80 bd bf fd ff ff 00 	cmpb   $0x0,-0x241(%ebp)
c0000377:	0f 85 53 04 00 00    	jne    c00007d0 <kprintf+0x640>
                        flags.space = 1;
c000037d:	c6 85 bf fd ff ff 01 	movb   $0x1,-0x241(%ebp)
                        flags.sign = 1;
c0000384:	89 cb                	mov    %ecx,%ebx
c0000386:	e9 66 ff ff ff       	jmp    c00002f1 <kprintf+0x161>
c000038b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c000038f:	90                   	nop
                default:
c0000390:	89 9d b8 fd ff ff    	mov    %ebx,-0x248(%ebp)
                    length_mod = DEFAULT;
c0000396:	31 c0                	xor    %eax,%eax
c0000398:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000039f:	90                   	nop
            if(field_width>511)
c00003a0:	81 bd b0 fd ff ff ff 	cmpl   $0x1ff,-0x250(%ebp)
c00003a7:	01 00 00 
c00003aa:	0f 8f 50 ff ff ff    	jg     c0000300 <kprintf+0x170>
            switch(*f)
c00003b0:	8b 8d b8 fd ff ff    	mov    -0x248(%ebp),%ecx
c00003b6:	0f b6 19             	movzbl (%ecx),%ebx
c00003b9:	8d 53 ba             	lea    -0x46(%ebx),%edx
c00003bc:	80 fa 32             	cmp    $0x32,%dl
c00003bf:	0f 87 3b ff ff ff    	ja     c0000300 <kprintf+0x170>
c00003c5:	0f b6 d2             	movzbl %dl,%edx
c00003c8:	ff 24 95 00 31 00 c0 	jmp    *-0x3fffcf00(,%edx,4)
c00003cf:	90                   	nop
                    switch(length_mod)
c00003d0:	83 f8 04             	cmp    $0x4,%eax
c00003d3:	0f 87 27 ff ff ff    	ja     c0000300 <kprintf+0x170>
                                    ui_value = (unsigned int) va_arg(valist, long long unsigned int); //TODO: implement actual longlong handling
c00003d9:	8b 85 b4 fd ff ff    	mov    -0x24c(%ebp),%eax
c00003df:	8b 10                	mov    (%eax),%edx
                                if(length_mod == LONGLONGINT)
c00003e1:	0f 84 a3 05 00 00    	je     c000098a <kprintf+0x7fa>
                                    ui_value = va_arg(valist, unsigned int);
c00003e7:	83 c0 04             	add    $0x4,%eax
c00003ea:	89 85 b4 fd ff ff    	mov    %eax,-0x24c(%ebp)
                                if(*f == 'o')
c00003f0:	80 fb 6f             	cmp    $0x6f,%bl
c00003f3:	0f 84 9f 05 00 00    	je     c0000998 <kprintf+0x808>
                                else if(*f == 'x' || *f == 'X')
c00003f9:	89 d8                	mov    %ebx,%eax
c00003fb:	83 e0 df             	and    $0xffffffdf,%eax
c00003fe:	3c 58                	cmp    $0x58,%al
c0000400:	0f 85 d1 03 00 00    	jne    c00007d7 <kprintf+0x647>
                                int len = format_uint(ui_value, val_buf, base, field_prec, cap);
c0000406:	83 ec 0c             	sub    $0xc,%esp
                                else if(*f == 'x' || *f == 'X')
c0000409:	31 c0                	xor    %eax,%eax
c000040b:	80 fb 58             	cmp    $0x58,%bl
c000040e:	0f 94 c0             	sete   %al
                                int len = format_uint(ui_value, val_buf, base, field_prec, cap);
c0000411:	50                   	push   %eax
c0000412:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
c0000418:	ff b5 ac fd ff ff    	pushl  -0x254(%ebp)
c000041e:	6a 10                	push   $0x10
c0000420:	50                   	push   %eax
c0000421:	52                   	push   %edx
c0000422:	89 85 c0 fd ff ff    	mov    %eax,-0x240(%ebp)
c0000428:	e8 73 fc ff ff       	call   c00000a0 <format_uint>
                                int lenpad = field_width - len; 
c000042d:	8b 95 b0 fd ff ff    	mov    -0x250(%ebp),%edx
                                if(flags.alt)
c0000433:	83 c4 20             	add    $0x20,%esp
                                char radix[3]="";
c0000436:	c6 85 e7 fd ff ff 00 	movb   $0x0,-0x219(%ebp)
                                int lenpad = field_width - len; 
c000043d:	29 c2                	sub    %eax,%edx
                                char radix[3]="";
c000043f:	31 c0                	xor    %eax,%eax
                                if(flags.alt)
c0000441:	80 bd c8 fd ff ff 00 	cmpb   $0x0,-0x238(%ebp)
                                char radix[3]="";
c0000448:	66 89 85 e5 fd ff ff 	mov    %ax,-0x21b(%ebp)
                                if(flags.alt)
c000044f:	0f 84 c6 03 00 00    	je     c000081b <kprintf+0x68b>
                                        radix[0] = '0';
c0000455:	c6 85 e5 fd ff ff 30 	movb   $0x30,-0x21b(%ebp)
                                        lenpad -= 2;
c000045c:	83 ea 02             	sub    $0x2,%edx
                                        radix[1] = cap ? 'X' : 'x';
c000045f:	80 fb 58             	cmp    $0x58,%bl
c0000462:	0f 85 6d 0b 00 00    	jne    c0000fd5 <kprintf+0xe45>
c0000468:	88 9d e6 fd ff ff    	mov    %bl,-0x21a(%ebp)
                                    if(flags.zero)
c000046e:	89 f0                	mov    %esi,%eax
c0000470:	84 c0                	test   %al,%al
c0000472:	0f 85 d0 08 00 00    	jne    c0000d48 <kprintf+0xbb8>
                                if(!flags.left && lenpad>0)
c0000478:	80 bd d0 fd ff ff 00 	cmpb   $0x0,-0x230(%ebp)
c000047f:	0f 85 0a 08 00 00    	jne    c0000c8f <kprintf+0xaff>
c0000485:	85 d2                	test   %edx,%edx
c0000487:	0f 8e 40 08 00 00    	jle    c0000ccd <kprintf+0xb3d>
                                        nchar += kprintn_char('0', lenpad);
c000048d:	01 d7                	add    %edx,%edi
    terminal_putcharn(&stdout, c, rpt); 
c000048f:	83 ec 04             	sub    $0x4,%esp
c0000492:	52                   	push   %edx
c0000493:	6a 20                	push   $0x20
c0000495:	68 20 b8 00 c0       	push   $0xc000b820
c000049a:	e8 21 17 00 00       	call   c0001bc0 <terminal_putcharn>
                                if(!flags.zero && radix[0])
c000049f:	83 c4 10             	add    $0x10,%esp
c00004a2:	80 bd e5 fd ff ff 00 	cmpb   $0x0,-0x21b(%ebp)
c00004a9:	0f 85 2b 08 00 00    	jne    c0000cda <kprintf+0xb4a>
    terminal_writestring(&stdout, str);
c00004af:	83 ec 08             	sub    $0x8,%esp
c00004b2:	e9 99 03 00 00       	jmp    c0000850 <kprintf+0x6c0>
                    length_mod = SIZE;
c00004b7:	b8 07 00 00 00       	mov    $0x7,%eax
                    break;
c00004bc:	e9 df fe ff ff       	jmp    c00003a0 <kprintf+0x210>
                    switch(length_mod)
c00004c1:	83 f8 04             	cmp    $0x4,%eax
c00004c4:	0f 87 36 fe ff ff    	ja     c0000300 <kprintf+0x170>
                                    i_value = (int) va_arg(valist, long long int); //TODO: implement actual longlong handling
c00004ca:	8b 8d b4 fd ff ff    	mov    -0x24c(%ebp),%ecx
c00004d0:	8b 01                	mov    (%ecx),%eax
                                if(length_mod == LONGLONGINT)
c00004d2:	0f 84 a4 04 00 00    	je     c000097c <kprintf+0x7ec>
                                    i_value = va_arg(valist, int);
c00004d8:	83 c1 04             	add    $0x4,%ecx
c00004db:	89 8d b4 fd ff ff    	mov    %ecx,-0x24c(%ebp)
                                if(i_value<0)
c00004e1:	85 c0                	test   %eax,%eax
c00004e3:	0f 88 5a 04 00 00    	js     c0000943 <kprintf+0x7b3>
                                    if(flags.sign)
c00004e9:	80 bd c0 fd ff ff 00 	cmpb   $0x0,-0x240(%ebp)
                                    ui_value = i_value;
c00004f0:	89 c2                	mov    %eax,%edx
                                    if(flags.sign)
c00004f2:	0f 85 85 03 00 00    	jne    c000087d <kprintf+0x6ed>
                                    else if(flags.space)
c00004f8:	80 bd bf fd ff ff 00 	cmpb   $0x0,-0x241(%ebp)
c00004ff:	0f 84 b3 08 00 00    	je     c0000db8 <kprintf+0xc28>
                                        sign_char = ' ';
c0000505:	b9 20 00 00 00       	mov    $0x20,%ecx
c000050a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
                                int len = format_uint(ui_value, val_buf, 10, field_prec, 0);
c0000510:	83 ec 0c             	sub    $0xc,%esp
c0000513:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
c0000519:	88 8d c8 fd ff ff    	mov    %cl,-0x238(%ebp)
c000051f:	6a 00                	push   $0x0
c0000521:	ff b5 ac fd ff ff    	pushl  -0x254(%ebp)
c0000527:	6a 0a                	push   $0xa
c0000529:	50                   	push   %eax
c000052a:	52                   	push   %edx
c000052b:	89 85 c0 fd ff ff    	mov    %eax,-0x240(%ebp)
c0000531:	e8 6a fb ff ff       	call   c00000a0 <format_uint>
                                int lenpad = field_width - len; 
c0000536:	8b 9d b0 fd ff ff    	mov    -0x250(%ebp),%ebx
                                    if(flags.zero)
c000053c:	83 c4 20             	add    $0x20,%esp
c000053f:	0f b6 8d c8 fd ff ff 	movzbl -0x238(%ebp),%ecx
                                int lenpad = field_width - len; 
c0000546:	29 c3                	sub    %eax,%ebx
                                    if(flags.zero)
c0000548:	89 f0                	mov    %esi,%eax
                                    lenpad--; //remove one char of padding to account for sign
c000054a:	83 eb 01             	sub    $0x1,%ebx
                                    if(flags.zero)
c000054d:	84 c0                	test   %al,%al
c000054f:	0f 85 aa 07 00 00    	jne    c0000cff <kprintf+0xb6f>
                                if(!flags.left && lenpad>0)
c0000555:	80 bd d0 fd ff ff 00 	cmpb   $0x0,-0x230(%ebp)
c000055c:	0f 84 ef 03 00 00    	je     c0000951 <kprintf+0x7c1>
    terminal_putchar(&stdout, c); 
c0000562:	83 ec 08             	sub    $0x8,%esp
                                    nchar += kprint_char(sign_char); //if not zero padding, write sign here
c0000565:	0f be c1             	movsbl %cl,%eax
c0000568:	83 c7 01             	add    $0x1,%edi
    terminal_putchar(&stdout, c); 
c000056b:	50                   	push   %eax
c000056c:	68 20 b8 00 c0       	push   $0xc000b820
c0000571:	e8 2a 18 00 00       	call   c0001da0 <terminal_putchar>
    terminal_writestring(&stdout, str);
c0000576:	58                   	pop    %eax
c0000577:	5a                   	pop    %edx
c0000578:	8b b5 c0 fd ff ff    	mov    -0x240(%ebp),%esi
c000057e:	56                   	push   %esi
c000057f:	68 20 b8 00 c0       	push   $0xc000b820
c0000584:	e8 67 1a 00 00       	call   c0001ff0 <terminal_writestring>
    return strlen(str);
c0000589:	89 34 24             	mov    %esi,(%esp)
c000058c:	e8 6f 0c 00 00       	call   c0001200 <strlen>
                                nchar += kprint(val_buf);
c0000591:	83 c4 10             	add    $0x10,%esp
c0000594:	01 c7                	add    %eax,%edi
                                if(flags.left && lenpad>0)
c0000596:	85 db                	test   %ebx,%ebx
c0000598:	7e 56                	jle    c00005f0 <kprintf+0x460>
    terminal_putcharn(&stdout, c, rpt); 
c000059a:	83 ec 04             	sub    $0x4,%esp
c000059d:	e9 86 01 00 00       	jmp    c0000728 <kprintf+0x598>
                        float f_value = (float) va_arg(valist, double);
c00005a2:	8b 8d b4 fd ff ff    	mov    -0x24c(%ebp),%ecx
                        if(f_value==0 && field_prec==0)
c00005a8:	ba 00 00 00 00       	mov    $0x0,%edx
                        float f_value = (float) va_arg(valist, double);
c00005ad:	89 c8                	mov    %ecx,%eax
c00005af:	83 c1 08             	add    $0x8,%ecx
c00005b2:	dd 00                	fldl   (%eax)
c00005b4:	89 8d b4 fd ff ff    	mov    %ecx,-0x24c(%ebp)
c00005ba:	d9 9d c8 fd ff ff    	fstps  -0x238(%ebp)
c00005c0:	d9 85 c8 fd ff ff    	flds   -0x238(%ebp)
                        if(f_value==0 && field_prec==0)
c00005c6:	d9 ee                	fldz   
c00005c8:	df e9                	fucomip %st(1),%st
c00005ca:	dd d8                	fstp   %st(0)
c00005cc:	0f 9b c0             	setnp  %al
c00005cf:	0f 45 c2             	cmovne %edx,%eax
c00005d2:	84 c0                	test   %al,%al
c00005d4:	0f 84 22 04 00 00    	je     c00009fc <kprintf+0x86c>
c00005da:	8b 85 ac fd ff ff    	mov    -0x254(%ebp),%eax
c00005e0:	85 c0                	test   %eax,%eax
c00005e2:	0f 85 14 04 00 00    	jne    c00009fc <kprintf+0x86c>
c00005e8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00005ef:	90                   	nop
            f++;
c00005f0:	8b 9d b8 fd ff ff    	mov    -0x248(%ebp),%ebx
c00005f6:	83 c3 01             	add    $0x1,%ebx
c00005f9:	e9 d5 fb ff ff       	jmp    c00001d3 <kprintf+0x43>
                    if(*f == 'h')
c00005fe:	80 7b 01 68          	cmpb   $0x68,0x1(%ebx)
                        length_mod = SHORTINT;
c0000602:	b8 02 00 00 00       	mov    $0x2,%eax
                    if(*f == 'h')
c0000607:	0f 85 93 fd ff ff    	jne    c00003a0 <kprintf+0x210>
                        f++;
c000060d:	8d 43 02             	lea    0x2(%ebx),%eax
c0000610:	89 85 b8 fd ff ff    	mov    %eax,-0x248(%ebp)
                        length_mod = CHARINT;
c0000616:	b8 01 00 00 00       	mov    $0x1,%eax
c000061b:	e9 80 fd ff ff       	jmp    c00003a0 <kprintf+0x210>
                    if(*f == 'l')
c0000620:	80 7b 01 6c          	cmpb   $0x6c,0x1(%ebx)
                        length_mod = LONGINT;
c0000624:	b8 03 00 00 00       	mov    $0x3,%eax
                    if(*f == 'l')
c0000629:	0f 85 71 fd ff ff    	jne    c00003a0 <kprintf+0x210>
                        f++;
c000062f:	8d 43 02             	lea    0x2(%ebx),%eax
c0000632:	89 85 b8 fd ff ff    	mov    %eax,-0x248(%ebp)
                        length_mod = LONGLONGINT;
c0000638:	b8 04 00 00 00       	mov    $0x4,%eax
c000063d:	e9 5e fd ff ff       	jmp    c00003a0 <kprintf+0x210>
                    length_mod = PTRDIFF;
c0000642:	b8 08 00 00 00       	mov    $0x8,%eax
                    break;
c0000647:	e9 54 fd ff ff       	jmp    c00003a0 <kprintf+0x210>
                        char* str = va_arg(valist, char*);
c000064c:	8b 85 b4 fd ff ff    	mov    -0x24c(%ebp),%eax
                        int len = strlen(str);
c0000652:	83 ec 0c             	sub    $0xc,%esp
                        char* str = va_arg(valist, char*);
c0000655:	8d 70 04             	lea    0x4(%eax),%esi
c0000658:	89 b5 c8 fd ff ff    	mov    %esi,-0x238(%ebp)
c000065e:	8b 30                	mov    (%eax),%esi
                        int len = strlen(str);
c0000660:	56                   	push   %esi
c0000661:	e8 9a 0b 00 00       	call   c0001200 <strlen>
                        if(field_prec > 0 && field_prec < len)
c0000666:	8b 8d ac fd ff ff    	mov    -0x254(%ebp),%ecx
c000066c:	83 c4 10             	add    $0x10,%esp
                        int len = strlen(str);
c000066f:	89 c3                	mov    %eax,%ebx
                        if(field_prec > 0 && field_prec < len)
c0000671:	85 c9                	test   %ecx,%ecx
c0000673:	7e 08                	jle    c000067d <kprintf+0x4ed>
c0000675:	39 c1                	cmp    %eax,%ecx
c0000677:	7d 04                	jge    c000067d <kprintf+0x4ed>
                        nchar += kprintn(str,len);
c0000679:	89 cb                	mov    %ecx,%ebx
c000067b:	89 c8                	mov    %ecx,%eax
                        int lenpad = field_width - len; 
c000067d:	8b 95 b0 fd ff ff    	mov    -0x250(%ebp),%edx
c0000683:	29 c2                	sub    %eax,%edx
                        if(lenpad>0 && !flags.left)    
c0000685:	85 d2                	test   %edx,%edx
c0000687:	0f 8e 7d 02 00 00    	jle    c000090a <kprintf+0x77a>
c000068d:	80 bd d0 fd ff ff 00 	cmpb   $0x0,-0x230(%ebp)
c0000694:	0f 84 17 02 00 00    	je     c00008b1 <kprintf+0x721>
    terminal_write(&stdout, str, len);
c000069a:	83 ec 04             	sub    $0x4,%esp
c000069d:	89 95 d0 fd ff ff    	mov    %edx,-0x230(%ebp)
c00006a3:	53                   	push   %ebx
c00006a4:	56                   	push   %esi
c00006a5:	68 20 b8 00 c0       	push   $0xc000b820
c00006aa:	e8 e1 17 00 00       	call   c0001e90 <terminal_write>
    terminal_putcharn(&stdout, c, rpt); 
c00006af:	8b 95 d0 fd ff ff    	mov    -0x230(%ebp),%edx
c00006b5:	83 c4 0c             	add    $0xc,%esp
c00006b8:	52                   	push   %edx
c00006b9:	6a 20                	push   $0x20
c00006bb:	68 20 b8 00 c0       	push   $0xc000b820
c00006c0:	e8 fb 14 00 00       	call   c0001bc0 <terminal_putcharn>
                        char* str = va_arg(valist, char*);
c00006c5:	8b 85 c8 fd ff ff    	mov    -0x238(%ebp),%eax
                            nchar += kprintn_char(' ', lenpad);
c00006cb:	03 bd b0 fd ff ff    	add    -0x250(%ebp),%edi
c00006d1:	83 c4 10             	add    $0x10,%esp
                        char* str = va_arg(valist, char*);
c00006d4:	89 85 b4 fd ff ff    	mov    %eax,-0x24c(%ebp)
c00006da:	e9 11 ff ff ff       	jmp    c00005f0 <kprintf+0x460>
                        char c = (char) va_arg(valist, int);
c00006df:	8b b5 b4 fd ff ff    	mov    -0x24c(%ebp),%esi
c00006e5:	89 f0                	mov    %esi,%eax
c00006e7:	83 c6 04             	add    $0x4,%esi
c00006ea:	89 b5 b4 fd ff ff    	mov    %esi,-0x24c(%ebp)
                        nchar += kprint_char(c);
c00006f0:	0f be 30             	movsbl (%eax),%esi
                        if(field_width>1 && !flags.left)    
c00006f3:	8b 85 b0 fd ff ff    	mov    -0x250(%ebp),%eax
c00006f9:	83 f8 01             	cmp    $0x1,%eax
c00006fc:	0f 8e 39 02 00 00    	jle    c000093b <kprintf+0x7ab>
                            nchar += kprintn_char(' ', field_width-1);
c0000702:	89 c3                	mov    %eax,%ebx
c0000704:	83 eb 01             	sub    $0x1,%ebx
                        if(field_width>1 && !flags.left)    
c0000707:	80 bd d0 fd ff ff 00 	cmpb   $0x0,-0x230(%ebp)
c000070e:	0f 84 73 01 00 00    	je     c0000887 <kprintf+0x6f7>
    terminal_putchar(&stdout, c); 
c0000714:	83 ec 08             	sub    $0x8,%esp
                        nchar += kprint_char(c);
c0000717:	83 c7 01             	add    $0x1,%edi
    terminal_putchar(&stdout, c); 
c000071a:	56                   	push   %esi
c000071b:	68 20 b8 00 c0       	push   $0xc000b820
c0000720:	e8 7b 16 00 00       	call   c0001da0 <terminal_putchar>
    terminal_putcharn(&stdout, c, rpt); 
c0000725:	83 c4 0c             	add    $0xc,%esp
c0000728:	53                   	push   %ebx
                            nchar += kprintn_char(' ', field_width-1);
c0000729:	01 df                	add    %ebx,%edi
    terminal_putcharn(&stdout, c, rpt); 
c000072b:	6a 20                	push   $0x20
c000072d:	68 20 b8 00 c0       	push   $0xc000b820
c0000732:	e8 89 14 00 00       	call   c0001bc0 <terminal_putcharn>
                            nchar += kprintn_char(' ', field_width-1);
c0000737:	83 c4 10             	add    $0x10,%esp
c000073a:	e9 b1 fe ff ff       	jmp    c00005f0 <kprintf+0x460>
c000073f:	90                   	nop
                while(f[nn] >= '0' && f[nn] <= '9')
c0000740:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
c0000744:	8d 4b 02             	lea    0x2(%ebx),%ecx
c0000747:	8d 42 d0             	lea    -0x30(%edx),%eax
c000074a:	3c 09                	cmp    $0x9,%al
c000074c:	0f 87 41 07 00 00    	ja     c0000e93 <kprintf+0xd03>
c0000752:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0000759:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0000760:	89 cb                	mov    %ecx,%ebx
c0000762:	8d 49 01             	lea    0x1(%ecx),%ecx
c0000765:	0f b6 03             	movzbl (%ebx),%eax
c0000768:	83 e8 30             	sub    $0x30,%eax
c000076b:	3c 09                	cmp    $0x9,%al
c000076d:	76 f1                	jbe    c0000760 <kprintf+0x5d0>
                    field_prec = atoi(f);
c000076f:	83 ec 0c             	sub    $0xc,%esp
c0000772:	ff b5 b8 fd ff ff    	pushl  -0x248(%ebp)
c0000778:	89 8d a0 fd ff ff    	mov    %ecx,-0x260(%ebp)
c000077e:	e8 fd 0a 00 00       	call   c0001280 <atoi>
                    if(field_prec<0) field_prec = 0;
c0000783:	83 c4 10             	add    $0x10,%esp
c0000786:	ba 00 00 00 00       	mov    $0x0,%edx
            switch(*(f++))
c000078b:	8b 8d a0 fd ff ff    	mov    -0x260(%ebp),%ecx
c0000791:	85 c0                	test   %eax,%eax
c0000793:	0f 49 d0             	cmovns %eax,%edx
c0000796:	89 8d b8 fd ff ff    	mov    %ecx,-0x248(%ebp)
c000079c:	89 95 ac fd ff ff    	mov    %edx,-0x254(%ebp)
c00007a2:	0f b6 13             	movzbl (%ebx),%edx
c00007a5:	e9 16 fb ff ff       	jmp    c00002c0 <kprintf+0x130>
c00007aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
            int field_width=0;
c00007b0:	c7 85 b0 fd ff ff 00 	movl   $0x0,-0x250(%ebp)
c00007b7:	00 00 00 
            while(f[nn] >= '0' && f[nn] <= '9')
c00007ba:	89 cb                	mov    %ecx,%ebx
c00007bc:	e9 e3 fa ff ff       	jmp    c00002a4 <kprintf+0x114>
c00007c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00007c8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00007cf:	90                   	nop
                        if(flags.alt) return 0;
c00007d0:	31 ff                	xor    %edi,%edi
c00007d2:	e9 03 fa ff ff       	jmp    c00001da <kprintf+0x4a>
                                else if(*f == 'p')
c00007d7:	80 fb 70             	cmp    $0x70,%bl
c00007da:	0f 84 e9 06 00 00    	je     c0000ec9 <kprintf+0xd39>
                                int len = format_uint(ui_value, val_buf, base, field_prec, cap);
c00007e0:	83 ec 0c             	sub    $0xc,%esp
c00007e3:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
c00007e9:	6a 00                	push   $0x0
c00007eb:	ff b5 ac fd ff ff    	pushl  -0x254(%ebp)
c00007f1:	6a 0a                	push   $0xa
c00007f3:	50                   	push   %eax
c00007f4:	52                   	push   %edx
c00007f5:	89 85 c0 fd ff ff    	mov    %eax,-0x240(%ebp)
c00007fb:	e8 a0 f8 ff ff       	call   c00000a0 <format_uint>
                                int lenpad = field_width - len; 
c0000800:	8b 95 b0 fd ff ff    	mov    -0x250(%ebp),%edx
                                char radix[3]="";
c0000806:	c6 85 e7 fd ff ff 00 	movb   $0x0,-0x219(%ebp)
c000080d:	83 c4 20             	add    $0x20,%esp
                                int lenpad = field_width - len; 
c0000810:	29 c2                	sub    %eax,%edx
                                char radix[3]="";
c0000812:	31 c0                	xor    %eax,%eax
c0000814:	66 89 85 e5 fd ff ff 	mov    %ax,-0x21b(%ebp)
                                if(!flags.left && lenpad>0)
c000081b:	80 bd d0 fd ff ff 00 	cmpb   $0x0,-0x230(%ebp)
c0000822:	0f 85 06 04 00 00    	jne    c0000c2e <kprintf+0xa9e>
c0000828:	85 d2                	test   %edx,%edx
c000082a:	0f 8e 93 04 00 00    	jle    c0000cc3 <kprintf+0xb33>
                                    if(flags.zero)
c0000830:	89 f0                	mov    %esi,%eax
                                        nchar += kprintn_char('0', lenpad);
c0000832:	01 d7                	add    %edx,%edi
                                    if(flags.zero)
c0000834:	84 c0                	test   %al,%al
c0000836:	0f 84 53 fc ff ff    	je     c000048f <kprintf+0x2ff>
    terminal_putcharn(&stdout, c, rpt); 
c000083c:	83 ec 04             	sub    $0x4,%esp
c000083f:	52                   	push   %edx
c0000840:	6a 30                	push   $0x30
c0000842:	68 20 b8 00 c0       	push   $0xc000b820
c0000847:	e8 74 13 00 00       	call   c0001bc0 <terminal_putcharn>
    terminal_writestring(&stdout, str);
c000084c:	58                   	pop    %eax
c000084d:	5a                   	pop    %edx
c000084e:	66 90                	xchg   %ax,%ax
c0000850:	8b b5 c0 fd ff ff    	mov    -0x240(%ebp),%esi
c0000856:	56                   	push   %esi
c0000857:	68 20 b8 00 c0       	push   $0xc000b820
c000085c:	e8 8f 17 00 00       	call   c0001ff0 <terminal_writestring>
    return strlen(str);
c0000861:	89 34 24             	mov    %esi,(%esp)
c0000864:	e8 97 09 00 00       	call   c0001200 <strlen>
                                nchar += kprint(val_buf);
c0000869:	83 c4 10             	add    $0x10,%esp
c000086c:	01 c7                	add    %eax,%edi
                                if(flags.left && lenpad>0)
c000086e:	e9 7d fd ff ff       	jmp    c00005f0 <kprintf+0x460>
                    length_mod = LONGDOUBLE;
c0000873:	b8 05 00 00 00       	mov    $0x5,%eax
c0000878:	e9 23 fb ff ff       	jmp    c00003a0 <kprintf+0x210>
                                        sign_char = '+';
c000087d:	b9 2b 00 00 00       	mov    $0x2b,%ecx
c0000882:	e9 89 fc ff ff       	jmp    c0000510 <kprintf+0x380>
    terminal_putcharn(&stdout, c, rpt); 
c0000887:	83 ec 04             	sub    $0x4,%esp
                            nchar += kprintn_char(' ', field_width-1);
c000088a:	01 df                	add    %ebx,%edi
    terminal_putcharn(&stdout, c, rpt); 
c000088c:	53                   	push   %ebx
c000088d:	6a 20                	push   $0x20
c000088f:	68 20 b8 00 c0       	push   $0xc000b820
c0000894:	e8 27 13 00 00       	call   c0001bc0 <terminal_putcharn>
    terminal_putchar(&stdout, c); 
c0000899:	58                   	pop    %eax
c000089a:	5a                   	pop    %edx
c000089b:	56                   	push   %esi
                        nchar += kprint_char(c);
c000089c:	83 c7 01             	add    $0x1,%edi
    terminal_putchar(&stdout, c); 
c000089f:	68 20 b8 00 c0       	push   $0xc000b820
c00008a4:	e8 f7 14 00 00       	call   c0001da0 <terminal_putchar>
                        if(field_width>1 && flags.left)    
c00008a9:	83 c4 10             	add    $0x10,%esp
c00008ac:	e9 3f fd ff ff       	jmp    c00005f0 <kprintf+0x460>
    terminal_putcharn(&stdout, c, rpt); 
c00008b1:	83 ec 04             	sub    $0x4,%esp
c00008b4:	89 85 c0 fd ff ff    	mov    %eax,-0x240(%ebp)
c00008ba:	52                   	push   %edx
c00008bb:	6a 20                	push   $0x20
c00008bd:	68 20 b8 00 c0       	push   $0xc000b820
c00008c2:	89 95 d0 fd ff ff    	mov    %edx,-0x230(%ebp)
c00008c8:	e8 f3 12 00 00       	call   c0001bc0 <terminal_putcharn>
    terminal_write(&stdout, str, len);
c00008cd:	83 c4 0c             	add    $0xc,%esp
                            nchar += kprintn_char(' ', lenpad);
c00008d0:	8b 95 d0 fd ff ff    	mov    -0x230(%ebp),%edx
    terminal_write(&stdout, str, len);
c00008d6:	53                   	push   %ebx
c00008d7:	56                   	push   %esi
                            nchar += kprintn_char(' ', lenpad);
c00008d8:	01 d7                	add    %edx,%edi
    terminal_write(&stdout, str, len);
c00008da:	68 20 b8 00 c0       	push   $0xc000b820
c00008df:	e8 ac 15 00 00       	call   c0001e90 <terminal_write>
                        nchar += kprintn(str,len);
c00008e4:	8b 85 c0 fd ff ff    	mov    -0x240(%ebp),%eax
c00008ea:	83 c4 10             	add    $0x10,%esp
c00008ed:	01 c7                	add    %eax,%edi
                        char* str = va_arg(valist, char*);
c00008ef:	8b 85 c8 fd ff ff    	mov    -0x238(%ebp),%eax
c00008f5:	89 85 b4 fd ff ff    	mov    %eax,-0x24c(%ebp)
c00008fb:	e9 f0 fc ff ff       	jmp    c00005f0 <kprintf+0x460>
            int field_prec=-1; //default is -1
c0000900:	b8 06 00 00 00       	mov    $0x6,%eax
c0000905:	e9 96 fa ff ff       	jmp    c00003a0 <kprintf+0x210>
    terminal_write(&stdout, str, len);
c000090a:	83 ec 04             	sub    $0x4,%esp
c000090d:	89 85 d0 fd ff ff    	mov    %eax,-0x230(%ebp)
c0000913:	53                   	push   %ebx
c0000914:	56                   	push   %esi
c0000915:	68 20 b8 00 c0       	push   $0xc000b820
c000091a:	e8 71 15 00 00       	call   c0001e90 <terminal_write>
                        nchar += kprintn(str,len);
c000091f:	8b 85 d0 fd ff ff    	mov    -0x230(%ebp),%eax
c0000925:	83 c4 10             	add    $0x10,%esp
c0000928:	01 c7                	add    %eax,%edi
                        char* str = va_arg(valist, char*);
c000092a:	8b 85 c8 fd ff ff    	mov    -0x238(%ebp),%eax
c0000930:	89 85 b4 fd ff ff    	mov    %eax,-0x24c(%ebp)
c0000936:	e9 b5 fc ff ff       	jmp    c00005f0 <kprintf+0x460>
    terminal_putchar(&stdout, c); 
c000093b:	83 ec 08             	sub    $0x8,%esp
c000093e:	e9 58 ff ff ff       	jmp    c000089b <kprintf+0x70b>
                                    ui_value = -i_value;
c0000943:	f7 d8                	neg    %eax
                                    sign_char = '-';
c0000945:	b9 2d 00 00 00       	mov    $0x2d,%ecx
                                    ui_value = -i_value;
c000094a:	89 c2                	mov    %eax,%edx
                                    sign_char = '-';
c000094c:	e9 bf fb ff ff       	jmp    c0000510 <kprintf+0x380>
                                if(!flags.left && lenpad>0)
c0000951:	85 db                	test   %ebx,%ebx
c0000953:	0f 8f 38 04 00 00    	jg     c0000d91 <kprintf+0xc01>
                                if(!flags.zero && sign_char)
c0000959:	84 c9                	test   %cl,%cl
c000095b:	0f 84 4e fb ff ff    	je     c00004af <kprintf+0x31f>
    terminal_putchar(&stdout, c); 
c0000961:	83 ec 08             	sub    $0x8,%esp
                                    nchar += kprint_char(sign_char); //if not zero padding, write sign here
c0000964:	0f be c1             	movsbl %cl,%eax
c0000967:	83 c7 01             	add    $0x1,%edi
    terminal_putchar(&stdout, c); 
c000096a:	50                   	push   %eax
c000096b:	68 20 b8 00 c0       	push   $0xc000b820
c0000970:	e8 2b 14 00 00       	call   c0001da0 <terminal_putchar>
    terminal_writestring(&stdout, str);
c0000975:	59                   	pop    %ecx
c0000976:	5b                   	pop    %ebx
c0000977:	e9 d4 fe ff ff       	jmp    c0000850 <kprintf+0x6c0>
                                    i_value = (int) va_arg(valist, long long int); //TODO: implement actual longlong handling
c000097c:	83 c1 08             	add    $0x8,%ecx
c000097f:	89 8d b4 fd ff ff    	mov    %ecx,-0x24c(%ebp)
c0000985:	e9 57 fb ff ff       	jmp    c00004e1 <kprintf+0x351>
                                    ui_value = (unsigned int) va_arg(valist, long long unsigned int); //TODO: implement actual longlong handling
c000098a:	83 c0 08             	add    $0x8,%eax
c000098d:	89 85 b4 fd ff ff    	mov    %eax,-0x24c(%ebp)
c0000993:	e9 58 fa ff ff       	jmp    c00003f0 <kprintf+0x260>
                                int len = format_uint(ui_value, val_buf, base, field_prec, cap);
c0000998:	83 ec 0c             	sub    $0xc,%esp
c000099b:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
c00009a1:	6a 00                	push   $0x0
c00009a3:	ff b5 ac fd ff ff    	pushl  -0x254(%ebp)
c00009a9:	6a 08                	push   $0x8
c00009ab:	50                   	push   %eax
c00009ac:	52                   	push   %edx
c00009ad:	89 85 c0 fd ff ff    	mov    %eax,-0x240(%ebp)
c00009b3:	e8 e8 f6 ff ff       	call   c00000a0 <format_uint>
                                int lenpad = field_width - len; 
c00009b8:	8b 95 b0 fd ff ff    	mov    -0x250(%ebp),%edx
                                if(flags.alt)
c00009be:	83 c4 20             	add    $0x20,%esp
                                char radix[3]="";
c00009c1:	c6 85 e7 fd ff ff 00 	movb   $0x0,-0x219(%ebp)
                                int lenpad = field_width - len; 
c00009c8:	29 c2                	sub    %eax,%edx
                                char radix[3]="";
c00009ca:	31 c0                	xor    %eax,%eax
                                if(flags.alt)
c00009cc:	80 bd c8 fd ff ff 00 	cmpb   $0x0,-0x238(%ebp)
                                char radix[3]="";
c00009d3:	66 89 85 e5 fd ff ff 	mov    %ax,-0x21b(%ebp)
                                if(flags.alt)
c00009da:	0f 84 3b fe ff ff    	je     c000081b <kprintf+0x68b>
                                    else if(base==8 && val_buf[0] != '0')
c00009e0:	80 bd e8 fd ff ff 30 	cmpb   $0x30,-0x218(%ebp)
c00009e7:	0f 84 81 fa ff ff    	je     c000046e <kprintf+0x2de>
                                        radix[0] = '0';
c00009ed:	c6 85 e5 fd ff ff 30 	movb   $0x30,-0x21b(%ebp)
                                        lenpad -= 1;
c00009f4:	83 ea 01             	sub    $0x1,%edx
                                        radix[1] = 0;
c00009f7:	e9 72 fa ff ff       	jmp    c000046e <kprintf+0x2de>
                        if(field_prec<0) field_prec = 6;  //default is prec = 6
c00009fc:	8b 8d ac fd ff ff    	mov    -0x254(%ebp),%ecx
                        if(f_value<0)
c0000a02:	d9 85 c8 fd ff ff    	flds   -0x238(%ebp)
c0000a08:	d9 ee                	fldz   
                        if(field_prec<0) field_prec = 6;  //default is prec = 6
c0000a0a:	b8 06 00 00 00       	mov    $0x6,%eax
                        if(!flags.left && lenpad>0)
c0000a0f:	0f b6 9d d0 fd ff ff 	movzbl -0x230(%ebp),%ebx
                        if(field_prec<0) field_prec = 6;  //default is prec = 6
c0000a16:	83 f9 ff             	cmp    $0xffffffff,%ecx
c0000a19:	0f 45 c1             	cmovne %ecx,%eax
                        if(!flags.left && lenpad>0)
c0000a1c:	83 f3 01             	xor    $0x1,%ebx
                        if(f_value<0)
c0000a1f:	df f1                	fcomip %st(1),%st
                        if(field_prec<0) field_prec = 6;  //default is prec = 6
c0000a21:	89 85 ac fd ff ff    	mov    %eax,-0x254(%ebp)
                        if(f_value<0)
c0000a27:	0f 87 e2 04 00 00    	ja     c0000f0f <kprintf+0xd7f>
c0000a2d:	dd d8                	fstp   %st(0)
                            ui_part = (unsigned int) f_value;
c0000a2f:	d9 bd d6 fd ff ff    	fnstcw -0x22a(%ebp)
c0000a35:	d9 85 c8 fd ff ff    	flds   -0x238(%ebp)
c0000a3b:	0f b7 85 d6 fd ff ff 	movzwl -0x22a(%ebp),%eax
c0000a42:	80 cc 0c             	or     $0xc,%ah
                            if(flags.sign)
c0000a45:	80 bd c0 fd ff ff 00 	cmpb   $0x0,-0x240(%ebp)
                            ui_part = (unsigned int) f_value;
c0000a4c:	66 89 85 d4 fd ff ff 	mov    %ax,-0x22c(%ebp)
c0000a53:	d9 ad d4 fd ff ff    	fldcw  -0x22c(%ebp)
c0000a59:	df bd a0 fd ff ff    	fistpll -0x260(%ebp)
c0000a5f:	d9 ad d6 fd ff ff    	fldcw  -0x22a(%ebp)
c0000a65:	8b 85 a0 fd ff ff    	mov    -0x260(%ebp),%eax
                            if(flags.sign)
c0000a6b:	0f 85 e1 04 00 00    	jne    c0000f52 <kprintf+0xdc2>
                            else if(flags.space)
c0000a71:	80 bd bf fd ff ff 00 	cmpb   $0x0,-0x241(%ebp)
c0000a78:	0f 84 92 03 00 00    	je     c0000e10 <kprintf+0xc80>
                                sign_char = ' ';
c0000a7e:	c6 85 ab fd ff ff 20 	movb   $0x20,-0x255(%ebp)
                        int int_len = format_uint(ui_part,val_buf,10,-1,0);
c0000a85:	83 ec 0c             	sub    $0xc,%esp
c0000a88:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
c0000a8e:	6a 00                	push   $0x0
c0000a90:	6a ff                	push   $0xffffffff
c0000a92:	6a 0a                	push   $0xa
c0000a94:	50                   	push   %eax
c0000a95:	ff b5 a0 fd ff ff    	pushl  -0x260(%ebp)
c0000a9b:	89 85 c0 fd ff ff    	mov    %eax,-0x240(%ebp)
c0000aa1:	e8 fa f5 ff ff       	call   c00000a0 <format_uint>
                        int f_len = int_len + 1 + field_prec;
c0000aa6:	8b 8d ac fd ff ff    	mov    -0x254(%ebp),%ecx
                        int lenpad = field_width - f_len; 
c0000aac:	8b 95 b0 fd ff ff    	mov    -0x250(%ebp),%edx
                        if(!flags.left && lenpad>0)
c0000ab2:	83 c4 20             	add    $0x20,%esp
                        int f_len = int_len + 1 + field_prec;
c0000ab5:	8d 44 01 01          	lea    0x1(%ecx,%eax,1),%eax
                        int lenpad = field_width - f_len; 
c0000ab9:	29 c2                	sub    %eax,%edx
                            lenpad--; //remove one char of padding to account for sign
c0000abb:	8d 42 ff             	lea    -0x1(%edx),%eax
                        if(!flags.left && lenpad>0)
c0000abe:	85 c0                	test   %eax,%eax
                            lenpad--; //remove one char of padding to account for sign
c0000ac0:	89 85 b0 fd ff ff    	mov    %eax,-0x250(%ebp)
                        if(!flags.left && lenpad>0)
c0000ac6:	0f 9f 85 bf fd ff ff 	setg   -0x241(%ebp)
c0000acd:	0f b6 85 bf fd ff ff 	movzbl -0x241(%ebp),%eax
c0000ad4:	21 c3                	and    %eax,%ebx
                            if(flags.zero)
c0000ad6:	89 f0                	mov    %esi,%eax
c0000ad8:	84 c0                	test   %al,%al
c0000ada:	0f 85 7e 04 00 00    	jne    c0000f5e <kprintf+0xdce>
                        if(!flags.left && lenpad>0)
c0000ae0:	84 db                	test   %bl,%bl
c0000ae2:	0f 85 a4 04 00 00    	jne    c0000f8c <kprintf+0xdfc>
                            nchar += kprint_char(sign_char); //if not zero padding, write sign here
c0000ae8:	0f be 85 ab fd ff ff 	movsbl -0x255(%ebp),%eax
    terminal_putchar(&stdout, c); 
c0000aef:	83 ec 08             	sub    $0x8,%esp
                            nchar += kprint_char(sign_char); //if not zero padding, write sign here
c0000af2:	83 c7 01             	add    $0x1,%edi
    terminal_putchar(&stdout, c); 
c0000af5:	50                   	push   %eax
c0000af6:	68 20 b8 00 c0       	push   $0xc000b820
c0000afb:	e8 a0 12 00 00       	call   c0001da0 <terminal_putchar>
                            nchar += kprint_char(sign_char); //if not zero padding, write sign here
c0000b00:	83 c4 10             	add    $0x10,%esp
    terminal_writestring(&stdout, str);
c0000b03:	8b b5 c0 fd ff ff    	mov    -0x240(%ebp),%esi
c0000b09:	83 ec 08             	sub    $0x8,%esp
c0000b0c:	56                   	push   %esi
c0000b0d:	68 20 b8 00 c0       	push   $0xc000b820
c0000b12:	e8 d9 14 00 00       	call   c0001ff0 <terminal_writestring>
    return strlen(str);
c0000b17:	89 34 24             	mov    %esi,(%esp)
c0000b1a:	e8 e1 06 00 00       	call   c0001200 <strlen>
    terminal_putchar(&stdout, c); 
c0000b1f:	5b                   	pop    %ebx
c0000b20:	5e                   	pop    %esi
c0000b21:	6a 2e                	push   $0x2e
c0000b23:	68 20 b8 00 c0       	push   $0xc000b820
                        nchar += kprint(val_buf);
c0000b28:	01 c7                	add    %eax,%edi
                        nchar += kprint_char('.');
c0000b2a:	83 c7 01             	add    $0x1,%edi
    terminal_putchar(&stdout, c); 
c0000b2d:	e8 6e 12 00 00       	call   c0001da0 <terminal_putchar>
                        float frac = f_value<0 ? -f_value - ui_part : f_value - ui_part;
c0000b32:	83 c4 10             	add    $0x10,%esp
c0000b35:	d9 85 c8 fd ff ff    	flds   -0x238(%ebp)
c0000b3b:	d9 ee                	fldz   
c0000b3d:	df f1                	fcomip %st(1),%st
c0000b3f:	0f 87 5f 03 00 00    	ja     c0000ea4 <kprintf+0xd14>
c0000b45:	dd d8                	fstp   %st(0)
c0000b47:	c7 85 c4 fd ff ff 00 	movl   $0x0,-0x23c(%ebp)
c0000b4e:	00 00 00 
c0000b51:	8b 85 a0 fd ff ff    	mov    -0x260(%ebp),%eax
c0000b57:	89 85 c0 fd ff ff    	mov    %eax,-0x240(%ebp)
c0000b5d:	df ad c0 fd ff ff    	fildll -0x240(%ebp)
c0000b63:	d8 ad c8 fd ff ff    	fsubrs -0x238(%ebp)
                        for(int nn=0;nn<field_prec; nn++)
c0000b69:	8b 8d ac fd ff ff    	mov    -0x254(%ebp),%ecx
c0000b6f:	8b b5 ac fd ff ff    	mov    -0x254(%ebp),%esi
c0000b75:	31 db                	xor    %ebx,%ebx
c0000b77:	85 c9                	test   %ecx,%ecx
c0000b79:	74 77                	je     c0000bf2 <kprintf+0xa62>
c0000b7b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c0000b7f:	90                   	nop
                            d = (int) frac;
c0000b80:	d9 bd d6 fd ff ff    	fnstcw -0x22a(%ebp)
                            frac *= 10.;
c0000b86:	d8 0d 1c 35 00 c0    	fmuls  0xc000351c
    terminal_putchar(&stdout, c); 
c0000b8c:	83 ec 08             	sub    $0x8,%esp
                        for(int nn=0;nn<field_prec; nn++)
c0000b8f:	83 c3 01             	add    $0x1,%ebx
                            d = (int) frac;
c0000b92:	0f b7 85 d6 fd ff ff 	movzwl -0x22a(%ebp),%eax
c0000b99:	80 cc 0c             	or     $0xc,%ah
c0000b9c:	66 89 85 d4 fd ff ff 	mov    %ax,-0x22c(%ebp)
c0000ba3:	d9 ad d4 fd ff ff    	fldcw  -0x22c(%ebp)
c0000ba9:	db 95 c8 fd ff ff    	fistl  -0x238(%ebp)
c0000baf:	d9 ad d6 fd ff ff    	fldcw  -0x22a(%ebp)
                            nchar += kprint_char('0' + d);
c0000bb5:	0f b6 85 c8 fd ff ff 	movzbl -0x238(%ebp),%eax
                            frac -= d;
c0000bbc:	db 85 c8 fd ff ff    	fildl  -0x238(%ebp)
                            nchar += kprint_char('0' + d);
c0000bc2:	83 c0 30             	add    $0x30,%eax
c0000bc5:	0f be c0             	movsbl %al,%eax
                            frac -= d;
c0000bc8:	de e9                	fsubrp %st,%st(1)
    terminal_putchar(&stdout, c); 
c0000bca:	50                   	push   %eax
c0000bcb:	68 20 b8 00 c0       	push   $0xc000b820
                            frac -= d;
c0000bd0:	d9 9d c0 fd ff ff    	fstps  -0x240(%ebp)
    terminal_putchar(&stdout, c); 
c0000bd6:	e8 c5 11 00 00       	call   c0001da0 <terminal_putchar>
                        for(int nn=0;nn<field_prec; nn++)
c0000bdb:	83 c4 10             	add    $0x10,%esp
c0000bde:	39 de                	cmp    %ebx,%esi
c0000be0:	d9 85 c0 fd ff ff    	flds   -0x240(%ebp)
c0000be6:	75 98                	jne    c0000b80 <kprintf+0x9f0>
c0000be8:	dd d8                	fstp   %st(0)
                            nchar += kprint_char('0' + d);
c0000bea:	03 bd ac fd ff ff    	add    -0x254(%ebp),%edi
c0000bf0:	eb 02                	jmp    c0000bf4 <kprintf+0xa64>
c0000bf2:	dd d8                	fstp   %st(0)
                        if(flags.left && lenpad>0)
c0000bf4:	80 bd d0 fd ff ff 00 	cmpb   $0x0,-0x230(%ebp)
c0000bfb:	0f 84 ef f9 ff ff    	je     c00005f0 <kprintf+0x460>
c0000c01:	80 bd bf fd ff ff 00 	cmpb   $0x0,-0x241(%ebp)
c0000c08:	0f 84 e2 f9 ff ff    	je     c00005f0 <kprintf+0x460>
    terminal_putcharn(&stdout, c, rpt); 
c0000c0e:	8b b5 b0 fd ff ff    	mov    -0x250(%ebp),%esi
c0000c14:	83 ec 04             	sub    $0x4,%esp
c0000c17:	56                   	push   %esi
                            nchar += kprintn_char(' ', lenpad);
c0000c18:	01 f7                	add    %esi,%edi
    terminal_putcharn(&stdout, c, rpt); 
c0000c1a:	6a 20                	push   $0x20
c0000c1c:	68 20 b8 00 c0       	push   $0xc000b820
c0000c21:	e8 9a 0f 00 00       	call   c0001bc0 <terminal_putcharn>
                            nchar += kprintn_char(' ', lenpad);
c0000c26:	83 c4 10             	add    $0x10,%esp
c0000c29:	e9 c2 f9 ff ff       	jmp    c00005f0 <kprintf+0x460>
                                if(!flags.zero && radix[0])
c0000c2e:	89 f0                	mov    %esi,%eax
c0000c30:	84 c0                	test   %al,%al
c0000c32:	74 5b                	je     c0000c8f <kprintf+0xaff>
c0000c34:	89 95 d0 fd ff ff    	mov    %edx,-0x230(%ebp)
    terminal_writestring(&stdout, str);
c0000c3a:	83 ec 08             	sub    $0x8,%esp
c0000c3d:	8b b5 c0 fd ff ff    	mov    -0x240(%ebp),%esi
c0000c43:	56                   	push   %esi
c0000c44:	68 20 b8 00 c0       	push   $0xc000b820
c0000c49:	e8 a2 13 00 00       	call   c0001ff0 <terminal_writestring>
    return strlen(str);
c0000c4e:	89 34 24             	mov    %esi,(%esp)
c0000c51:	e8 aa 05 00 00       	call   c0001200 <strlen>
c0000c56:	8b 95 d0 fd ff ff    	mov    -0x230(%ebp),%edx
                                nchar += kprint(val_buf);
c0000c5c:	83 c4 10             	add    $0x10,%esp
c0000c5f:	01 c7                	add    %eax,%edi
                                if(flags.left && lenpad>0)
c0000c61:	85 d2                	test   %edx,%edx
c0000c63:	0f 8e 87 f9 ff ff    	jle    c00005f0 <kprintf+0x460>
    terminal_putcharn(&stdout, c, rpt); 
c0000c69:	83 ec 04             	sub    $0x4,%esp
c0000c6c:	89 95 d0 fd ff ff    	mov    %edx,-0x230(%ebp)
c0000c72:	52                   	push   %edx
c0000c73:	6a 20                	push   $0x20
c0000c75:	68 20 b8 00 c0       	push   $0xc000b820
c0000c7a:	e8 41 0f 00 00       	call   c0001bc0 <terminal_putcharn>
                                    nchar += kprintn_char(' ', lenpad);
c0000c7f:	8b 95 d0 fd ff ff    	mov    -0x230(%ebp),%edx
c0000c85:	83 c4 10             	add    $0x10,%esp
c0000c88:	01 d7                	add    %edx,%edi
                    break;
c0000c8a:	e9 61 f9 ff ff       	jmp    c00005f0 <kprintf+0x460>
                                if(!flags.zero && radix[0])
c0000c8f:	80 bd e5 fd ff ff 00 	cmpb   $0x0,-0x21b(%ebp)
c0000c96:	74 9c                	je     c0000c34 <kprintf+0xaa4>
    terminal_writestring(&stdout, str);
c0000c98:	83 ec 08             	sub    $0x8,%esp
c0000c9b:	8d 9d e5 fd ff ff    	lea    -0x21b(%ebp),%ebx
c0000ca1:	89 95 d0 fd ff ff    	mov    %edx,-0x230(%ebp)
c0000ca7:	53                   	push   %ebx
c0000ca8:	68 20 b8 00 c0       	push   $0xc000b820
c0000cad:	e8 3e 13 00 00       	call   c0001ff0 <terminal_writestring>
    return strlen(str);
c0000cb2:	89 1c 24             	mov    %ebx,(%esp)
c0000cb5:	e8 46 05 00 00       	call   c0001200 <strlen>
    terminal_writestring(&stdout, str);
c0000cba:	5e                   	pop    %esi
                                    nchar += kprint(radix);
c0000cbb:	01 c7                	add    %eax,%edi
    terminal_writestring(&stdout, str);
c0000cbd:	58                   	pop    %eax
c0000cbe:	e9 7a ff ff ff       	jmp    c0000c3d <kprintf+0xaad>
                                if(!flags.zero && radix[0])
c0000cc3:	89 f0                	mov    %esi,%eax
c0000cc5:	84 c0                	test   %al,%al
c0000cc7:	0f 85 e2 f7 ff ff    	jne    c00004af <kprintf+0x31f>
c0000ccd:	80 bd e5 fd ff ff 00 	cmpb   $0x0,-0x21b(%ebp)
c0000cd4:	0f 84 d5 f7 ff ff    	je     c00004af <kprintf+0x31f>
    terminal_writestring(&stdout, str);
c0000cda:	83 ec 08             	sub    $0x8,%esp
c0000cdd:	8d 9d e5 fd ff ff    	lea    -0x21b(%ebp),%ebx
c0000ce3:	53                   	push   %ebx
c0000ce4:	68 20 b8 00 c0       	push   $0xc000b820
c0000ce9:	e8 02 13 00 00       	call   c0001ff0 <terminal_writestring>
    return strlen(str);
c0000cee:	89 1c 24             	mov    %ebx,(%esp)
c0000cf1:	e8 0a 05 00 00       	call   c0001200 <strlen>
    terminal_writestring(&stdout, str);
c0000cf6:	59                   	pop    %ecx
c0000cf7:	5b                   	pop    %ebx
                                    nchar += kprint(radix);
c0000cf8:	01 c7                	add    %eax,%edi
    terminal_writestring(&stdout, str);
c0000cfa:	e9 51 fb ff ff       	jmp    c0000850 <kprintf+0x6c0>
    terminal_putchar(&stdout, c); 
c0000cff:	83 ec 08             	sub    $0x8,%esp
                                        nchar += kprint_char(sign_char); //if zero padding, sign is at beginning
c0000d02:	0f be c1             	movsbl %cl,%eax
c0000d05:	83 c7 01             	add    $0x1,%edi
    terminal_putchar(&stdout, c); 
c0000d08:	50                   	push   %eax
c0000d09:	68 20 b8 00 c0       	push   $0xc000b820
c0000d0e:	e8 8d 10 00 00       	call   c0001da0 <terminal_putchar>
                                if(!flags.left && lenpad>0)
c0000d13:	83 c4 10             	add    $0x10,%esp
c0000d16:	80 bd d0 fd ff ff 00 	cmpb   $0x0,-0x230(%ebp)
c0000d1d:	75 21                	jne    c0000d40 <kprintf+0xbb0>
c0000d1f:	85 db                	test   %ebx,%ebx
c0000d21:	0f 8e 88 f7 ff ff    	jle    c00004af <kprintf+0x31f>
                                        nchar += kprintn_char('0', lenpad);
c0000d27:	01 df                	add    %ebx,%edi
    terminal_putcharn(&stdout, c, rpt); 
c0000d29:	83 ec 04             	sub    $0x4,%esp
c0000d2c:	53                   	push   %ebx
c0000d2d:	6a 30                	push   $0x30
c0000d2f:	68 20 b8 00 c0       	push   $0xc000b820
c0000d34:	e8 87 0e 00 00       	call   c0001bc0 <terminal_putcharn>
    terminal_writestring(&stdout, str);
c0000d39:	5e                   	pop    %esi
c0000d3a:	58                   	pop    %eax
c0000d3b:	e9 10 fb ff ff       	jmp    c0000850 <kprintf+0x6c0>
c0000d40:	83 ec 08             	sub    $0x8,%esp
c0000d43:	e9 30 f8 ff ff       	jmp    c0000578 <kprintf+0x3e8>
c0000d48:	83 ec 08             	sub    $0x8,%esp
c0000d4b:	8d 9d e5 fd ff ff    	lea    -0x21b(%ebp),%ebx
c0000d51:	89 95 c8 fd ff ff    	mov    %edx,-0x238(%ebp)
c0000d57:	53                   	push   %ebx
c0000d58:	68 20 b8 00 c0       	push   $0xc000b820
c0000d5d:	e8 8e 12 00 00       	call   c0001ff0 <terminal_writestring>
    return strlen(str);
c0000d62:	89 1c 24             	mov    %ebx,(%esp)
c0000d65:	e8 96 04 00 00       	call   c0001200 <strlen>
                                if(!flags.left && lenpad>0)
c0000d6a:	83 c4 10             	add    $0x10,%esp
c0000d6d:	8b 95 c8 fd ff ff    	mov    -0x238(%ebp),%edx
                                        nchar += kprint(radix);
c0000d73:	01 c7                	add    %eax,%edi
                                if(!flags.left && lenpad>0)
c0000d75:	80 bd d0 fd ff ff 00 	cmpb   $0x0,-0x230(%ebp)
c0000d7c:	0f 85 b2 fe ff ff    	jne    c0000c34 <kprintf+0xaa4>
c0000d82:	85 d2                	test   %edx,%edx
c0000d84:	0f 8e 25 f7 ff ff    	jle    c00004af <kprintf+0x31f>
                                        nchar += kprintn_char('0', lenpad);
c0000d8a:	01 d7                	add    %edx,%edi
c0000d8c:	e9 ab fa ff ff       	jmp    c000083c <kprintf+0x6ac>
                                        nchar += kprintn_char('0', lenpad);
c0000d91:	01 df                	add    %ebx,%edi
    terminal_putcharn(&stdout, c, rpt); 
c0000d93:	83 ec 04             	sub    $0x4,%esp
c0000d96:	88 8d d0 fd ff ff    	mov    %cl,-0x230(%ebp)
c0000d9c:	53                   	push   %ebx
c0000d9d:	6a 20                	push   $0x20
c0000d9f:	68 20 b8 00 c0       	push   $0xc000b820
c0000da4:	e8 17 0e 00 00       	call   c0001bc0 <terminal_putcharn>
                                if(!flags.zero && sign_char)
c0000da9:	0f b6 8d d0 fd ff ff 	movzbl -0x230(%ebp),%ecx
    terminal_putcharn(&stdout, c, rpt); 
c0000db0:	83 c4 10             	add    $0x10,%esp
c0000db3:	e9 a1 fb ff ff       	jmp    c0000959 <kprintf+0x7c9>
                                int len = format_uint(ui_value, val_buf, 10, field_prec, 0);
c0000db8:	83 ec 0c             	sub    $0xc,%esp
c0000dbb:	8d 8d e8 fd ff ff    	lea    -0x218(%ebp),%ecx
c0000dc1:	6a 00                	push   $0x0
c0000dc3:	ff b5 ac fd ff ff    	pushl  -0x254(%ebp)
c0000dc9:	6a 0a                	push   $0xa
c0000dcb:	51                   	push   %ecx
c0000dcc:	50                   	push   %eax
c0000dcd:	89 8d c0 fd ff ff    	mov    %ecx,-0x240(%ebp)
c0000dd3:	e8 c8 f2 ff ff       	call   c00000a0 <format_uint>
                                int lenpad = field_width - len; 
c0000dd8:	8b 9d b0 fd ff ff    	mov    -0x250(%ebp),%ebx
                                if(!flags.left && lenpad>0)
c0000dde:	83 c4 20             	add    $0x20,%esp
                                int lenpad = field_width - len; 
c0000de1:	29 c3                	sub    %eax,%ebx
                                if(!flags.left && lenpad>0)
c0000de3:	80 bd d0 fd ff ff 00 	cmpb   $0x0,-0x230(%ebp)
c0000dea:	0f 85 50 ff ff ff    	jne    c0000d40 <kprintf+0xbb0>
c0000df0:	85 db                	test   %ebx,%ebx
c0000df2:	0f 8e b7 f6 ff ff    	jle    c00004af <kprintf+0x31f>
                                    if(flags.zero)
c0000df8:	89 f0                	mov    %esi,%eax
                                        nchar += kprintn_char('0', lenpad);
c0000dfa:	01 df                	add    %ebx,%edi
                                    if(flags.zero)
c0000dfc:	84 c0                	test   %al,%al
c0000dfe:	0f 85 25 ff ff ff    	jne    c0000d29 <kprintf+0xb99>
                                char sign_char = 0; //sign character or 0 if none
c0000e04:	31 c9                	xor    %ecx,%ecx
c0000e06:	eb 8b                	jmp    c0000d93 <kprintf+0xc03>
c0000e08:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0000e0f:	90                   	nop
                        int int_len = format_uint(ui_part,val_buf,10,-1,0);
c0000e10:	83 ec 0c             	sub    $0xc,%esp
c0000e13:	8d 8d e8 fd ff ff    	lea    -0x218(%ebp),%ecx
c0000e19:	6a 00                	push   $0x0
c0000e1b:	6a ff                	push   $0xffffffff
c0000e1d:	6a 0a                	push   $0xa
c0000e1f:	51                   	push   %ecx
c0000e20:	50                   	push   %eax
c0000e21:	89 8d c0 fd ff ff    	mov    %ecx,-0x240(%ebp)
c0000e27:	e8 74 f2 ff ff       	call   c00000a0 <format_uint>
                        int f_len = int_len + 1 + field_prec;
c0000e2c:	8b 8d ac fd ff ff    	mov    -0x254(%ebp),%ecx
                        if(!flags.left && lenpad>0)
c0000e32:	83 c4 20             	add    $0x20,%esp
                        int f_len = int_len + 1 + field_prec;
c0000e35:	8d 44 01 01          	lea    0x1(%ecx,%eax,1),%eax
                        int lenpad = field_width - f_len; 
c0000e39:	8b 8d b0 fd ff ff    	mov    -0x250(%ebp),%ecx
c0000e3f:	29 c1                	sub    %eax,%ecx
                        if(!flags.left && lenpad>0)
c0000e41:	85 c9                	test   %ecx,%ecx
                        int lenpad = field_width - f_len; 
c0000e43:	89 8d b0 fd ff ff    	mov    %ecx,-0x250(%ebp)
                        if(!flags.left && lenpad>0)
c0000e49:	0f 9f 85 bf fd ff ff 	setg   -0x241(%ebp)
c0000e50:	0f b6 85 bf fd ff ff 	movzbl -0x241(%ebp),%eax
c0000e57:	20 c3                	and    %al,%bl
c0000e59:	0f 84 a4 fc ff ff    	je     c0000b03 <kprintf+0x973>
                            if(flags.zero)
c0000e5f:	89 f0                	mov    %esi,%eax
                                nchar += kprintn_char(' ', lenpad);
c0000e61:	03 bd b0 fd ff ff    	add    -0x250(%ebp),%edi
                            if(flags.zero)
c0000e67:	84 c0                	test   %al,%al
c0000e69:	0f 84 43 01 00 00    	je     c0000fb2 <kprintf+0xe22>
    terminal_putcharn(&stdout, c, rpt); 
c0000e6f:	83 ec 04             	sub    $0x4,%esp
c0000e72:	ff b5 b0 fd ff ff    	pushl  -0x250(%ebp)
c0000e78:	6a 30                	push   $0x30
c0000e7a:	68 20 b8 00 c0       	push   $0xc000b820
c0000e7f:	e8 3c 0d 00 00       	call   c0001bc0 <terminal_putcharn>
c0000e84:	c6 85 bf fd ff ff 01 	movb   $0x1,-0x241(%ebp)
c0000e8b:	83 c4 10             	add    $0x10,%esp
c0000e8e:	e9 70 fc ff ff       	jmp    c0000b03 <kprintf+0x973>
                f++;
c0000e93:	8b 9d b8 fd ff ff    	mov    -0x248(%ebp),%ebx
            switch(*(f++))
c0000e99:	89 8d b8 fd ff ff    	mov    %ecx,-0x248(%ebp)
c0000e9f:	e9 1c f4 ff ff       	jmp    c00002c0 <kprintf+0x130>
                        float frac = f_value<0 ? -f_value - ui_part : f_value - ui_part;
c0000ea4:	8b 85 a0 fd ff ff    	mov    -0x260(%ebp),%eax
c0000eaa:	d9 e0                	fchs   
c0000eac:	c7 85 cc fd ff ff 00 	movl   $0x0,-0x234(%ebp)
c0000eb3:	00 00 00 
c0000eb6:	89 85 c8 fd ff ff    	mov    %eax,-0x238(%ebp)
c0000ebc:	df ad c8 fd ff ff    	fildll -0x238(%ebp)
c0000ec2:	de e9                	fsubrp %st,%st(1)
c0000ec4:	e9 a0 fc ff ff       	jmp    c0000b69 <kprintf+0x9d9>
                                int len = format_uint(ui_value, val_buf, base, field_prec, cap);
c0000ec9:	83 ec 0c             	sub    $0xc,%esp
c0000ecc:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
c0000ed2:	6a 00                	push   $0x0
c0000ed4:	ff b5 ac fd ff ff    	pushl  -0x254(%ebp)
c0000eda:	6a 10                	push   $0x10
c0000edc:	50                   	push   %eax
c0000edd:	52                   	push   %edx
c0000ede:	89 85 c0 fd ff ff    	mov    %eax,-0x240(%ebp)
c0000ee4:	e8 b7 f1 ff ff       	call   c00000a0 <format_uint>
                                int lenpad = field_width - len; 
c0000ee9:	8b 9d b0 fd ff ff    	mov    -0x250(%ebp),%ebx
                                char radix[3]="";
c0000eef:	c6 85 e7 fd ff ff 00 	movb   $0x0,-0x219(%ebp)
                                        radix[0] = '0';
c0000ef6:	83 c4 20             	add    $0x20,%esp
c0000ef9:	c6 85 e5 fd ff ff 30 	movb   $0x30,-0x21b(%ebp)
                                int lenpad = field_width - len; 
c0000f00:	29 c3                	sub    %eax,%ebx
                                        lenpad -= 2;
c0000f02:	8d 53 fe             	lea    -0x2(%ebx),%edx
                                        radix[1] = cap ? 'X' : 'x';
c0000f05:	bb 78 00 00 00       	mov    $0x78,%ebx
c0000f0a:	e9 59 f5 ff ff       	jmp    c0000468 <kprintf+0x2d8>
                            ui_part = (unsigned int) -f_value;
c0000f0f:	d9 bd d6 fd ff ff    	fnstcw -0x22a(%ebp)
c0000f15:	d9 e0                	fchs   
                            sign_char = '-';
c0000f17:	c6 85 ab fd ff ff 2d 	movb   $0x2d,-0x255(%ebp)
                            ui_part = (unsigned int) -f_value;
c0000f1e:	0f b7 85 d6 fd ff ff 	movzwl -0x22a(%ebp),%eax
c0000f25:	80 cc 0c             	or     $0xc,%ah
c0000f28:	66 89 85 d4 fd ff ff 	mov    %ax,-0x22c(%ebp)
c0000f2f:	d9 ad d4 fd ff ff    	fldcw  -0x22c(%ebp)
c0000f35:	df bd c0 fd ff ff    	fistpll -0x240(%ebp)
c0000f3b:	d9 ad d6 fd ff ff    	fldcw  -0x22a(%ebp)
c0000f41:	8b 85 c0 fd ff ff    	mov    -0x240(%ebp),%eax
c0000f47:	89 85 a0 fd ff ff    	mov    %eax,-0x260(%ebp)
                            sign_char = '-';
c0000f4d:	e9 33 fb ff ff       	jmp    c0000a85 <kprintf+0x8f5>
                                sign_char = '+';
c0000f52:	c6 85 ab fd ff ff 2b 	movb   $0x2b,-0x255(%ebp)
c0000f59:	e9 27 fb ff ff       	jmp    c0000a85 <kprintf+0x8f5>
                                nchar += kprint_char(sign_char); //if zero padding, sign is at beginning
c0000f5e:	0f be 85 ab fd ff ff 	movsbl -0x255(%ebp),%eax
    terminal_putchar(&stdout, c); 
c0000f65:	83 ec 08             	sub    $0x8,%esp
                                nchar += kprint_char(sign_char); //if zero padding, sign is at beginning
c0000f68:	83 c7 01             	add    $0x1,%edi
    terminal_putchar(&stdout, c); 
c0000f6b:	50                   	push   %eax
c0000f6c:	68 20 b8 00 c0       	push   $0xc000b820
c0000f71:	e8 2a 0e 00 00       	call   c0001da0 <terminal_putchar>
                        if(!flags.left && lenpad>0)
c0000f76:	83 c4 10             	add    $0x10,%esp
c0000f79:	84 db                	test   %bl,%bl
c0000f7b:	0f 84 82 fb ff ff    	je     c0000b03 <kprintf+0x973>
                                nchar += kprintn_char('0', lenpad);
c0000f81:	03 bd b0 fd ff ff    	add    -0x250(%ebp),%edi
c0000f87:	e9 e3 fe ff ff       	jmp    c0000e6f <kprintf+0xcdf>
                                nchar += kprintn_char(' ', lenpad);
c0000f8c:	8b 85 b0 fd ff ff    	mov    -0x250(%ebp),%eax
    terminal_putcharn(&stdout, c, rpt); 
c0000f92:	83 ec 04             	sub    $0x4,%esp
c0000f95:	50                   	push   %eax
                                nchar += kprintn_char(' ', lenpad);
c0000f96:	01 c7                	add    %eax,%edi
    terminal_putcharn(&stdout, c, rpt); 
c0000f98:	6a 20                	push   $0x20
c0000f9a:	68 20 b8 00 c0       	push   $0xc000b820
c0000f9f:	e8 1c 0c 00 00       	call   c0001bc0 <terminal_putcharn>
c0000fa4:	88 9d bf fd ff ff    	mov    %bl,-0x241(%ebp)
c0000faa:	83 c4 10             	add    $0x10,%esp
c0000fad:	e9 36 fb ff ff       	jmp    c0000ae8 <kprintf+0x958>
c0000fb2:	83 ec 04             	sub    $0x4,%esp
c0000fb5:	ff b5 b0 fd ff ff    	pushl  -0x250(%ebp)
c0000fbb:	6a 20                	push   $0x20
c0000fbd:	68 20 b8 00 c0       	push   $0xc000b820
c0000fc2:	e8 f9 0b 00 00       	call   c0001bc0 <terminal_putcharn>
c0000fc7:	88 9d bf fd ff ff    	mov    %bl,-0x241(%ebp)
c0000fcd:	83 c4 10             	add    $0x10,%esp
c0000fd0:	e9 2e fb ff ff       	jmp    c0000b03 <kprintf+0x973>
                                        radix[1] = cap ? 'X' : 'x';
c0000fd5:	bb 78 00 00 00       	mov    $0x78,%ebx
c0000fda:	e9 89 f4 ff ff       	jmp    c0000468 <kprintf+0x2d8>
c0000fdf:	90                   	nop

c0000fe0 <numdigits_uint>:
{
c0000fe0:	55                   	push   %ebp
c0000fe1:	89 e5                	mov    %esp,%ebp
c0000fe3:	53                   	push   %ebx
    unsigned int num_digits = 1;
c0000fe4:	bb 01 00 00 00       	mov    $0x1,%ebx
{
c0000fe9:	8b 45 08             	mov    0x8(%ebp),%eax
c0000fec:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    while(value >= base)
c0000fef:	39 c8                	cmp    %ecx,%eax
c0000ff1:	72 18                	jb     c000100b <numdigits_uint+0x2b>
c0000ff3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0000ffa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        value /= base;
c0001000:	31 d2                	xor    %edx,%edx
        num_digits++;
c0001002:	83 c3 01             	add    $0x1,%ebx
        value /= base;
c0001005:	f7 f1                	div    %ecx
    while(value >= base)
c0001007:	39 c1                	cmp    %eax,%ecx
c0001009:	76 f5                	jbe    c0001000 <numdigits_uint+0x20>
    }
    return num_digits;
}
c000100b:	89 d8                	mov    %ebx,%eax
c000100d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0001010:	c9                   	leave  
c0001011:	c3                   	ret    
c0001012:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001019:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

c0001020 <kprintf_test>:



void kprintf_test()
{
c0001020:	55                   	push   %ebp
c0001021:	89 e5                	mov    %esp,%ebp
c0001023:	83 ec 10             	sub    $0x10,%esp
    int num = 12345678;    
    kprintf("\nkprintf() tests...\n", num);
c0001026:	68 4e 61 bc 00       	push   $0xbc614e
c000102b:	68 cc 31 00 c0       	push   $0xc00031cc
c0001030:	e8 5b f1 ff ff       	call   c0000190 <kprintf>
    kprintf("Fixed width, right justify:\n");
c0001035:	c7 04 24 e1 31 00 c0 	movl   $0xc00031e1,(%esp)
c000103c:	e8 4f f1 ff ff       	call   c0000190 <kprintf>
    kprintf("Decimal: [%15d]\n", num);
c0001041:	58                   	pop    %eax
c0001042:	5a                   	pop    %edx
c0001043:	68 4e 61 bc 00       	push   $0xbc614e
c0001048:	68 fe 31 00 c0       	push   $0xc00031fe
c000104d:	e8 3e f1 ff ff       	call   c0000190 <kprintf>
    kprintf("Hex:     [%#15x]\n", num);
c0001052:	59                   	pop    %ecx
c0001053:	58                   	pop    %eax
c0001054:	68 4e 61 bc 00       	push   $0xbc614e
c0001059:	68 0f 32 00 c0       	push   $0xc000320f
c000105e:	e8 2d f1 ff ff       	call   c0000190 <kprintf>
    kprintf("Oct:     [%#15o]\n", num);
c0001063:	58                   	pop    %eax
c0001064:	5a                   	pop    %edx
c0001065:	68 4e 61 bc 00       	push   $0xbc614e
c000106a:	68 21 32 00 c0       	push   $0xc0003221
c000106f:	e8 1c f1 ff ff       	call   c0000190 <kprintf>
    kprintf("String:  [%15s]\n", "Hello World!");
c0001074:	59                   	pop    %ecx
c0001075:	58                   	pop    %eax
c0001076:	68 33 32 00 c0       	push   $0xc0003233
c000107b:	68 40 32 00 c0       	push   $0xc0003240
c0001080:	e8 0b f1 ff ff       	call   c0000190 <kprintf>
    kprintf("Char:    [%15c]\n", '!');
c0001085:	58                   	pop    %eax
c0001086:	5a                   	pop    %edx
c0001087:	6a 21                	push   $0x21
c0001089:	68 51 32 00 c0       	push   $0xc0003251
c000108e:	e8 fd f0 ff ff       	call   c0000190 <kprintf>

    kprintf("\nFixed width, left justify:\n");
c0001093:	c7 04 24 62 32 00 c0 	movl   $0xc0003262,(%esp)
c000109a:	e8 f1 f0 ff ff       	call   c0000190 <kprintf>
    kprintf("Decimal: [%-15d]\n", num);
c000109f:	59                   	pop    %ecx
c00010a0:	58                   	pop    %eax
c00010a1:	68 4e 61 bc 00       	push   $0xbc614e
c00010a6:	68 7f 32 00 c0       	push   $0xc000327f
c00010ab:	e8 e0 f0 ff ff       	call   c0000190 <kprintf>
    kprintf("Hex:     [%-#15x]\n", num);
c00010b0:	58                   	pop    %eax
c00010b1:	5a                   	pop    %edx
c00010b2:	68 4e 61 bc 00       	push   $0xbc614e
c00010b7:	68 91 32 00 c0       	push   $0xc0003291
c00010bc:	e8 cf f0 ff ff       	call   c0000190 <kprintf>
    kprintf("String:  [%-15s]\n", "Hello World!");
c00010c1:	59                   	pop    %ecx
c00010c2:	58                   	pop    %eax
c00010c3:	68 33 32 00 c0       	push   $0xc0003233
c00010c8:	68 a4 32 00 c0       	push   $0xc00032a4
c00010cd:	e8 be f0 ff ff       	call   c0000190 <kprintf>

    kprintf("\nFixed Precision:\n");
c00010d2:	c7 04 24 b6 32 00 c0 	movl   $0xc00032b6,(%esp)
c00010d9:	e8 b2 f0 ff ff       	call   c0000190 <kprintf>
    kprintf("Decimal: [%15.10d]\nHex:     [%#15.10x]\nOct:     [%#15.10o]\nString:  [%15.10s]\n", 
c00010de:	c7 04 24 33 32 00 c0 	movl   $0xc0003233,(%esp)
c00010e5:	68 4e 61 bc 00       	push   $0xbc614e
c00010ea:	68 4e 61 bc 00       	push   $0xbc614e
c00010ef:	68 4e 61 bc 00       	push   $0xbc614e
c00010f4:	68 e0 33 00 c0       	push   $0xc00033e0
c00010f9:	e8 92 f0 ff ff       	call   c0000190 <kprintf>
        num, num, num, "Hello World!");

    kprintf("\nLeading Zeros:\n");
c00010fe:	83 c4 14             	add    $0x14,%esp
c0001101:	68 c9 32 00 c0       	push   $0xc00032c9
c0001106:	e8 85 f0 ff ff       	call   c0000190 <kprintf>
    kprintf("Decimal: [%015.10d]\nHex:     [%#015.10x]\nOct:     [%#015.10o]\n",num, num, num);
c000110b:	68 4e 61 bc 00       	push   $0xbc614e
c0001110:	68 4e 61 bc 00       	push   $0xbc614e
c0001115:	68 4e 61 bc 00       	push   $0xbc614e
c000111a:	68 30 34 00 c0       	push   $0xc0003430
c000111f:	e8 6c f0 ff ff       	call   c0000190 <kprintf>

    kprintf("Signed (none):  [%d], [%d]\n",num, -num);
c0001124:	83 c4 1c             	add    $0x1c,%esp
c0001127:	68 b2 9e 43 ff       	push   $0xff439eb2
c000112c:	68 4e 61 bc 00       	push   $0xbc614e
c0001131:	68 da 32 00 c0       	push   $0xc00032da
c0001136:	e8 55 f0 ff ff       	call   c0000190 <kprintf>
    kprintf("Signed (space): [% d], [% d]\n",num, -num);
c000113b:	83 c4 0c             	add    $0xc,%esp
c000113e:	68 b2 9e 43 ff       	push   $0xff439eb2
c0001143:	68 4e 61 bc 00       	push   $0xbc614e
c0001148:	68 f6 32 00 c0       	push   $0xc00032f6
c000114d:	e8 3e f0 ff ff       	call   c0000190 <kprintf>
    kprintf("Signed (+):     [%+d], [%+d]\n",num, -num);
c0001152:	83 c4 0c             	add    $0xc,%esp
c0001155:	68 b2 9e 43 ff       	push   $0xff439eb2
c000115a:	68 4e 61 bc 00       	push   $0xbc614e
c000115f:	68 14 33 00 c0       	push   $0xc0003314
c0001164:	e8 27 f0 ff ff       	call   c0000190 <kprintf>

    float f = 1.23456789;
    kprintf("\nfloat:     [%15.f]\n",f);
c0001169:	d9 05 20 35 00 c0    	flds   0xc0003520
c000116f:	c7 04 24 32 33 00 c0 	movl   $0xc0003332,(%esp)
c0001176:	dd 5c 24 04          	fstpl  0x4(%esp)
c000117a:	e8 11 f0 ff ff       	call   c0000190 <kprintf>
    kprintf("float:     [%15.3f]\n",f);
c000117f:	dd 05 28 35 00 c0    	fldl   0xc0003528
c0001185:	c7 04 24 47 33 00 c0 	movl   $0xc0003347,(%esp)
c000118c:	dd 5c 24 04          	fstpl  0x4(%esp)
c0001190:	e8 fb ef ff ff       	call   c0000190 <kprintf>
    kprintf("float:     [%15.10f]\n",f);
c0001195:	dd 05 28 35 00 c0    	fldl   0xc0003528
c000119b:	c7 04 24 5c 33 00 c0 	movl   $0xc000335c,(%esp)
c00011a2:	dd 5c 24 04          	fstpl  0x4(%esp)
c00011a6:	e8 e5 ef ff ff       	call   c0000190 <kprintf>

    f = -12345.6789;
    kprintf("float:     [%15f]\n",f);
c00011ab:	d9 05 24 35 00 c0    	flds   0xc0003524
c00011b1:	c7 04 24 72 33 00 c0 	movl   $0xc0003372,(%esp)
c00011b8:	dd 5c 24 04          	fstpl  0x4(%esp)
c00011bc:	e8 cf ef ff ff       	call   c0000190 <kprintf>
    kprintf("float:     [%15.3f]\n",f);
c00011c1:	dd 05 30 35 00 c0    	fldl   0xc0003530
c00011c7:	c7 04 24 47 33 00 c0 	movl   $0xc0003347,(%esp)
c00011ce:	dd 5c 24 04          	fstpl  0x4(%esp)
c00011d2:	e8 b9 ef ff ff       	call   c0000190 <kprintf>
    kprintf("float:     [%15.10f]\n",f);
c00011d7:	dd 05 30 35 00 c0    	fldl   0xc0003530
c00011dd:	c7 04 24 5c 33 00 c0 	movl   $0xc000335c,(%esp)
c00011e4:	dd 5c 24 04          	fstpl  0x4(%esp)
c00011e8:	e8 a3 ef ff ff       	call   c0000190 <kprintf>
}
c00011ed:	83 c4 10             	add    $0x10,%esp
c00011f0:	c9                   	leave  
c00011f1:	c3                   	ret    
c00011f2:	66 90                	xchg   %ax,%ax
c00011f4:	66 90                	xchg   %ax,%ax
c00011f6:	66 90                	xchg   %ax,%ax
c00011f8:	66 90                	xchg   %ax,%ax
c00011fa:	66 90                	xchg   %ax,%ax
c00011fc:	66 90                	xchg   %ax,%ax
c00011fe:	66 90                	xchg   %ax,%ax

c0001200 <strlen>:
#include "common.h"

size_t strlen(const char* str) 
{
c0001200:	55                   	push   %ebp
	size_t len = 0;
c0001201:	31 c0                	xor    %eax,%eax
{
c0001203:	89 e5                	mov    %esp,%ebp
c0001205:	8b 55 08             	mov    0x8(%ebp),%edx
	while (str[len])
c0001208:	80 3a 00             	cmpb   $0x0,(%edx)
c000120b:	74 0c                	je     c0001219 <strlen+0x19>
c000120d:	8d 76 00             	lea    0x0(%esi),%esi
		len++;
c0001210:	83 c0 01             	add    $0x1,%eax
	while (str[len])
c0001213:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
c0001217:	75 f7                	jne    c0001210 <strlen+0x10>
	return len;
}
c0001219:	5d                   	pop    %ebp
c000121a:	c3                   	ret    
c000121b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c000121f:	90                   	nop

c0001220 <memcpy>:

// copy n bytes from src to dest
void *memcpy(void *dest, const void *src, size_t n)
{
c0001220:	55                   	push   %ebp
c0001221:	89 e5                	mov    %esp,%ebp
c0001223:	57                   	push   %edi
c0001224:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0001227:	8b 7d 08             	mov    0x8(%ebp),%edi
c000122a:	56                   	push   %esi
c000122b:	8b 75 10             	mov    0x10(%ebp),%esi
c000122e:	53                   	push   %ebx
    //system wordsize is equal to length of size_t
    size_t n_words = n/sizeof(size_t);
    size_t* dest_word = (size_t *) dest;
    size_t* src_word = (size_t *) src;
    for(size_t nn=0; nn<n_words; nn++)
c000122f:	89 f3                	mov    %esi,%ebx
c0001231:	c1 eb 02             	shr    $0x2,%ebx
c0001234:	74 1c                	je     c0001252 <memcpy+0x32>
c0001236:	89 c8                	mov    %ecx,%eax
c0001238:	89 fa                	mov    %edi,%edx
c000123a:	8d 1c 99             	lea    (%ecx,%ebx,4),%ebx
c000123d:	8d 76 00             	lea    0x0(%esi),%esi
        dest_word[nn]=src_word[nn];
c0001240:	8b 08                	mov    (%eax),%ecx
    for(size_t nn=0; nn<n_words; nn++)
c0001242:	83 c0 04             	add    $0x4,%eax
c0001245:	83 c2 04             	add    $0x4,%edx
        dest_word[nn]=src_word[nn];
c0001248:	89 4a fc             	mov    %ecx,-0x4(%edx)
    for(size_t nn=0; nn<n_words; nn++)
c000124b:	39 d8                	cmp    %ebx,%eax
c000124d:	75 f1                	jne    c0001240 <memcpy+0x20>
c000124f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    
    //copy remaining bytes
    size_t n_bytes = n - n_words*sizeof(size_t);
    if(n_bytes > 0)
c0001252:	83 e6 03             	and    $0x3,%esi
c0001255:	74 14                	je     c000126b <memcpy+0x4b>
c0001257:	89 fa                	mov    %edi,%edx
c0001259:	01 ce                	add    %ecx,%esi
    {
        char* dest_byte = (char *) dest;
        char* src_byte = (char *) src;
        for(size_t nn=0; nn<n_bytes; nn++)
            dest_byte[nn]=src_byte[nn];
c000125b:	0f b6 01             	movzbl (%ecx),%eax
        for(size_t nn=0; nn<n_bytes; nn++)
c000125e:	83 c1 01             	add    $0x1,%ecx
c0001261:	83 c2 01             	add    $0x1,%edx
            dest_byte[nn]=src_byte[nn];
c0001264:	88 42 ff             	mov    %al,-0x1(%edx)
        for(size_t nn=0; nn<n_bytes; nn++)
c0001267:	39 f1                	cmp    %esi,%ecx
c0001269:	75 f0                	jne    c000125b <memcpy+0x3b>
    }

    return dest;
}
c000126b:	5b                   	pop    %ebx
c000126c:	89 f8                	mov    %edi,%eax
c000126e:	5e                   	pop    %esi
c000126f:	5f                   	pop    %edi
c0001270:	5d                   	pop    %ebp
c0001271:	c3                   	ret    
c0001272:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001279:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

c0001280 <atoi>:

int atoi(const char* str)
{
c0001280:	55                   	push   %ebp
    int p = 0;
    int neg = 0;
    //find start of number string, ignore whitespace
    while(str[p] == '-' || str[p] == ' ' || (str[p] >= 9 && str[p] <= 13))
c0001281:	b8 01 00 00 00       	mov    $0x1,%eax
{
c0001286:	89 e5                	mov    %esp,%ebp
c0001288:	57                   	push   %edi
c0001289:	8b 4d 08             	mov    0x8(%ebp),%ecx
c000128c:	56                   	push   %esi
c000128d:	53                   	push   %ebx
    while(str[p] == '-' || str[p] == ' ' || (str[p] >= 9 && str[p] <= 13))
c000128e:	eb 1e                	jmp    c00012ae <atoi+0x2e>
c0001290:	89 d7                	mov    %edx,%edi
c0001292:	8d 77 f7             	lea    -0x9(%edi),%esi
c0001295:	89 f2                	mov    %esi,%edx
c0001297:	80 fa 04             	cmp    $0x4,%dl
c000129a:	0f 87 b0 00 00 00    	ja     c0001350 <atoi+0xd0>
        if(str[p++] == '-')
        {
            neg=1;
            break;
        }
        if(str[p++] == '\0')
c00012a0:	83 c0 02             	add    $0x2,%eax
c00012a3:	80 7c 01 fe 00       	cmpb   $0x0,-0x2(%ecx,%eax,1)
c00012a8:	0f 84 92 00 00 00    	je     c0001340 <atoi+0xc0>
    while(str[p] == '-' || str[p] == ' ' || (str[p] >= 9 && str[p] <= 13))
c00012ae:	0f b6 54 01 ff       	movzbl -0x1(%ecx,%eax,1),%edx
c00012b3:	8d 58 ff             	lea    -0x1(%eax),%ebx
c00012b6:	80 fa 2d             	cmp    $0x2d,%dl
c00012b9:	74 05                	je     c00012c0 <atoi+0x40>
c00012bb:	80 fa 20             	cmp    $0x20,%dl
c00012be:	75 d0                	jne    c0001290 <atoi+0x10>
        if(str[p++] == '-')
c00012c0:	89 c3                	mov    %eax,%ebx
c00012c2:	80 fa 2d             	cmp    $0x2d,%dl
c00012c5:	75 d9                	jne    c00012a0 <atoi+0x20>
    }

    int num_start = p;

    //find end of integer string (ints only, no decimal point)
    while(str[p] >= '0' && str[p] <= '9')
c00012c7:	0f b6 3c 01          	movzbl (%ecx,%eax,1),%edi
            neg=1;
c00012cb:	be 01 00 00 00       	mov    $0x1,%esi
    while(str[p] >= '0' && str[p] <= '9')
c00012d0:	8d 57 d0             	lea    -0x30(%edi),%edx
c00012d3:	80 fa 09             	cmp    $0x9,%dl
c00012d6:	77 68                	ja     c0001340 <atoi+0xc0>
c00012d8:	89 d8                	mov    %ebx,%eax
c00012da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    {
        if(str[p++] == '\0')
c00012e0:	89 c7                	mov    %eax,%edi
c00012e2:	83 c0 01             	add    $0x1,%eax
    while(str[p] >= '0' && str[p] <= '9')
c00012e5:	0f b6 14 01          	movzbl (%ecx,%eax,1),%edx
c00012e9:	83 ea 30             	sub    $0x30,%edx
c00012ec:	80 fa 09             	cmp    $0x9,%dl
c00012ef:	76 ef                	jbe    c00012e0 <atoi+0x60>
            return 0; //invalid string (only whitespace found)
    }

    if(num_start == p) return 0; //length 0 string
c00012f1:	39 c3                	cmp    %eax,%ebx
c00012f3:	74 4b                	je     c0001340 <atoi+0xc0>

    int number = 0;
    int place = 1;
    //iterate backwards through number to add each digit
    for(int digit = p-1; digit >= num_start; digit--)
c00012f5:	39 fb                	cmp    %edi,%ebx
c00012f7:	7f 5e                	jg     c0001357 <atoi+0xd7>
c00012f9:	01 cf                	add    %ecx,%edi
c00012fb:	8d 5c 19 ff          	lea    -0x1(%ecx,%ebx,1),%ebx
    int place = 1;
c00012ff:	b8 01 00 00 00       	mov    $0x1,%eax
    int number = 0;
c0001304:	31 c9                	xor    %ecx,%ecx
c0001306:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000130d:	8d 76 00             	lea    0x0(%esi),%esi
    {
        number += (int) (str[digit] - '0') * place;
c0001310:	0f be 17             	movsbl (%edi),%edx
    for(int digit = p-1; digit >= num_start; digit--)
c0001313:	83 ef 01             	sub    $0x1,%edi
        number += (int) (str[digit] - '0') * place;
c0001316:	83 ea 30             	sub    $0x30,%edx
c0001319:	0f af d0             	imul   %eax,%edx
        place *= 10;
c000131c:	8d 04 80             	lea    (%eax,%eax,4),%eax
c000131f:	01 c0                	add    %eax,%eax
        number += (int) (str[digit] - '0') * place;
c0001321:	01 d1                	add    %edx,%ecx
    for(int digit = p-1; digit >= num_start; digit--)
c0001323:	39 fb                	cmp    %edi,%ebx
c0001325:	75 e9                	jne    c0001310 <atoi+0x90>
    }

    if(neg)
        return -1*number;
c0001327:	89 c8                	mov    %ecx,%eax
    else
        return number;
}
c0001329:	5b                   	pop    %ebx
        return -1*number;
c000132a:	f7 d8                	neg    %eax
c000132c:	85 f6                	test   %esi,%esi
}
c000132e:	5e                   	pop    %esi
c000132f:	5f                   	pop    %edi
        return -1*number;
c0001330:	0f 45 c8             	cmovne %eax,%ecx
}
c0001333:	5d                   	pop    %ebp
c0001334:	89 c8                	mov    %ecx,%eax
c0001336:	c3                   	ret    
c0001337:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000133e:	66 90                	xchg   %ax,%ax
            return 0; //invalid string (only whitespace found)
c0001340:	31 c9                	xor    %ecx,%ecx
}
c0001342:	5b                   	pop    %ebx
c0001343:	5e                   	pop    %esi
c0001344:	89 c8                	mov    %ecx,%eax
c0001346:	5f                   	pop    %edi
c0001347:	5d                   	pop    %ebp
c0001348:	c3                   	ret    
c0001349:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    int neg = 0;
c0001350:	31 f6                	xor    %esi,%esi
c0001352:	e9 79 ff ff ff       	jmp    c00012d0 <atoi+0x50>
    int number = 0;
c0001357:	31 c9                	xor    %ecx,%ecx
c0001359:	eb cc                	jmp    c0001327 <atoi+0xa7>
c000135b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c000135f:	90                   	nop

c0001360 <itoa>:

char* itoa( int value, char* str, int base)
{
c0001360:	55                   	push   %ebp
c0001361:	89 e5                	mov    %esp,%ebp
c0001363:	57                   	push   %edi
c0001364:	56                   	push   %esi
c0001365:	53                   	push   %ebx
c0001366:	83 ec 08             	sub    $0x8,%esp
c0001369:	8b 4d 10             	mov    0x10(%ebp),%ecx
c000136c:	8b 45 08             	mov    0x8(%ebp),%eax
    if(base < 2 || base > 32)
c000136f:	8d 51 fe             	lea    -0x2(%ecx),%edx
c0001372:	83 fa 1e             	cmp    $0x1e,%edx
c0001375:	0f 87 b5 00 00 00    	ja     c0001430 <itoa+0xd0>
        return NULL;

    //handle zero as special case 
    if(value == 0)
c000137b:	85 c0                	test   %eax,%eax
c000137d:	0f 84 8d 00 00 00    	je     c0001410 <itoa+0xb0>
        return str;
    }

    char* s = str;
    unsigned int residual; //holds the unsigned value still to be parsed
    if(base == 10 && value < 0)
c0001383:	83 f9 0a             	cmp    $0xa,%ecx
c0001386:	75 78                	jne    c0001400 <itoa+0xa0>
c0001388:	85 c0                	test   %eax,%eax
c000138a:	79 74                	jns    c0001400 <itoa+0xa0>
    {
        residual = -value;
c000138c:	f7 d8                	neg    %eax
c000138e:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *(s++) = '-';
c0001391:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001394:	83 c0 01             	add    $0x1,%eax
c0001397:	89 45 ec             	mov    %eax,-0x14(%ebp)
c000139a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000139d:	c6 00 2d             	movb   $0x2d,(%eax)
    }
    
    // find number of digits so that we can parse number
    // directly into string from lowest to highest digit    
    unsigned int num_digits = 0;
    unsigned int temp = residual;
c00013a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    unsigned int num_digits = 0;
c00013a3:	31 f6                	xor    %esi,%esi
c00013a5:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00013ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    while(temp>0)
    {
        num_digits++;
c00013b0:	89 c3                	mov    %eax,%ebx
        temp /= base;
c00013b2:	31 d2                	xor    %edx,%edx
c00013b4:	89 f7                	mov    %esi,%edi
        num_digits++;
c00013b6:	83 c6 01             	add    $0x1,%esi
        temp /= base;
c00013b9:	f7 f1                	div    %ecx
    while(temp>0)
c00013bb:	39 d9                	cmp    %ebx,%ecx
c00013bd:	76 f1                	jbe    c00013b0 <itoa+0x50>
    }

    //point at end of string
    s += num_digits;
    *(s--) = '\0'; //null termination
c00013bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00013c2:	89 4d 10             	mov    %ecx,0x10(%ebp)
c00013c5:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
c00013c9:	8d 1c 38             	lea    (%eax,%edi,1),%ebx
c00013cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00013cf:	90                   	nop
    //compute each digit from lowest to highest.
    unsigned int digit;
    while(residual>0)
    {
        digit = residual % base;
        residual /= base;
c00013d0:	31 d2                	xor    %edx,%edx
c00013d2:	89 c1                	mov    %eax,%ecx

        //write digit into string and decrement pointer
        if(digit < 10)
            *(s--) = digit + '0';
c00013d4:	83 eb 01             	sub    $0x1,%ebx
        residual /= base;
c00013d7:	f7 75 10             	divl   0x10(%ebp)
            *(s--) = digit + '0';
c00013da:	8d 7a 30             	lea    0x30(%edx),%edi
c00013dd:	8d 72 37             	lea    0x37(%edx),%esi
c00013e0:	83 fa 09             	cmp    $0x9,%edx
c00013e3:	0f 47 fe             	cmova  %esi,%edi
c00013e6:	89 fa                	mov    %edi,%edx
c00013e8:	88 53 01             	mov    %dl,0x1(%ebx)
    while(residual>0)
c00013eb:	39 4d 10             	cmp    %ecx,0x10(%ebp)
c00013ee:	76 e0                	jbe    c00013d0 <itoa+0x70>
        else
            *(s--) = digit - 10 + 'A';        
    }

    return str;
}
c00013f0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00013f3:	83 c4 08             	add    $0x8,%esp
c00013f6:	5b                   	pop    %ebx
c00013f7:	5e                   	pop    %esi
c00013f8:	5f                   	pop    %edi
c00013f9:	5d                   	pop    %ebp
c00013fa:	c3                   	ret    
c00013fb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c00013ff:	90                   	nop
        residual = (unsigned int) value;
c0001400:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0001403:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001406:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0001409:	eb 95                	jmp    c00013a0 <itoa+0x40>
c000140b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c000140f:	90                   	nop
        str[0] = '0';
c0001410:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001413:	ba 30 00 00 00       	mov    $0x30,%edx
c0001418:	66 89 10             	mov    %dx,(%eax)
}
c000141b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000141e:	83 c4 08             	add    $0x8,%esp
c0001421:	5b                   	pop    %ebx
c0001422:	5e                   	pop    %esi
c0001423:	5f                   	pop    %edi
c0001424:	5d                   	pop    %ebp
c0001425:	c3                   	ret    
c0001426:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000142d:	8d 76 00             	lea    0x0(%esi),%esi
        return NULL;
c0001430:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
}
c0001437:	8b 45 0c             	mov    0xc(%ebp),%eax
c000143a:	83 c4 08             	add    $0x8,%esp
c000143d:	5b                   	pop    %ebx
c000143e:	5e                   	pop    %esi
c000143f:	5f                   	pop    %edi
c0001440:	5d                   	pop    %ebp
c0001441:	c3                   	ret    
c0001442:	66 90                	xchg   %ax,%ax
c0001444:	66 90                	xchg   %ax,%ax
c0001446:	66 90                	xchg   %ax,%ax
c0001448:	66 90                	xchg   %ax,%ax
c000144a:	66 90                	xchg   %ax,%ax
c000144c:	66 90                	xchg   %ax,%ax
c000144e:	66 90                	xchg   %ax,%ax

c0001450 <memory_table>:
#include "multiboot.h"
#include "kprintf.h"

size_t memory_table(multiboot_info_t* mbd)
{
c0001450:	55                   	push   %ebp
c0001451:	89 e5                	mov    %esp,%ebp
c0001453:	56                   	push   %esi
c0001454:	8b 55 08             	mov    0x8(%ebp),%edx
c0001457:	53                   	push   %ebx
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
    size_t available_mem = 0;
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001458:	8b 5a 2c             	mov    0x2c(%edx),%ebx
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c000145b:	8b 42 30             	mov    0x30(%edx),%eax
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c000145e:	85 db                	test   %ebx,%ebx
c0001460:	74 35                	je     c0001497 <memory_table+0x47>
c0001462:	8d 14 5b             	lea    (%ebx,%ebx,2),%edx
    size_t available_mem = 0;
c0001465:	31 db                	xor    %ebx,%ebx
c0001467:	8d 0c d0             	lea    (%eax,%edx,8),%ecx
c000146a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	{
		if(mmap_table[nn].len>0 && mmap_table[nn].size>0)
c0001470:	8b 50 0c             	mov    0xc(%eax),%edx
c0001473:	89 d6                	mov    %edx,%esi
c0001475:	0b 70 10             	or     0x10(%eax),%esi
c0001478:	74 16                	je     c0001490 <memory_table+0x40>
c000147a:	8b 30                	mov    (%eax),%esi
c000147c:	85 f6                	test   %esi,%esi
c000147e:	74 10                	je     c0001490 <memory_table+0x40>
        {
            if(mmap_table[nn].type == 1)
c0001480:	83 78 14 01          	cmpl   $0x1,0x14(%eax)
c0001484:	75 0a                	jne    c0001490 <memory_table+0x40>
            available_mem += mmap_table[nn].len;
c0001486:	01 d3                	add    %edx,%ebx
c0001488:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000148f:	90                   	nop
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001490:	83 c0 18             	add    $0x18,%eax
c0001493:	39 c8                	cmp    %ecx,%eax
c0001495:	75 d9                	jne    c0001470 <memory_table+0x20>
        }
		
	}

    return available_mem;
}
c0001497:	89 d8                	mov    %ebx,%eax
c0001499:	5b                   	pop    %ebx
c000149a:	5e                   	pop    %esi
c000149b:	5d                   	pop    %ebp
c000149c:	c3                   	ret    
c000149d:	8d 76 00             	lea    0x0(%esi),%esi

c00014a0 <print_memory_table>:

int print_memory_table(multiboot_info_t* mbd)
{
c00014a0:	55                   	push   %ebp
c00014a1:	89 e5                	mov    %esp,%ebp
c00014a3:	57                   	push   %edi
c00014a4:	56                   	push   %esi
c00014a5:	53                   	push   %ebx
c00014a6:	83 ec 28             	sub    $0x28,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c00014a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00014ac:	8b 78 30             	mov    0x30(%eax),%edi
	kprintf("Memory Table:\n");
c00014af:	68 85 33 00 c0       	push   $0xc0003385
c00014b4:	e8 d7 ec ff ff       	call   c0000190 <kprintf>
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c00014b9:	8b 45 08             	mov    0x8(%ebp),%eax
c00014bc:	83 c4 10             	add    $0x10,%esp
c00014bf:	8b 50 2c             	mov    0x2c(%eax),%edx
c00014c2:	85 d2                	test   %edx,%edx
c00014c4:	0f 84 8f 00 00 00    	je     c0001559 <print_memory_table+0xb9>
c00014ca:	31 f6                	xor    %esi,%esi
c00014cc:	eb 2a                	jmp    c00014f8 <print_memory_table+0x58>
c00014ce:	66 90                	xchg   %ax,%ax
		if(mmap_table[nn].len>0)
		{
			if(mmap_table[nn].type == MULTIBOOT_MEMORY_AVAILABLE)
				kprintf("%.8llp - %.8llp [AVAILABLE] (%6llu kiB)\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
			else
				kprintf("%.8llp - %.8llp [RESERVED]\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c00014d0:	83 ec 04             	sub    $0x4,%esp
c00014d3:	ff 75 e4             	pushl  -0x1c(%ebp)
c00014d6:	ff 75 e0             	pushl  -0x20(%ebp)
c00014d9:	52                   	push   %edx
c00014da:	50                   	push   %eax
c00014db:	53                   	push   %ebx
c00014dc:	51                   	push   %ecx
c00014dd:	68 94 33 00 c0       	push   $0xc0003394
c00014e2:	e8 a9 ec ff ff       	call   c0000190 <kprintf>
c00014e7:	83 c4 20             	add    $0x20,%esp
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c00014ea:	8b 45 08             	mov    0x8(%ebp),%eax
c00014ed:	83 c6 01             	add    $0x1,%esi
c00014f0:	83 c7 18             	add    $0x18,%edi
c00014f3:	39 70 2c             	cmp    %esi,0x2c(%eax)
c00014f6:	76 61                	jbe    c0001559 <print_memory_table+0xb9>
        if(mmap_table[nn].size == 0)
c00014f8:	8b 07                	mov    (%edi),%eax
c00014fa:	85 c0                	test   %eax,%eax
c00014fc:	74 5b                	je     c0001559 <print_memory_table+0xb9>
		if(mmap_table[nn].len>0)
c00014fe:	8b 57 10             	mov    0x10(%edi),%edx
c0001501:	8b 47 0c             	mov    0xc(%edi),%eax
c0001504:	89 d3                	mov    %edx,%ebx
c0001506:	89 c1                	mov    %eax,%ecx
c0001508:	09 c3                	or     %eax,%ebx
c000150a:	74 de                	je     c00014ea <print_memory_table+0x4a>
				kprintf("%.8llp - %.8llp [AVAILABLE] (%6llu kiB)\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c000150c:	89 d3                	mov    %edx,%ebx
c000150e:	0f ac d9 0a          	shrd   $0xa,%ebx,%ecx
c0001512:	c1 eb 0a             	shr    $0xa,%ebx
c0001515:	89 4d e0             	mov    %ecx,-0x20(%ebp)
c0001518:	8b 4f 04             	mov    0x4(%edi),%ecx
c000151b:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
c000151e:	8b 5f 08             	mov    0x8(%edi),%ebx
c0001521:	01 c8                	add    %ecx,%eax
c0001523:	11 da                	adc    %ebx,%edx
c0001525:	83 c0 ff             	add    $0xffffffff,%eax
c0001528:	83 d2 ff             	adc    $0xffffffff,%edx
			if(mmap_table[nn].type == MULTIBOOT_MEMORY_AVAILABLE)
c000152b:	83 7f 14 01          	cmpl   $0x1,0x14(%edi)
c000152f:	75 9f                	jne    c00014d0 <print_memory_table+0x30>
				kprintf("%.8llp - %.8llp [AVAILABLE] (%6llu kiB)\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c0001531:	83 ec 04             	sub    $0x4,%esp
c0001534:	ff 75 e4             	pushl  -0x1c(%ebp)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001537:	83 c6 01             	add    $0x1,%esi
c000153a:	83 c7 18             	add    $0x18,%edi
				kprintf("%.8llp - %.8llp [AVAILABLE] (%6llu kiB)\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c000153d:	ff 75 e0             	pushl  -0x20(%ebp)
c0001540:	52                   	push   %edx
c0001541:	50                   	push   %eax
c0001542:	53                   	push   %ebx
c0001543:	51                   	push   %ecx
c0001544:	68 70 34 00 c0       	push   $0xc0003470
c0001549:	e8 42 ec ff ff       	call   c0000190 <kprintf>
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c000154e:	8b 45 08             	mov    0x8(%ebp),%eax
c0001551:	83 c4 20             	add    $0x20,%esp
c0001554:	39 70 2c             	cmp    %esi,0x2c(%eax)
c0001557:	77 9f                	ja     c00014f8 <print_memory_table+0x58>
	// }

    // print_crs();

    return 0;
}
c0001559:	8d 65 f4             	lea    -0xc(%ebp),%esp
c000155c:	31 c0                	xor    %eax,%eax
c000155e:	5b                   	pop    %ebx
c000155f:	5e                   	pop    %esi
c0001560:	5f                   	pop    %edi
c0001561:	5d                   	pop    %ebp
c0001562:	c3                   	ret    
c0001563:	66 90                	xchg   %ax,%ax
c0001565:	66 90                	xchg   %ax,%ax
c0001567:	66 90                	xchg   %ax,%ax
c0001569:	66 90                	xchg   %ax,%ax
c000156b:	66 90                	xchg   %ax,%ax
c000156d:	66 90                	xchg   %ax,%ax
c000156f:	90                   	nop

c0001570 <init_interrupts>:
}

inline void
outb (unsigned char __value, unsigned short int __port)
{
  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
c0001570:	b8 11 00 00 00       	mov    $0x11,%eax
c0001575:	e6 20                	out    %al,$0x20
c0001577:	e6 a0                	out    %al,$0xa0
c0001579:	b8 20 00 00 00       	mov    $0x20,%eax
c000157e:	e6 21                	out    %al,$0x21
c0001580:	b8 28 00 00 00       	mov    $0x28,%eax
c0001585:	e6 a1                	out    %al,$0xa1
c0001587:	b8 04 00 00 00       	mov    $0x4,%eax
c000158c:	e6 21                	out    %al,$0x21
c000158e:	b8 02 00 00 00       	mov    $0x2,%eax
c0001593:	e6 a1                	out    %al,$0xa1
c0001595:	b8 01 00 00 00       	mov    $0x1,%eax
c000159a:	e6 21                	out    %al,$0x21
c000159c:	e6 a1                	out    %al,$0xa1
c000159e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
c00015a3:	e6 21                	out    %al,$0x21
c00015a5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00015aa:	e6 a1                	out    %al,$0xa1
    load_idt();
}

void set_interrupt_handler(int int_num, void* handler)
{
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c00015ac:	b8 2c 2a 00 c0       	mov    $0xc0002a2c,%eax
	idt[int_num].segment = KERNEL_CODE_SEGMENT;
c00015b1:	ba 08 00 00 00       	mov    $0x8,%edx
c00015b6:	c7 05 22 b0 00 c0 08 	movl   $0x8e000008,0xc000b022
c00015bd:	00 00 8e 
	idt[int_num].zero = 0;
c00015c0:	b9 00 8e ff ff       	mov    $0xffff8e00,%ecx
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c00015c5:	66 a3 20 b0 00 c0    	mov    %ax,0xc000b020
	idt[int_num].type = 0x8e; /* INTERRUPT_GATE */
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c00015cb:	c1 e8 10             	shr    $0x10,%eax
c00015ce:	66 a3 26 b0 00 c0    	mov    %ax,0xc000b026
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c00015d4:	b8 44 2a 00 c0       	mov    $0xc0002a44,%eax
c00015d9:	66 a3 28 b0 00 c0    	mov    %ax,0xc000b028
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c00015df:	c1 e8 10             	shr    $0x10,%eax
c00015e2:	66 a3 2e b0 00 c0    	mov    %ax,0xc000b02e
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c00015e8:	b8 5c 2a 00 c0       	mov    $0xc0002a5c,%eax
c00015ed:	66 a3 30 b0 00 c0    	mov    %ax,0xc000b030
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c00015f3:	c1 e8 10             	shr    $0x10,%eax
c00015f6:	66 a3 36 b0 00 c0    	mov    %ax,0xc000b036
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c00015fc:	b8 74 2a 00 c0       	mov    $0xc0002a74,%eax
c0001601:	66 a3 38 b0 00 c0    	mov    %ax,0xc000b038
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c0001607:	c1 e8 10             	shr    $0x10,%eax
c000160a:	66 a3 3e b0 00 c0    	mov    %ax,0xc000b03e
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c0001610:	b8 8c 2a 00 c0       	mov    $0xc0002a8c,%eax
c0001615:	66 a3 40 b0 00 c0    	mov    %ax,0xc000b040
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c000161b:	c1 e8 10             	shr    $0x10,%eax
c000161e:	66 a3 46 b0 00 c0    	mov    %ax,0xc000b046
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c0001624:	b8 a4 2a 00 c0       	mov    $0xc0002aa4,%eax
c0001629:	66 a3 48 b0 00 c0    	mov    %ax,0xc000b048
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c000162f:	c1 e8 10             	shr    $0x10,%eax
c0001632:	66 a3 4e b0 00 c0    	mov    %ax,0xc000b04e
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c0001638:	b8 bc 2a 00 c0       	mov    $0xc0002abc,%eax
c000163d:	66 a3 50 b0 00 c0    	mov    %ax,0xc000b050
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c0001643:	c1 e8 10             	shr    $0x10,%eax
c0001646:	66 a3 56 b0 00 c0    	mov    %ax,0xc000b056
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c000164c:	b8 d4 2a 00 c0       	mov    $0xc0002ad4,%eax
c0001651:	66 a3 58 b0 00 c0    	mov    %ax,0xc000b058
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c0001657:	c1 e8 10             	shr    $0x10,%eax
c000165a:	66 a3 5e b0 00 c0    	mov    %ax,0xc000b05e
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c0001660:	b8 ec 2a 00 c0       	mov    $0xc0002aec,%eax
c0001665:	66 a3 60 b0 00 c0    	mov    %ax,0xc000b060
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c000166b:	c1 e8 10             	shr    $0x10,%eax
c000166e:	66 a3 66 b0 00 c0    	mov    %ax,0xc000b066
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c0001674:	b8 08 2b 00 c0       	mov    $0xc0002b08,%eax
c0001679:	66 a3 70 b0 00 c0    	mov    %ax,0xc000b070
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c000167f:	c1 e8 10             	shr    $0x10,%eax
c0001682:	66 a3 76 b0 00 c0    	mov    %ax,0xc000b076
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c0001688:	b8 24 2b 00 c0       	mov    $0xc0002b24,%eax
c000168d:	66 a3 78 b0 00 c0    	mov    %ax,0xc000b078
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c0001693:	c1 e8 10             	shr    $0x10,%eax
	idt[int_num].segment = KERNEL_CODE_SEGMENT;
c0001696:	c7 05 2a b0 00 c0 08 	movl   $0x8e000008,0xc000b02a
c000169d:	00 00 8e 
c00016a0:	c7 05 32 b0 00 c0 08 	movl   $0x8e000008,0xc000b032
c00016a7:	00 00 8e 
c00016aa:	c7 05 3a b0 00 c0 08 	movl   $0x8e000008,0xc000b03a
c00016b1:	00 00 8e 
c00016b4:	c7 05 42 b0 00 c0 08 	movl   $0x8e000008,0xc000b042
c00016bb:	00 00 8e 
c00016be:	c7 05 4a b0 00 c0 08 	movl   $0x8e000008,0xc000b04a
c00016c5:	00 00 8e 
c00016c8:	c7 05 52 b0 00 c0 08 	movl   $0x8e000008,0xc000b052
c00016cf:	00 00 8e 
c00016d2:	c7 05 5a b0 00 c0 08 	movl   $0x8e000008,0xc000b05a
c00016d9:	00 00 8e 
c00016dc:	c7 05 62 b0 00 c0 08 	movl   $0x8e000008,0xc000b062
c00016e3:	00 00 8e 
c00016e6:	c7 05 72 b0 00 c0 08 	movl   $0x8e000008,0xc000b072
c00016ed:	00 00 8e 
c00016f0:	c7 05 7a b0 00 c0 08 	movl   $0x8e000008,0xc000b07a
c00016f7:	00 00 8e 
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c00016fa:	66 a3 7e b0 00 c0    	mov    %ax,0xc000b07e
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c0001700:	b8 40 2b 00 c0       	mov    $0xc0002b40,%eax
c0001705:	66 a3 80 b0 00 c0    	mov    %ax,0xc000b080
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c000170b:	c1 e8 10             	shr    $0x10,%eax
c000170e:	66 a3 86 b0 00 c0    	mov    %ax,0xc000b086
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c0001714:	b8 5c 2b 00 c0       	mov    $0xc0002b5c,%eax
c0001719:	66 a3 88 b0 00 c0    	mov    %ax,0xc000b088
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c000171f:	c1 e8 10             	shr    $0x10,%eax
c0001722:	66 a3 8e b0 00 c0    	mov    %ax,0xc000b08e
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c0001728:	b8 78 2b 00 c0       	mov    $0xc0002b78,%eax
c000172d:	66 a3 90 b0 00 c0    	mov    %ax,0xc000b090
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c0001733:	c1 e8 10             	shr    $0x10,%eax
c0001736:	66 a3 96 b0 00 c0    	mov    %ax,0xc000b096
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c000173c:	b8 94 2b 00 c0       	mov    $0xc0002b94,%eax
c0001741:	66 a3 a0 b0 00 c0    	mov    %ax,0xc000b0a0
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c0001747:	c1 e8 10             	shr    $0x10,%eax
c000174a:	66 a3 a6 b0 00 c0    	mov    %ax,0xc000b0a6
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c0001750:	b8 b0 2b 00 c0       	mov    $0xc0002bb0,%eax
c0001755:	66 a3 a8 b0 00 c0    	mov    %ax,0xc000b0a8
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c000175b:	c1 e8 10             	shr    $0x10,%eax
c000175e:	66 a3 ae b0 00 c0    	mov    %ax,0xc000b0ae
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c0001764:	b8 cc 2b 00 c0       	mov    $0xc0002bcc,%eax
c0001769:	66 a3 b0 b0 00 c0    	mov    %ax,0xc000b0b0
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c000176f:	c1 e8 10             	shr    $0x10,%eax
c0001772:	66 a3 b6 b0 00 c0    	mov    %ax,0xc000b0b6
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c0001778:	b8 e8 2b 00 c0       	mov    $0xc0002be8,%eax
c000177d:	66 a3 b8 b0 00 c0    	mov    %ax,0xc000b0b8
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c0001783:	c1 e8 10             	shr    $0x10,%eax
c0001786:	66 a3 be b0 00 c0    	mov    %ax,0xc000b0be
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c000178c:	b8 04 2c 00 c0       	mov    $0xc0002c04,%eax
c0001791:	66 a3 c0 b0 00 c0    	mov    %ax,0xc000b0c0
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c0001797:	c1 e8 10             	shr    $0x10,%eax
c000179a:	66 a3 c6 b0 00 c0    	mov    %ax,0xc000b0c6
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c00017a0:	b8 20 2c 00 c0       	mov    $0xc0002c20,%eax
c00017a5:	66 a3 10 b1 00 c0    	mov    %ax,0xc000b110
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c00017ab:	c1 e8 10             	shr    $0x10,%eax
c00017ae:	66 a3 16 b1 00 c0    	mov    %ax,0xc000b116
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c00017b4:	b8 3c 2c 00 c0       	mov    $0xc0002c3c,%eax
c00017b9:	66 a3 20 b1 00 c0    	mov    %ax,0xc000b120
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c00017bf:	c1 e8 10             	shr    $0x10,%eax
c00017c2:	66 a3 26 b1 00 c0    	mov    %ax,0xc000b126
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c00017c8:	b8 50 2c 00 c0       	mov    $0xc0002c50,%eax
c00017cd:	66 a3 28 b1 00 c0    	mov    %ax,0xc000b128
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c00017d3:	c1 e8 10             	shr    $0x10,%eax
	idt[int_num].segment = KERNEL_CODE_SEGMENT;
c00017d6:	c7 05 82 b0 00 c0 08 	movl   $0x8e000008,0xc000b082
c00017dd:	00 00 8e 
c00017e0:	c7 05 8a b0 00 c0 08 	movl   $0x8e000008,0xc000b08a
c00017e7:	00 00 8e 
c00017ea:	c7 05 92 b0 00 c0 08 	movl   $0x8e000008,0xc000b092
c00017f1:	00 00 8e 
c00017f4:	c7 05 a2 b0 00 c0 08 	movl   $0x8e000008,0xc000b0a2
c00017fb:	00 00 8e 
c00017fe:	c7 05 aa b0 00 c0 08 	movl   $0x8e000008,0xc000b0aa
c0001805:	00 00 8e 
c0001808:	c7 05 b2 b0 00 c0 08 	movl   $0x8e000008,0xc000b0b2
c000180f:	00 00 8e 
c0001812:	c7 05 ba b0 00 c0 08 	movl   $0x8e000008,0xc000b0ba
c0001819:	00 00 8e 
c000181c:	c7 05 c2 b0 00 c0 08 	movl   $0x8e000008,0xc000b0c2
c0001823:	00 00 8e 
c0001826:	c7 05 12 b1 00 c0 08 	movl   $0x8e000008,0xc000b112
c000182d:	00 00 8e 
c0001830:	c7 05 22 b1 00 c0 08 	movl   $0x8e000008,0xc000b122
c0001837:	00 00 8e 
c000183a:	c7 05 2a b1 00 c0 08 	movl   $0x8e000008,0xc000b12a
c0001841:	00 00 8e 
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c0001844:	66 a3 2e b1 00 c0    	mov    %ax,0xc000b12e
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c000184a:	b8 64 2c 00 c0       	mov    $0xc0002c64,%eax
c000184f:	66 a3 30 b1 00 c0    	mov    %ax,0xc000b130
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c0001855:	c1 e8 10             	shr    $0x10,%eax
c0001858:	66 a3 36 b1 00 c0    	mov    %ax,0xc000b136
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c000185e:	b8 78 2c 00 c0       	mov    $0xc0002c78,%eax
c0001863:	66 a3 38 b1 00 c0    	mov    %ax,0xc000b138
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c0001869:	c1 e8 10             	shr    $0x10,%eax
c000186c:	66 a3 3e b1 00 c0    	mov    %ax,0xc000b13e
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c0001872:	b8 8c 2c 00 c0       	mov    $0xc0002c8c,%eax
c0001877:	66 a3 40 b1 00 c0    	mov    %ax,0xc000b140
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c000187d:	c1 e8 10             	shr    $0x10,%eax
c0001880:	66 a3 46 b1 00 c0    	mov    %ax,0xc000b146
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c0001886:	b8 a0 2c 00 c0       	mov    $0xc0002ca0,%eax
c000188b:	66 a3 48 b1 00 c0    	mov    %ax,0xc000b148
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c0001891:	c1 e8 10             	shr    $0x10,%eax
c0001894:	66 a3 4e b1 00 c0    	mov    %ax,0xc000b14e
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c000189a:	b8 b4 2c 00 c0       	mov    $0xc0002cb4,%eax
c000189f:	66 a3 50 b1 00 c0    	mov    %ax,0xc000b150
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c00018a5:	c1 e8 10             	shr    $0x10,%eax
c00018a8:	66 a3 56 b1 00 c0    	mov    %ax,0xc000b156
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c00018ae:	b8 c8 2c 00 c0       	mov    $0xc0002cc8,%eax
c00018b3:	66 a3 58 b1 00 c0    	mov    %ax,0xc000b158
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c00018b9:	c1 e8 10             	shr    $0x10,%eax
c00018bc:	66 a3 5e b1 00 c0    	mov    %ax,0xc000b15e
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c00018c2:	b8 dc 2c 00 c0       	mov    $0xc0002cdc,%eax
c00018c7:	66 a3 60 b1 00 c0    	mov    %ax,0xc000b160
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c00018cd:	c1 e8 10             	shr    $0x10,%eax
c00018d0:	66 a3 66 b1 00 c0    	mov    %ax,0xc000b166
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c00018d6:	b8 f0 2c 00 c0       	mov    $0xc0002cf0,%eax
c00018db:	66 a3 68 b1 00 c0    	mov    %ax,0xc000b168
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c00018e1:	c1 e8 10             	shr    $0x10,%eax
c00018e4:	66 a3 6e b1 00 c0    	mov    %ax,0xc000b16e
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c00018ea:	b8 04 2d 00 c0       	mov    $0xc0002d04,%eax
c00018ef:	66 a3 70 b1 00 c0    	mov    %ax,0xc000b170
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c00018f5:	c1 e8 10             	shr    $0x10,%eax
c00018f8:	66 a3 76 b1 00 c0    	mov    %ax,0xc000b176
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c00018fe:	b8 18 2d 00 c0       	mov    $0xc0002d18,%eax
c0001903:	66 a3 78 b1 00 c0    	mov    %ax,0xc000b178
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c0001909:	c1 e8 10             	shr    $0x10,%eax
c000190c:	66 a3 7e b1 00 c0    	mov    %ax,0xc000b17e
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c0001912:	b8 2c 2d 00 c0       	mov    $0xc0002d2c,%eax
c0001917:	66 a3 80 b1 00 c0    	mov    %ax,0xc000b180
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c000191d:	c1 e8 10             	shr    $0x10,%eax
	idt[int_num].segment = KERNEL_CODE_SEGMENT;
c0001920:	c7 05 32 b1 00 c0 08 	movl   $0x8e000008,0xc000b132
c0001927:	00 00 8e 
c000192a:	c7 05 3a b1 00 c0 08 	movl   $0x8e000008,0xc000b13a
c0001931:	00 00 8e 
c0001934:	c7 05 42 b1 00 c0 08 	movl   $0x8e000008,0xc000b142
c000193b:	00 00 8e 
c000193e:	66 89 15 4a b1 00 c0 	mov    %dx,0xc000b14a
	idt[int_num].zero = 0;
c0001945:	66 89 0d 4c b1 00 c0 	mov    %cx,0xc000b14c
	idt[int_num].segment = KERNEL_CODE_SEGMENT;
c000194c:	c7 05 52 b1 00 c0 08 	movl   $0x8e000008,0xc000b152
c0001953:	00 00 8e 
c0001956:	c7 05 5a b1 00 c0 08 	movl   $0x8e000008,0xc000b15a
c000195d:	00 00 8e 
c0001960:	c7 05 62 b1 00 c0 08 	movl   $0x8e000008,0xc000b162
c0001967:	00 00 8e 
c000196a:	c7 05 6a b1 00 c0 08 	movl   $0x8e000008,0xc000b16a
c0001971:	00 00 8e 
c0001974:	c7 05 72 b1 00 c0 08 	movl   $0x8e000008,0xc000b172
c000197b:	00 00 8e 
c000197e:	c7 05 7a b1 00 c0 08 	movl   $0x8e000008,0xc000b17a
c0001985:	00 00 8e 
c0001988:	c7 05 82 b1 00 c0 08 	movl   $0x8e000008,0xc000b182
c000198f:	00 00 8e 
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c0001992:	66 a3 86 b1 00 c0    	mov    %ax,0xc000b186
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c0001998:	b8 40 2d 00 c0       	mov    $0xc0002d40,%eax
c000199d:	66 a3 88 b1 00 c0    	mov    %ax,0xc000b188
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c00019a3:	c1 e8 10             	shr    $0x10,%eax
c00019a6:	66 a3 8e b1 00 c0    	mov    %ax,0xc000b18e
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c00019ac:	b8 54 2d 00 c0       	mov    $0xc0002d54,%eax
c00019b1:	66 a3 90 b1 00 c0    	mov    %ax,0xc000b190
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c00019b7:	c1 e8 10             	shr    $0x10,%eax
c00019ba:	66 a3 96 b1 00 c0    	mov    %ax,0xc000b196
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c00019c0:	b8 68 2d 00 c0       	mov    $0xc0002d68,%eax
c00019c5:	66 a3 98 b1 00 c0    	mov    %ax,0xc000b198
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c00019cb:	c1 e8 10             	shr    $0x10,%eax
c00019ce:	66 a3 9e b1 00 c0    	mov    %ax,0xc000b19e
    idtd.limit = sizeof(idt_entry_t) * NUM_INTERRUPT_HANDLERS - 1;
c00019d4:	b8 ff 07 00 00       	mov    $0x7ff,%eax
	idt[int_num].segment = KERNEL_CODE_SEGMENT;
c00019d9:	c7 05 8a b1 00 c0 08 	movl   $0x8e000008,0xc000b18a
c00019e0:	00 00 8e 
c00019e3:	c7 05 92 b1 00 c0 08 	movl   $0x8e000008,0xc000b192
c00019ea:	00 00 8e 
c00019ed:	c7 05 9a b1 00 c0 08 	movl   $0x8e000008,0xc000b19a
c00019f4:	00 00 8e 
    idtd.base = (uint32_t) idt;
c00019f7:	c7 05 02 b0 00 c0 20 	movl   $0xc000b020,0xc000b002
c00019fe:	b0 00 c0 
    idtd.limit = sizeof(idt_entry_t) * NUM_INTERRUPT_HANDLERS - 1;
c0001a01:	66 a3 00 b0 00 c0    	mov    %ax,0xc000b000
    load_idt();
c0001a07:	e9 14 10 00 00       	jmp    c0002a20 <load_idt>
c0001a0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

c0001a10 <set_interrupt_handler>:
{
c0001a10:	55                   	push   %ebp
c0001a11:	89 e5                	mov    %esp,%ebp
c0001a13:	8b 55 08             	mov    0x8(%ebp),%edx
c0001a16:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c0001a19:	5d                   	pop    %ebp
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c0001a1a:	66 89 04 d5 20 b0 00 	mov    %ax,-0x3fff4fe0(,%edx,8)
c0001a21:	c0 
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c0001a22:	c1 e8 10             	shr    $0x10,%eax
	idt[int_num].segment = KERNEL_CODE_SEGMENT;
c0001a25:	c7 04 d5 22 b0 00 c0 	movl   $0x8e000008,-0x3fff4fde(,%edx,8)
c0001a2c:	08 00 00 8e 
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c0001a30:	66 89 04 d5 26 b0 00 	mov    %ax,-0x3fff4fda(,%edx,8)
c0001a37:	c0 
}
c0001a38:	c3                   	ret    
c0001a39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

c0001a40 <exception_handler>:

void exception_handler(uint32_t exception_num, uint32_t code)
{
c0001a40:	55                   	push   %ebp
c0001a41:	89 e5                	mov    %esp,%ebp
c0001a43:	83 ec 0c             	sub    $0xc,%esp
    kprintf("Exception %u with code %u\n", exception_num, code);
c0001a46:	ff 75 0c             	pushl  0xc(%ebp)
c0001a49:	ff 75 08             	pushl  0x8(%ebp)
c0001a4c:	68 b0 33 00 c0       	push   $0xc00033b0
c0001a51:	e8 3a e7 ff ff       	call   c0000190 <kprintf>
}
c0001a56:	83 c4 10             	add    $0x10,%esp
c0001a59:	c9                   	leave  
c0001a5a:	c3                   	ret    
c0001a5b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c0001a5f:	90                   	nop

c0001a60 <irq_handler>:

void irq_handler(uint32_t irq_num)
{
c0001a60:	55                   	push   %ebp
c0001a61:	89 e5                	mov    %esp,%ebp
c0001a63:	83 ec 08             	sub    $0x8,%esp
c0001a66:	8b 45 08             	mov    0x8(%ebp),%eax
    if(irq_num == 1)
c0001a69:	83 f8 01             	cmp    $0x1,%eax
c0001a6c:	74 22                	je     c0001a90 <irq_handler+0x30>
            kprint_char(key_ascii);
    
    }

    // notify PIC that interrupt handling is complete
    if(irq_num >= 8)
c0001a6e:	83 f8 07             	cmp    $0x7,%eax
c0001a71:	76 07                	jbe    c0001a7a <irq_handler+0x1a>
c0001a73:	b8 20 00 00 00       	mov    $0x20,%eax
c0001a78:	e6 a0                	out    %al,$0xa0
c0001a7a:	b8 20 00 00 00       	mov    $0x20,%eax
c0001a7f:	e6 20                	out    %al,$0x20
        outb(PIC_EOI, PIC2_CMD);

    outb(PIC_EOI, PIC1_CMD);

    return;
}
c0001a81:	c9                   	leave  
c0001a82:	c3                   	ret    
c0001a83:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001a8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  __asm__ __volatile__ ("inb %w1,%0":"=a" (_v):"Nd" (__port));
c0001a90:	e4 60                	in     $0x60,%al
        char key_ascii = scancode_to_ascii(scan_code);
c0001a92:	83 ec 0c             	sub    $0xc,%esp
c0001a95:	0f b6 c0             	movzbl %al,%eax
c0001a98:	50                   	push   %eax
c0001a99:	e8 02 0e 00 00       	call   c00028a0 <scancode_to_ascii>
        if(key_ascii>0)
c0001a9e:	83 c4 10             	add    $0x10,%esp
c0001aa1:	84 c0                	test   %al,%al
c0001aa3:	7e d5                	jle    c0001a7a <irq_handler+0x1a>
            kprint_char(key_ascii);
c0001aa5:	83 ec 0c             	sub    $0xc,%esp
c0001aa8:	0f be c0             	movsbl %al,%eax
c0001aab:	50                   	push   %eax
c0001aac:	e8 9f e5 ff ff       	call   c0000050 <kprint_char>
c0001ab1:	83 c4 10             	add    $0x10,%esp
c0001ab4:	eb c4                	jmp    c0001a7a <irq_handler+0x1a>
c0001ab6:	66 90                	xchg   %ax,%ax
c0001ab8:	66 90                	xchg   %ax,%ax
c0001aba:	66 90                	xchg   %ax,%ax
c0001abc:	66 90                	xchg   %ax,%ax
c0001abe:	66 90                	xchg   %ax,%ax

c0001ac0 <terminal_init>:
#include "io.h"

struct terminal stdout;

void terminal_init(struct terminal* term) 
{
c0001ac0:	55                   	push   %ebp
	term->row = 0;
	term->column = 0;
	term->color = vga_entry_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
	term->buffer = (uint16_t*) VGA_BUFFER;
c0001ac1:	ba a0 80 0b 00       	mov    $0xb80a0,%edx
{
c0001ac6:	89 e5                	mov    %esp,%ebp
c0001ac8:	8b 45 08             	mov    0x8(%ebp),%eax
	term->row = 0;
c0001acb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	term->column = 0;
c0001ad1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	term->color = vga_entry_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
c0001ad8:	c6 40 08 07          	movb   $0x7,0x8(%eax)
	term->buffer = (uint16_t*) VGA_BUFFER;
c0001adc:	c7 40 0c 00 80 0b 00 	movl   $0xb8000,0xc(%eax)
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
c0001ae3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001aea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		for (size_t x = 0; x < VGA_WIDTH; x++) {
c0001af0:	8d 82 60 ff ff ff    	lea    -0xa0(%edx),%eax
c0001af6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001afd:	8d 76 00             	lea    0x0(%esi),%esi
			const size_t index = y * VGA_WIDTH + x;
			term->buffer[index] = vga_entry(' ', term->color);
c0001b00:	b9 20 07 00 00       	mov    $0x720,%ecx
		for (size_t x = 0; x < VGA_WIDTH; x++) {
c0001b05:	83 c0 02             	add    $0x2,%eax
			term->buffer[index] = vga_entry(' ', term->color);
c0001b08:	66 89 48 fe          	mov    %cx,-0x2(%eax)
		for (size_t x = 0; x < VGA_WIDTH; x++) {
c0001b0c:	39 d0                	cmp    %edx,%eax
c0001b0e:	75 f0                	jne    c0001b00 <terminal_init+0x40>
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
c0001b10:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c0001b16:	3d a0 8f 0b 00       	cmp    $0xb8fa0,%eax
c0001b1b:	75 d3                	jne    c0001af0 <terminal_init+0x30>
  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
c0001b1d:	b8 0a 00 00 00       	mov    $0xa,%eax
c0001b22:	ba d4 03 00 00       	mov    $0x3d4,%edx
c0001b27:	ee                   	out    %al,(%dx)
c0001b28:	b8 20 00 00 00       	mov    $0x20,%eax
c0001b2d:	ba d5 03 00 00       	mov    $0x3d5,%edx
c0001b32:	ee                   	out    %al,(%dx)
	// outb(0x0A, 0x3D4);
	// outb((inb(0x3D5) & 0xC0) | cursor_start, 0x3D5);
 
	// outb(0x0B, 0x3D4);
	// outb((inb(0x3D5) & 0xE0) | cursor_end, 0x3D5);
}
c0001b33:	5d                   	pop    %ebp
c0001b34:	c3                   	ret    
c0001b35:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001b3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

c0001b40 <terminal_setcolor>:
 
void terminal_setcolor(struct terminal* term, uint8_t color) 
{
c0001b40:	55                   	push   %ebp
c0001b41:	89 e5                	mov    %esp,%ebp
	term->color = color;
c0001b43:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b46:	8b 55 0c             	mov    0xc(%ebp),%edx
c0001b49:	88 50 08             	mov    %dl,0x8(%eax)
}
c0001b4c:	5d                   	pop    %ebp
c0001b4d:	c3                   	ret    
c0001b4e:	66 90                	xchg   %ax,%ax

c0001b50 <terminal_putentryat>:
 
void terminal_putentryat(struct terminal* term, char c, uint8_t color, size_t x, size_t y) 
{
c0001b50:	55                   	push   %ebp
c0001b51:	89 e5                	mov    %esp,%ebp
c0001b53:	53                   	push   %ebx
	const size_t index = y * VGA_WIDTH + x;
	term->buffer[index] = vga_entry(c, color);
c0001b54:	8b 55 08             	mov    0x8(%ebp),%edx
{
c0001b57:	8b 45 18             	mov    0x18(%ebp),%eax
	term->buffer[index] = vga_entry(c, color);
c0001b5a:	8b 5a 0c             	mov    0xc(%edx),%ebx
c0001b5d:	0f b6 55 10          	movzbl 0x10(%ebp),%edx
c0001b61:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0001b64:	c1 e0 04             	shl    $0x4,%eax
c0001b67:	03 45 14             	add    0x14(%ebp),%eax
	return fg | bg << 4;
}
 
static inline uint16_t vga_entry(unsigned char uc, uint8_t color) 
{
	return (uint16_t) uc | (uint16_t) color << 8;
c0001b6a:	89 d1                	mov    %edx,%ecx
c0001b6c:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
c0001b70:	c1 e1 08             	shl    $0x8,%ecx
c0001b73:	09 ca                	or     %ecx,%edx
c0001b75:	66 89 14 43          	mov    %dx,(%ebx,%eax,2)
	// terminal_movecursor(term, x, y);
}
c0001b79:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0001b7c:	c9                   	leave  
c0001b7d:	c3                   	ret    
c0001b7e:	66 90                	xchg   %ax,%ax

c0001b80 <terminal_movecursor>:

void terminal_movecursor(struct terminal* term, size_t x, size_t y)
{
c0001b80:	55                   	push   %ebp
c0001b81:	b8 0f 00 00 00       	mov    $0xf,%eax
c0001b86:	89 e5                	mov    %esp,%ebp
c0001b88:	56                   	push   %esi
c0001b89:	be d4 03 00 00       	mov    $0x3d4,%esi
c0001b8e:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0001b91:	53                   	push   %ebx
c0001b92:	89 f2                	mov    %esi,%edx
	(void) term; //we are directly manipulating curser, so were arean't using the term struct

	uint16_t pos = y * VGA_WIDTH + x;
c0001b94:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c0001b97:	c1 e1 04             	shl    $0x4,%ecx
c0001b9a:	66 03 4d 0c          	add    0xc(%ebp),%cx
c0001b9e:	ee                   	out    %al,(%dx)
c0001b9f:	bb d5 03 00 00       	mov    $0x3d5,%ebx
c0001ba4:	89 c8                	mov    %ecx,%eax
c0001ba6:	89 da                	mov    %ebx,%edx
c0001ba8:	ee                   	out    %al,(%dx)
c0001ba9:	b8 0e 00 00 00       	mov    $0xe,%eax
c0001bae:	89 f2                	mov    %esi,%edx
c0001bb0:	ee                   	out    %al,(%dx)

	outb(0x0F, 0x3D4);
	outb((uint8_t) (pos & 0xFF), 0x3D5);
	outb(0x0E, 0x3D4);
	outb((uint8_t) ((pos >> 8) & 0xFF), 0x3D5);
c0001bb1:	89 c8                	mov    %ecx,%eax
c0001bb3:	89 da                	mov    %ebx,%edx
c0001bb5:	66 c1 e8 08          	shr    $0x8,%ax
c0001bb9:	ee                   	out    %al,(%dx)
}
c0001bba:	5b                   	pop    %ebx
c0001bbb:	5e                   	pop    %esi
c0001bbc:	5d                   	pop    %ebp
c0001bbd:	c3                   	ret    
c0001bbe:	66 90                	xchg   %ax,%ax

c0001bc0 <terminal_putcharn>:
	if (++term->column == VGA_WIDTH)
		terminal_newline(term);
}

void terminal_putcharn(struct terminal* term, char c, size_t repeat) 
{
c0001bc0:	55                   	push   %ebp
c0001bc1:	89 e5                	mov    %esp,%ebp
c0001bc3:	57                   	push   %edi
c0001bc4:	56                   	push   %esi
c0001bc5:	53                   	push   %ebx
c0001bc6:	83 ec 1c             	sub    $0x1c,%esp
c0001bc9:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
c0001bcd:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0001bd0:	88 45 e3             	mov    %al,-0x1d(%ebp)
c0001bd3:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
	for (size_t i = 0; i < repeat; i++)
c0001bd7:	8b 45 10             	mov    0x10(%ebp),%eax
c0001bda:	85 c0                	test   %eax,%eax
c0001bdc:	0f 84 c4 00 00 00    	je     c0001ca6 <terminal_putcharn+0xe6>
c0001be2:	31 ff                	xor    %edi,%edi
c0001be4:	eb 19                	jmp    c0001bff <terminal_putcharn+0x3f>
c0001be6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001bed:	8d 76 00             	lea    0x0(%esi),%esi
	if (++term->column == VGA_WIDTH)
c0001bf0:	89 43 04             	mov    %eax,0x4(%ebx)
	for (size_t i = 0; i < repeat; i++)
c0001bf3:	83 c7 01             	add    $0x1,%edi
c0001bf6:	39 7d 10             	cmp    %edi,0x10(%ebp)
c0001bf9:	0f 84 a7 00 00 00    	je     c0001ca6 <terminal_putcharn+0xe6>
}

void terminal_newline(struct terminal* term)
{
    term->column = 0;
    if (++term->row == VGA_HEIGHT)
c0001bff:	8b 03                	mov    (%ebx),%eax
	if(c == '\n')
c0001c01:	80 7d e3 0a          	cmpb   $0xa,-0x1d(%ebp)
    if (++term->row == VGA_HEIGHT)
c0001c05:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if(c == '\n')
c0001c08:	0f 84 a2 00 00 00    	je     c0001cb0 <terminal_putcharn+0xf0>
	term->buffer[index] = vga_entry(c, color);
c0001c0e:	8b 43 0c             	mov    0xc(%ebx),%eax
	terminal_putentryat(term, c, term->color, term->column, term->row);
c0001c11:	8b 73 04             	mov    0x4(%ebx),%esi
c0001c14:	0f b6 53 08          	movzbl 0x8(%ebx),%edx
	term->buffer[index] = vga_entry(c, color);
c0001c18:	89 c1                	mov    %eax,%ecx
c0001c1a:	89 45 dc             	mov    %eax,-0x24(%ebp)
c0001c1d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0001c20:	c1 e2 08             	shl    $0x8,%edx
c0001c23:	66 0b 55 e0          	or     -0x20(%ebp),%dx
c0001c27:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0001c2a:	c1 e0 04             	shl    $0x4,%eax
c0001c2d:	01 f0                	add    %esi,%eax
c0001c2f:	66 89 14 41          	mov    %dx,(%ecx,%eax,2)
	if (++term->column == VGA_WIDTH)
c0001c33:	8d 46 01             	lea    0x1(%esi),%eax
c0001c36:	83 fe 4f             	cmp    $0x4f,%esi
c0001c39:	75 b5                	jne    c0001bf0 <terminal_putcharn+0x30>
    if (++term->row == VGA_HEIGHT)
c0001c3b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    term->column = 0;
c0001c3e:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    if (++term->row == VGA_HEIGHT)
c0001c45:	83 c1 01             	add    $0x1,%ecx
c0001c48:	89 0b                	mov    %ecx,(%ebx)
c0001c4a:	83 f9 19             	cmp    $0x19,%ecx
c0001c4d:	75 a4                	jne    c0001bf3 <terminal_putcharn+0x33>
}

void terminal_scrollline(struct terminal* term)
{
	// copy rows 2 though N to rows 1 through N-1
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c0001c4f:	8b 75 dc             	mov    -0x24(%ebp),%esi
c0001c52:	83 ec 04             	sub    $0x4,%esp
c0001c55:	68 00 0f 00 00       	push   $0xf00
c0001c5a:	8d 86 a0 00 00 00    	lea    0xa0(%esi),%eax
c0001c60:	50                   	push   %eax
c0001c61:	56                   	push   %esi
c0001c62:	e8 b9 f5 ff ff       	call   c0001220 <memcpy>

void terminal_clearline(struct terminal* term)
{
	size_t row_start = term->row * VGA_WIDTH;
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001c67:	0f b6 53 08          	movzbl 0x8(%ebx),%edx
c0001c6b:	8b 4b 0c             	mov    0xc(%ebx),%ecx
c0001c6e:	83 c4 10             	add    $0x10,%esp
	term->row = VGA_HEIGHT-1;
c0001c71:	c7 03 18 00 00 00    	movl   $0x18,(%ebx)
c0001c77:	c1 e2 08             	shl    $0x8,%edx
c0001c7a:	8d 81 00 0f 00 00    	lea    0xf00(%ecx),%eax
c0001c80:	81 c1 a0 0f 00 00    	add    $0xfa0,%ecx
c0001c86:	83 ca 20             	or     $0x20,%edx
c0001c89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001c90:	66 89 10             	mov    %dx,(%eax)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c0001c93:	83 c0 02             	add    $0x2,%eax
c0001c96:	39 c8                	cmp    %ecx,%eax
c0001c98:	75 f6                	jne    c0001c90 <terminal_putcharn+0xd0>
	for (size_t i = 0; i < repeat; i++)
c0001c9a:	83 c7 01             	add    $0x1,%edi
c0001c9d:	39 7d 10             	cmp    %edi,0x10(%ebp)
c0001ca0:	0f 85 59 ff ff ff    	jne    c0001bff <terminal_putcharn+0x3f>
}
c0001ca6:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0001ca9:	5b                   	pop    %ebx
c0001caa:	5e                   	pop    %esi
c0001cab:	5f                   	pop    %edi
c0001cac:	5d                   	pop    %ebp
c0001cad:	c3                   	ret    
c0001cae:	66 90                	xchg   %ax,%ax
    if (++term->row == VGA_HEIGHT)
c0001cb0:	89 c1                	mov    %eax,%ecx
    term->column = 0;
c0001cb2:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    if (++term->row == VGA_HEIGHT)
c0001cb9:	83 c1 01             	add    $0x1,%ecx
c0001cbc:	89 0b                	mov    %ecx,(%ebx)
c0001cbe:	83 f9 19             	cmp    $0x19,%ecx
c0001cc1:	0f 85 2c ff ff ff    	jne    c0001bf3 <terminal_putcharn+0x33>
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c0001cc7:	8b 43 0c             	mov    0xc(%ebx),%eax
c0001cca:	83 ec 04             	sub    $0x4,%esp
c0001ccd:	68 00 0f 00 00       	push   $0xf00
c0001cd2:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c0001cd8:	52                   	push   %edx
c0001cd9:	50                   	push   %eax
c0001cda:	e8 41 f5 ff ff       	call   c0001220 <memcpy>
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001cdf:	0f b6 53 08          	movzbl 0x8(%ebx),%edx
c0001ce3:	8b 4b 0c             	mov    0xc(%ebx),%ecx
c0001ce6:	83 c4 10             	add    $0x10,%esp
	term->row = VGA_HEIGHT-1;
c0001ce9:	c7 03 18 00 00 00    	movl   $0x18,(%ebx)
c0001cef:	c1 e2 08             	shl    $0x8,%edx
c0001cf2:	8d 81 00 0f 00 00    	lea    0xf00(%ecx),%eax
c0001cf8:	81 c1 a0 0f 00 00    	add    $0xfa0,%ecx
c0001cfe:	83 ca 20             	or     $0x20,%edx
c0001d01:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001d08:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001d0f:	90                   	nop
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001d10:	66 89 10             	mov    %dx,(%eax)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c0001d13:	83 c0 02             	add    $0x2,%eax
c0001d16:	39 c8                	cmp    %ecx,%eax
c0001d18:	75 f6                	jne    c0001d10 <terminal_putcharn+0x150>
c0001d1a:	e9 d4 fe ff ff       	jmp    c0001bf3 <terminal_putcharn+0x33>
c0001d1f:	90                   	nop

c0001d20 <terminal_newline>:
{
c0001d20:	55                   	push   %ebp
c0001d21:	89 e5                	mov    %esp,%ebp
c0001d23:	53                   	push   %ebx
c0001d24:	83 ec 04             	sub    $0x4,%esp
c0001d27:	8b 5d 08             	mov    0x8(%ebp),%ebx
    if (++term->row == VGA_HEIGHT)
c0001d2a:	8b 03                	mov    (%ebx),%eax
    term->column = 0;
c0001d2c:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    if (++term->row == VGA_HEIGHT)
c0001d33:	83 c0 01             	add    $0x1,%eax
c0001d36:	89 03                	mov    %eax,(%ebx)
c0001d38:	83 f8 19             	cmp    $0x19,%eax
c0001d3b:	74 13                	je     c0001d50 <terminal_newline+0x30>
}
c0001d3d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0001d40:	c9                   	leave  
c0001d41:	c3                   	ret    
c0001d42:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001d49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c0001d50:	8b 43 0c             	mov    0xc(%ebx),%eax
c0001d53:	83 ec 04             	sub    $0x4,%esp
c0001d56:	68 00 0f 00 00       	push   $0xf00
c0001d5b:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c0001d61:	52                   	push   %edx
c0001d62:	50                   	push   %eax
c0001d63:	e8 b8 f4 ff ff       	call   c0001220 <memcpy>
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001d68:	0f b6 53 08          	movzbl 0x8(%ebx),%edx
c0001d6c:	8b 4b 0c             	mov    0xc(%ebx),%ecx
c0001d6f:	83 c4 10             	add    $0x10,%esp
	term->row = VGA_HEIGHT-1;
c0001d72:	c7 03 18 00 00 00    	movl   $0x18,(%ebx)
c0001d78:	c1 e2 08             	shl    $0x8,%edx
c0001d7b:	8d 81 00 0f 00 00    	lea    0xf00(%ecx),%eax
c0001d81:	81 c1 a0 0f 00 00    	add    $0xfa0,%ecx
c0001d87:	83 ca 20             	or     $0x20,%edx
c0001d8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001d90:	66 89 10             	mov    %dx,(%eax)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c0001d93:	83 c0 02             	add    $0x2,%eax
c0001d96:	39 c8                	cmp    %ecx,%eax
c0001d98:	75 f6                	jne    c0001d90 <terminal_newline+0x70>
}
c0001d9a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0001d9d:	c9                   	leave  
c0001d9e:	c3                   	ret    
c0001d9f:	90                   	nop

c0001da0 <terminal_putchar>:
{
c0001da0:	55                   	push   %ebp
c0001da1:	89 e5                	mov    %esp,%ebp
c0001da3:	56                   	push   %esi
c0001da4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001da7:	8b 55 08             	mov    0x8(%ebp),%edx
c0001daa:	53                   	push   %ebx
	if(c == '\n')
c0001dab:	3c 0a                	cmp    $0xa,%al
c0001dad:	74 31                	je     c0001de0 <terminal_putchar+0x40>
	const size_t index = y * VGA_WIDTH + x;
c0001daf:	8b 1a                	mov    (%edx),%ebx
	terminal_putentryat(term, c, term->color, term->column, term->row);
c0001db1:	0f b6 72 08          	movzbl 0x8(%edx),%esi
c0001db5:	0f b6 c0             	movzbl %al,%eax
c0001db8:	8b 4a 04             	mov    0x4(%edx),%ecx
c0001dbb:	c1 e6 08             	shl    $0x8,%esi
	term->buffer[index] = vga_entry(c, color);
c0001dbe:	8d 1c 9b             	lea    (%ebx,%ebx,4),%ebx
c0001dc1:	09 f0                	or     %esi,%eax
c0001dc3:	c1 e3 04             	shl    $0x4,%ebx
c0001dc6:	8b 72 0c             	mov    0xc(%edx),%esi
c0001dc9:	01 cb                	add    %ecx,%ebx
	if (++term->column == VGA_WIDTH)
c0001dcb:	83 c1 01             	add    $0x1,%ecx
c0001dce:	66 89 04 5e          	mov    %ax,(%esi,%ebx,2)
c0001dd2:	89 4a 04             	mov    %ecx,0x4(%edx)
c0001dd5:	83 f9 50             	cmp    $0x50,%ecx
c0001dd8:	74 06                	je     c0001de0 <terminal_putchar+0x40>
}
c0001dda:	5b                   	pop    %ebx
c0001ddb:	5e                   	pop    %esi
c0001ddc:	5d                   	pop    %ebp
c0001ddd:	c3                   	ret    
c0001dde:	66 90                	xchg   %ax,%ax
c0001de0:	5b                   	pop    %ebx
c0001de1:	5e                   	pop    %esi
		terminal_newline(term);
c0001de2:	89 55 08             	mov    %edx,0x8(%ebp)
}
c0001de5:	5d                   	pop    %ebp
		terminal_newline(term);
c0001de6:	e9 35 ff ff ff       	jmp    c0001d20 <terminal_newline>
c0001deb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c0001def:	90                   	nop

c0001df0 <terminal_scrollline>:
{
c0001df0:	55                   	push   %ebp
c0001df1:	89 e5                	mov    %esp,%ebp
c0001df3:	53                   	push   %ebx
c0001df4:	83 ec 08             	sub    $0x8,%esp
c0001df7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c0001dfa:	8b 43 0c             	mov    0xc(%ebx),%eax
c0001dfd:	68 00 0f 00 00       	push   $0xf00
c0001e02:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c0001e08:	52                   	push   %edx
c0001e09:	50                   	push   %eax
c0001e0a:	e8 11 f4 ff ff       	call   c0001220 <memcpy>
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001e0f:	0f b6 53 08          	movzbl 0x8(%ebx),%edx
c0001e13:	8b 4b 0c             	mov    0xc(%ebx),%ecx
c0001e16:	83 c4 10             	add    $0x10,%esp
	term->row = VGA_HEIGHT-1;
c0001e19:	c7 03 18 00 00 00    	movl   $0x18,(%ebx)
c0001e1f:	c1 e2 08             	shl    $0x8,%edx
c0001e22:	8d 81 00 0f 00 00    	lea    0xf00(%ecx),%eax
c0001e28:	81 c1 a0 0f 00 00    	add    $0xfa0,%ecx
c0001e2e:	83 ca 20             	or     $0x20,%edx
c0001e31:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001e38:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001e3f:	90                   	nop
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001e40:	66 89 10             	mov    %dx,(%eax)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c0001e43:	83 c0 02             	add    $0x2,%eax
c0001e46:	39 c8                	cmp    %ecx,%eax
c0001e48:	75 f6                	jne    c0001e40 <terminal_scrollline+0x50>
}
c0001e4a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0001e4d:	c9                   	leave  
c0001e4e:	c3                   	ret    
c0001e4f:	90                   	nop

c0001e50 <terminal_clearline>:
{
c0001e50:	55                   	push   %ebp
c0001e51:	89 e5                	mov    %esp,%ebp
c0001e53:	53                   	push   %ebx
c0001e54:	8b 45 08             	mov    0x8(%ebp),%eax
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001e57:	8b 58 0c             	mov    0xc(%eax),%ebx
c0001e5a:	0f b6 50 08          	movzbl 0x8(%eax),%edx
c0001e5e:	8b 00                	mov    (%eax),%eax
c0001e60:	c1 e2 08             	shl    $0x8,%edx
c0001e63:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
c0001e66:	83 ca 20             	or     $0x20,%edx
c0001e69:	c1 e1 05             	shl    $0x5,%ecx
c0001e6c:	8d 04 0b             	lea    (%ebx,%ecx,1),%eax
c0001e6f:	8d 8c 0b a0 00 00 00 	lea    0xa0(%ebx,%ecx,1),%ecx
c0001e76:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001e7d:	8d 76 00             	lea    0x0(%esi),%esi
c0001e80:	66 89 10             	mov    %dx,(%eax)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c0001e83:	83 c0 02             	add    $0x2,%eax
c0001e86:	39 c8                	cmp    %ecx,%eax
c0001e88:	75 f6                	jne    c0001e80 <terminal_clearline+0x30>

}
c0001e8a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0001e8d:	c9                   	leave  
c0001e8e:	c3                   	ret    
c0001e8f:	90                   	nop

c0001e90 <terminal_write>:


void terminal_write(struct terminal* term, const char* data, size_t size) 
{
c0001e90:	55                   	push   %ebp
c0001e91:	89 e5                	mov    %esp,%ebp
c0001e93:	57                   	push   %edi
c0001e94:	56                   	push   %esi
c0001e95:	53                   	push   %ebx
c0001e96:	83 ec 1c             	sub    $0x1c,%esp
c0001e99:	8b 45 10             	mov    0x10(%ebp),%eax
c0001e9c:	8b 7d 0c             	mov    0xc(%ebp),%edi
c0001e9f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	for (size_t i = 0; i < size; i++)
c0001ea2:	8d 14 07             	lea    (%edi,%eax,1),%edx
c0001ea5:	89 55 dc             	mov    %edx,-0x24(%ebp)
c0001ea8:	85 c0                	test   %eax,%eax
c0001eaa:	75 23                	jne    c0001ecf <terminal_write+0x3f>
c0001eac:	e9 c5 00 00 00       	jmp    c0001f76 <terminal_write+0xe6>
c0001eb1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001eb8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001ebf:	90                   	nop
	if (++term->column == VGA_WIDTH)
c0001ec0:	89 43 04             	mov    %eax,0x4(%ebx)
	for (size_t i = 0; i < size; i++)
c0001ec3:	83 c7 01             	add    $0x1,%edi
c0001ec6:	3b 7d dc             	cmp    -0x24(%ebp),%edi
c0001ec9:	0f 84 a7 00 00 00    	je     c0001f76 <terminal_write+0xe6>
    if (++term->row == VGA_HEIGHT)
c0001ecf:	8b 0b                	mov    (%ebx),%ecx
		terminal_putchar(term, data[i]);
c0001ed1:	0f b6 07             	movzbl (%edi),%eax
    if (++term->row == VGA_HEIGHT)
c0001ed4:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	if(c == '\n')
c0001ed7:	3c 0a                	cmp    $0xa,%al
c0001ed9:	0f 84 a1 00 00 00    	je     c0001f80 <terminal_write+0xf0>
	term->buffer[index] = vga_entry(c, color);
c0001edf:	8b 73 0c             	mov    0xc(%ebx),%esi
	terminal_putentryat(term, c, term->color, term->column, term->row);
c0001ee2:	8b 4b 04             	mov    0x4(%ebx),%ecx
	term->buffer[index] = vga_entry(c, color);
c0001ee5:	89 f2                	mov    %esi,%edx
c0001ee7:	89 75 d8             	mov    %esi,-0x28(%ebp)
c0001eea:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c0001eed:	8d 34 b6             	lea    (%esi,%esi,4),%esi
c0001ef0:	c1 e6 04             	shl    $0x4,%esi
c0001ef3:	01 ce                	add    %ecx,%esi
c0001ef5:	89 75 e0             	mov    %esi,-0x20(%ebp)
	terminal_putentryat(term, c, term->color, term->column, term->row);
c0001ef8:	0f b6 73 08          	movzbl 0x8(%ebx),%esi
c0001efc:	c1 e6 08             	shl    $0x8,%esi
c0001eff:	09 f0                	or     %esi,%eax
c0001f01:	89 d6                	mov    %edx,%esi
c0001f03:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0001f06:	66 89 04 56          	mov    %ax,(%esi,%edx,2)
	if (++term->column == VGA_WIDTH)
c0001f0a:	8d 41 01             	lea    0x1(%ecx),%eax
c0001f0d:	83 f9 4f             	cmp    $0x4f,%ecx
c0001f10:	75 ae                	jne    c0001ec0 <terminal_write+0x30>
    if (++term->row == VGA_HEIGHT)
c0001f12:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    term->column = 0;
c0001f15:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    if (++term->row == VGA_HEIGHT)
c0001f1c:	83 c2 01             	add    $0x1,%edx
c0001f1f:	89 13                	mov    %edx,(%ebx)
c0001f21:	83 fa 19             	cmp    $0x19,%edx
c0001f24:	75 9d                	jne    c0001ec3 <terminal_write+0x33>
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c0001f26:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0001f29:	83 ec 04             	sub    $0x4,%esp
c0001f2c:	68 00 0f 00 00       	push   $0xf00
c0001f31:	8d 82 a0 00 00 00    	lea    0xa0(%edx),%eax
c0001f37:	50                   	push   %eax
c0001f38:	52                   	push   %edx
c0001f39:	e8 e2 f2 ff ff       	call   c0001220 <memcpy>
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001f3e:	0f b6 53 08          	movzbl 0x8(%ebx),%edx
c0001f42:	8b 4b 0c             	mov    0xc(%ebx),%ecx
c0001f45:	83 c4 10             	add    $0x10,%esp
	term->row = VGA_HEIGHT-1;
c0001f48:	c7 03 18 00 00 00    	movl   $0x18,(%ebx)
c0001f4e:	c1 e2 08             	shl    $0x8,%edx
c0001f51:	8d 81 00 0f 00 00    	lea    0xf00(%ecx),%eax
c0001f57:	81 c1 a0 0f 00 00    	add    $0xfa0,%ecx
c0001f5d:	83 ca 20             	or     $0x20,%edx
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001f60:	66 89 10             	mov    %dx,(%eax)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c0001f63:	83 c0 02             	add    $0x2,%eax
c0001f66:	39 c8                	cmp    %ecx,%eax
c0001f68:	75 f6                	jne    c0001f60 <terminal_write+0xd0>
	for (size_t i = 0; i < size; i++)
c0001f6a:	83 c7 01             	add    $0x1,%edi
c0001f6d:	3b 7d dc             	cmp    -0x24(%ebp),%edi
c0001f70:	0f 85 59 ff ff ff    	jne    c0001ecf <terminal_write+0x3f>
}
c0001f76:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0001f79:	5b                   	pop    %ebx
c0001f7a:	5e                   	pop    %esi
c0001f7b:	5f                   	pop    %edi
c0001f7c:	5d                   	pop    %ebp
c0001f7d:	c3                   	ret    
c0001f7e:	66 90                	xchg   %ax,%ax
    if (++term->row == VGA_HEIGHT)
c0001f80:	89 ca                	mov    %ecx,%edx
    term->column = 0;
c0001f82:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    if (++term->row == VGA_HEIGHT)
c0001f89:	83 c2 01             	add    $0x1,%edx
c0001f8c:	89 13                	mov    %edx,(%ebx)
c0001f8e:	83 fa 19             	cmp    $0x19,%edx
c0001f91:	0f 85 2c ff ff ff    	jne    c0001ec3 <terminal_write+0x33>
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c0001f97:	8b 43 0c             	mov    0xc(%ebx),%eax
c0001f9a:	83 ec 04             	sub    $0x4,%esp
c0001f9d:	68 00 0f 00 00       	push   $0xf00
c0001fa2:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c0001fa8:	52                   	push   %edx
c0001fa9:	50                   	push   %eax
c0001faa:	e8 71 f2 ff ff       	call   c0001220 <memcpy>
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001faf:	0f b6 53 08          	movzbl 0x8(%ebx),%edx
c0001fb3:	8b 4b 0c             	mov    0xc(%ebx),%ecx
c0001fb6:	83 c4 10             	add    $0x10,%esp
	term->row = VGA_HEIGHT-1;
c0001fb9:	c7 03 18 00 00 00    	movl   $0x18,(%ebx)
c0001fbf:	c1 e2 08             	shl    $0x8,%edx
c0001fc2:	8d 81 00 0f 00 00    	lea    0xf00(%ecx),%eax
c0001fc8:	81 c1 a0 0f 00 00    	add    $0xfa0,%ecx
c0001fce:	83 ca 20             	or     $0x20,%edx
c0001fd1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001fd8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001fdf:	90                   	nop
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001fe0:	66 89 10             	mov    %dx,(%eax)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c0001fe3:	83 c0 02             	add    $0x2,%eax
c0001fe6:	39 c8                	cmp    %ecx,%eax
c0001fe8:	75 f6                	jne    c0001fe0 <terminal_write+0x150>
c0001fea:	e9 d4 fe ff ff       	jmp    c0001ec3 <terminal_write+0x33>
c0001fef:	90                   	nop

c0001ff0 <terminal_writestring>:
 
void terminal_writestring(struct terminal* term, const char* data) 
{
c0001ff0:	55                   	push   %ebp
c0001ff1:	89 e5                	mov    %esp,%ebp
c0001ff3:	57                   	push   %edi
c0001ff4:	56                   	push   %esi
c0001ff5:	53                   	push   %ebx
c0001ff6:	83 ec 28             	sub    $0x28,%esp
c0001ff9:	8b 7d 0c             	mov    0xc(%ebp),%edi
c0001ffc:	8b 5d 08             	mov    0x8(%ebp),%ebx
	terminal_write(term, data, strlen(data));
c0001fff:	57                   	push   %edi
c0002000:	e8 fb f1 ff ff       	call   c0001200 <strlen>
	for (size_t i = 0; i < size; i++)
c0002005:	83 c4 10             	add    $0x10,%esp
c0002008:	8d 14 07             	lea    (%edi,%eax,1),%edx
c000200b:	89 55 dc             	mov    %edx,-0x24(%ebp)
c000200e:	85 c0                	test   %eax,%eax
c0002010:	75 1d                	jne    c000202f <terminal_writestring+0x3f>
c0002012:	e9 bf 00 00 00       	jmp    c00020d6 <terminal_writestring+0xe6>
c0002017:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000201e:	66 90                	xchg   %ax,%ax
	if (++term->column == VGA_WIDTH)
c0002020:	89 43 04             	mov    %eax,0x4(%ebx)
	for (size_t i = 0; i < size; i++)
c0002023:	83 c7 01             	add    $0x1,%edi
c0002026:	3b 7d dc             	cmp    -0x24(%ebp),%edi
c0002029:	0f 84 a7 00 00 00    	je     c00020d6 <terminal_writestring+0xe6>
    if (++term->row == VGA_HEIGHT)
c000202f:	8b 0b                	mov    (%ebx),%ecx
		terminal_putchar(term, data[i]);
c0002031:	0f b6 07             	movzbl (%edi),%eax
    if (++term->row == VGA_HEIGHT)
c0002034:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	if(c == '\n')
c0002037:	3c 0a                	cmp    $0xa,%al
c0002039:	0f 84 a1 00 00 00    	je     c00020e0 <terminal_writestring+0xf0>
	term->buffer[index] = vga_entry(c, color);
c000203f:	8b 73 0c             	mov    0xc(%ebx),%esi
	terminal_putentryat(term, c, term->color, term->column, term->row);
c0002042:	8b 4b 04             	mov    0x4(%ebx),%ecx
	term->buffer[index] = vga_entry(c, color);
c0002045:	89 f2                	mov    %esi,%edx
c0002047:	89 75 d8             	mov    %esi,-0x28(%ebp)
c000204a:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c000204d:	8d 34 b6             	lea    (%esi,%esi,4),%esi
c0002050:	c1 e6 04             	shl    $0x4,%esi
c0002053:	01 ce                	add    %ecx,%esi
c0002055:	89 75 e0             	mov    %esi,-0x20(%ebp)
	terminal_putentryat(term, c, term->color, term->column, term->row);
c0002058:	0f b6 73 08          	movzbl 0x8(%ebx),%esi
c000205c:	c1 e6 08             	shl    $0x8,%esi
c000205f:	09 f0                	or     %esi,%eax
c0002061:	89 d6                	mov    %edx,%esi
c0002063:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0002066:	66 89 04 56          	mov    %ax,(%esi,%edx,2)
	if (++term->column == VGA_WIDTH)
c000206a:	8d 41 01             	lea    0x1(%ecx),%eax
c000206d:	83 f9 4f             	cmp    $0x4f,%ecx
c0002070:	75 ae                	jne    c0002020 <terminal_writestring+0x30>
    if (++term->row == VGA_HEIGHT)
c0002072:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    term->column = 0;
c0002075:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    if (++term->row == VGA_HEIGHT)
c000207c:	83 c2 01             	add    $0x1,%edx
c000207f:	89 13                	mov    %edx,(%ebx)
c0002081:	83 fa 19             	cmp    $0x19,%edx
c0002084:	75 9d                	jne    c0002023 <terminal_writestring+0x33>
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c0002086:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0002089:	83 ec 04             	sub    $0x4,%esp
c000208c:	68 00 0f 00 00       	push   $0xf00
c0002091:	8d 82 a0 00 00 00    	lea    0xa0(%edx),%eax
c0002097:	50                   	push   %eax
c0002098:	52                   	push   %edx
c0002099:	e8 82 f1 ff ff       	call   c0001220 <memcpy>
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c000209e:	0f b6 53 08          	movzbl 0x8(%ebx),%edx
c00020a2:	8b 4b 0c             	mov    0xc(%ebx),%ecx
c00020a5:	83 c4 10             	add    $0x10,%esp
	term->row = VGA_HEIGHT-1;
c00020a8:	c7 03 18 00 00 00    	movl   $0x18,(%ebx)
c00020ae:	c1 e2 08             	shl    $0x8,%edx
c00020b1:	8d 81 00 0f 00 00    	lea    0xf00(%ecx),%eax
c00020b7:	81 c1 a0 0f 00 00    	add    $0xfa0,%ecx
c00020bd:	83 ca 20             	or     $0x20,%edx
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c00020c0:	66 89 10             	mov    %dx,(%eax)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c00020c3:	83 c0 02             	add    $0x2,%eax
c00020c6:	39 c8                	cmp    %ecx,%eax
c00020c8:	75 f6                	jne    c00020c0 <terminal_writestring+0xd0>
	for (size_t i = 0; i < size; i++)
c00020ca:	83 c7 01             	add    $0x1,%edi
c00020cd:	3b 7d dc             	cmp    -0x24(%ebp),%edi
c00020d0:	0f 85 59 ff ff ff    	jne    c000202f <terminal_writestring+0x3f>
}
c00020d6:	8d 65 f4             	lea    -0xc(%ebp),%esp
c00020d9:	5b                   	pop    %ebx
c00020da:	5e                   	pop    %esi
c00020db:	5f                   	pop    %edi
c00020dc:	5d                   	pop    %ebp
c00020dd:	c3                   	ret    
c00020de:	66 90                	xchg   %ax,%ax
    if (++term->row == VGA_HEIGHT)
c00020e0:	89 ca                	mov    %ecx,%edx
    term->column = 0;
c00020e2:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    if (++term->row == VGA_HEIGHT)
c00020e9:	83 c2 01             	add    $0x1,%edx
c00020ec:	89 13                	mov    %edx,(%ebx)
c00020ee:	83 fa 19             	cmp    $0x19,%edx
c00020f1:	0f 85 2c ff ff ff    	jne    c0002023 <terminal_writestring+0x33>
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c00020f7:	8b 43 0c             	mov    0xc(%ebx),%eax
c00020fa:	83 ec 04             	sub    $0x4,%esp
c00020fd:	68 00 0f 00 00       	push   $0xf00
c0002102:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c0002108:	52                   	push   %edx
c0002109:	50                   	push   %eax
c000210a:	e8 11 f1 ff ff       	call   c0001220 <memcpy>
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c000210f:	0f b6 53 08          	movzbl 0x8(%ebx),%edx
c0002113:	8b 4b 0c             	mov    0xc(%ebx),%ecx
c0002116:	83 c4 10             	add    $0x10,%esp
	term->row = VGA_HEIGHT-1;
c0002119:	c7 03 18 00 00 00    	movl   $0x18,(%ebx)
c000211f:	c1 e2 08             	shl    $0x8,%edx
c0002122:	8d 81 00 0f 00 00    	lea    0xf00(%ecx),%eax
c0002128:	81 c1 a0 0f 00 00    	add    $0xfa0,%ecx
c000212e:	83 ca 20             	or     $0x20,%edx
c0002131:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0002138:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000213f:	90                   	nop
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0002140:	66 89 10             	mov    %dx,(%eax)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c0002143:	83 c0 02             	add    $0x2,%eax
c0002146:	39 c8                	cmp    %ecx,%eax
c0002148:	75 f6                	jne    c0002140 <terminal_writestring+0x150>
c000214a:	e9 d4 fe ff ff       	jmp    c0002023 <terminal_writestring+0x33>
c000214f:	90                   	nop

c0002150 <get_table>:

page_directory_virt_t* pd = (page_directory_virt_t*) PD_ADDR;

// return page directory index for virtual address
page_table_t* get_table(void* addr)
{
c0002150:	55                   	push   %ebp
    uint32_t idx = get_pdindex(addr);
    if(pd->dir.pde[idx] & PAGE_FLAG_PRESENT)
c0002151:	8b 0d 00 40 00 c0    	mov    0xc0004000,%ecx
{
c0002157:	89 e5                	mov    %esp,%ebp
}

// return page directory index for virtual address
inline uint32_t get_pdindex(void* addr)
{
    return ((uint32_t) addr) >> 22;
c0002159:	8b 55 08             	mov    0x8(%ebp),%edx
        return pd->tables + get_pdindex(addr);
    else 
        return NULL;
}
c000215c:	5d                   	pop    %ebp
c000215d:	c1 ea 16             	shr    $0x16,%edx
        return pd->tables + get_pdindex(addr);
c0002160:	89 d0                	mov    %edx,%eax
c0002162:	c1 e0 0c             	shl    $0xc,%eax
c0002165:	01 c8                	add    %ecx,%eax
c0002167:	f6 84 91 00 f0 3f 00 	testb  $0x1,0x3ff000(%ecx,%edx,4)
c000216e:	01 
c000216f:	ba 00 00 00 00       	mov    $0x0,%edx
c0002174:	0f 44 c2             	cmove  %edx,%eax
}
c0002177:	c3                   	ret    
c0002178:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000217f:	90                   	nop

c0002180 <get_physaddr>:

// return physical addr from virt addr
char* get_physaddr(char* addr)
{
c0002180:	55                   	push   %ebp
c0002181:	89 e5                	mov    %esp,%ebp
c0002183:	53                   	push   %ebx
    //check pd entry is present
    uint32_t pdi = get_pdindex(addr);
    if(! pd->dir.pde[pdi] & PAGE_FLAG_PRESENT)
c0002184:	8b 1d 00 40 00 c0    	mov    0xc0004000,%ebx
{
c000218a:	8b 55 08             	mov    0x8(%ebp),%edx
c000218d:	89 d0                	mov    %edx,%eax
c000218f:	c1 e8 16             	shr    $0x16,%eax
    if(! pd->dir.pde[pdi] & PAGE_FLAG_PRESENT)
c0002192:	8b 8c 83 00 f0 3f 00 	mov    0x3ff000(%ebx,%eax,4),%ecx
c0002199:	85 c9                	test   %ecx,%ecx
c000219b:	74 33                	je     c00021d0 <get_physaddr+0x50>
    return (((uint32_t) addr) & PAGE_PTE_MASK ) >> 12;
c000219d:	89 d1                	mov    %edx,%ecx
        return NULL;

    //check pt entry is present
    uint32_t pte = pd->tables[pdi].pte[get_ptindex(addr)];
c000219f:	c1 e0 0a             	shl    $0xa,%eax
c00021a2:	c1 e9 0c             	shr    $0xc,%ecx
c00021a5:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
c00021ab:	01 c8                	add    %ecx,%eax
c00021ad:	8b 04 83             	mov    (%ebx,%eax,4),%eax
    if(! pte & PAGE_FLAG_PRESENT)
c00021b0:	85 c0                	test   %eax,%eax
c00021b2:	74 1c                	je     c00021d0 <get_physaddr+0x50>
        return NULL;

    return (char*) ((pte & PAGE_ADDRMASK) +  get_page_offset(addr) );
c00021b4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}

// return offset into page
inline uint32_t get_page_offset(void* addr)
{
    return ((uint32_t) addr) & ~PAGE_ADDRMASK;
c00021b9:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
}
c00021bf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00021c2:	c9                   	leave  
    return (char*) ((pte & PAGE_ADDRMASK) +  get_page_offset(addr) );
c00021c3:	09 d0                	or     %edx,%eax
}
c00021c5:	c3                   	ret    
c00021c6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00021cd:	8d 76 00             	lea    0x0(%esi),%esi
c00021d0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
        return NULL;
c00021d3:	31 c0                	xor    %eax,%eax
}
c00021d5:	c9                   	leave  
c00021d6:	c3                   	ret    
c00021d7:	66 90                	xchg   %ax,%ax
c00021d9:	66 90                	xchg   %ax,%ax
c00021db:	66 90                	xchg   %ax,%ax
c00021dd:	66 90                	xchg   %ax,%ax
c00021df:	90                   	nop

c00021e0 <unmap_lowmem>:

    return 0;
}

int unmap_lowmem()
{
c00021e0:	55                   	push   %ebp
c00021e1:	89 e5                	mov    %esp,%ebp
c00021e3:	83 ec 08             	sub    $0x8,%esp
    pd->dir.pde[0] = PAGE_FLAG_EMPTY;
c00021e6:	a1 00 40 00 c0       	mov    0xc0004000,%eax
c00021eb:	c7 80 00 f0 3f 00 00 	movl   $0x0,0x3ff000(%eax)
c00021f2:	00 00 00 
    refresh_tlb();
c00021f5:	e8 a6 0b 00 00       	call   c0002da0 <refresh_tlb>
    return 0;
}
c00021fa:	31 c0                	xor    %eax,%eax
c00021fc:	c9                   	leave  
c00021fd:	c3                   	ret    
c00021fe:	66 90                	xchg   %ax,%ax

c0002200 <get_big_block>:
    return heap;
}


size_t get_big_block(multiboot_info_t* mbd, void** block)
{
c0002200:	55                   	push   %ebp
c0002201:	89 e5                	mov    %esp,%ebp
c0002203:	57                   	push   %edi
c0002204:	56                   	push   %esi
c0002205:	53                   	push   %ebx
c0002206:	83 ec 0c             	sub    $0xc,%esp
c0002209:	8b 55 08             	mov    0x8(%ebp),%edx
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
    size_t block_size = 0;
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c000220c:	8b 4a 2c             	mov    0x2c(%edx),%ecx
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c000220f:	8b 42 30             	mov    0x30(%edx),%eax
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0002212:	89 4d ec             	mov    %ecx,-0x14(%ebp)
c0002215:	85 c9                	test   %ecx,%ecx
c0002217:	74 53                	je     c000226c <get_big_block+0x6c>
c0002219:	31 d2                	xor    %edx,%edx
    size_t block_size = 0;
c000221b:	31 f6                	xor    %esi,%esi
c000221d:	eb 0c                	jmp    c000222b <get_big_block+0x2b>
c000221f:	90                   	nop
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0002220:	83 c2 01             	add    $0x1,%edx
c0002223:	83 c0 18             	add    $0x18,%eax
c0002226:	3b 55 ec             	cmp    -0x14(%ebp),%edx
c0002229:	74 37                	je     c0002262 <get_big_block+0x62>
	{
        if(mmap_table[nn].size == 0)
c000222b:	8b 38                	mov    (%eax),%edi
c000222d:	85 ff                	test   %edi,%edi
c000222f:	74 31                	je     c0002262 <get_big_block+0x62>
            break;

		if(mmap_table[nn].len>block_size && mmap_table[nn].type == MULTIBOOT_MEMORY_AVAILABLE)
c0002231:	8b 78 0c             	mov    0xc(%eax),%edi
c0002234:	bb 00 00 00 00       	mov    $0x0,%ebx
c0002239:	39 fe                	cmp    %edi,%esi
c000223b:	1b 58 10             	sbb    0x10(%eax),%ebx
c000223e:	73 e0                	jae    c0002220 <get_big_block+0x20>
c0002240:	83 78 14 01          	cmpl   $0x1,0x14(%eax)
c0002244:	75 da                	jne    c0002220 <get_big_block+0x20>
        {
            block_size = mmap_table[nn].len;
            if(mmap_table[nn].addr >> 32)
c0002246:	8b 58 08             	mov    0x8(%eax),%ebx
c0002249:	8b 48 04             	mov    0x4(%eax),%ecx
            block_size = mmap_table[nn].len;
c000224c:	89 fe                	mov    %edi,%esi
            if(mmap_table[nn].addr >> 32)
c000224e:	85 db                	test   %ebx,%ebx
c0002250:	75 10                	jne    c0002262 <get_big_block+0x62>
            {
                // ignore anything above 32bits
                break;
            }
            *block = (void*) (uint32_t) mmap_table[nn].addr;
c0002252:	8b 7d 0c             	mov    0xc(%ebp),%edi
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0002255:	83 c2 01             	add    $0x1,%edx
c0002258:	83 c0 18             	add    $0x18,%eax
            *block = (void*) (uint32_t) mmap_table[nn].addr;
c000225b:	89 0f                	mov    %ecx,(%edi)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c000225d:	3b 55 ec             	cmp    -0x14(%ebp),%edx
c0002260:	75 c9                	jne    c000222b <get_big_block+0x2b>
        }
	}
    return block_size;
}
c0002262:	83 c4 0c             	add    $0xc,%esp
c0002265:	89 f0                	mov    %esi,%eax
c0002267:	5b                   	pop    %ebx
c0002268:	5e                   	pop    %esi
c0002269:	5f                   	pop    %edi
c000226a:	5d                   	pop    %ebp
c000226b:	c3                   	ret    
    size_t block_size = 0;
c000226c:	31 f6                	xor    %esi,%esi
    return block_size;
c000226e:	eb f2                	jmp    c0002262 <get_big_block+0x62>

c0002270 <new_page_table>:
    refresh_page(page_virt);
    return page_virt;
}

page_table_t* new_page_table(void* addr, uint32_t flags)
{
c0002270:	55                   	push   %ebp
c0002271:	89 e5                	mov    %esp,%ebp
c0002273:	53                   	push   %ebx
c0002274:	83 ec 04             	sub    $0x4,%esp
    return ((uint32_t) addr) >> 22;
c0002277:	8b 5d 08             	mov    0x8(%ebp),%ebx
    uint32_t pdindex = get_pdindex(addr);      // index into page dir (which table does this address point to)

    // is this table already mapped?
    if(pd->dir.pde[pdindex] & PAGE_FLAG_PRESENT)
c000227a:	8b 15 00 40 00 c0    	mov    0xc0004000,%edx
c0002280:	c1 eb 16             	shr    $0x16,%ebx
c0002283:	f6 84 9a 00 f0 3f 00 	testb  $0x1,0x3ff000(%edx,%ebx,4)
c000228a:	01 
c000228b:	75 73                	jne    c0002300 <new_page_table+0x90>

// return next available physical page from the heap and updates the heap_page_phys pointer
// returns NULL on OOM
page_t* get_next_heap_page_phys()
{
    if( (uint32_t) (heap_page_phys+1) > (uint32_t) heap_end_phys)
c000228d:	a1 3c b8 00 c0       	mov    0xc000b83c,%eax
c0002292:	05 00 10 00 00       	add    $0x1000,%eax
c0002297:	39 05 30 b8 00 c0    	cmp    %eax,0xc000b830
c000229d:	72 61                	jb     c0002300 <new_page_table+0x90>
c000229f:	8d 8b 00 fc 0f 00    	lea    0xffc00(%ebx),%ecx
    {
        //out of memory
        return NULL;
    }
    return ++heap_page_phys;
c00022a5:	a3 3c b8 00 c0       	mov    %eax,0xc000b83c
    page_table_t* pv = pd->tables + pdindex;        // pointer to table (virtual)
c00022aa:	c1 e3 0c             	shl    $0xc,%ebx
    refresh_page(pv);
c00022ad:	83 ec 0c             	sub    $0xc,%esp
    pd->dir.pde[pdindex] = (((uint32_t) pp) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c00022b0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00022b5:	0b 45 0c             	or     0xc(%ebp),%eax
    page_table_t* pv = pd->tables + pdindex;        // pointer to table (virtual)
c00022b8:	01 d3                	add    %edx,%ebx
    pd->dir.pde[pdindex] = (((uint32_t) pp) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c00022ba:	83 c8 01             	or     $0x1,%eax
c00022bd:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
    refresh_page(pv);
c00022c0:	53                   	push   %ebx
c00022c1:	e8 e2 0a 00 00       	call   c0002da8 <refresh_page>
    for(size_t nn=0;nn<cnt; nn++)
c00022c6:	89 d8                	mov    %ebx,%eax
c00022c8:	8d 93 00 10 00 00    	lea    0x1000(%ebx),%edx
c00022ce:	83 c4 10             	add    $0x10,%esp
c00022d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00022d8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00022df:	90                   	nop
        m[nn] = val;
c00022e0:	c6 00 00             	movb   $0x0,(%eax)
    for(size_t nn=0;nn<cnt; nn++)
c00022e3:	83 c0 01             	add    $0x1,%eax
c00022e6:	39 d0                	cmp    %edx,%eax
c00022e8:	75 f6                	jne    c00022e0 <new_page_table+0x70>
}
c00022ea:	89 d8                	mov    %ebx,%eax
c00022ec:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00022ef:	c9                   	leave  
c00022f0:	c3                   	ret    
c00022f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00022f8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00022ff:	90                   	nop
        return NULL;
c0002300:	31 db                	xor    %ebx,%ebx
}
c0002302:	89 d8                	mov    %ebx,%eax
c0002304:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0002307:	c9                   	leave  
c0002308:	c3                   	ret    
c0002309:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

c0002310 <map_page_at>:
{
c0002310:	55                   	push   %ebp
c0002311:	89 e5                	mov    %esp,%ebp
c0002313:	53                   	push   %ebx
c0002314:	83 ec 10             	sub    $0x10,%esp
c0002317:	8b 5d 08             	mov    0x8(%ebp),%ebx
    page_table_t* pt = get_table(page_virt);
c000231a:	53                   	push   %ebx
c000231b:	e8 30 fe ff ff       	call   c0002150 <get_table>
    if(!pt)
c0002320:	83 c4 10             	add    $0x10,%esp
c0002323:	85 c0                	test   %eax,%eax
c0002325:	74 49                	je     c0002370 <map_page_at+0x60>
    return (((uint32_t) addr) & PAGE_PTE_MASK ) >> 12;
c0002327:	89 d9                	mov    %ebx,%ecx
        return NULL; //page already mapped
c0002329:	31 d2                	xor    %edx,%edx
c000232b:	c1 e9 0c             	shr    $0xc,%ecx
c000232e:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
    if(pt->pte[get_ptindex(page_virt)] & PAGE_FLAG_PRESENT)
c0002334:	f6 04 88 01          	testb  $0x1,(%eax,%ecx,4)
c0002338:	75 20                	jne    c000235a <map_page_at+0x4a>
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c000233a:	8b 55 0c             	mov    0xc(%ebp),%edx
    refresh_page(page_virt);
c000233d:	83 ec 0c             	sub    $0xc,%esp
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0002340:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c0002346:	0b 55 10             	or     0x10(%ebp),%edx
c0002349:	83 ca 01             	or     $0x1,%edx
c000234c:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    refresh_page(page_virt);
c000234f:	53                   	push   %ebx
c0002350:	e8 53 0a 00 00       	call   c0002da8 <refresh_page>
    return page_virt;
c0002355:	83 c4 10             	add    $0x10,%esp
c0002358:	89 da                	mov    %ebx,%edx
}
c000235a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000235d:	89 d0                	mov    %edx,%eax
c000235f:	c9                   	leave  
c0002360:	c3                   	ret    
c0002361:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0002368:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000236f:	90                   	nop
        pt = new_page_table(page_virt, flags); // page table is not present, allocate a new one
c0002370:	83 ec 08             	sub    $0x8,%esp
c0002373:	ff 75 10             	pushl  0x10(%ebp)
c0002376:	53                   	push   %ebx
c0002377:	e8 f4 fe ff ff       	call   c0002270 <new_page_table>
c000237c:	83 c4 10             	add    $0x10,%esp
c000237f:	eb a6                	jmp    c0002327 <map_page_at+0x17>
c0002381:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0002388:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000238f:	90                   	nop

c0002390 <heap_init>:
{
c0002390:	55                   	push   %ebp
c0002391:	89 e5                	mov    %esp,%ebp
c0002393:	83 ec 18             	sub    $0x18,%esp
	size_t free_mem_size = get_big_block(mbd, (void**) &heap_phys);
c0002396:	8d 45 f4             	lea    -0xc(%ebp),%eax
c0002399:	50                   	push   %eax
c000239a:	ff 75 08             	pushl  0x8(%ebp)
c000239d:	e8 5e fe ff ff       	call   c0002200 <get_big_block>
	if(&_kernel_end_phys >= heap_phys && &_kernel_end_phys < heap_end_phys)
c00023a2:	83 c4 08             	add    $0x8,%esp
	size_t free_mem_size = get_big_block(mbd, (void**) &heap_phys);
c00023a5:	89 c2                	mov    %eax,%edx
	heap_end_phys = heap_phys+free_mem_size;
c00023a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00023aa:	01 c2                	add    %eax,%edx
c00023ac:	89 15 30 b8 00 c0    	mov    %edx,0xc000b830
	if(&_kernel_end_phys >= heap_phys && &_kernel_end_phys < heap_end_phys)
c00023b2:	81 fa 30 c9 10 00    	cmp    $0x10c930,%edx
c00023b8:	76 0d                	jbe    c00023c7 <heap_init+0x37>
c00023ba:	3d 30 c9 10 00       	cmp    $0x10c930,%eax
c00023bf:	b9 30 c9 10 00       	mov    $0x10c930,%ecx
c00023c4:	0f 46 c1             	cmovbe %ecx,%eax
void* memset(void* addr, int val, size_t cnt);

inline void* align_addr(void* addr, uint32_t alignment)
{
    uint32_t am = alignment - 1;
    return (char*) (((uint32_t)addr + am) & ~am);
c00023c7:	05 ff 0f 00 00       	add    $0xfff,%eax
	kprintf("\nPhysical heap: 0x%.8x - 0x%.8x (%u MiB)\n", heap_phys, heap_end_phys,  (uint32_t) (heap_end_phys-heap_phys) >> 20);
c00023cc:	89 d1                	mov    %edx,%ecx
    heap_page = (page_t*) align_addr((void*) KERNEL_HEAP, PAGE_SIZE);
c00023ce:	c7 05 40 b8 00 c0 00 	movl   $0x400000,0xc000b840
c00023d5:	00 40 00 
    heap = (char*) heap_page;
c00023d8:	c7 05 38 b8 00 c0 00 	movl   $0x400000,0xc000b838
c00023df:	00 40 00 
c00023e2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
	kprintf("\nPhysical heap: 0x%.8x - 0x%.8x (%u MiB)\n", heap_phys, heap_end_phys,  (uint32_t) (heap_end_phys-heap_phys) >> 20);
c00023e7:	29 c1                	sub    %eax,%ecx
    heap_phys = (char*) heap_page_phys;
c00023e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	kprintf("\nPhysical heap: 0x%.8x - 0x%.8x (%u MiB)\n", heap_phys, heap_end_phys,  (uint32_t) (heap_end_phys-heap_phys) >> 20);
c00023ec:	c1 e9 14             	shr    $0x14,%ecx
    heap_page_phys = (page_t*) align_addr((void*) heap_phys, PAGE_SIZE);
c00023ef:	a3 3c b8 00 c0       	mov    %eax,0xc000b83c
	kprintf("\nPhysical heap: 0x%.8x - 0x%.8x (%u MiB)\n", heap_phys, heap_end_phys,  (uint32_t) (heap_end_phys-heap_phys) >> 20);
c00023f4:	51                   	push   %ecx
c00023f5:	52                   	push   %edx
c00023f6:	50                   	push   %eax
c00023f7:	68 9c 34 00 c0       	push   $0xc000349c
    heap_end = (char*) KERNEL_BASE;
c00023fc:	c7 05 34 b8 00 c0 00 	movl   $0xc0000000,0xc000b834
c0002403:	00 00 c0 
	kprintf("\nPhysical heap: 0x%.8x - 0x%.8x (%u MiB)\n", heap_phys, heap_end_phys,  (uint32_t) (heap_end_phys-heap_phys) >> 20);
c0002406:	e8 85 dd ff ff       	call   c0000190 <kprintf>
	kprintf("Virtual heap: 0x%.8x - 0x%.8x (%u MiB)\n\n", heap, heap_end,  (uint32_t) (heap_end-heap) >> 20);
c000240b:	8b 0d 34 b8 00 c0    	mov    0xc000b834,%ecx
c0002411:	8b 15 38 b8 00 c0    	mov    0xc000b838,%edx
c0002417:	89 c8                	mov    %ecx,%eax
c0002419:	29 d0                	sub    %edx,%eax
c000241b:	c1 e8 14             	shr    $0x14,%eax
c000241e:	50                   	push   %eax
c000241f:	51                   	push   %ecx
c0002420:	52                   	push   %edx
c0002421:	68 c8 34 00 c0       	push   $0xc00034c8
c0002426:	e8 65 dd ff ff       	call   c0000190 <kprintf>
    if(!map_page_at(heap_page, heap_page_phys, PAGE_FLAG_WRITE))
c000242b:	83 c4 1c             	add    $0x1c,%esp
c000242e:	6a 02                	push   $0x2
c0002430:	ff 35 3c b8 00 c0    	pushl  0xc000b83c
c0002436:	ff 35 40 b8 00 c0    	pushl  0xc000b840
c000243c:	e8 cf fe ff ff       	call   c0002310 <map_page_at>
c0002441:	83 c4 10             	add    $0x10,%esp
    return heap;
c0002444:	85 c0                	test   %eax,%eax
c0002446:	0f 45 05 38 b8 00 c0 	cmovne 0xc000b838,%eax
}
c000244d:	c9                   	leave  
c000244e:	c3                   	ret    
c000244f:	90                   	nop

c0002450 <map_vga>:
{
c0002450:	55                   	push   %ebp
c0002451:	89 e5                	mov    %esp,%ebp
c0002453:	83 ec 14             	sub    $0x14,%esp
    page_table_t* pt = get_table(page_virt);
c0002456:	68 00 80 0b 00       	push   $0xb8000
c000245b:	e8 f0 fc ff ff       	call   c0002150 <get_table>
    if(!pt)
c0002460:	83 c4 10             	add    $0x10,%esp
c0002463:	85 c0                	test   %eax,%eax
c0002465:	0f 84 95 01 00 00    	je     c0002600 <map_vga+0x1b0>
    if(pt->pte[get_ptindex(page_virt)] & PAGE_FLAG_PRESENT)
c000246b:	f6 80 e0 02 00 00 01 	testb  $0x1,0x2e0(%eax)
c0002472:	75 1a                	jne    c000248e <map_vga+0x3e>
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0002474:	c7 80 e0 02 00 00 07 	movl   $0xb8007,0x2e0(%eax)
c000247b:	80 0b 00 
    refresh_page(page_virt);
c000247e:	83 ec 0c             	sub    $0xc,%esp
c0002481:	68 00 80 0b 00       	push   $0xb8000
c0002486:	e8 1d 09 00 00       	call   c0002da8 <refresh_page>
    return page_virt;
c000248b:	83 c4 10             	add    $0x10,%esp
    page_table_t* pt = get_table(page_virt);
c000248e:	83 ec 0c             	sub    $0xc,%esp
c0002491:	68 00 90 0b 00       	push   $0xb9000
c0002496:	e8 b5 fc ff ff       	call   c0002150 <get_table>
    if(!pt)
c000249b:	83 c4 10             	add    $0x10,%esp
c000249e:	85 c0                	test   %eax,%eax
c00024a0:	0f 84 7a 01 00 00    	je     c0002620 <map_vga+0x1d0>
    if(pt->pte[get_ptindex(page_virt)] & PAGE_FLAG_PRESENT)
c00024a6:	f6 80 e4 02 00 00 01 	testb  $0x1,0x2e4(%eax)
c00024ad:	75 1a                	jne    c00024c9 <map_vga+0x79>
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c00024af:	c7 80 e4 02 00 00 07 	movl   $0xb9007,0x2e4(%eax)
c00024b6:	90 0b 00 
    refresh_page(page_virt);
c00024b9:	83 ec 0c             	sub    $0xc,%esp
c00024bc:	68 00 90 0b 00       	push   $0xb9000
c00024c1:	e8 e2 08 00 00       	call   c0002da8 <refresh_page>
    return page_virt;
c00024c6:	83 c4 10             	add    $0x10,%esp
    page_table_t* pt = get_table(page_virt);
c00024c9:	83 ec 0c             	sub    $0xc,%esp
c00024cc:	68 00 a0 0b 00       	push   $0xba000
c00024d1:	e8 7a fc ff ff       	call   c0002150 <get_table>
    if(!pt)
c00024d6:	83 c4 10             	add    $0x10,%esp
c00024d9:	85 c0                	test   %eax,%eax
c00024db:	0f 84 5f 01 00 00    	je     c0002640 <map_vga+0x1f0>
    if(pt->pte[get_ptindex(page_virt)] & PAGE_FLAG_PRESENT)
c00024e1:	f6 80 e8 02 00 00 01 	testb  $0x1,0x2e8(%eax)
c00024e8:	75 1a                	jne    c0002504 <map_vga+0xb4>
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c00024ea:	c7 80 e8 02 00 00 07 	movl   $0xba007,0x2e8(%eax)
c00024f1:	a0 0b 00 
    refresh_page(page_virt);
c00024f4:	83 ec 0c             	sub    $0xc,%esp
c00024f7:	68 00 a0 0b 00       	push   $0xba000
c00024fc:	e8 a7 08 00 00       	call   c0002da8 <refresh_page>
    return page_virt;
c0002501:	83 c4 10             	add    $0x10,%esp
    page_table_t* pt = get_table(page_virt);
c0002504:	83 ec 0c             	sub    $0xc,%esp
c0002507:	68 00 b0 0b 00       	push   $0xbb000
c000250c:	e8 3f fc ff ff       	call   c0002150 <get_table>
    if(!pt)
c0002511:	83 c4 10             	add    $0x10,%esp
c0002514:	85 c0                	test   %eax,%eax
c0002516:	0f 84 44 01 00 00    	je     c0002660 <map_vga+0x210>
    if(pt->pte[get_ptindex(page_virt)] & PAGE_FLAG_PRESENT)
c000251c:	f6 80 ec 02 00 00 01 	testb  $0x1,0x2ec(%eax)
c0002523:	75 1a                	jne    c000253f <map_vga+0xef>
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0002525:	c7 80 ec 02 00 00 07 	movl   $0xbb007,0x2ec(%eax)
c000252c:	b0 0b 00 
    refresh_page(page_virt);
c000252f:	83 ec 0c             	sub    $0xc,%esp
c0002532:	68 00 b0 0b 00       	push   $0xbb000
c0002537:	e8 6c 08 00 00       	call   c0002da8 <refresh_page>
    return page_virt;
c000253c:	83 c4 10             	add    $0x10,%esp
    page_table_t* pt = get_table(page_virt);
c000253f:	83 ec 0c             	sub    $0xc,%esp
c0002542:	68 00 c0 0b 00       	push   $0xbc000
c0002547:	e8 04 fc ff ff       	call   c0002150 <get_table>
    if(!pt)
c000254c:	83 c4 10             	add    $0x10,%esp
c000254f:	85 c0                	test   %eax,%eax
c0002551:	0f 84 29 01 00 00    	je     c0002680 <map_vga+0x230>
    if(pt->pte[get_ptindex(page_virt)] & PAGE_FLAG_PRESENT)
c0002557:	f6 80 f0 02 00 00 01 	testb  $0x1,0x2f0(%eax)
c000255e:	75 1a                	jne    c000257a <map_vga+0x12a>
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0002560:	c7 80 f0 02 00 00 07 	movl   $0xbc007,0x2f0(%eax)
c0002567:	c0 0b 00 
    refresh_page(page_virt);
c000256a:	83 ec 0c             	sub    $0xc,%esp
c000256d:	68 00 c0 0b 00       	push   $0xbc000
c0002572:	e8 31 08 00 00       	call   c0002da8 <refresh_page>
    return page_virt;
c0002577:	83 c4 10             	add    $0x10,%esp
    page_table_t* pt = get_table(page_virt);
c000257a:	83 ec 0c             	sub    $0xc,%esp
c000257d:	68 00 d0 0b 00       	push   $0xbd000
c0002582:	e8 c9 fb ff ff       	call   c0002150 <get_table>
    if(!pt)
c0002587:	83 c4 10             	add    $0x10,%esp
c000258a:	85 c0                	test   %eax,%eax
c000258c:	0f 84 0e 01 00 00    	je     c00026a0 <map_vga+0x250>
    if(pt->pte[get_ptindex(page_virt)] & PAGE_FLAG_PRESENT)
c0002592:	f6 80 f4 02 00 00 01 	testb  $0x1,0x2f4(%eax)
c0002599:	75 1a                	jne    c00025b5 <map_vga+0x165>
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c000259b:	c7 80 f4 02 00 00 07 	movl   $0xbd007,0x2f4(%eax)
c00025a2:	d0 0b 00 
    refresh_page(page_virt);
c00025a5:	83 ec 0c             	sub    $0xc,%esp
c00025a8:	68 00 d0 0b 00       	push   $0xbd000
c00025ad:	e8 f6 07 00 00       	call   c0002da8 <refresh_page>
    return page_virt;
c00025b2:	83 c4 10             	add    $0x10,%esp
    page_table_t* pt = get_table(page_virt);
c00025b5:	83 ec 0c             	sub    $0xc,%esp
c00025b8:	68 00 e0 0b 00       	push   $0xbe000
c00025bd:	e8 8e fb ff ff       	call   c0002150 <get_table>
    if(!pt)
c00025c2:	83 c4 10             	add    $0x10,%esp
c00025c5:	85 c0                	test   %eax,%eax
c00025c7:	0f 84 f3 00 00 00    	je     c00026c0 <map_vga+0x270>
    if(pt->pte[get_ptindex(page_virt)] & PAGE_FLAG_PRESENT)
c00025cd:	f6 80 f8 02 00 00 01 	testb  $0x1,0x2f8(%eax)
c00025d4:	75 1a                	jne    c00025f0 <map_vga+0x1a0>
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c00025d6:	c7 80 f8 02 00 00 07 	movl   $0xbe007,0x2f8(%eax)
c00025dd:	e0 0b 00 
    refresh_page(page_virt);
c00025e0:	83 ec 0c             	sub    $0xc,%esp
c00025e3:	68 00 e0 0b 00       	push   $0xbe000
c00025e8:	e8 bb 07 00 00       	call   c0002da8 <refresh_page>
    return page_virt;
c00025ed:	83 c4 10             	add    $0x10,%esp
}
c00025f0:	c9                   	leave  
c00025f1:	b8 00 80 0b 00       	mov    $0xb8000,%eax
c00025f6:	c3                   	ret    
c00025f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00025fe:	66 90                	xchg   %ax,%ax
        pt = new_page_table(page_virt, flags); // page table is not present, allocate a new one
c0002600:	83 ec 08             	sub    $0x8,%esp
c0002603:	6a 06                	push   $0x6
c0002605:	68 00 80 0b 00       	push   $0xb8000
c000260a:	e8 61 fc ff ff       	call   c0002270 <new_page_table>
c000260f:	83 c4 10             	add    $0x10,%esp
c0002612:	e9 54 fe ff ff       	jmp    c000246b <map_vga+0x1b>
c0002617:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000261e:	66 90                	xchg   %ax,%ax
c0002620:	83 ec 08             	sub    $0x8,%esp
c0002623:	6a 06                	push   $0x6
c0002625:	68 00 90 0b 00       	push   $0xb9000
c000262a:	e8 41 fc ff ff       	call   c0002270 <new_page_table>
c000262f:	83 c4 10             	add    $0x10,%esp
c0002632:	e9 6f fe ff ff       	jmp    c00024a6 <map_vga+0x56>
c0002637:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000263e:	66 90                	xchg   %ax,%ax
c0002640:	83 ec 08             	sub    $0x8,%esp
c0002643:	6a 06                	push   $0x6
c0002645:	68 00 a0 0b 00       	push   $0xba000
c000264a:	e8 21 fc ff ff       	call   c0002270 <new_page_table>
c000264f:	83 c4 10             	add    $0x10,%esp
c0002652:	e9 8a fe ff ff       	jmp    c00024e1 <map_vga+0x91>
c0002657:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000265e:	66 90                	xchg   %ax,%ax
c0002660:	83 ec 08             	sub    $0x8,%esp
c0002663:	6a 06                	push   $0x6
c0002665:	68 00 b0 0b 00       	push   $0xbb000
c000266a:	e8 01 fc ff ff       	call   c0002270 <new_page_table>
c000266f:	83 c4 10             	add    $0x10,%esp
c0002672:	e9 a5 fe ff ff       	jmp    c000251c <map_vga+0xcc>
c0002677:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000267e:	66 90                	xchg   %ax,%ax
c0002680:	83 ec 08             	sub    $0x8,%esp
c0002683:	6a 06                	push   $0x6
c0002685:	68 00 c0 0b 00       	push   $0xbc000
c000268a:	e8 e1 fb ff ff       	call   c0002270 <new_page_table>
c000268f:	83 c4 10             	add    $0x10,%esp
c0002692:	e9 c0 fe ff ff       	jmp    c0002557 <map_vga+0x107>
c0002697:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000269e:	66 90                	xchg   %ax,%ax
c00026a0:	83 ec 08             	sub    $0x8,%esp
c00026a3:	6a 06                	push   $0x6
c00026a5:	68 00 d0 0b 00       	push   $0xbd000
c00026aa:	e8 c1 fb ff ff       	call   c0002270 <new_page_table>
c00026af:	83 c4 10             	add    $0x10,%esp
c00026b2:	e9 db fe ff ff       	jmp    c0002592 <map_vga+0x142>
c00026b7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00026be:	66 90                	xchg   %ax,%ax
c00026c0:	83 ec 08             	sub    $0x8,%esp
c00026c3:	6a 06                	push   $0x6
c00026c5:	68 00 e0 0b 00       	push   $0xbe000
c00026ca:	e8 a1 fb ff ff       	call   c0002270 <new_page_table>
c00026cf:	83 c4 10             	add    $0x10,%esp
c00026d2:	e9 f6 fe ff ff       	jmp    c00025cd <map_vga+0x17d>
c00026d7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00026de:	66 90                	xchg   %ax,%ax

c00026e0 <memory_init>:
{
c00026e0:	55                   	push   %ebp
c00026e1:	89 e5                	mov    %esp,%ebp
c00026e3:	83 ec 14             	sub    $0x14,%esp
	if(! heap_init(mbd) )
c00026e6:	ff 75 08             	pushl  0x8(%ebp)
c00026e9:	e8 a2 fc ff ff       	call   c0002390 <heap_init>
c00026ee:	83 c4 10             	add    $0x10,%esp
c00026f1:	85 c0                	test   %eax,%eax
c00026f3:	74 25                	je     c000271a <memory_init+0x3a>
    pd->dir.pde[0] = PAGE_FLAG_EMPTY;
c00026f5:	a1 00 40 00 c0       	mov    0xc0004000,%eax
c00026fa:	c7 80 00 f0 3f 00 00 	movl   $0x0,0x3ff000(%eax)
c0002701:	00 00 00 
    refresh_tlb();
c0002704:	e8 97 06 00 00       	call   c0002da0 <refresh_tlb>
	if(! map_vga() )
c0002709:	e8 42 fd ff ff       	call   c0002450 <map_vga>
}
c000270e:	c9                   	leave  
	if(! map_vga() )
c000270f:	85 c0                	test   %eax,%eax
c0002711:	0f 94 c0             	sete   %al
c0002714:	0f b6 c0             	movzbl %al,%eax
c0002717:	f7 d8                	neg    %eax
}
c0002719:	c3                   	ret    
c000271a:	c9                   	leave  
        return -1;
c000271b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0002720:	c3                   	ret    
c0002721:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0002728:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000272f:	90                   	nop

c0002730 <kmalloc_aligned>:
{
c0002730:	55                   	push   %ebp
c0002731:	89 e5                	mov    %esp,%ebp
c0002733:	57                   	push   %edi
c0002734:	56                   	push   %esi
c0002735:	53                   	push   %ebx
c0002736:	83 ec 0c             	sub    $0xc,%esp
c0002739:	8b 45 08             	mov    0x8(%ebp),%eax
c000273c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
}

inline int is_pow_of_two(uint32_t x)
{
    return (x != 0) && ((x & (x - 1)) == 0);
c000273f:	85 c0                	test   %eax,%eax
c0002741:	0f 84 8c 00 00 00    	je     c00027d3 <kmalloc_aligned+0xa3>
c0002747:	85 db                	test   %ebx,%ebx
c0002749:	0f 84 84 00 00 00    	je     c00027d3 <kmalloc_aligned+0xa3>
c000274f:	8d 4b ff             	lea    -0x1(%ebx),%ecx
c0002752:	85 cb                	test   %ecx,%ebx
c0002754:	75 7d                	jne    c00027d3 <kmalloc_aligned+0xa3>
    return (char*) (((uint32_t)addr + am) & ~am);
c0002756:	8b 3d 38 b8 00 c0    	mov    0xc000b838,%edi
c000275c:	f7 db                	neg    %ebx
c000275e:	89 da                	mov    %ebx,%edx
c0002760:	01 cf                	add    %ecx,%edi
c0002762:	21 df                	and    %ebx,%edi
    char* mem_end = align_addr(mem+sz, alignment); //first byte past end of allocated region
c0002764:	01 f8                	add    %edi,%eax
c0002766:	8d 1c 08             	lea    (%eax,%ecx,1),%ebx
c0002769:	21 d3                	and    %edx,%ebx
    if(mem_end > heap_end)
c000276b:	39 1d 34 b8 00 c0    	cmp    %ebx,0xc000b834
c0002771:	72 60                	jb     c00027d3 <kmalloc_aligned+0xa3>
    page_t* page_end = (page_t*) (((uint32_t) mem_end - 1) & PAGE_ADDRMASK);
c0002773:	8d 73 ff             	lea    -0x1(%ebx),%esi
c0002776:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
    while(page_end > heap_page)
c000277c:	eb 24                	jmp    c00027a2 <kmalloc_aligned+0x72>
c000277e:	66 90                	xchg   %ax,%ax
    return ++heap_page_phys;
c0002780:	89 15 3c b8 00 c0    	mov    %edx,0xc000b83c
// returns next available virtual page from the heap and updates the heap_page_phys pointer
// this does *not* update the heap pointer
// returns NULL on OOM
page_t* get_next_heap_page_virt()
{
    if( (uint32_t) (heap_page+1) > (uint32_t) heap_end)
c0002786:	39 c1                	cmp    %eax,%ecx
c0002788:	72 49                	jb     c00027d3 <kmalloc_aligned+0xa3>
        if(!map_page_at(pv, pp, PAGE_FLAG_WRITE))
c000278a:	83 ec 04             	sub    $0x4,%esp
    {
        //out of memory
        return NULL;
    }
    return ++heap_page;
c000278d:	a3 40 b8 00 c0       	mov    %eax,0xc000b840
        if(!map_page_at(pv, pp, PAGE_FLAG_WRITE))
c0002792:	6a 02                	push   $0x2
c0002794:	52                   	push   %edx
c0002795:	50                   	push   %eax
c0002796:	e8 75 fb ff ff       	call   c0002310 <map_page_at>
c000279b:	83 c4 10             	add    $0x10,%esp
c000279e:	85 c0                	test   %eax,%eax
c00027a0:	74 31                	je     c00027d3 <kmalloc_aligned+0xa3>
    while(page_end > heap_page)
c00027a2:	a1 40 b8 00 c0       	mov    0xc000b840,%eax
c00027a7:	39 f0                	cmp    %esi,%eax
c00027a9:	73 35                	jae    c00027e0 <kmalloc_aligned+0xb0>
    if( (uint32_t) (heap_page_phys+1) > (uint32_t) heap_end_phys)
c00027ab:	8b 0d 3c b8 00 c0    	mov    0xc000b83c,%ecx
    if( (uint32_t) (heap_page+1) > (uint32_t) heap_end)
c00027b1:	05 00 10 00 00       	add    $0x1000,%eax
    if( (uint32_t) (heap_page_phys+1) > (uint32_t) heap_end_phys)
c00027b6:	8d 91 00 10 00 00    	lea    0x1000(%ecx),%edx
    if( (uint32_t) (heap_page+1) > (uint32_t) heap_end)
c00027bc:	8b 0d 34 b8 00 c0    	mov    0xc000b834,%ecx
    if( (uint32_t) (heap_page_phys+1) > (uint32_t) heap_end_phys)
c00027c2:	3b 15 30 b8 00 c0    	cmp    0xc000b830,%edx
c00027c8:	76 b6                	jbe    c0002780 <kmalloc_aligned+0x50>
    if( (uint32_t) (heap_page+1) > (uint32_t) heap_end)
c00027ca:	39 c1                	cmp    %eax,%ecx
c00027cc:	72 05                	jb     c00027d3 <kmalloc_aligned+0xa3>
    return ++heap_page;
c00027ce:	a3 40 b8 00 c0       	mov    %eax,0xc000b840
            return NULL; //OOM
c00027d3:	31 ff                	xor    %edi,%edi
}
c00027d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
c00027d8:	89 f8                	mov    %edi,%eax
c00027da:	5b                   	pop    %ebx
c00027db:	5e                   	pop    %esi
c00027dc:	5f                   	pop    %edi
c00027dd:	5d                   	pop    %ebp
c00027de:	c3                   	ret    
c00027df:	90                   	nop
    heap = mem_end;     //update pointer to end of used heap
c00027e0:	89 1d 38 b8 00 c0    	mov    %ebx,0xc000b838
    return (void*) mem;
c00027e6:	eb ed                	jmp    c00027d5 <kmalloc_aligned+0xa5>
c00027e8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00027ef:	90                   	nop

c00027f0 <kmalloc>:
{
c00027f0:	55                   	push   %ebp
c00027f1:	89 e5                	mov    %esp,%ebp
c00027f3:	83 ec 10             	sub    $0x10,%esp
    return kmalloc_aligned(sz, 4);
c00027f6:	6a 04                	push   $0x4
c00027f8:	ff 75 08             	pushl  0x8(%ebp)
c00027fb:	e8 30 ff ff ff       	call   c0002730 <kmalloc_aligned>
}
c0002800:	c9                   	leave  
c0002801:	c3                   	ret    
c0002802:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0002809:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

c0002810 <memset>:
{
c0002810:	55                   	push   %ebp
c0002811:	89 e5                	mov    %esp,%ebp
c0002813:	56                   	push   %esi
c0002814:	8b 75 10             	mov    0x10(%ebp),%esi
        m[nn] = val;
c0002817:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
{
c000281b:	53                   	push   %ebx
c000281c:	8b 5d 08             	mov    0x8(%ebp),%ebx
    for(size_t nn=0;nn<cnt; nn++)
c000281f:	8d 14 33             	lea    (%ebx,%esi,1),%edx
c0002822:	85 f6                	test   %esi,%esi
c0002824:	74 13                	je     c0002839 <memset+0x29>
c0002826:	89 d8                	mov    %ebx,%eax
c0002828:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000282f:	90                   	nop
        m[nn] = val;
c0002830:	88 08                	mov    %cl,(%eax)
    for(size_t nn=0;nn<cnt; nn++)
c0002832:	83 c0 01             	add    $0x1,%eax
c0002835:	39 d0                	cmp    %edx,%eax
c0002837:	75 f7                	jne    c0002830 <memset+0x20>
}
c0002839:	89 d8                	mov    %ebx,%eax
c000283b:	5b                   	pop    %ebx
c000283c:	5e                   	pop    %esi
c000283d:	5d                   	pop    %ebp
c000283e:	c3                   	ret    
c000283f:	90                   	nop

c0002840 <get_next_heap_page_phys>:
    if( (uint32_t) (heap_page_phys+1) > (uint32_t) heap_end_phys)
c0002840:	a1 3c b8 00 c0       	mov    0xc000b83c,%eax
c0002845:	05 00 10 00 00       	add    $0x1000,%eax
c000284a:	3b 05 30 b8 00 c0    	cmp    0xc000b830,%eax
c0002850:	77 0e                	ja     c0002860 <get_next_heap_page_phys+0x20>
    return ++heap_page_phys;
c0002852:	a3 3c b8 00 c0       	mov    %eax,0xc000b83c
c0002857:	c3                   	ret    
c0002858:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000285f:	90                   	nop
        return NULL;
c0002860:	31 c0                	xor    %eax,%eax
}
c0002862:	c3                   	ret    
c0002863:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000286a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

c0002870 <get_next_heap_page_virt>:
    if( (uint32_t) (heap_page+1) > (uint32_t) heap_end)
c0002870:	a1 40 b8 00 c0       	mov    0xc000b840,%eax
c0002875:	05 00 10 00 00       	add    $0x1000,%eax
c000287a:	3b 05 34 b8 00 c0    	cmp    0xc000b834,%eax
c0002880:	77 0e                	ja     c0002890 <get_next_heap_page_virt+0x20>
    return ++heap_page;
c0002882:	a3 40 b8 00 c0       	mov    %eax,0xc000b840
c0002887:	c3                   	ret    
c0002888:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000288f:	90                   	nop
        return NULL;
c0002890:	31 c0                	xor    %eax,%eax
}
c0002892:	c3                   	ret    
c0002893:	66 90                	xchg   %ax,%ax
c0002895:	66 90                	xchg   %ax,%ax
c0002897:	66 90                	xchg   %ax,%ax
c0002899:	66 90                	xchg   %ax,%ax
c000289b:	66 90                	xchg   %ax,%ax
c000289d:	66 90                	xchg   %ax,%ax
c000289f:	90                   	nop

c00028a0 <scancode_to_ascii>:
    0,  /* F12 Key */
    0,  /* All other keys are undefined */
};

char scancode_to_ascii(uint8_t scancode)
{
c00028a0:	55                   	push   %ebp
c00028a1:	89 e5                	mov    %esp,%ebp
    return kbd_US[scancode];
c00028a3:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
}
c00028a7:	5d                   	pop    %ebp
    return kbd_US[scancode];
c00028a8:	0f b6 80 20 40 00 c0 	movzbl -0x3fffbfe0(%eax),%eax
}
c00028af:	c3                   	ret    

c00028b0 <kernel_main>:
#if defined(__linux__)  || !defined(__i386__)
#error "This kernel requires ix86-elf cross compiler"
#endif

void kernel_main(multiboot_info_t* mbd)
{
c00028b0:	55                   	push   %ebp
c00028b1:	89 e5                	mov    %esp,%ebp
c00028b3:	53                   	push   %ebx
c00028b4:	83 ec 04             	sub    $0x4,%esp
c00028b7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	init_gdt();
c00028ba:	e8 51 00 00 00       	call   c0002910 <init_gdt>
	init_interrupts();
c00028bf:	e8 ac ec ff ff       	call   c0001570 <init_interrupts>

	terminal_init(&stdout);
c00028c4:	83 ec 0c             	sub    $0xc,%esp
c00028c7:	68 20 b8 00 c0       	push   $0xc000b820
c00028cc:	e8 ef f1 ff ff       	call   c0001ac0 <terminal_init>

    // terminal_setcolor(&stdout, VGA_COLOR_WHITE);
	kprintf("Let's learn about Operating Systems!\n");
c00028d1:	c7 04 24 f4 34 00 c0 	movl   $0xc00034f4,(%esp)
c00028d8:	e8 b3 d8 ff ff       	call   c0000190 <kprintf>
	kprintf("Jon Doane, 2020\n\n");
c00028dd:	c7 04 24 cb 33 00 c0 	movl   $0xc00033cb,(%esp)
c00028e4:	e8 a7 d8 ff ff       	call   c0000190 <kprintf>

	print_memory_table(mbd);
c00028e9:	89 1c 24             	mov    %ebx,(%esp)
c00028ec:	e8 af eb ff ff       	call   c00014a0 <print_memory_table>
	memory_init(mbd);	//after this the multiboot structure is unmapped
c00028f1:	89 1c 24             	mov    %ebx,(%esp)
c00028f4:	e8 e7 fd ff ff       	call   c00026e0 <memory_init>
	// int* d = (int*) 0xbadbadba;
	// kprintf("Try a page fault...");
	// int e = *d;
	// kprintf("%d\n",e);

	kprintf("$ ");
c00028f9:	c7 04 24 dd 33 00 c0 	movl   $0xc00033dd,(%esp)
c0002900:	e8 8b d8 ff ff       	call   c0000190 <kprintf>
c0002905:	83 c4 10             	add    $0x10,%esp
	while(1);
c0002908:	eb fe                	jmp    c0002908 <kernel_main+0x58>
c000290a:	66 90                	xchg   %ax,%ax
c000290c:	66 90                	xchg   %ax,%ax
c000290e:	66 90                	xchg   %ax,%ax

c0002910 <init_gdt>:
gdt_description_t __aligned  gdtd;

tss_entry_t tss = {0};

void init_gdt()
{
c0002910:	55                   	push   %ebp
    // gdt[0] unused
    populate_gdt_entry(&gdt[1], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(0) | SEG_DESCTYPE(1) | SEG_CODE_EXRD, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // priv code, seg 0x008
    populate_gdt_entry(&gdt[2], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(0) | SEG_DESCTYPE(1) | SEG_DATA_RDWR, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // priv data, seg 0x010
    populate_gdt_entry(&gdt[3], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(3) | SEG_DESCTYPE(1) | SEG_CODE_EXRD, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // user code, seg 0x018
    populate_gdt_entry(&gdt[4], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(3) | SEG_DESCTYPE(1) | SEG_DATA_RDWR, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // user data  seg 0x020
    populate_gdt_entry(&gdt[5], &tss, sizeof(tss_entry_t), SEG_TSS, SEG_FLAG_TSS); // tss, seg 0x028
c0002911:	b8 60 b8 00 c0       	mov    $0xc000b860,%eax
} tss_entry_t;


inline void populate_gdt_entry(gdt_entry_t* sd, uint32_t base, uint32_t limit, uint8_t access, uint8_t flags)
{
    sd->limit_low = limit & SEGMENT_LIMIT_LOW_MASK;
c0002916:	ba 68 00 00 00       	mov    $0x68,%edx
    sd->limit_high = (limit & SEGMENT_LIMIT_HIGH_MASK) >> 16;
    sd->base_low = base & SEGMENT_BASE_LOW_MASK;
    sd->base_mid = (base & SEGMENT_BASE_MID_MASK) >> 16;
    sd->base_high = (base & SEGMENT_BASE_HIGH_MASK) >> 24;
    sd->access = access;
c000291b:	b9 89 40 00 00       	mov    $0x4089,%ecx
{
c0002920:	89 e5                	mov    %esp,%ebp
c0002922:	83 ec 14             	sub    $0x14,%esp
    sd->limit_low = limit & SEGMENT_LIMIT_LOW_MASK;
c0002925:	66 89 15 28 b9 00 c0 	mov    %dx,0xc000b928
    sd->base_mid = (base & SEGMENT_BASE_MID_MASK) >> 16;
c000292c:	89 c2                	mov    %eax,%edx
    sd->base_low = base & SEGMENT_BASE_LOW_MASK;
c000292e:	66 a3 2a b9 00 c0    	mov    %ax,0xc000b92a
    sd->base_high = (base & SEGMENT_BASE_HIGH_MASK) >> 24;
c0002934:	c1 e8 18             	shr    $0x18,%eax
    sd->base_mid = (base & SEGMENT_BASE_MID_MASK) >> 16;
c0002937:	c1 ea 10             	shr    $0x10,%edx
    tss.iomap_base = sizeof(tss_entry_t);
    // before we can actually switch tasks, we must first set the kernel stack pointer, with update_tss()

    gdtd.addr = gdt;
    gdtd.size = sizeof(gdt);    
    load_gdt(&gdtd);
c000293a:	68 e0 b8 00 c0       	push   $0xc000b8e0
    sd->base_high = (base & SEGMENT_BASE_HIGH_MASK) >> 24;
c000293f:	a2 2f b9 00 c0       	mov    %al,0xc000b92f
    tss.iomap_base = sizeof(tss_entry_t);
c0002944:	b8 68 00 00 00       	mov    $0x68,%eax
c0002949:	66 a3 c6 b8 00 c0    	mov    %ax,0xc000b8c6
    gdtd.size = sizeof(gdt);    
c000294f:	b8 30 00 00 00       	mov    $0x30,%eax
    sd->limit_low = limit & SEGMENT_LIMIT_LOW_MASK;
c0002954:	c7 05 08 b9 00 c0 ff 	movl   $0xffff,0xc000b908
c000295b:	ff 00 00 
    sd->base_mid = (base & SEGMENT_BASE_MID_MASK) >> 16;
c000295e:	c7 05 0c b9 00 c0 00 	movl   $0xcf9a00,0xc000b90c
c0002965:	9a cf 00 
    sd->limit_low = limit & SEGMENT_LIMIT_LOW_MASK;
c0002968:	c7 05 10 b9 00 c0 ff 	movl   $0xffff,0xc000b910
c000296f:	ff 00 00 
    sd->base_mid = (base & SEGMENT_BASE_MID_MASK) >> 16;
c0002972:	c7 05 14 b9 00 c0 00 	movl   $0xcf9200,0xc000b914
c0002979:	92 cf 00 
    sd->limit_low = limit & SEGMENT_LIMIT_LOW_MASK;
c000297c:	c7 05 18 b9 00 c0 ff 	movl   $0xffff,0xc000b918
c0002983:	ff 00 00 
    sd->base_mid = (base & SEGMENT_BASE_MID_MASK) >> 16;
c0002986:	c7 05 1c b9 00 c0 00 	movl   $0xcffa00,0xc000b91c
c000298d:	fa cf 00 
    sd->limit_low = limit & SEGMENT_LIMIT_LOW_MASK;
c0002990:	c7 05 20 b9 00 c0 ff 	movl   $0xffff,0xc000b920
c0002997:	ff 00 00 
    sd->base_mid = (base & SEGMENT_BASE_MID_MASK) >> 16;
c000299a:	c7 05 24 b9 00 c0 00 	movl   $0xcff200,0xc000b924
c00029a1:	f2 cf 00 
c00029a4:	88 15 2c b9 00 c0    	mov    %dl,0xc000b92c
    sd->access = access;
c00029aa:	66 89 0d 2d b9 00 c0 	mov    %cx,0xc000b92d
    tss.ss0 = KERNEL_DATA_SEGMENT; //kernel data segment    
c00029b1:	c7 05 68 b8 00 c0 10 	movl   $0x10,0xc000b868
c00029b8:	00 00 00 
    gdtd.addr = gdt;
c00029bb:	c7 05 e2 b8 00 c0 00 	movl   $0xc000b900,0xc000b8e2
c00029c2:	b9 00 c0 
    gdtd.size = sizeof(gdt);    
c00029c5:	66 a3 e0 b8 00 c0    	mov    %ax,0xc000b8e0
    load_gdt(&gdtd);
c00029cb:	e8 24 00 00 00       	call   c00029f4 <load_gdt>
}
c00029d0:	83 c4 10             	add    $0x10,%esp
c00029d3:	c9                   	leave  
c00029d4:	c3                   	ret    
c00029d5:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00029dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

c00029e0 <update_tss>:

void update_tss(uint32_t kernel_stack_ptr)
{
c00029e0:	55                   	push   %ebp
c00029e1:	89 e5                	mov    %esp,%ebp
    tss.esp0 = kernel_stack_ptr; //kernel stack ptr
c00029e3:	8b 45 08             	mov    0x8(%ebp),%eax
    load_tss();
}
c00029e6:	5d                   	pop    %ebp
    tss.esp0 = kernel_stack_ptr; //kernel stack ptr
c00029e7:	a3 64 b8 00 c0       	mov    %eax,0xc000b864
    load_tss();
c00029ec:	e9 23 00 00 00       	jmp    c0002a14 <load_tss>
c00029f1:	66 90                	xchg   %ax,%ax
c00029f3:	90                   	nop

c00029f4 <load_gdt>:
c00029f4:	0f 01 15 e0 b8 00 c0 	lgdtl  0xc000b8e0
c00029fb:	ea 02 2a 00 c0 08 00 	ljmp   $0x8,$0xc0002a02

c0002a02 <complete_flush>:
c0002a02:	66 b8 10 00          	mov    $0x10,%ax
c0002a06:	8e d8                	mov    %eax,%ds
c0002a08:	8e c0                	mov    %eax,%es
c0002a0a:	8e e0                	mov    %eax,%fs
c0002a0c:	8e e8                	mov    %eax,%gs
c0002a0e:	8e d0                	mov    %eax,%ss
c0002a10:	c3                   	ret    
c0002a11:	8d 76 00             	lea    0x0(%esi),%esi

c0002a14 <load_tss>:
c0002a14:	66 b8 28 00          	mov    $0x28,%ax
c0002a18:	66 83 c8 03          	or     $0x3,%ax
c0002a1c:	0f 00 d8             	ltr    %ax
c0002a1f:	c3                   	ret    

c0002a20 <load_idt>:
c0002a20:	0f 01 1d 00 b0 00 c0 	lidtl  0xc000b000
c0002a27:	fb                   	sti    
c0002a28:	c3                   	ret    
c0002a29:	8d 76 00             	lea    0x0(%esi),%esi

c0002a2c <except_0>:
c0002a2c:	60                   	pusha  
c0002a2d:	b8 00 00 00 00       	mov    $0x0,%eax
c0002a32:	50                   	push   %eax
c0002a33:	b8 00 00 00 00       	mov    $0x0,%eax
c0002a38:	50                   	push   %eax
c0002a39:	e8 02 f0 ff ff       	call   c0001a40 <exception_handler>
c0002a3e:	83 c4 08             	add    $0x8,%esp
c0002a41:	61                   	popa   
c0002a42:	cf                   	iret   
c0002a43:	90                   	nop

c0002a44 <except_1>:
c0002a44:	60                   	pusha  
c0002a45:	b8 00 00 00 00       	mov    $0x0,%eax
c0002a4a:	50                   	push   %eax
c0002a4b:	b8 01 00 00 00       	mov    $0x1,%eax
c0002a50:	50                   	push   %eax
c0002a51:	e8 ea ef ff ff       	call   c0001a40 <exception_handler>
c0002a56:	83 c4 08             	add    $0x8,%esp
c0002a59:	61                   	popa   
c0002a5a:	cf                   	iret   
c0002a5b:	90                   	nop

c0002a5c <except_2>:
c0002a5c:	60                   	pusha  
c0002a5d:	b8 00 00 00 00       	mov    $0x0,%eax
c0002a62:	50                   	push   %eax
c0002a63:	b8 02 00 00 00       	mov    $0x2,%eax
c0002a68:	50                   	push   %eax
c0002a69:	e8 d2 ef ff ff       	call   c0001a40 <exception_handler>
c0002a6e:	83 c4 08             	add    $0x8,%esp
c0002a71:	61                   	popa   
c0002a72:	cf                   	iret   
c0002a73:	90                   	nop

c0002a74 <except_3>:
c0002a74:	60                   	pusha  
c0002a75:	b8 00 00 00 00       	mov    $0x0,%eax
c0002a7a:	50                   	push   %eax
c0002a7b:	b8 03 00 00 00       	mov    $0x3,%eax
c0002a80:	50                   	push   %eax
c0002a81:	e8 ba ef ff ff       	call   c0001a40 <exception_handler>
c0002a86:	83 c4 08             	add    $0x8,%esp
c0002a89:	61                   	popa   
c0002a8a:	cf                   	iret   
c0002a8b:	90                   	nop

c0002a8c <except_4>:
c0002a8c:	60                   	pusha  
c0002a8d:	b8 00 00 00 00       	mov    $0x0,%eax
c0002a92:	50                   	push   %eax
c0002a93:	b8 04 00 00 00       	mov    $0x4,%eax
c0002a98:	50                   	push   %eax
c0002a99:	e8 a2 ef ff ff       	call   c0001a40 <exception_handler>
c0002a9e:	83 c4 08             	add    $0x8,%esp
c0002aa1:	61                   	popa   
c0002aa2:	cf                   	iret   
c0002aa3:	90                   	nop

c0002aa4 <except_5>:
c0002aa4:	60                   	pusha  
c0002aa5:	b8 00 00 00 00       	mov    $0x0,%eax
c0002aaa:	50                   	push   %eax
c0002aab:	b8 05 00 00 00       	mov    $0x5,%eax
c0002ab0:	50                   	push   %eax
c0002ab1:	e8 8a ef ff ff       	call   c0001a40 <exception_handler>
c0002ab6:	83 c4 08             	add    $0x8,%esp
c0002ab9:	61                   	popa   
c0002aba:	cf                   	iret   
c0002abb:	90                   	nop

c0002abc <except_6>:
c0002abc:	60                   	pusha  
c0002abd:	b8 00 00 00 00       	mov    $0x0,%eax
c0002ac2:	50                   	push   %eax
c0002ac3:	b8 06 00 00 00       	mov    $0x6,%eax
c0002ac8:	50                   	push   %eax
c0002ac9:	e8 72 ef ff ff       	call   c0001a40 <exception_handler>
c0002ace:	83 c4 08             	add    $0x8,%esp
c0002ad1:	61                   	popa   
c0002ad2:	cf                   	iret   
c0002ad3:	90                   	nop

c0002ad4 <except_7>:
c0002ad4:	60                   	pusha  
c0002ad5:	b8 00 00 00 00       	mov    $0x0,%eax
c0002ada:	50                   	push   %eax
c0002adb:	b8 07 00 00 00       	mov    $0x7,%eax
c0002ae0:	50                   	push   %eax
c0002ae1:	e8 5a ef ff ff       	call   c0001a40 <exception_handler>
c0002ae6:	83 c4 08             	add    $0x8,%esp
c0002ae9:	61                   	popa   
c0002aea:	cf                   	iret   
c0002aeb:	90                   	nop

c0002aec <except_8>:
c0002aec:	60                   	pusha  
c0002aed:	8b 44 24 24          	mov    0x24(%esp),%eax
c0002af1:	50                   	push   %eax
c0002af2:	b8 08 00 00 00       	mov    $0x8,%eax
c0002af7:	50                   	push   %eax
c0002af8:	e8 43 ef ff ff       	call   c0001a40 <exception_handler>
c0002afd:	83 c4 08             	add    $0x8,%esp
c0002b00:	61                   	popa   
c0002b01:	83 c4 04             	add    $0x4,%esp
c0002b04:	cf                   	iret   
c0002b05:	8d 76 00             	lea    0x0(%esi),%esi

c0002b08 <except_10>:
c0002b08:	60                   	pusha  
c0002b09:	8b 44 24 24          	mov    0x24(%esp),%eax
c0002b0d:	50                   	push   %eax
c0002b0e:	b8 0a 00 00 00       	mov    $0xa,%eax
c0002b13:	50                   	push   %eax
c0002b14:	e8 27 ef ff ff       	call   c0001a40 <exception_handler>
c0002b19:	83 c4 08             	add    $0x8,%esp
c0002b1c:	61                   	popa   
c0002b1d:	83 c4 04             	add    $0x4,%esp
c0002b20:	cf                   	iret   
c0002b21:	8d 76 00             	lea    0x0(%esi),%esi

c0002b24 <except_11>:
c0002b24:	60                   	pusha  
c0002b25:	8b 44 24 24          	mov    0x24(%esp),%eax
c0002b29:	50                   	push   %eax
c0002b2a:	b8 0b 00 00 00       	mov    $0xb,%eax
c0002b2f:	50                   	push   %eax
c0002b30:	e8 0b ef ff ff       	call   c0001a40 <exception_handler>
c0002b35:	83 c4 08             	add    $0x8,%esp
c0002b38:	61                   	popa   
c0002b39:	83 c4 04             	add    $0x4,%esp
c0002b3c:	cf                   	iret   
c0002b3d:	8d 76 00             	lea    0x0(%esi),%esi

c0002b40 <except_12>:
c0002b40:	60                   	pusha  
c0002b41:	8b 44 24 24          	mov    0x24(%esp),%eax
c0002b45:	50                   	push   %eax
c0002b46:	b8 0c 00 00 00       	mov    $0xc,%eax
c0002b4b:	50                   	push   %eax
c0002b4c:	e8 ef ee ff ff       	call   c0001a40 <exception_handler>
c0002b51:	83 c4 08             	add    $0x8,%esp
c0002b54:	61                   	popa   
c0002b55:	83 c4 04             	add    $0x4,%esp
c0002b58:	cf                   	iret   
c0002b59:	8d 76 00             	lea    0x0(%esi),%esi

c0002b5c <except_13>:
c0002b5c:	60                   	pusha  
c0002b5d:	8b 44 24 24          	mov    0x24(%esp),%eax
c0002b61:	50                   	push   %eax
c0002b62:	b8 0d 00 00 00       	mov    $0xd,%eax
c0002b67:	50                   	push   %eax
c0002b68:	e8 d3 ee ff ff       	call   c0001a40 <exception_handler>
c0002b6d:	83 c4 08             	add    $0x8,%esp
c0002b70:	61                   	popa   
c0002b71:	83 c4 04             	add    $0x4,%esp
c0002b74:	cf                   	iret   
c0002b75:	8d 76 00             	lea    0x0(%esi),%esi

c0002b78 <except_14>:
c0002b78:	60                   	pusha  
c0002b79:	8b 44 24 24          	mov    0x24(%esp),%eax
c0002b7d:	50                   	push   %eax
c0002b7e:	b8 0e 00 00 00       	mov    $0xe,%eax
c0002b83:	50                   	push   %eax
c0002b84:	e8 b7 ee ff ff       	call   c0001a40 <exception_handler>
c0002b89:	83 c4 08             	add    $0x8,%esp
c0002b8c:	61                   	popa   
c0002b8d:	83 c4 04             	add    $0x4,%esp
c0002b90:	cf                   	iret   
c0002b91:	8d 76 00             	lea    0x0(%esi),%esi

c0002b94 <except_16>:
c0002b94:	60                   	pusha  
c0002b95:	8b 44 24 24          	mov    0x24(%esp),%eax
c0002b99:	50                   	push   %eax
c0002b9a:	b8 10 00 00 00       	mov    $0x10,%eax
c0002b9f:	50                   	push   %eax
c0002ba0:	e8 9b ee ff ff       	call   c0001a40 <exception_handler>
c0002ba5:	83 c4 08             	add    $0x8,%esp
c0002ba8:	61                   	popa   
c0002ba9:	83 c4 04             	add    $0x4,%esp
c0002bac:	cf                   	iret   
c0002bad:	8d 76 00             	lea    0x0(%esi),%esi

c0002bb0 <except_17>:
c0002bb0:	60                   	pusha  
c0002bb1:	8b 44 24 24          	mov    0x24(%esp),%eax
c0002bb5:	50                   	push   %eax
c0002bb6:	b8 11 00 00 00       	mov    $0x11,%eax
c0002bbb:	50                   	push   %eax
c0002bbc:	e8 7f ee ff ff       	call   c0001a40 <exception_handler>
c0002bc1:	83 c4 08             	add    $0x8,%esp
c0002bc4:	61                   	popa   
c0002bc5:	83 c4 04             	add    $0x4,%esp
c0002bc8:	cf                   	iret   
c0002bc9:	8d 76 00             	lea    0x0(%esi),%esi

c0002bcc <except_18>:
c0002bcc:	60                   	pusha  
c0002bcd:	8b 44 24 24          	mov    0x24(%esp),%eax
c0002bd1:	50                   	push   %eax
c0002bd2:	b8 12 00 00 00       	mov    $0x12,%eax
c0002bd7:	50                   	push   %eax
c0002bd8:	e8 63 ee ff ff       	call   c0001a40 <exception_handler>
c0002bdd:	83 c4 08             	add    $0x8,%esp
c0002be0:	61                   	popa   
c0002be1:	83 c4 04             	add    $0x4,%esp
c0002be4:	cf                   	iret   
c0002be5:	8d 76 00             	lea    0x0(%esi),%esi

c0002be8 <except_19>:
c0002be8:	60                   	pusha  
c0002be9:	8b 44 24 24          	mov    0x24(%esp),%eax
c0002bed:	50                   	push   %eax
c0002bee:	b8 13 00 00 00       	mov    $0x13,%eax
c0002bf3:	50                   	push   %eax
c0002bf4:	e8 47 ee ff ff       	call   c0001a40 <exception_handler>
c0002bf9:	83 c4 08             	add    $0x8,%esp
c0002bfc:	61                   	popa   
c0002bfd:	83 c4 04             	add    $0x4,%esp
c0002c00:	cf                   	iret   
c0002c01:	8d 76 00             	lea    0x0(%esi),%esi

c0002c04 <except_20>:
c0002c04:	60                   	pusha  
c0002c05:	8b 44 24 24          	mov    0x24(%esp),%eax
c0002c09:	50                   	push   %eax
c0002c0a:	b8 14 00 00 00       	mov    $0x14,%eax
c0002c0f:	50                   	push   %eax
c0002c10:	e8 2b ee ff ff       	call   c0001a40 <exception_handler>
c0002c15:	83 c4 08             	add    $0x8,%esp
c0002c18:	61                   	popa   
c0002c19:	83 c4 04             	add    $0x4,%esp
c0002c1c:	cf                   	iret   
c0002c1d:	8d 76 00             	lea    0x0(%esi),%esi

c0002c20 <except_30>:
c0002c20:	60                   	pusha  
c0002c21:	8b 44 24 24          	mov    0x24(%esp),%eax
c0002c25:	50                   	push   %eax
c0002c26:	b8 1e 00 00 00       	mov    $0x1e,%eax
c0002c2b:	50                   	push   %eax
c0002c2c:	e8 0f ee ff ff       	call   c0001a40 <exception_handler>
c0002c31:	83 c4 08             	add    $0x8,%esp
c0002c34:	61                   	popa   
c0002c35:	83 c4 04             	add    $0x4,%esp
c0002c38:	cf                   	iret   
c0002c39:	8d 76 00             	lea    0x0(%esi),%esi

c0002c3c <irq_0>:
c0002c3c:	60                   	pusha  
c0002c3d:	b8 00 00 00 00       	mov    $0x0,%eax
c0002c42:	50                   	push   %eax
c0002c43:	e8 18 ee ff ff       	call   c0001a60 <irq_handler>
c0002c48:	83 c4 04             	add    $0x4,%esp
c0002c4b:	61                   	popa   
c0002c4c:	cf                   	iret   
c0002c4d:	8d 76 00             	lea    0x0(%esi),%esi

c0002c50 <irq_1>:
c0002c50:	60                   	pusha  
c0002c51:	b8 01 00 00 00       	mov    $0x1,%eax
c0002c56:	50                   	push   %eax
c0002c57:	e8 04 ee ff ff       	call   c0001a60 <irq_handler>
c0002c5c:	83 c4 04             	add    $0x4,%esp
c0002c5f:	61                   	popa   
c0002c60:	cf                   	iret   
c0002c61:	8d 76 00             	lea    0x0(%esi),%esi

c0002c64 <irq_2>:
c0002c64:	60                   	pusha  
c0002c65:	b8 02 00 00 00       	mov    $0x2,%eax
c0002c6a:	50                   	push   %eax
c0002c6b:	e8 f0 ed ff ff       	call   c0001a60 <irq_handler>
c0002c70:	83 c4 04             	add    $0x4,%esp
c0002c73:	61                   	popa   
c0002c74:	cf                   	iret   
c0002c75:	8d 76 00             	lea    0x0(%esi),%esi

c0002c78 <irq_3>:
c0002c78:	60                   	pusha  
c0002c79:	b8 03 00 00 00       	mov    $0x3,%eax
c0002c7e:	50                   	push   %eax
c0002c7f:	e8 dc ed ff ff       	call   c0001a60 <irq_handler>
c0002c84:	83 c4 04             	add    $0x4,%esp
c0002c87:	61                   	popa   
c0002c88:	cf                   	iret   
c0002c89:	8d 76 00             	lea    0x0(%esi),%esi

c0002c8c <irq_4>:
c0002c8c:	60                   	pusha  
c0002c8d:	b8 04 00 00 00       	mov    $0x4,%eax
c0002c92:	50                   	push   %eax
c0002c93:	e8 c8 ed ff ff       	call   c0001a60 <irq_handler>
c0002c98:	83 c4 04             	add    $0x4,%esp
c0002c9b:	61                   	popa   
c0002c9c:	cf                   	iret   
c0002c9d:	8d 76 00             	lea    0x0(%esi),%esi

c0002ca0 <irq_5>:
c0002ca0:	60                   	pusha  
c0002ca1:	b8 05 00 00 00       	mov    $0x5,%eax
c0002ca6:	50                   	push   %eax
c0002ca7:	e8 b4 ed ff ff       	call   c0001a60 <irq_handler>
c0002cac:	83 c4 04             	add    $0x4,%esp
c0002caf:	61                   	popa   
c0002cb0:	cf                   	iret   
c0002cb1:	8d 76 00             	lea    0x0(%esi),%esi

c0002cb4 <irq_6>:
c0002cb4:	60                   	pusha  
c0002cb5:	b8 06 00 00 00       	mov    $0x6,%eax
c0002cba:	50                   	push   %eax
c0002cbb:	e8 a0 ed ff ff       	call   c0001a60 <irq_handler>
c0002cc0:	83 c4 04             	add    $0x4,%esp
c0002cc3:	61                   	popa   
c0002cc4:	cf                   	iret   
c0002cc5:	8d 76 00             	lea    0x0(%esi),%esi

c0002cc8 <irq_7>:
c0002cc8:	60                   	pusha  
c0002cc9:	b8 07 00 00 00       	mov    $0x7,%eax
c0002cce:	50                   	push   %eax
c0002ccf:	e8 8c ed ff ff       	call   c0001a60 <irq_handler>
c0002cd4:	83 c4 04             	add    $0x4,%esp
c0002cd7:	61                   	popa   
c0002cd8:	cf                   	iret   
c0002cd9:	8d 76 00             	lea    0x0(%esi),%esi

c0002cdc <irq_8>:
c0002cdc:	60                   	pusha  
c0002cdd:	b8 08 00 00 00       	mov    $0x8,%eax
c0002ce2:	50                   	push   %eax
c0002ce3:	e8 78 ed ff ff       	call   c0001a60 <irq_handler>
c0002ce8:	83 c4 04             	add    $0x4,%esp
c0002ceb:	61                   	popa   
c0002cec:	cf                   	iret   
c0002ced:	8d 76 00             	lea    0x0(%esi),%esi

c0002cf0 <irq_9>:
c0002cf0:	60                   	pusha  
c0002cf1:	b8 09 00 00 00       	mov    $0x9,%eax
c0002cf6:	50                   	push   %eax
c0002cf7:	e8 64 ed ff ff       	call   c0001a60 <irq_handler>
c0002cfc:	83 c4 04             	add    $0x4,%esp
c0002cff:	61                   	popa   
c0002d00:	cf                   	iret   
c0002d01:	8d 76 00             	lea    0x0(%esi),%esi

c0002d04 <irq_10>:
c0002d04:	60                   	pusha  
c0002d05:	b8 0a 00 00 00       	mov    $0xa,%eax
c0002d0a:	50                   	push   %eax
c0002d0b:	e8 50 ed ff ff       	call   c0001a60 <irq_handler>
c0002d10:	83 c4 04             	add    $0x4,%esp
c0002d13:	61                   	popa   
c0002d14:	cf                   	iret   
c0002d15:	8d 76 00             	lea    0x0(%esi),%esi

c0002d18 <irq_11>:
c0002d18:	60                   	pusha  
c0002d19:	b8 0b 00 00 00       	mov    $0xb,%eax
c0002d1e:	50                   	push   %eax
c0002d1f:	e8 3c ed ff ff       	call   c0001a60 <irq_handler>
c0002d24:	83 c4 04             	add    $0x4,%esp
c0002d27:	61                   	popa   
c0002d28:	cf                   	iret   
c0002d29:	8d 76 00             	lea    0x0(%esi),%esi

c0002d2c <irq_12>:
c0002d2c:	60                   	pusha  
c0002d2d:	b8 0c 00 00 00       	mov    $0xc,%eax
c0002d32:	50                   	push   %eax
c0002d33:	e8 28 ed ff ff       	call   c0001a60 <irq_handler>
c0002d38:	83 c4 04             	add    $0x4,%esp
c0002d3b:	61                   	popa   
c0002d3c:	cf                   	iret   
c0002d3d:	8d 76 00             	lea    0x0(%esi),%esi

c0002d40 <irq_13>:
c0002d40:	60                   	pusha  
c0002d41:	b8 0d 00 00 00       	mov    $0xd,%eax
c0002d46:	50                   	push   %eax
c0002d47:	e8 14 ed ff ff       	call   c0001a60 <irq_handler>
c0002d4c:	83 c4 04             	add    $0x4,%esp
c0002d4f:	61                   	popa   
c0002d50:	cf                   	iret   
c0002d51:	8d 76 00             	lea    0x0(%esi),%esi

c0002d54 <irq_14>:
c0002d54:	60                   	pusha  
c0002d55:	b8 0e 00 00 00       	mov    $0xe,%eax
c0002d5a:	50                   	push   %eax
c0002d5b:	e8 00 ed ff ff       	call   c0001a60 <irq_handler>
c0002d60:	83 c4 04             	add    $0x4,%esp
c0002d63:	61                   	popa   
c0002d64:	cf                   	iret   
c0002d65:	8d 76 00             	lea    0x0(%esi),%esi

c0002d68 <irq_15>:
c0002d68:	60                   	pusha  
c0002d69:	b8 0f 00 00 00       	mov    $0xf,%eax
c0002d6e:	50                   	push   %eax
c0002d6f:	e8 ec ec ff ff       	call   c0001a60 <irq_handler>
c0002d74:	83 c4 04             	add    $0x4,%esp
c0002d77:	61                   	popa   
c0002d78:	cf                   	iret   
c0002d79:	66 90                	xchg   %ax,%ax
c0002d7b:	90                   	nop

c0002d7c <enable_paging>:
c0002d7c:	55                   	push   %ebp
c0002d7d:	89 e5                	mov    %esp,%ebp
c0002d7f:	8b 45 04             	mov    0x4(%ebp),%eax
c0002d82:	0f 22 d8             	mov    %eax,%cr3
c0002d85:	0f 20 c0             	mov    %cr0,%eax
c0002d88:	0d 01 00 00 80       	or     $0x80000001,%eax
c0002d8d:	0f 22 c0             	mov    %eax,%cr0
c0002d90:	89 ec                	mov    %ebp,%esp
c0002d92:	5d                   	pop    %ebp
c0002d93:	c3                   	ret    

c0002d94 <set_page_dir>:
c0002d94:	8b 44 24 04          	mov    0x4(%esp),%eax
c0002d98:	0f 22 d8             	mov    %eax,%cr3
c0002d9b:	c3                   	ret    

c0002d9c <get_page_dir>:
c0002d9c:	0f 20 d8             	mov    %cr3,%eax
c0002d9f:	c3                   	ret    

c0002da0 <refresh_tlb>:
c0002da0:	0f 20 d8             	mov    %cr3,%eax
c0002da3:	0f 22 d8             	mov    %eax,%cr3
c0002da6:	c3                   	ret    
c0002da7:	90                   	nop

c0002da8 <refresh_page>:
c0002da8:	8b 44 24 04          	mov    0x4(%esp),%eax
c0002dac:	0f 01 38             	invlpg (%eax)
c0002daf:	c3                   	ret    
