
build/kernel:     file format elf32-i386


Disassembly of section .text.boot:

00100000 <_start-0xc>:
  100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fb                   	sti    
  100009:	4f                   	dec    %edi
  10000a:	52                   	push   %edx
  10000b:	e4                   	.byte 0xe4

0010000c <_start>:
  10000c:	fa                   	cli    
  10000d:	3d 02 b0 ad 2b       	cmp    $0x2badb002,%eax
  100012:	0f 85 c1 00 00 00    	jne    1000d9 <kpanic>
  100018:	8d 25 00 f0 10 00    	lea    0x10f000,%esp
  10001e:	53                   	push   %ebx
  10001f:	8d 3d 00 f0 10 00    	lea    0x10f000,%edi
  100025:	b8 83 00 00 00       	mov    $0x83,%eax
  10002a:	89 07                	mov    %eax,(%edi)
  10002c:	0f 20 e0             	mov    %cr4,%eax
  10002f:	83 c8 10             	or     $0x10,%eax
  100032:	0f 22 e0             	mov    %eax,%cr4
  100035:	8d 35 00 00 11 00    	lea    0x110000,%esi
  10003b:	83 ce 03             	or     $0x3,%esi
  10003e:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  100044:	c1 e8 16             	shr    $0x16,%eax
  100047:	bb 04 00 00 00       	mov    $0x4,%ebx
  10004c:	f7 e3                	mul    %ebx
  10004e:	8d 3d 00 f0 10 00    	lea    0x10f000,%edi
  100054:	01 c7                	add    %eax,%edi
  100056:	89 37                	mov    %esi,(%edi)
  100058:	8d 1d 00 00 00 c0    	lea    0xc0000000,%ebx
  10005e:	c1 eb 0c             	shr    $0xc,%ebx
  100061:	8d 0d 88 09 01 c0    	lea    0xc0010988,%ecx
  100067:	81 c1 ff 0f 00 00    	add    $0xfff,%ecx
  10006d:	c1 e9 0c             	shr    $0xc,%ecx
  100070:	29 d9                	sub    %ebx,%ecx
  100072:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  100078:	25 00 f0 3f 00       	and    $0x3ff000,%eax
  10007d:	c1 e8 0c             	shr    $0xc,%eax
  100080:	bb 04 00 00 00       	mov    $0x4,%ebx
  100085:	f7 e3                	mul    %ebx
  100087:	8d 3d 00 00 11 00    	lea    0x110000,%edi
  10008d:	01 c7                	add    %eax,%edi
  10008f:	8d 05 00 10 10 00    	lea    0x101000,%eax
  100095:	83 c8 03             	or     $0x3,%eax
  100098:	fc                   	cld    

00100099 <.nextpte>:
  100099:	ab                   	stos   %eax,%es:(%edi)
  10009a:	05 00 10 00 00       	add    $0x1000,%eax
  10009f:	e2 f8                	loop   100099 <.nextpte>
  1000a1:	8d 35 00 f0 10 00    	lea    0x10f000,%esi
  1000a7:	89 f7                	mov    %esi,%edi
  1000a9:	81 c7 fc 0f 00 00    	add    $0xffc,%edi
  1000af:	83 ce 03             	or     $0x3,%esi
  1000b2:	89 37                	mov    %esi,(%edi)
  1000b4:	5b                   	pop    %ebx

001000b5 <_enable_paging>:
  1000b5:	8d 05 00 f0 10 00    	lea    0x10f000,%eax
  1000bb:	0f 22 d8             	mov    %eax,%cr3
  1000be:	0f 20 c0             	mov    %cr0,%eax
  1000c1:	0d 00 00 01 80       	or     $0x80010000,%eax
  1000c6:	0f 22 c0             	mov    %eax,%cr0
  1000c9:	8d 25 00 e0 00 c0    	lea    0xc000e000,%esp
  1000cf:	50                   	push   %eax
  1000d0:	50                   	push   %eax
  1000d1:	50                   	push   %eax
  1000d2:	53                   	push   %ebx
  1000d3:	e8 43 2c f0 bf       	call   c0002d1b <kernel_main>
  1000d8:	fa                   	cli    

001000d9 <kpanic>:
  1000d9:	f4                   	hlt    
  1000da:	eb fd                	jmp    1000d9 <kpanic>

Disassembly of section .text:

c0000000 <syscall>:
#include "terminal.h"
#include "kprintf.h"

void syscall()
{
c0000000:	55                   	push   %ebp
c0000001:	89 e5                	mov    %esp,%ebp
}
c0000003:	90                   	nop
c0000004:	5d                   	pop    %ebp
c0000005:	c3                   	ret    

c0000006 <vga_entry_color>:
	VGA_COLOR_LIGHT_BROWN = 14,
	VGA_COLOR_WHITE = 15,
};
 
static inline uint8_t vga_entry_color(enum vga_color fg, enum vga_color bg) 
{
c0000006:	55                   	push   %ebp
c0000007:	89 e5                	mov    %esp,%ebp
	return fg | bg << 4;
c0000009:	8b 45 0c             	mov    0xc(%ebp),%eax
c000000c:	c1 e0 04             	shl    $0x4,%eax
c000000f:	89 c2                	mov    %eax,%edx
c0000011:	8b 45 08             	mov    0x8(%ebp),%eax
c0000014:	09 d0                	or     %edx,%eax
}
c0000016:	5d                   	pop    %ebp
c0000017:	c3                   	ret    

c0000018 <vga_entry>:
 
static inline uint16_t vga_entry(unsigned char uc, uint8_t color) 
{
c0000018:	55                   	push   %ebp
c0000019:	89 e5                	mov    %esp,%ebp
c000001b:	83 ec 08             	sub    $0x8,%esp
c000001e:	8b 55 08             	mov    0x8(%ebp),%edx
c0000021:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000024:	88 55 fc             	mov    %dl,-0x4(%ebp)
c0000027:	88 45 f8             	mov    %al,-0x8(%ebp)
	return (uint16_t) uc | (uint16_t) color << 8;
c000002a:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c000002e:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0000032:	c1 e0 08             	shl    $0x8,%eax
c0000035:	09 d0                	or     %edx,%eax
}
c0000037:	c9                   	leave  
c0000038:	c3                   	ret    

c0000039 <outb>:
  return _v;
}

static inline void
outb (unsigned char __value, unsigned short int __port)
{
c0000039:	55                   	push   %ebp
c000003a:	89 e5                	mov    %esp,%ebp
c000003c:	83 ec 08             	sub    $0x8,%esp
c000003f:	8b 55 08             	mov    0x8(%ebp),%edx
c0000042:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000045:	88 55 fc             	mov    %dl,-0x4(%ebp)
c0000048:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
c000004c:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0000050:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
c0000054:	ee                   	out    %al,(%dx)
}
c0000055:	90                   	nop
c0000056:	c9                   	leave  
c0000057:	c3                   	ret    

c0000058 <terminal_init>:
#include "io.h"

struct terminal stdout;

void terminal_init(struct terminal* term) 
{
c0000058:	55                   	push   %ebp
c0000059:	89 e5                	mov    %esp,%ebp
c000005b:	53                   	push   %ebx
c000005c:	83 ec 10             	sub    $0x10,%esp
	term->row = 0;
c000005f:	8b 45 08             	mov    0x8(%ebp),%eax
c0000062:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	term->column = 0;
c0000068:	8b 45 08             	mov    0x8(%ebp),%eax
c000006b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	term->color = vga_entry_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
c0000072:	6a 00                	push   $0x0
c0000074:	6a 07                	push   $0x7
c0000076:	e8 8b ff ff ff       	call   c0000006 <vga_entry_color>
c000007b:	83 c4 08             	add    $0x8,%esp
c000007e:	8b 55 08             	mov    0x8(%ebp),%edx
c0000081:	88 42 08             	mov    %al,0x8(%edx)
	term->buffer = (uint16_t*) VGA_BUFFER;
c0000084:	8b 45 08             	mov    0x8(%ebp),%eax
c0000087:	c7 40 0c 00 80 0b 00 	movl   $0xb8000,0xc(%eax)
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
c000008e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0000095:	eb 54                	jmp    c00000eb <terminal_init+0x93>
		for (size_t x = 0; x < VGA_WIDTH; x++) {
c0000097:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000009e:	eb 41                	jmp    c00000e1 <terminal_init+0x89>
			const size_t index = y * VGA_WIDTH + x;
c00000a0:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00000a3:	89 d0                	mov    %edx,%eax
c00000a5:	c1 e0 02             	shl    $0x2,%eax
c00000a8:	01 d0                	add    %edx,%eax
c00000aa:	c1 e0 04             	shl    $0x4,%eax
c00000ad:	89 c2                	mov    %eax,%edx
c00000af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00000b2:	01 d0                	add    %edx,%eax
c00000b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
			term->buffer[index] = vga_entry(' ', term->color);
c00000b7:	8b 45 08             	mov    0x8(%ebp),%eax
c00000ba:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c00000be:	0f b6 c0             	movzbl %al,%eax
c00000c1:	8b 55 08             	mov    0x8(%ebp),%edx
c00000c4:	8b 4a 0c             	mov    0xc(%edx),%ecx
c00000c7:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00000ca:	01 d2                	add    %edx,%edx
c00000cc:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
c00000cf:	50                   	push   %eax
c00000d0:	6a 20                	push   $0x20
c00000d2:	e8 41 ff ff ff       	call   c0000018 <vga_entry>
c00000d7:	83 c4 08             	add    $0x8,%esp
c00000da:	66 89 03             	mov    %ax,(%ebx)
		for (size_t x = 0; x < VGA_WIDTH; x++) {
c00000dd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00000e1:	83 7d f4 4f          	cmpl   $0x4f,-0xc(%ebp)
c00000e5:	76 b9                	jbe    c00000a0 <terminal_init+0x48>
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
c00000e7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c00000eb:	83 7d f8 18          	cmpl   $0x18,-0x8(%ebp)
c00000ef:	76 a6                	jbe    c0000097 <terminal_init+0x3f>
		}
	}

	//disable cursor
	outb(0x0A, 0x3D4);
c00000f1:	68 d4 03 00 00       	push   $0x3d4
c00000f6:	6a 0a                	push   $0xa
c00000f8:	e8 3c ff ff ff       	call   c0000039 <outb>
c00000fd:	83 c4 08             	add    $0x8,%esp
	outb(0x20, 0x3D5);
c0000100:	68 d5 03 00 00       	push   $0x3d5
c0000105:	6a 20                	push   $0x20
c0000107:	e8 2d ff ff ff       	call   c0000039 <outb>
c000010c:	83 c4 08             	add    $0x8,%esp
	// outb(0x0A, 0x3D4);
	// outb((inb(0x3D5) & 0xC0) | cursor_start, 0x3D5);
 
	// outb(0x0B, 0x3D4);
	// outb((inb(0x3D5) & 0xE0) | cursor_end, 0x3D5);
}
c000010f:	90                   	nop
c0000110:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0000113:	c9                   	leave  
c0000114:	c3                   	ret    

c0000115 <terminal_setcolor>:
 
void terminal_setcolor(struct terminal* term, uint8_t color) 
{
c0000115:	55                   	push   %ebp
c0000116:	89 e5                	mov    %esp,%ebp
c0000118:	83 ec 04             	sub    $0x4,%esp
c000011b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000011e:	88 45 fc             	mov    %al,-0x4(%ebp)
	term->color = color;
c0000121:	8b 45 08             	mov    0x8(%ebp),%eax
c0000124:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c0000128:	88 50 08             	mov    %dl,0x8(%eax)
}
c000012b:	90                   	nop
c000012c:	c9                   	leave  
c000012d:	c3                   	ret    

c000012e <terminal_putentryat>:
 
void terminal_putentryat(struct terminal* term, char c, uint8_t color, size_t x, size_t y) 
{
c000012e:	55                   	push   %ebp
c000012f:	89 e5                	mov    %esp,%ebp
c0000131:	53                   	push   %ebx
c0000132:	83 ec 18             	sub    $0x18,%esp
c0000135:	8b 55 0c             	mov    0xc(%ebp),%edx
c0000138:	8b 45 10             	mov    0x10(%ebp),%eax
c000013b:	88 55 e8             	mov    %dl,-0x18(%ebp)
c000013e:	88 45 e4             	mov    %al,-0x1c(%ebp)
	const size_t index = y * VGA_WIDTH + x;
c0000141:	8b 55 18             	mov    0x18(%ebp),%edx
c0000144:	89 d0                	mov    %edx,%eax
c0000146:	c1 e0 02             	shl    $0x2,%eax
c0000149:	01 d0                	add    %edx,%eax
c000014b:	c1 e0 04             	shl    $0x4,%eax
c000014e:	89 c2                	mov    %eax,%edx
c0000150:	8b 45 14             	mov    0x14(%ebp),%eax
c0000153:	01 d0                	add    %edx,%eax
c0000155:	89 45 f8             	mov    %eax,-0x8(%ebp)
	term->buffer[index] = vga_entry(c, color);
c0000158:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c000015c:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0000160:	0f b6 c0             	movzbl %al,%eax
c0000163:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0000166:	8b 59 0c             	mov    0xc(%ecx),%ebx
c0000169:	8b 4d f8             	mov    -0x8(%ebp),%ecx
c000016c:	01 c9                	add    %ecx,%ecx
c000016e:	01 cb                	add    %ecx,%ebx
c0000170:	52                   	push   %edx
c0000171:	50                   	push   %eax
c0000172:	e8 a1 fe ff ff       	call   c0000018 <vga_entry>
c0000177:	83 c4 08             	add    $0x8,%esp
c000017a:	66 89 03             	mov    %ax,(%ebx)
	// terminal_movecursor(term, x, y);
}
c000017d:	90                   	nop
c000017e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0000181:	c9                   	leave  
c0000182:	c3                   	ret    

c0000183 <terminal_movecursor>:

void terminal_movecursor(struct terminal* term, size_t x, size_t y)
{
c0000183:	55                   	push   %ebp
c0000184:	89 e5                	mov    %esp,%ebp
c0000186:	83 ec 10             	sub    $0x10,%esp
	(void) term; //we are directly manipulating curser, so were arean't using the term struct

	uint16_t pos = y * VGA_WIDTH + x;
c0000189:	8b 45 10             	mov    0x10(%ebp),%eax
c000018c:	89 c2                	mov    %eax,%edx
c000018e:	89 d0                	mov    %edx,%eax
c0000190:	c1 e0 02             	shl    $0x2,%eax
c0000193:	01 d0                	add    %edx,%eax
c0000195:	c1 e0 04             	shl    $0x4,%eax
c0000198:	89 c2                	mov    %eax,%edx
c000019a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000019d:	01 d0                	add    %edx,%eax
c000019f:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

	outb(0x0F, 0x3D4);
c00001a3:	68 d4 03 00 00       	push   $0x3d4
c00001a8:	6a 0f                	push   $0xf
c00001aa:	e8 8a fe ff ff       	call   c0000039 <outb>
c00001af:	83 c4 08             	add    $0x8,%esp
	outb((uint8_t) (pos & 0xFF), 0x3D5);
c00001b2:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c00001b6:	0f b6 c0             	movzbl %al,%eax
c00001b9:	68 d5 03 00 00       	push   $0x3d5
c00001be:	50                   	push   %eax
c00001bf:	e8 75 fe ff ff       	call   c0000039 <outb>
c00001c4:	83 c4 08             	add    $0x8,%esp
	outb(0x0E, 0x3D4);
c00001c7:	68 d4 03 00 00       	push   $0x3d4
c00001cc:	6a 0e                	push   $0xe
c00001ce:	e8 66 fe ff ff       	call   c0000039 <outb>
c00001d3:	83 c4 08             	add    $0x8,%esp
	outb((uint8_t) ((pos >> 8) & 0xFF), 0x3D5);
c00001d6:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c00001da:	66 c1 e8 08          	shr    $0x8,%ax
c00001de:	0f b6 c0             	movzbl %al,%eax
c00001e1:	68 d5 03 00 00       	push   $0x3d5
c00001e6:	50                   	push   %eax
c00001e7:	e8 4d fe ff ff       	call   c0000039 <outb>
c00001ec:	83 c4 08             	add    $0x8,%esp
}
c00001ef:	90                   	nop
c00001f0:	c9                   	leave  
c00001f1:	c3                   	ret    

c00001f2 <terminal_putchar>:

 
void terminal_putchar(struct terminal* term, char c) 
{
c00001f2:	55                   	push   %ebp
c00001f3:	89 e5                	mov    %esp,%ebp
c00001f5:	53                   	push   %ebx
c00001f6:	83 ec 14             	sub    $0x14,%esp
c00001f9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00001fc:	88 45 f4             	mov    %al,-0xc(%ebp)
	if(c == '\n')
c00001ff:	80 7d f4 0a          	cmpb   $0xa,-0xc(%ebp)
c0000203:	75 10                	jne    c0000215 <terminal_putchar+0x23>
	{
		terminal_newline(term);
c0000205:	83 ec 0c             	sub    $0xc,%esp
c0000208:	ff 75 08             	pushl  0x8(%ebp)
c000020b:	e8 95 00 00 00       	call   c00002a5 <terminal_newline>
c0000210:	83 c4 10             	add    $0x10,%esp
		return;
c0000213:	eb 53                	jmp    c0000268 <terminal_putchar+0x76>
	}

	terminal_putentryat(term, c, term->color, term->column, term->row);
c0000215:	8b 45 08             	mov    0x8(%ebp),%eax
c0000218:	8b 18                	mov    (%eax),%ebx
c000021a:	8b 45 08             	mov    0x8(%ebp),%eax
c000021d:	8b 48 04             	mov    0x4(%eax),%ecx
c0000220:	8b 45 08             	mov    0x8(%ebp),%eax
c0000223:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c0000227:	0f b6 d0             	movzbl %al,%edx
c000022a:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c000022e:	83 ec 0c             	sub    $0xc,%esp
c0000231:	53                   	push   %ebx
c0000232:	51                   	push   %ecx
c0000233:	52                   	push   %edx
c0000234:	50                   	push   %eax
c0000235:	ff 75 08             	pushl  0x8(%ebp)
c0000238:	e8 f1 fe ff ff       	call   c000012e <terminal_putentryat>
c000023d:	83 c4 20             	add    $0x20,%esp
	if (++term->column == VGA_WIDTH)
c0000240:	8b 45 08             	mov    0x8(%ebp),%eax
c0000243:	8b 40 04             	mov    0x4(%eax),%eax
c0000246:	8d 50 01             	lea    0x1(%eax),%edx
c0000249:	8b 45 08             	mov    0x8(%ebp),%eax
c000024c:	89 50 04             	mov    %edx,0x4(%eax)
c000024f:	8b 45 08             	mov    0x8(%ebp),%eax
c0000252:	8b 40 04             	mov    0x4(%eax),%eax
c0000255:	83 f8 50             	cmp    $0x50,%eax
c0000258:	75 0e                	jne    c0000268 <terminal_putchar+0x76>
		terminal_newline(term);
c000025a:	83 ec 0c             	sub    $0xc,%esp
c000025d:	ff 75 08             	pushl  0x8(%ebp)
c0000260:	e8 40 00 00 00       	call   c00002a5 <terminal_newline>
c0000265:	83 c4 10             	add    $0x10,%esp
}
c0000268:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000026b:	c9                   	leave  
c000026c:	c3                   	ret    

c000026d <terminal_putcharn>:

void terminal_putcharn(struct terminal* term, char c, size_t repeat) 
{
c000026d:	55                   	push   %ebp
c000026e:	89 e5                	mov    %esp,%ebp
c0000270:	83 ec 28             	sub    $0x28,%esp
c0000273:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000276:	88 45 e4             	mov    %al,-0x1c(%ebp)
	for (size_t i = 0; i < repeat; i++)
c0000279:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0000280:	eb 17                	jmp    c0000299 <terminal_putcharn+0x2c>
		terminal_putchar(term, c);
c0000282:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
c0000286:	83 ec 08             	sub    $0x8,%esp
c0000289:	50                   	push   %eax
c000028a:	ff 75 08             	pushl  0x8(%ebp)
c000028d:	e8 60 ff ff ff       	call   c00001f2 <terminal_putchar>
c0000292:	83 c4 10             	add    $0x10,%esp
	for (size_t i = 0; i < repeat; i++)
c0000295:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0000299:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000029c:	3b 45 10             	cmp    0x10(%ebp),%eax
c000029f:	72 e1                	jb     c0000282 <terminal_putcharn+0x15>
}
c00002a1:	90                   	nop
c00002a2:	90                   	nop
c00002a3:	c9                   	leave  
c00002a4:	c3                   	ret    

c00002a5 <terminal_newline>:

void terminal_newline(struct terminal* term)
{
c00002a5:	55                   	push   %ebp
c00002a6:	89 e5                	mov    %esp,%ebp
c00002a8:	83 ec 08             	sub    $0x8,%esp
    term->column = 0;
c00002ab:	8b 45 08             	mov    0x8(%ebp),%eax
c00002ae:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if (++term->row == VGA_HEIGHT)
c00002b5:	8b 45 08             	mov    0x8(%ebp),%eax
c00002b8:	8b 00                	mov    (%eax),%eax
c00002ba:	8d 50 01             	lea    0x1(%eax),%edx
c00002bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00002c0:	89 10                	mov    %edx,(%eax)
c00002c2:	8b 45 08             	mov    0x8(%ebp),%eax
c00002c5:	8b 00                	mov    (%eax),%eax
c00002c7:	83 f8 19             	cmp    $0x19,%eax
c00002ca:	75 0e                	jne    c00002da <terminal_newline+0x35>
        terminal_scrollline(term);
c00002cc:	83 ec 0c             	sub    $0xc,%esp
c00002cf:	ff 75 08             	pushl  0x8(%ebp)
c00002d2:	e8 06 00 00 00       	call   c00002dd <terminal_scrollline>
c00002d7:	83 c4 10             	add    $0x10,%esp
}
c00002da:	90                   	nop
c00002db:	c9                   	leave  
c00002dc:	c3                   	ret    

c00002dd <terminal_scrollline>:

void terminal_scrollline(struct terminal* term)
{
c00002dd:	55                   	push   %ebp
c00002de:	89 e5                	mov    %esp,%ebp
c00002e0:	83 ec 08             	sub    $0x8,%esp
	// copy rows 2 though N to rows 1 through N-1
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c00002e3:	8b 45 08             	mov    0x8(%ebp),%eax
c00002e6:	8b 40 0c             	mov    0xc(%eax),%eax
c00002e9:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c00002ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00002f2:	8b 40 0c             	mov    0xc(%eax),%eax
c00002f5:	83 ec 04             	sub    $0x4,%esp
c00002f8:	68 00 0f 00 00       	push   $0xf00
c00002fd:	52                   	push   %edx
c00002fe:	50                   	push   %eax
c00002ff:	e8 d5 0f 00 00       	call   c00012d9 <memcpy>
c0000304:	83 c4 10             	add    $0x10,%esp
	// clear last row
	term->row = VGA_HEIGHT-1;
c0000307:	8b 45 08             	mov    0x8(%ebp),%eax
c000030a:	c7 00 18 00 00 00    	movl   $0x18,(%eax)
	terminal_clearline(term);
c0000310:	83 ec 0c             	sub    $0xc,%esp
c0000313:	ff 75 08             	pushl  0x8(%ebp)
c0000316:	e8 06 00 00 00       	call   c0000321 <terminal_clearline>
c000031b:	83 c4 10             	add    $0x10,%esp
}
c000031e:	90                   	nop
c000031f:	c9                   	leave  
c0000320:	c3                   	ret    

c0000321 <terminal_clearline>:

void terminal_clearline(struct terminal* term)
{
c0000321:	55                   	push   %ebp
c0000322:	89 e5                	mov    %esp,%ebp
c0000324:	53                   	push   %ebx
c0000325:	83 ec 10             	sub    $0x10,%esp
	size_t row_start = term->row * VGA_WIDTH;
c0000328:	8b 45 08             	mov    0x8(%ebp),%eax
c000032b:	8b 10                	mov    (%eax),%edx
c000032d:	89 d0                	mov    %edx,%eax
c000032f:	c1 e0 02             	shl    $0x2,%eax
c0000332:	01 d0                	add    %edx,%eax
c0000334:	c1 e0 04             	shl    $0x4,%eax
c0000337:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c000033a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0000341:	eb 2f                	jmp    c0000372 <terminal_clearline+0x51>
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0000343:	8b 45 08             	mov    0x8(%ebp),%eax
c0000346:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c000034a:	0f b6 c0             	movzbl %al,%eax
c000034d:	8b 55 08             	mov    0x8(%ebp),%edx
c0000350:	8b 4a 0c             	mov    0xc(%edx),%ecx
c0000353:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c0000356:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0000359:	01 da                	add    %ebx,%edx
c000035b:	01 d2                	add    %edx,%edx
c000035d:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
c0000360:	50                   	push   %eax
c0000361:	6a 20                	push   $0x20
c0000363:	e8 b0 fc ff ff       	call   c0000018 <vga_entry>
c0000368:	83 c4 08             	add    $0x8,%esp
c000036b:	66 89 03             	mov    %ax,(%ebx)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c000036e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0000372:	83 7d f8 4f          	cmpl   $0x4f,-0x8(%ebp)
c0000376:	76 cb                	jbe    c0000343 <terminal_clearline+0x22>

}
c0000378:	90                   	nop
c0000379:	90                   	nop
c000037a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000037d:	c9                   	leave  
c000037e:	c3                   	ret    

c000037f <terminal_write>:


void terminal_write(struct terminal* term, const char* data, size_t size) 
{
c000037f:	55                   	push   %ebp
c0000380:	89 e5                	mov    %esp,%ebp
c0000382:	83 ec 18             	sub    $0x18,%esp
	for (size_t i = 0; i < size; i++)
c0000385:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000038c:	eb 21                	jmp    c00003af <terminal_write+0x30>
		terminal_putchar(term, data[i]);
c000038e:	8b 55 0c             	mov    0xc(%ebp),%edx
c0000391:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000394:	01 d0                	add    %edx,%eax
c0000396:	0f b6 00             	movzbl (%eax),%eax
c0000399:	0f be c0             	movsbl %al,%eax
c000039c:	83 ec 08             	sub    $0x8,%esp
c000039f:	50                   	push   %eax
c00003a0:	ff 75 08             	pushl  0x8(%ebp)
c00003a3:	e8 4a fe ff ff       	call   c00001f2 <terminal_putchar>
c00003a8:	83 c4 10             	add    $0x10,%esp
	for (size_t i = 0; i < size; i++)
c00003ab:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00003af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00003b2:	3b 45 10             	cmp    0x10(%ebp),%eax
c00003b5:	72 d7                	jb     c000038e <terminal_write+0xf>
}
c00003b7:	90                   	nop
c00003b8:	90                   	nop
c00003b9:	c9                   	leave  
c00003ba:	c3                   	ret    

c00003bb <terminal_writestring>:
 
void terminal_writestring(struct terminal* term, const char* data) 
{
c00003bb:	55                   	push   %ebp
c00003bc:	89 e5                	mov    %esp,%ebp
c00003be:	83 ec 08             	sub    $0x8,%esp
	terminal_write(term, data, strlen(data));
c00003c1:	83 ec 0c             	sub    $0xc,%esp
c00003c4:	ff 75 0c             	pushl  0xc(%ebp)
c00003c7:	e8 e6 0e 00 00       	call   c00012b2 <strlen>
c00003cc:	83 c4 10             	add    $0x10,%esp
c00003cf:	83 ec 04             	sub    $0x4,%esp
c00003d2:	50                   	push   %eax
c00003d3:	ff 75 0c             	pushl  0xc(%ebp)
c00003d6:	ff 75 08             	pushl  0x8(%ebp)
c00003d9:	e8 a1 ff ff ff       	call   c000037f <terminal_write>
c00003de:	83 c4 10             	add    $0x10,%esp
}
c00003e1:	90                   	nop
c00003e2:	c9                   	leave  
c00003e3:	c3                   	ret    

c00003e4 <kprint>:
unsigned int numdigits_uint(unsigned int value, unsigned int base);

int format_uint(unsigned int value, char* str, unsigned int base, int precision, int cap);

int kprint(const char* str)
{
c00003e4:	55                   	push   %ebp
c00003e5:	89 e5                	mov    %esp,%ebp
c00003e7:	83 ec 08             	sub    $0x8,%esp
    terminal_writestring(&stdout, str);
c00003ea:	83 ec 08             	sub    $0x8,%esp
c00003ed:	ff 75 08             	pushl  0x8(%ebp)
c00003f0:	68 00 00 01 c0       	push   $0xc0010000
c00003f5:	e8 c1 ff ff ff       	call   c00003bb <terminal_writestring>
c00003fa:	83 c4 10             	add    $0x10,%esp
    return strlen(str);
c00003fd:	83 ec 0c             	sub    $0xc,%esp
c0000400:	ff 75 08             	pushl  0x8(%ebp)
c0000403:	e8 aa 0e 00 00       	call   c00012b2 <strlen>
c0000408:	83 c4 10             	add    $0x10,%esp
}
c000040b:	c9                   	leave  
c000040c:	c3                   	ret    

c000040d <kprintn>:

int kprintn(const char* str, size_t len)
{
c000040d:	55                   	push   %ebp
c000040e:	89 e5                	mov    %esp,%ebp
c0000410:	83 ec 08             	sub    $0x8,%esp
    terminal_write(&stdout, str, len);
c0000413:	83 ec 04             	sub    $0x4,%esp
c0000416:	ff 75 0c             	pushl  0xc(%ebp)
c0000419:	ff 75 08             	pushl  0x8(%ebp)
c000041c:	68 00 00 01 c0       	push   $0xc0010000
c0000421:	e8 59 ff ff ff       	call   c000037f <terminal_write>
c0000426:	83 c4 10             	add    $0x10,%esp
    return len;
c0000429:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c000042c:	c9                   	leave  
c000042d:	c3                   	ret    

c000042e <kprint_char>:

int kprint_char(char c)
{
c000042e:	55                   	push   %ebp
c000042f:	89 e5                	mov    %esp,%ebp
c0000431:	83 ec 18             	sub    $0x18,%esp
c0000434:	8b 45 08             	mov    0x8(%ebp),%eax
c0000437:	88 45 f4             	mov    %al,-0xc(%ebp)
    terminal_putchar(&stdout, c); 
c000043a:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c000043e:	83 ec 08             	sub    $0x8,%esp
c0000441:	50                   	push   %eax
c0000442:	68 00 00 01 c0       	push   $0xc0010000
c0000447:	e8 a6 fd ff ff       	call   c00001f2 <terminal_putchar>
c000044c:	83 c4 10             	add    $0x10,%esp
    return 1;
c000044f:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0000454:	c9                   	leave  
c0000455:	c3                   	ret    

c0000456 <kprintn_char>:

int kprintn_char(char c, size_t rpt)
{
c0000456:	55                   	push   %ebp
c0000457:	89 e5                	mov    %esp,%ebp
c0000459:	83 ec 18             	sub    $0x18,%esp
c000045c:	8b 45 08             	mov    0x8(%ebp),%eax
c000045f:	88 45 f4             	mov    %al,-0xc(%ebp)
    terminal_putcharn(&stdout, c, rpt); 
c0000462:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c0000466:	83 ec 04             	sub    $0x4,%esp
c0000469:	ff 75 0c             	pushl  0xc(%ebp)
c000046c:	50                   	push   %eax
c000046d:	68 00 00 01 c0       	push   $0xc0010000
c0000472:	e8 f6 fd ff ff       	call   c000026d <terminal_putcharn>
c0000477:	83 c4 10             	add    $0x10,%esp
    return rpt;
c000047a:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c000047d:	c9                   	leave  
c000047e:	c3                   	ret    

c000047f <kprintf>:


int kprintf(const char* format, ...)
{
c000047f:	55                   	push   %ebp
c0000480:	89 e5                	mov    %esp,%ebp
c0000482:	81 ec a8 02 00 00    	sub    $0x2a8,%esp
    /* initialize valist for num number of arguments */
    va_list valist;
    va_start(valist, format);
c0000488:	8d 45 0c             	lea    0xc(%ebp),%eax
c000048b:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)

    // parse format into str
    const char* f = format;
c0000491:	8b 45 08             	mov    0x8(%ebp),%eax
c0000494:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int nchar = 0;
c0000497:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    while(f[0] != 0)
c000049e:	e9 9e 0a 00 00       	jmp    c0000f41 <kprintf+0xac2>
    {
        if(f[0] == '\\' && f[1] == '%')
c00004a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00004a6:	0f b6 00             	movzbl (%eax),%eax
c00004a9:	3c 5c                	cmp    $0x5c,%al
c00004ab:	75 22                	jne    c00004cf <kprintf+0x50>
c00004ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00004b0:	83 c0 01             	add    $0x1,%eax
c00004b3:	0f b6 00             	movzbl (%eax),%eax
c00004b6:	3c 25                	cmp    $0x25,%al
c00004b8:	75 15                	jne    c00004cf <kprintf+0x50>
        {
            //write escaped "%%" as '%'
            kprint_char('%');
c00004ba:	83 ec 0c             	sub    $0xc,%esp
c00004bd:	6a 25                	push   $0x25
c00004bf:	e8 6a ff ff ff       	call   c000042e <kprint_char>
c00004c4:	83 c4 10             	add    $0x10,%esp
            nchar++;
c00004c7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
            f += 2;
c00004cb:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
        }

        if(f[0] == '%')
c00004cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00004d2:	0f b6 00             	movzbl (%eax),%eax
c00004d5:	3c 25                	cmp    $0x25,%al
c00004d7:	0f 85 45 0a 00 00    	jne    c0000f22 <kprintf+0xaa3>
        {
            // found new field

            // parse flags
            struct format_flags flags = {0};
c00004dd:	c7 85 77 ff ff ff 00 	movl   $0x0,-0x89(%ebp)
c00004e4:	00 00 00 
c00004e7:	c6 85 7b ff ff ff 00 	movb   $0x0,-0x85(%ebp)
            int check_flags = 1;
c00004ee:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
            while(check_flags)
c00004f5:	e9 ee 00 00 00       	jmp    c00005e8 <kprintf+0x169>
            {
                switch(*(++f))
c00004fa:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00004fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000501:	0f b6 00             	movzbl (%eax),%eax
c0000504:	0f be c0             	movsbl %al,%eax
c0000507:	85 c0                	test   %eax,%eax
c0000509:	0f 84 c8 00 00 00    	je     c00005d7 <kprintf+0x158>
c000050f:	85 c0                	test   %eax,%eax
c0000511:	0f 88 ca 00 00 00    	js     c00005e1 <kprintf+0x162>
c0000517:	83 f8 30             	cmp    $0x30,%eax
c000051a:	0f 8f c1 00 00 00    	jg     c00005e1 <kprintf+0x162>
c0000520:	83 f8 20             	cmp    $0x20,%eax
c0000523:	0f 8c b8 00 00 00    	jl     c00005e1 <kprintf+0x162>
c0000529:	83 e8 20             	sub    $0x20,%eax
c000052c:	83 f8 10             	cmp    $0x10,%eax
c000052f:	0f 87 ac 00 00 00    	ja     c00005e1 <kprintf+0x162>
c0000535:	8b 04 85 00 40 00 c0 	mov    -0x3fffc000(,%eax,4),%eax
c000053c:	ff e0                	jmp    *%eax
                {
                    case '#':
                        if(flags.alt) return 0;
c000053e:	0f b6 85 77 ff ff ff 	movzbl -0x89(%ebp),%eax
c0000545:	84 c0                	test   %al,%al
c0000547:	74 0a                	je     c0000553 <kprintf+0xd4>
c0000549:	b8 00 00 00 00       	mov    $0x0,%eax
c000054e:	e9 ff 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        flags.alt = 1;
c0000553:	c6 85 77 ff ff ff 01 	movb   $0x1,-0x89(%ebp)
                        break;
c000055a:	e9 89 00 00 00       	jmp    c00005e8 <kprintf+0x169>
                    case '0':
                        if(flags.zero) return 0;
c000055f:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000566:	84 c0                	test   %al,%al
c0000568:	74 0a                	je     c0000574 <kprintf+0xf5>
c000056a:	b8 00 00 00 00       	mov    $0x0,%eax
c000056f:	e9 de 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        flags.zero = 1;
c0000574:	c6 85 78 ff ff ff 01 	movb   $0x1,-0x88(%ebp)
                        break;
c000057b:	eb 6b                	jmp    c00005e8 <kprintf+0x169>
                    case '-':
                        if(flags.left) return 0;
c000057d:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000584:	84 c0                	test   %al,%al
c0000586:	74 0a                	je     c0000592 <kprintf+0x113>
c0000588:	b8 00 00 00 00       	mov    $0x0,%eax
c000058d:	e9 c0 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        flags.left = 1;
c0000592:	c6 85 79 ff ff ff 01 	movb   $0x1,-0x87(%ebp)
                        break;
c0000599:	eb 4d                	jmp    c00005e8 <kprintf+0x169>
                    case ' ':
                        if(flags.space) return 0;
c000059b:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c00005a2:	84 c0                	test   %al,%al
c00005a4:	74 0a                	je     c00005b0 <kprintf+0x131>
c00005a6:	b8 00 00 00 00       	mov    $0x0,%eax
c00005ab:	e9 a2 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        flags.space = 1;
c00005b0:	c6 85 7a ff ff ff 01 	movb   $0x1,-0x86(%ebp)
                        break;
c00005b7:	eb 2f                	jmp    c00005e8 <kprintf+0x169>
                    case '+':
                        if(flags.sign) return 0;
c00005b9:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c00005c0:	84 c0                	test   %al,%al
c00005c2:	74 0a                	je     c00005ce <kprintf+0x14f>
c00005c4:	b8 00 00 00 00       	mov    $0x0,%eax
c00005c9:	e9 84 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        flags.sign = 1;
c00005ce:	c6 85 7b ff ff ff 01 	movb   $0x1,-0x85(%ebp)
                        break;
c00005d5:	eb 11                	jmp    c00005e8 <kprintf+0x169>
                    case '\0':
                        //unexpected string termination
                        return -1;
c00005d7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00005dc:	e9 71 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        break;
                    default:
                        //no more flags
                        check_flags = 0;
c00005e1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
            while(check_flags)
c00005e8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c00005ec:	0f 85 08 ff ff ff    	jne    c00004fa <kprintf+0x7b>
                }
            }

            if(flags.left) flags.zero = 0; //If the 0 and - flags both appear, the 0 flag is ignored
c00005f2:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c00005f9:	84 c0                	test   %al,%al
c00005fb:	74 07                	je     c0000604 <kprintf+0x185>
c00005fd:	c6 85 78 ff ff ff 00 	movb   $0x0,-0x88(%ebp)

            // parse field width
            int field_width=0;
c0000604:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
            int nn=0;
c000060b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
            while(f[nn] >= '0' && f[nn] <= '9')
c0000612:	eb 04                	jmp    c0000618 <kprintf+0x199>
                nn++;            
c0000614:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
            while(f[nn] >= '0' && f[nn] <= '9')
c0000618:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c000061b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000061e:	01 d0                	add    %edx,%eax
c0000620:	0f b6 00             	movzbl (%eax),%eax
c0000623:	3c 2f                	cmp    $0x2f,%al
c0000625:	7e 0f                	jle    c0000636 <kprintf+0x1b7>
c0000627:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c000062a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000062d:	01 d0                	add    %edx,%eax
c000062f:	0f b6 00             	movzbl (%eax),%eax
c0000632:	3c 39                	cmp    $0x39,%al
c0000634:	7e de                	jle    c0000614 <kprintf+0x195>
            if(nn>0)
c0000636:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c000063a:	7e 17                	jle    c0000653 <kprintf+0x1d4>
            {
                field_width = atoi(f);
c000063c:	83 ec 0c             	sub    $0xc,%esp
c000063f:	ff 75 f4             	pushl  -0xc(%ebp)
c0000642:	e8 6a 0d 00 00       	call   c00013b1 <atoi>
c0000647:	83 c4 10             	add    $0x10,%esp
c000064a:	89 45 e8             	mov    %eax,-0x18(%ebp)
                f += nn;
c000064d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0000650:	01 45 f4             	add    %eax,-0xc(%ebp)
            }

            // parse field precision
            int field_prec=-1; //default is -1
c0000653:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
            if(f[0] == '.')
c000065a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000065d:	0f b6 00             	movzbl (%eax),%eax
c0000660:	3c 2e                	cmp    $0x2e,%al
c0000662:	75 59                	jne    c00006bd <kprintf+0x23e>
            {
                f++;
c0000664:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                nn=0;
c0000668:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
                while(f[nn] >= '0' && f[nn] <= '9')
c000066f:	eb 04                	jmp    c0000675 <kprintf+0x1f6>
                    nn++;            
c0000671:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                while(f[nn] >= '0' && f[nn] <= '9')
c0000675:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000678:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000067b:	01 d0                	add    %edx,%eax
c000067d:	0f b6 00             	movzbl (%eax),%eax
c0000680:	3c 2f                	cmp    $0x2f,%al
c0000682:	7e 0f                	jle    c0000693 <kprintf+0x214>
c0000684:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000687:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000068a:	01 d0                	add    %edx,%eax
c000068c:	0f b6 00             	movzbl (%eax),%eax
c000068f:	3c 39                	cmp    $0x39,%al
c0000691:	7e de                	jle    c0000671 <kprintf+0x1f2>
                if(nn>0)
c0000693:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0000697:	7e 24                	jle    c00006bd <kprintf+0x23e>
                {
                    field_prec = atoi(f);
c0000699:	83 ec 0c             	sub    $0xc,%esp
c000069c:	ff 75 f4             	pushl  -0xc(%ebp)
c000069f:	e8 0d 0d 00 00       	call   c00013b1 <atoi>
c00006a4:	83 c4 10             	add    $0x10,%esp
c00006a7:	89 45 e0             	mov    %eax,-0x20(%ebp)
                    if(field_prec<0) field_prec = 0;
c00006aa:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c00006ae:	79 07                	jns    c00006b7 <kprintf+0x238>
c00006b0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
                    f += nn;
c00006b7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00006ba:	01 45 f4             	add    %eax,-0xc(%ebp)

            //parse type
            enum length_mod_t {DEFAULT, CHARINT, SHORTINT, LONGINT, LONGLONGINT,
                            LONGDOUBLE, INTMAX, SIZE, PTRDIFF} length_mod;

            switch(*(f++))
c00006bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00006c0:	8d 50 01             	lea    0x1(%eax),%edx
c00006c3:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00006c6:	0f b6 00             	movzbl (%eax),%eax
c00006c9:	0f be c0             	movsbl %al,%eax
c00006cc:	83 e8 4c             	sub    $0x4c,%eax
c00006cf:	83 f8 2e             	cmp    $0x2e,%eax
c00006d2:	77 6d                	ja     c0000741 <kprintf+0x2c2>
c00006d4:	8b 04 85 44 40 00 c0 	mov    -0x3fffbfbc(,%eax,4),%eax
c00006db:	ff e0                	jmp    *%eax
            {
                case 'h':
                    if(*f == 'h')
c00006dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00006e0:	0f b6 00             	movzbl (%eax),%eax
c00006e3:	3c 68                	cmp    $0x68,%al
c00006e5:	75 0d                	jne    c00006f4 <kprintf+0x275>
                    {
                        f++;
c00006e7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                        length_mod = CHARINT;
c00006eb:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
                    }
                    else
                        length_mod = SHORTINT;
                    break;
c00006f2:	eb 58                	jmp    c000074c <kprintf+0x2cd>
                        length_mod = SHORTINT;
c00006f4:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
                    break;
c00006fb:	eb 4f                	jmp    c000074c <kprintf+0x2cd>
                case 'l':
                    if(*f == 'l')
c00006fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000700:	0f b6 00             	movzbl (%eax),%eax
c0000703:	3c 6c                	cmp    $0x6c,%al
c0000705:	75 0d                	jne    c0000714 <kprintf+0x295>
                    {
                        f++;
c0000707:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                        length_mod = LONGLONGINT;
c000070b:	c7 45 dc 04 00 00 00 	movl   $0x4,-0x24(%ebp)
                    }
                    else
                        length_mod = LONGINT;
                    break;
c0000712:	eb 38                	jmp    c000074c <kprintf+0x2cd>
                        length_mod = LONGINT;
c0000714:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
                    break;
c000071b:	eb 2f                	jmp    c000074c <kprintf+0x2cd>
                case 'q':
                case 'L':
                    length_mod = LONGDOUBLE;
c000071d:	c7 45 dc 05 00 00 00 	movl   $0x5,-0x24(%ebp)
                    break;
c0000724:	eb 26                	jmp    c000074c <kprintf+0x2cd>
                case 'j':
                    length_mod = INTMAX;
c0000726:	c7 45 dc 06 00 00 00 	movl   $0x6,-0x24(%ebp)
                    break;
c000072d:	eb 1d                	jmp    c000074c <kprintf+0x2cd>
                case 'Z':
                case 'z':
                    length_mod = SIZE;
c000072f:	c7 45 dc 07 00 00 00 	movl   $0x7,-0x24(%ebp)
                    break;
c0000736:	eb 14                	jmp    c000074c <kprintf+0x2cd>
                case 't':
                    length_mod = PTRDIFF;
c0000738:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
                    break;
c000073f:	eb 0b                	jmp    c000074c <kprintf+0x2cd>
                default:
                    f--; //no length mod, back up a char...
c0000741:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
                    length_mod = DEFAULT;
c0000745:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
            }

            //parse field
            char val_buf[512]; //assuming here that numberical values cannot exceed 512 chars 
            if(field_width>511)
c000074c:	81 7d e8 ff 01 00 00 	cmpl   $0x1ff,-0x18(%ebp)
c0000753:	7e 0a                	jle    c000075f <kprintf+0x2e0>
                return -1;
c0000755:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000075a:	e9 f3 07 00 00       	jmp    c0000f52 <kprintf+0xad3>

            switch(*f)
c000075f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000762:	0f b6 00             	movzbl (%eax),%eax
c0000765:	0f be c0             	movsbl %al,%eax
c0000768:	83 e8 45             	sub    $0x45,%eax
c000076b:	83 f8 33             	cmp    $0x33,%eax
c000076e:	0f 87 97 07 00 00    	ja     c0000f0b <kprintf+0xa8c>
c0000774:	8b 04 85 00 41 00 c0 	mov    -0x3fffbf00(,%eax,4),%eax
c000077b:	ff e0                	jmp    *%eax
c000077d:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000781:	0f 87 67 01 00 00    	ja     c00008ee <kprintf+0x46f>
                        case(LONGINT):
                        case(LONGLONGINT):
                        case(DEFAULT):
                            {
                                int i_value;
                                if(length_mod == LONGLONGINT)
c0000787:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c000078b:	75 19                	jne    c00007a6 <kprintf+0x327>
                                    i_value = (int) va_arg(valist, long long int); //TODO: implement actual longlong handling
c000078d:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000793:	8d 50 08             	lea    0x8(%eax),%edx
c0000796:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c000079c:	8b 50 04             	mov    0x4(%eax),%edx
c000079f:	8b 00                	mov    (%eax),%eax
c00007a1:	89 45 d8             	mov    %eax,-0x28(%ebp)
c00007a4:	eb 14                	jmp    c00007ba <kprintf+0x33b>
                                else
                                    i_value = va_arg(valist, int);
c00007a6:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c00007ac:	8d 50 04             	lea    0x4(%eax),%edx
c00007af:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c00007b5:	8b 00                	mov    (%eax),%eax
c00007b7:	89 45 d8             	mov    %eax,-0x28(%ebp)

                                char sign_char = 0; //sign character or 0 if none
c00007ba:	c6 45 d7 00          	movb   $0x0,-0x29(%ebp)
                                unsigned int ui_value; //unsigned value (abs value)
                                if(i_value<0)
c00007be:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c00007c2:	79 0e                	jns    c00007d2 <kprintf+0x353>
                                {
                                    ui_value = -i_value;
c00007c4:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00007c7:	f7 d8                	neg    %eax
c00007c9:	89 45 d0             	mov    %eax,-0x30(%ebp)
                                    sign_char = '-';
c00007cc:	c6 45 d7 2d          	movb   $0x2d,-0x29(%ebp)
c00007d0:	eb 26                	jmp    c00007f8 <kprintf+0x379>
                                }
                                else
                                {
                                    ui_value = i_value;
c00007d2:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00007d5:	89 45 d0             	mov    %eax,-0x30(%ebp)
                                    if(flags.sign)
c00007d8:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c00007df:	84 c0                	test   %al,%al
c00007e1:	74 06                	je     c00007e9 <kprintf+0x36a>
                                        sign_char = '+';
c00007e3:	c6 45 d7 2b          	movb   $0x2b,-0x29(%ebp)
c00007e7:	eb 0f                	jmp    c00007f8 <kprintf+0x379>
                                    else if(flags.space)
c00007e9:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c00007f0:	84 c0                	test   %al,%al
c00007f2:	74 04                	je     c00007f8 <kprintf+0x379>
                                        sign_char = ' ';
c00007f4:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
                                    
                                    //else positive number has no sign character
                                }

                                //convert value into string
                                int len = format_uint(ui_value, val_buf, 10, field_prec, 0);
c00007f8:	83 ec 0c             	sub    $0xc,%esp
c00007fb:	6a 00                	push   $0x0
c00007fd:	ff 75 e0             	pushl  -0x20(%ebp)
c0000800:	6a 0a                	push   $0xa
c0000802:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000808:	50                   	push   %eax
c0000809:	ff 75 d0             	pushl  -0x30(%ebp)
c000080c:	e8 43 07 00 00       	call   c0000f54 <format_uint>
c0000811:	83 c4 20             	add    $0x20,%esp
c0000814:	89 45 9c             	mov    %eax,-0x64(%ebp)
                                //amount of padding required to meet requested width
                                int lenpad = field_width - len; 
c0000817:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000081a:	2b 45 9c             	sub    -0x64(%ebp),%eax
c000081d:	89 45 cc             	mov    %eax,-0x34(%ebp)

                                if(sign_char)
c0000820:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
c0000824:	74 22                	je     c0000848 <kprintf+0x3c9>
                                {
                                    lenpad--; //remove one char of padding to account for sign
c0000826:	83 6d cc 01          	subl   $0x1,-0x34(%ebp)
                                    if(flags.zero)
c000082a:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000831:	84 c0                	test   %al,%al
c0000833:	74 13                	je     c0000848 <kprintf+0x3c9>
                                        nchar += kprint_char(sign_char); //if zero padding, sign is at beginning
c0000835:	0f be 45 d7          	movsbl -0x29(%ebp),%eax
c0000839:	83 ec 0c             	sub    $0xc,%esp
c000083c:	50                   	push   %eax
c000083d:	e8 ec fb ff ff       	call   c000042e <kprint_char>
c0000842:	83 c4 10             	add    $0x10,%esp
c0000845:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                if(!flags.left && lenpad>0)
c0000848:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c000084f:	84 c0                	test   %al,%al
c0000851:	75 3b                	jne    c000088e <kprintf+0x40f>
c0000853:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
c0000857:	7e 35                	jle    c000088e <kprintf+0x40f>
                                {
                                    if(flags.zero)
c0000859:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000860:	84 c0                	test   %al,%al
c0000862:	74 16                	je     c000087a <kprintf+0x3fb>
                                        nchar += kprintn_char('0', lenpad);
c0000864:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0000867:	83 ec 08             	sub    $0x8,%esp
c000086a:	50                   	push   %eax
c000086b:	6a 30                	push   $0x30
c000086d:	e8 e4 fb ff ff       	call   c0000456 <kprintn_char>
c0000872:	83 c4 10             	add    $0x10,%esp
c0000875:	01 45 f0             	add    %eax,-0x10(%ebp)
c0000878:	eb 14                	jmp    c000088e <kprintf+0x40f>
                                    else
                                        nchar += kprintn_char(' ', lenpad);
c000087a:	8b 45 cc             	mov    -0x34(%ebp),%eax
c000087d:	83 ec 08             	sub    $0x8,%esp
c0000880:	50                   	push   %eax
c0000881:	6a 20                	push   $0x20
c0000883:	e8 ce fb ff ff       	call   c0000456 <kprintn_char>
c0000888:	83 c4 10             	add    $0x10,%esp
c000088b:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                if(!flags.zero && sign_char)
c000088e:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000895:	84 c0                	test   %al,%al
c0000897:	75 19                	jne    c00008b2 <kprintf+0x433>
c0000899:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
c000089d:	74 13                	je     c00008b2 <kprintf+0x433>
                                    nchar += kprint_char(sign_char); //if not zero padding, write sign here
c000089f:	0f be 45 d7          	movsbl -0x29(%ebp),%eax
c00008a3:	83 ec 0c             	sub    $0xc,%esp
c00008a6:	50                   	push   %eax
c00008a7:	e8 82 fb ff ff       	call   c000042e <kprint_char>
c00008ac:	83 c4 10             	add    $0x10,%esp
c00008af:	01 45 f0             	add    %eax,-0x10(%ebp)

                                nchar += kprint(val_buf);
c00008b2:	83 ec 0c             	sub    $0xc,%esp
c00008b5:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c00008bb:	50                   	push   %eax
c00008bc:	e8 23 fb ff ff       	call   c00003e4 <kprint>
c00008c1:	83 c4 10             	add    $0x10,%esp
c00008c4:	01 45 f0             	add    %eax,-0x10(%ebp)

                                if(flags.left && lenpad>0)
c00008c7:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c00008ce:	84 c0                	test   %al,%al
c00008d0:	74 26                	je     c00008f8 <kprintf+0x479>
c00008d2:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
c00008d6:	7e 20                	jle    c00008f8 <kprintf+0x479>
                                    nchar += kprintn_char(' ', lenpad);
c00008d8:	8b 45 cc             	mov    -0x34(%ebp),%eax
c00008db:	83 ec 08             	sub    $0x8,%esp
c00008de:	50                   	push   %eax
c00008df:	6a 20                	push   $0x20
c00008e1:	e8 70 fb ff ff       	call   c0000456 <kprintn_char>
c00008e6:	83 c4 10             	add    $0x10,%esp
c00008e9:	01 45 f0             	add    %eax,-0x10(%ebp)


                            }
                            break;
c00008ec:	eb 0a                	jmp    c00008f8 <kprintf+0x479>
                        default:
                            return -1; //invalid length mod
c00008ee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00008f3:	e9 5a 06 00 00       	jmp    c0000f52 <kprintf+0xad3>
                            break;
c00008f8:	90                   	nop
                    }
                    break;
c00008f9:	e9 1e 06 00 00       	jmp    c0000f1c <kprintf+0xa9d>
c00008fe:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000902:	0f 87 03 02 00 00    	ja     c0000b0b <kprintf+0x68c>
                        case(SHORTINT):
                        case(LONGINT):
                        case(LONGLONGINT):
                        case(DEFAULT):
                            {
                                unsigned int base = 10;
c0000908:	c7 45 c8 0a 00 00 00 	movl   $0xa,-0x38(%ebp)
                                unsigned int ui_value;
                                if(length_mod == LONGLONGINT)
c000090f:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000913:	75 19                	jne    c000092e <kprintf+0x4af>
                                    ui_value = (unsigned int) va_arg(valist, long long unsigned int); //TODO: implement actual longlong handling
c0000915:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c000091b:	8d 50 08             	lea    0x8(%eax),%edx
c000091e:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000924:	8b 50 04             	mov    0x4(%eax),%edx
c0000927:	8b 00                	mov    (%eax),%eax
c0000929:	89 45 c4             	mov    %eax,-0x3c(%ebp)
c000092c:	eb 14                	jmp    c0000942 <kprintf+0x4c3>
                                else
                                    ui_value = va_arg(valist, unsigned int);
c000092e:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000934:	8d 50 04             	lea    0x4(%eax),%edx
c0000937:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c000093d:	8b 00                	mov    (%eax),%eax
c000093f:	89 45 c4             	mov    %eax,-0x3c(%ebp)

                                if(*f == 'o')
c0000942:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000945:	0f b6 00             	movzbl (%eax),%eax
c0000948:	3c 6f                	cmp    $0x6f,%al
c000094a:	75 09                	jne    c0000955 <kprintf+0x4d6>
                                    base = 8;
c000094c:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
c0000953:	eb 3e                	jmp    c0000993 <kprintf+0x514>
                                else if(*f == 'x' || *f == 'X')
c0000955:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000958:	0f b6 00             	movzbl (%eax),%eax
c000095b:	3c 78                	cmp    $0x78,%al
c000095d:	74 0a                	je     c0000969 <kprintf+0x4ea>
c000095f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000962:	0f b6 00             	movzbl (%eax),%eax
c0000965:	3c 58                	cmp    $0x58,%al
c0000967:	75 09                	jne    c0000972 <kprintf+0x4f3>
                                    base = 16;
c0000969:	c7 45 c8 10 00 00 00 	movl   $0x10,-0x38(%ebp)
c0000970:	eb 21                	jmp    c0000993 <kprintf+0x514>
                                else if(*f == 'p')
c0000972:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000975:	0f b6 00             	movzbl (%eax),%eax
c0000978:	3c 70                	cmp    $0x70,%al
c000097a:	75 10                	jne    c000098c <kprintf+0x50d>
                                {
                                    //print as hex with 0x prefix
                                    base = 16;
c000097c:	c7 45 c8 10 00 00 00 	movl   $0x10,-0x38(%ebp)
                                    flags.alt = 1; 
c0000983:	c6 85 77 ff ff ff 01 	movb   $0x1,-0x89(%ebp)
c000098a:	eb 07                	jmp    c0000993 <kprintf+0x514>
                                }
                                else
                                    flags.alt = 0;
c000098c:	c6 85 77 ff ff ff 00 	movb   $0x0,-0x89(%ebp)
                                
                                int cap = (*f == 'X') ? 1 : 0;
c0000993:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000996:	0f b6 00             	movzbl (%eax),%eax
c0000999:	3c 58                	cmp    $0x58,%al
c000099b:	0f 94 c0             	sete   %al
c000099e:	0f b6 c0             	movzbl %al,%eax
c00009a1:	89 45 94             	mov    %eax,-0x6c(%ebp)

                                //convert value into string
                                int len = format_uint(ui_value, val_buf, base, field_prec, cap);
c00009a4:	83 ec 0c             	sub    $0xc,%esp
c00009a7:	ff 75 94             	pushl  -0x6c(%ebp)
c00009aa:	ff 75 e0             	pushl  -0x20(%ebp)
c00009ad:	ff 75 c8             	pushl  -0x38(%ebp)
c00009b0:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c00009b6:	50                   	push   %eax
c00009b7:	ff 75 c4             	pushl  -0x3c(%ebp)
c00009ba:	e8 95 05 00 00       	call   c0000f54 <format_uint>
c00009bf:	83 c4 20             	add    $0x20,%esp
c00009c2:	89 45 90             	mov    %eax,-0x70(%ebp)
                                //amount of padding required to meet requested width
                                int lenpad = field_width - len; 
c00009c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00009c8:	2b 45 90             	sub    -0x70(%ebp),%eax
c00009cb:	89 45 c0             	mov    %eax,-0x40(%ebp)


                                //format radix prefix for oct and hex with alt flag
                                char radix[3]="";
c00009ce:	66 c7 85 74 ff ff ff 	movw   $0x0,-0x8c(%ebp)
c00009d5:	00 00 
c00009d7:	c6 85 76 ff ff ff 00 	movb   $0x0,-0x8a(%ebp)
                                if(flags.alt)
c00009de:	0f b6 85 77 ff ff ff 	movzbl -0x89(%ebp),%eax
c00009e5:	84 c0                	test   %al,%al
c00009e7:	74 75                	je     c0000a5e <kprintf+0x5df>
                                {
                                    if(base==16)
c00009e9:	83 7d c8 10          	cmpl   $0x10,-0x38(%ebp)
c00009ed:	75 2c                	jne    c0000a1b <kprintf+0x59c>
                                    {
                                        lenpad -= 2;
c00009ef:	83 6d c0 02          	subl   $0x2,-0x40(%ebp)
                                        radix[0] = '0';
c00009f3:	c6 85 74 ff ff ff 30 	movb   $0x30,-0x8c(%ebp)
                                        radix[1] = cap ? 'X' : 'x';
c00009fa:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
c00009fe:	74 07                	je     c0000a07 <kprintf+0x588>
c0000a00:	b8 58 00 00 00       	mov    $0x58,%eax
c0000a05:	eb 05                	jmp    c0000a0c <kprintf+0x58d>
c0000a07:	b8 78 00 00 00       	mov    $0x78,%eax
c0000a0c:	88 85 75 ff ff ff    	mov    %al,-0x8b(%ebp)
                                        radix[2] = 0;
c0000a12:	c6 85 76 ff ff ff 00 	movb   $0x0,-0x8a(%ebp)
c0000a19:	eb 23                	jmp    c0000a3e <kprintf+0x5bf>
                                    }
                                    else if(base==8 && val_buf[0] != '0')
c0000a1b:	83 7d c8 08          	cmpl   $0x8,-0x38(%ebp)
c0000a1f:	75 1d                	jne    c0000a3e <kprintf+0x5bf>
c0000a21:	0f b6 85 74 fd ff ff 	movzbl -0x28c(%ebp),%eax
c0000a28:	3c 30                	cmp    $0x30,%al
c0000a2a:	74 12                	je     c0000a3e <kprintf+0x5bf>
                                    {
                                        lenpad -= 1;
c0000a2c:	83 6d c0 01          	subl   $0x1,-0x40(%ebp)
                                        radix[0] = '0';
c0000a30:	c6 85 74 ff ff ff 30 	movb   $0x30,-0x8c(%ebp)
                                        radix[1] = 0;
c0000a37:	c6 85 75 ff ff ff 00 	movb   $0x0,-0x8b(%ebp)
                                    }

                                    //if zero padding, radix is printed first
                                    if(flags.zero)
c0000a3e:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000a45:	84 c0                	test   %al,%al
c0000a47:	74 15                	je     c0000a5e <kprintf+0x5df>
                                        nchar += kprint(radix);
c0000a49:	83 ec 0c             	sub    $0xc,%esp
c0000a4c:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
c0000a52:	50                   	push   %eax
c0000a53:	e8 8c f9 ff ff       	call   c00003e4 <kprint>
c0000a58:	83 c4 10             	add    $0x10,%esp
c0000a5b:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }


                                //print leading padding, if any
                                if(!flags.left && lenpad>0)
c0000a5e:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000a65:	84 c0                	test   %al,%al
c0000a67:	75 3b                	jne    c0000aa4 <kprintf+0x625>
c0000a69:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
c0000a6d:	7e 35                	jle    c0000aa4 <kprintf+0x625>
                                {
                                    if(flags.zero)
c0000a6f:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000a76:	84 c0                	test   %al,%al
c0000a78:	74 16                	je     c0000a90 <kprintf+0x611>
                                        nchar += kprintn_char('0', lenpad);
c0000a7a:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000a7d:	83 ec 08             	sub    $0x8,%esp
c0000a80:	50                   	push   %eax
c0000a81:	6a 30                	push   $0x30
c0000a83:	e8 ce f9 ff ff       	call   c0000456 <kprintn_char>
c0000a88:	83 c4 10             	add    $0x10,%esp
c0000a8b:	01 45 f0             	add    %eax,-0x10(%ebp)
c0000a8e:	eb 14                	jmp    c0000aa4 <kprintf+0x625>
                                    else
                                        nchar += kprintn_char(' ', lenpad);
c0000a90:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000a93:	83 ec 08             	sub    $0x8,%esp
c0000a96:	50                   	push   %eax
c0000a97:	6a 20                	push   $0x20
c0000a99:	e8 b8 f9 ff ff       	call   c0000456 <kprintn_char>
c0000a9e:	83 c4 10             	add    $0x10,%esp
c0000aa1:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                //print radix prefix if valid and not leading zeros
                                if(!flags.zero && radix[0])
c0000aa4:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000aab:	84 c0                	test   %al,%al
c0000aad:	75 20                	jne    c0000acf <kprintf+0x650>
c0000aaf:	0f b6 85 74 ff ff ff 	movzbl -0x8c(%ebp),%eax
c0000ab6:	84 c0                	test   %al,%al
c0000ab8:	74 15                	je     c0000acf <kprintf+0x650>
                                    nchar += kprint(radix);
c0000aba:	83 ec 0c             	sub    $0xc,%esp
c0000abd:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
c0000ac3:	50                   	push   %eax
c0000ac4:	e8 1b f9 ff ff       	call   c00003e4 <kprint>
c0000ac9:	83 c4 10             	add    $0x10,%esp
c0000acc:	01 45 f0             	add    %eax,-0x10(%ebp)

                                //print number itself
                                nchar += kprint(val_buf);
c0000acf:	83 ec 0c             	sub    $0xc,%esp
c0000ad2:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000ad8:	50                   	push   %eax
c0000ad9:	e8 06 f9 ff ff       	call   c00003e4 <kprint>
c0000ade:	83 c4 10             	add    $0x10,%esp
c0000ae1:	01 45 f0             	add    %eax,-0x10(%ebp)

                                //print trailing padding if left justified
                                if(flags.left && lenpad>0)
c0000ae4:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000aeb:	84 c0                	test   %al,%al
c0000aed:	74 26                	je     c0000b15 <kprintf+0x696>
c0000aef:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
c0000af3:	7e 20                	jle    c0000b15 <kprintf+0x696>
                                    nchar += kprintn_char(' ', lenpad);
c0000af5:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000af8:	83 ec 08             	sub    $0x8,%esp
c0000afb:	50                   	push   %eax
c0000afc:	6a 20                	push   $0x20
c0000afe:	e8 53 f9 ff ff       	call   c0000456 <kprintn_char>
c0000b03:	83 c4 10             	add    $0x10,%esp
c0000b06:	01 45 f0             	add    %eax,-0x10(%ebp)

                            }
                            break;
c0000b09:	eb 0a                	jmp    c0000b15 <kprintf+0x696>
                        default:
                            return -1; //invalid length mod
c0000b0b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000b10:	e9 3d 04 00 00       	jmp    c0000f52 <kprintf+0xad3>
                            break;
c0000b15:	90                   	nop
                    }

                    break;
c0000b16:	e9 01 04 00 00       	jmp    c0000f1c <kprintf+0xa9d>

                case 'f':
                case 'F':
                    {
                        float f_value = (float) va_arg(valist, double);
c0000b1b:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000b21:	8d 50 08             	lea    0x8(%eax),%edx
c0000b24:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000b2a:	dd 00                	fldl   (%eax)
c0000b2c:	d9 5d 8c             	fstps  -0x74(%ebp)

                        //When 0 is printed with an explicit precision 0, the output is empty.
                        if(f_value==0 && field_prec==0)
c0000b2f:	d9 45 8c             	flds   -0x74(%ebp)
c0000b32:	d9 ee                	fldz   
c0000b34:	df e9                	fucomip %st(1),%st
c0000b36:	dd d8                	fstp   %st(0)
c0000b38:	7a 15                	jp     c0000b4f <kprintf+0x6d0>
c0000b3a:	d9 45 8c             	flds   -0x74(%ebp)
c0000b3d:	d9 ee                	fldz   
c0000b3f:	df e9                	fucomip %st(1),%st
c0000b41:	dd d8                	fstp   %st(0)
c0000b43:	75 0a                	jne    c0000b4f <kprintf+0x6d0>
c0000b45:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000b49:	0f 84 c3 03 00 00    	je     c0000f12 <kprintf+0xa93>
                            break;
                        if(field_prec<0) field_prec = 6;  //default is prec = 6
c0000b4f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000b53:	79 07                	jns    c0000b5c <kprintf+0x6dd>
c0000b55:	c7 45 e0 06 00 00 00 	movl   $0x6,-0x20(%ebp)

                        unsigned int ui_part;
                        char sign_char = 0;
c0000b5c:	c6 45 bb 00          	movb   $0x0,-0x45(%ebp)
                        if(f_value<0)
c0000b60:	d9 45 8c             	flds   -0x74(%ebp)
c0000b63:	d9 ee                	fldz   
c0000b65:	df f1                	fcomip %st(1),%st
c0000b67:	dd d8                	fstp   %st(0)
c0000b69:	76 3d                	jbe    c0000ba8 <kprintf+0x729>
                        {
                            ui_part = (unsigned int) -f_value;
c0000b6b:	d9 45 8c             	flds   -0x74(%ebp)
c0000b6e:	d9 e0                	fchs   
c0000b70:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c0000b76:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c0000b7d:	80 cc 0c             	or     $0xc,%ah
c0000b80:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c0000b87:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c0000b8d:	df bd 58 fd ff ff    	fistpll -0x2a8(%ebp)
c0000b93:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
c0000b99:	8b 85 58 fd ff ff    	mov    -0x2a8(%ebp),%eax
c0000b9f:	89 45 bc             	mov    %eax,-0x44(%ebp)
                            sign_char = '-';
c0000ba2:	c6 45 bb 2d          	movb   $0x2d,-0x45(%ebp)
c0000ba6:	eb 55                	jmp    c0000bfd <kprintf+0x77e>
                        }
                        else
                        {
                            ui_part = (unsigned int) f_value;
c0000ba8:	d9 45 8c             	flds   -0x74(%ebp)
c0000bab:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c0000bb1:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c0000bb8:	80 cc 0c             	or     $0xc,%ah
c0000bbb:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c0000bc2:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c0000bc8:	df bd 58 fd ff ff    	fistpll -0x2a8(%ebp)
c0000bce:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
c0000bd4:	8b 85 58 fd ff ff    	mov    -0x2a8(%ebp),%eax
c0000bda:	89 45 bc             	mov    %eax,-0x44(%ebp)
                            if(flags.sign)
c0000bdd:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c0000be4:	84 c0                	test   %al,%al
c0000be6:	74 06                	je     c0000bee <kprintf+0x76f>
                                sign_char = '+';
c0000be8:	c6 45 bb 2b          	movb   $0x2b,-0x45(%ebp)
c0000bec:	eb 0f                	jmp    c0000bfd <kprintf+0x77e>
                            else if(flags.space)
c0000bee:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c0000bf5:	84 c0                	test   %al,%al
c0000bf7:	74 04                	je     c0000bfd <kprintf+0x77e>
                                sign_char = ' ';
c0000bf9:	c6 45 bb 20          	movb   $0x20,-0x45(%ebp)
                            
                            //else positive number has no sign character
                        }

                        int int_len = format_uint(ui_part,val_buf,10,-1,0);
c0000bfd:	83 ec 0c             	sub    $0xc,%esp
c0000c00:	6a 00                	push   $0x0
c0000c02:	6a ff                	push   $0xffffffff
c0000c04:	6a 0a                	push   $0xa
c0000c06:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000c0c:	50                   	push   %eax
c0000c0d:	ff 75 bc             	pushl  -0x44(%ebp)
c0000c10:	e8 3f 03 00 00       	call   c0000f54 <format_uint>
c0000c15:	83 c4 20             	add    $0x20,%esp
c0000c18:	89 45 88             	mov    %eax,-0x78(%ebp)

                        int f_len = int_len + 1 + field_prec;
c0000c1b:	8b 45 88             	mov    -0x78(%ebp),%eax
c0000c1e:	8d 50 01             	lea    0x1(%eax),%edx
c0000c21:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0000c24:	01 d0                	add    %edx,%eax
c0000c26:	89 45 84             	mov    %eax,-0x7c(%ebp)

                        //amount of padding required to meet requested width
                        int lenpad = field_width - f_len; 
c0000c29:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000c2c:	2b 45 84             	sub    -0x7c(%ebp),%eax
c0000c2f:	89 45 b4             	mov    %eax,-0x4c(%ebp)

                        if(sign_char)
c0000c32:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
c0000c36:	74 22                	je     c0000c5a <kprintf+0x7db>
                        {
                            lenpad--; //remove one char of padding to account for sign
c0000c38:	83 6d b4 01          	subl   $0x1,-0x4c(%ebp)
                            if(flags.zero)
c0000c3c:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000c43:	84 c0                	test   %al,%al
c0000c45:	74 13                	je     c0000c5a <kprintf+0x7db>
                                nchar += kprint_char(sign_char); //if zero padding, sign is at beginning
c0000c47:	0f be 45 bb          	movsbl -0x45(%ebp),%eax
c0000c4b:	83 ec 0c             	sub    $0xc,%esp
c0000c4e:	50                   	push   %eax
c0000c4f:	e8 da f7 ff ff       	call   c000042e <kprint_char>
c0000c54:	83 c4 10             	add    $0x10,%esp
c0000c57:	01 45 f0             	add    %eax,-0x10(%ebp)
                        }

                        if(!flags.left && lenpad>0)
c0000c5a:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000c61:	84 c0                	test   %al,%al
c0000c63:	75 3b                	jne    c0000ca0 <kprintf+0x821>
c0000c65:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
c0000c69:	7e 35                	jle    c0000ca0 <kprintf+0x821>
                        {
                            if(flags.zero)
c0000c6b:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000c72:	84 c0                	test   %al,%al
c0000c74:	74 16                	je     c0000c8c <kprintf+0x80d>
                                nchar += kprintn_char('0', lenpad);
c0000c76:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c0000c79:	83 ec 08             	sub    $0x8,%esp
c0000c7c:	50                   	push   %eax
c0000c7d:	6a 30                	push   $0x30
c0000c7f:	e8 d2 f7 ff ff       	call   c0000456 <kprintn_char>
c0000c84:	83 c4 10             	add    $0x10,%esp
c0000c87:	01 45 f0             	add    %eax,-0x10(%ebp)
c0000c8a:	eb 14                	jmp    c0000ca0 <kprintf+0x821>
                            else
                                nchar += kprintn_char(' ', lenpad);
c0000c8c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c0000c8f:	83 ec 08             	sub    $0x8,%esp
c0000c92:	50                   	push   %eax
c0000c93:	6a 20                	push   $0x20
c0000c95:	e8 bc f7 ff ff       	call   c0000456 <kprintn_char>
c0000c9a:	83 c4 10             	add    $0x10,%esp
c0000c9d:	01 45 f0             	add    %eax,-0x10(%ebp)
                        }

                        if(!flags.zero && sign_char)
c0000ca0:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000ca7:	84 c0                	test   %al,%al
c0000ca9:	75 19                	jne    c0000cc4 <kprintf+0x845>
c0000cab:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
c0000caf:	74 13                	je     c0000cc4 <kprintf+0x845>
                            nchar += kprint_char(sign_char); //if not zero padding, write sign here
c0000cb1:	0f be 45 bb          	movsbl -0x45(%ebp),%eax
c0000cb5:	83 ec 0c             	sub    $0xc,%esp
c0000cb8:	50                   	push   %eax
c0000cb9:	e8 70 f7 ff ff       	call   c000042e <kprint_char>
c0000cbe:	83 c4 10             	add    $0x10,%esp
c0000cc1:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprint(val_buf);
c0000cc4:	83 ec 0c             	sub    $0xc,%esp
c0000cc7:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000ccd:	50                   	push   %eax
c0000cce:	e8 11 f7 ff ff       	call   c00003e4 <kprint>
c0000cd3:	83 c4 10             	add    $0x10,%esp
c0000cd6:	01 45 f0             	add    %eax,-0x10(%ebp)
                        nchar += kprint_char('.');
c0000cd9:	83 ec 0c             	sub    $0xc,%esp
c0000cdc:	6a 2e                	push   $0x2e
c0000cde:	e8 4b f7 ff ff       	call   c000042e <kprint_char>
c0000ce3:	83 c4 10             	add    $0x10,%esp
c0000ce6:	01 45 f0             	add    %eax,-0x10(%ebp)

                        //compute fractional digits.
                        float frac = f_value<0 ? -f_value - ui_part : f_value - ui_part;
c0000ce9:	d9 45 8c             	flds   -0x74(%ebp)
c0000cec:	d9 ee                	fldz   
c0000cee:	df f1                	fcomip %st(1),%st
c0000cf0:	dd d8                	fstp   %st(0)
c0000cf2:	76 23                	jbe    c0000d17 <kprintf+0x898>
c0000cf4:	d9 45 8c             	flds   -0x74(%ebp)
c0000cf7:	d9 e0                	fchs   
c0000cf9:	8b 45 bc             	mov    -0x44(%ebp),%eax
c0000cfc:	ba 00 00 00 00       	mov    $0x0,%edx
c0000d01:	89 85 58 fd ff ff    	mov    %eax,-0x2a8(%ebp)
c0000d07:	89 95 5c fd ff ff    	mov    %edx,-0x2a4(%ebp)
c0000d0d:	df ad 58 fd ff ff    	fildll -0x2a8(%ebp)
c0000d13:	de e9                	fsubrp %st,%st(1)
c0000d15:	eb 1f                	jmp    c0000d36 <kprintf+0x8b7>
c0000d17:	8b 45 bc             	mov    -0x44(%ebp),%eax
c0000d1a:	ba 00 00 00 00       	mov    $0x0,%edx
c0000d1f:	89 85 58 fd ff ff    	mov    %eax,-0x2a8(%ebp)
c0000d25:	89 95 5c fd ff ff    	mov    %edx,-0x2a4(%ebp)
c0000d2b:	df ad 58 fd ff ff    	fildll -0x2a8(%ebp)
c0000d31:	d9 45 8c             	flds   -0x74(%ebp)
c0000d34:	de e1                	fsubp  %st,%st(1)
c0000d36:	d9 5d b0             	fstps  -0x50(%ebp)
                        int d;
                        for(int nn=0;nn<field_prec; nn++)
c0000d39:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
c0000d40:	eb 5e                	jmp    c0000da0 <kprintf+0x921>
                        {
                            frac *= 10.;
c0000d42:	d9 45 b0             	flds   -0x50(%ebp)
c0000d45:	d9 05 1c 44 00 c0    	flds   0xc000441c
c0000d4b:	de c9                	fmulp  %st,%st(1)
c0000d4d:	d9 5d b0             	fstps  -0x50(%ebp)
                            d = (int) frac;
c0000d50:	d9 45 b0             	flds   -0x50(%ebp)
c0000d53:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c0000d59:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c0000d60:	80 cc 0c             	or     $0xc,%ah
c0000d63:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c0000d6a:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c0000d70:	db 5d 80             	fistpl -0x80(%ebp)
c0000d73:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
                            frac -= d;
c0000d79:	db 45 80             	fildl  -0x80(%ebp)
c0000d7c:	d9 45 b0             	flds   -0x50(%ebp)
c0000d7f:	de e1                	fsubp  %st,%st(1)
c0000d81:	d9 5d b0             	fstps  -0x50(%ebp)
                            nchar += kprint_char('0' + d);
c0000d84:	8b 45 80             	mov    -0x80(%ebp),%eax
c0000d87:	83 c0 30             	add    $0x30,%eax
c0000d8a:	0f be c0             	movsbl %al,%eax
c0000d8d:	83 ec 0c             	sub    $0xc,%esp
c0000d90:	50                   	push   %eax
c0000d91:	e8 98 f6 ff ff       	call   c000042e <kprint_char>
c0000d96:	83 c4 10             	add    $0x10,%esp
c0000d99:	01 45 f0             	add    %eax,-0x10(%ebp)
                        for(int nn=0;nn<field_prec; nn++)
c0000d9c:	83 45 ac 01          	addl   $0x1,-0x54(%ebp)
c0000da0:	8b 45 ac             	mov    -0x54(%ebp),%eax
c0000da3:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c0000da6:	7c 9a                	jl     c0000d42 <kprintf+0x8c3>
                        }

                        if(flags.left && lenpad>0)
c0000da8:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000daf:	84 c0                	test   %al,%al
c0000db1:	0f 84 5e 01 00 00    	je     c0000f15 <kprintf+0xa96>
c0000db7:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
c0000dbb:	0f 8e 54 01 00 00    	jle    c0000f15 <kprintf+0xa96>
                            nchar += kprintn_char(' ', lenpad);
c0000dc1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c0000dc4:	83 ec 08             	sub    $0x8,%esp
c0000dc7:	50                   	push   %eax
c0000dc8:	6a 20                	push   $0x20
c0000dca:	e8 87 f6 ff ff       	call   c0000456 <kprintn_char>
c0000dcf:	83 c4 10             	add    $0x10,%esp
c0000dd2:	01 45 f0             	add    %eax,-0x10(%ebp)

                    }
                    break;
c0000dd5:	e9 3b 01 00 00       	jmp    c0000f15 <kprintf+0xa96>
                case 'e':
                case 'E':
                case 'g':
                case 'G':
                    return -1; // not yet implemented
c0000dda:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000ddf:	e9 6e 01 00 00       	jmp    c0000f52 <kprintf+0xad3>
                case 'c':
                    {
                        char c = (char) va_arg(valist, int);
c0000de4:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000dea:	8d 50 04             	lea    0x4(%eax),%edx
c0000ded:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000df3:	8b 00                	mov    (%eax),%eax
c0000df5:	88 45 9b             	mov    %al,-0x65(%ebp)

                        if(field_width>1 && !flags.left)    
c0000df8:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
c0000dfc:	7e 22                	jle    c0000e20 <kprintf+0x9a1>
c0000dfe:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000e05:	84 c0                	test   %al,%al
c0000e07:	75 17                	jne    c0000e20 <kprintf+0x9a1>
                            nchar += kprintn_char(' ', field_width-1);
c0000e09:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000e0c:	83 e8 01             	sub    $0x1,%eax
c0000e0f:	83 ec 08             	sub    $0x8,%esp
c0000e12:	50                   	push   %eax
c0000e13:	6a 20                	push   $0x20
c0000e15:	e8 3c f6 ff ff       	call   c0000456 <kprintn_char>
c0000e1a:	83 c4 10             	add    $0x10,%esp
c0000e1d:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprint_char(c);
c0000e20:	0f be 45 9b          	movsbl -0x65(%ebp),%eax
c0000e24:	83 ec 0c             	sub    $0xc,%esp
c0000e27:	50                   	push   %eax
c0000e28:	e8 01 f6 ff ff       	call   c000042e <kprint_char>
c0000e2d:	83 c4 10             	add    $0x10,%esp
c0000e30:	01 45 f0             	add    %eax,-0x10(%ebp)

                        if(field_width>1 && flags.left)    
c0000e33:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
c0000e37:	0f 8e db 00 00 00    	jle    c0000f18 <kprintf+0xa99>
c0000e3d:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000e44:	84 c0                	test   %al,%al
c0000e46:	0f 84 cc 00 00 00    	je     c0000f18 <kprintf+0xa99>
                            nchar += kprintn_char(' ', field_width-1);
c0000e4c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000e4f:	83 e8 01             	sub    $0x1,%eax
c0000e52:	83 ec 08             	sub    $0x8,%esp
c0000e55:	50                   	push   %eax
c0000e56:	6a 20                	push   $0x20
c0000e58:	e8 f9 f5 ff ff       	call   c0000456 <kprintn_char>
c0000e5d:	83 c4 10             	add    $0x10,%esp
c0000e60:	01 45 f0             	add    %eax,-0x10(%ebp)
                    }                    
                    break;
c0000e63:	e9 b0 00 00 00       	jmp    c0000f18 <kprintf+0xa99>

                case 's':
                    {
                        char* str = va_arg(valist, char*);
c0000e68:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000e6e:	8d 50 04             	lea    0x4(%eax),%edx
c0000e71:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000e77:	8b 00                	mov    (%eax),%eax
c0000e79:	89 45 a4             	mov    %eax,-0x5c(%ebp)
                        int len = strlen(str);
c0000e7c:	83 ec 0c             	sub    $0xc,%esp
c0000e7f:	ff 75 a4             	pushl  -0x5c(%ebp)
c0000e82:	e8 2b 04 00 00       	call   c00012b2 <strlen>
c0000e87:	83 c4 10             	add    $0x10,%esp
c0000e8a:	89 45 a8             	mov    %eax,-0x58(%ebp)
                        if(field_prec > 0 && field_prec < len)
c0000e8d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000e91:	7e 0e                	jle    c0000ea1 <kprintf+0xa22>
c0000e93:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0000e96:	3b 45 a8             	cmp    -0x58(%ebp),%eax
c0000e99:	7d 06                	jge    c0000ea1 <kprintf+0xa22>
                            len = field_prec;
c0000e9b:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0000e9e:	89 45 a8             	mov    %eax,-0x58(%ebp)

                        int lenpad = field_width - len; 
c0000ea1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000ea4:	2b 45 a8             	sub    -0x58(%ebp),%eax
c0000ea7:	89 45 a0             	mov    %eax,-0x60(%ebp)

                        if(lenpad>0 && !flags.left)    
c0000eaa:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
c0000eae:	7e 1f                	jle    c0000ecf <kprintf+0xa50>
c0000eb0:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000eb7:	84 c0                	test   %al,%al
c0000eb9:	75 14                	jne    c0000ecf <kprintf+0xa50>
                            nchar += kprintn_char(' ', lenpad);
c0000ebb:	8b 45 a0             	mov    -0x60(%ebp),%eax
c0000ebe:	83 ec 08             	sub    $0x8,%esp
c0000ec1:	50                   	push   %eax
c0000ec2:	6a 20                	push   $0x20
c0000ec4:	e8 8d f5 ff ff       	call   c0000456 <kprintn_char>
c0000ec9:	83 c4 10             	add    $0x10,%esp
c0000ecc:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprintn(str,len);
c0000ecf:	8b 45 a8             	mov    -0x58(%ebp),%eax
c0000ed2:	83 ec 08             	sub    $0x8,%esp
c0000ed5:	50                   	push   %eax
c0000ed6:	ff 75 a4             	pushl  -0x5c(%ebp)
c0000ed9:	e8 2f f5 ff ff       	call   c000040d <kprintn>
c0000ede:	83 c4 10             	add    $0x10,%esp
c0000ee1:	01 45 f0             	add    %eax,-0x10(%ebp)

                        if(lenpad>0 && flags.left)
c0000ee4:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
c0000ee8:	7e 31                	jle    c0000f1b <kprintf+0xa9c>
c0000eea:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000ef1:	84 c0                	test   %al,%al
c0000ef3:	74 26                	je     c0000f1b <kprintf+0xa9c>
                            nchar += kprintn_char(' ', lenpad);
c0000ef5:	8b 45 a0             	mov    -0x60(%ebp),%eax
c0000ef8:	83 ec 08             	sub    $0x8,%esp
c0000efb:	50                   	push   %eax
c0000efc:	6a 20                	push   $0x20
c0000efe:	e8 53 f5 ff ff       	call   c0000456 <kprintn_char>
c0000f03:	83 c4 10             	add    $0x10,%esp
c0000f06:	01 45 f0             	add    %eax,-0x10(%ebp)
                        
                    }
                    break;
c0000f09:	eb 10                	jmp    c0000f1b <kprintf+0xa9c>
                default:
                    //unsupported type
                    return -1;
c0000f0b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000f10:	eb 40                	jmp    c0000f52 <kprintf+0xad3>
                            break;
c0000f12:	90                   	nop
c0000f13:	eb 07                	jmp    c0000f1c <kprintf+0xa9d>
                    break;
c0000f15:	90                   	nop
c0000f16:	eb 04                	jmp    c0000f1c <kprintf+0xa9d>
                    break;
c0000f18:	90                   	nop
c0000f19:	eb 01                	jmp    c0000f1c <kprintf+0xa9d>
                    break;
c0000f1b:	90                   	nop
                
            }
            f++;
c0000f1c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0000f20:	eb 1f                	jmp    c0000f41 <kprintf+0xac2>
        }
        else
        {
            //this isnt part of a format code, just copy char to string and increment pointers
            kprint_char(*(f++));
c0000f22:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000f25:	8d 50 01             	lea    0x1(%eax),%edx
c0000f28:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0000f2b:	0f b6 00             	movzbl (%eax),%eax
c0000f2e:	0f be c0             	movsbl %al,%eax
c0000f31:	83 ec 0c             	sub    $0xc,%esp
c0000f34:	50                   	push   %eax
c0000f35:	e8 f4 f4 ff ff       	call   c000042e <kprint_char>
c0000f3a:	83 c4 10             	add    $0x10,%esp
            nchar++;
c0000f3d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    while(f[0] != 0)
c0000f41:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000f44:	0f b6 00             	movzbl (%eax),%eax
c0000f47:	84 c0                	test   %al,%al
c0000f49:	0f 85 54 f5 ff ff    	jne    c00004a3 <kprintf+0x24>
    }

   /* clean memory reserved for valist */
   va_end(valist);

   return nchar; //number of characters copied to str
c0000f4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0000f52:	c9                   	leave  
c0000f53:	c3                   	ret    

c0000f54 <format_uint>:
// base may be 2-32
// precision is per printf format, precision<0 represents default (unspecified) 
// cap = 0, alpha-numbers are capitalized [base>10 only]
// returns length of string (not counting null termination)
int format_uint(unsigned int value, char* str, unsigned int base, int precision, int cap)
{
c0000f54:	55                   	push   %ebp
c0000f55:	89 e5                	mov    %esp,%ebp
c0000f57:	83 ec 18             	sub    $0x18,%esp
    if(base < 2 || base > 32)
c0000f5a:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c0000f5e:	76 06                	jbe    c0000f66 <format_uint+0x12>
c0000f60:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
c0000f64:	76 0a                	jbe    c0000f70 <format_uint+0x1c>
        return -1;
c0000f66:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000f6b:	e9 d1 00 00 00       	jmp    c0001041 <format_uint+0xed>

    //When 0 is printed with an explicit precision 0, the output is empty.
    if(value==0 && precision==0)
c0000f70:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0000f74:	75 16                	jne    c0000f8c <format_uint+0x38>
c0000f76:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c0000f7a:	75 10                	jne    c0000f8c <format_uint+0x38>
    {
        str[0] = 0;
c0000f7c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000f7f:	c6 00 00             	movb   $0x0,(%eax)
        return 0;
c0000f82:	b8 00 00 00 00       	mov    $0x0,%eax
c0000f87:	e9 b5 00 00 00       	jmp    c0001041 <format_uint+0xed>
    }

    // find number of digits
    int num_digits = numdigits_uint(value, base);
c0000f8c:	83 ec 08             	sub    $0x8,%esp
c0000f8f:	ff 75 10             	pushl  0x10(%ebp)
c0000f92:	ff 75 08             	pushl  0x8(%ebp)
c0000f95:	e8 a9 00 00 00       	call   c0001043 <numdigits_uint>
c0000f9a:	83 c4 10             	add    $0x10,%esp
c0000f9d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    num_digits = num_digits>precision ? num_digits : precision;
c0000fa0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0000fa3:	39 45 14             	cmp    %eax,0x14(%ebp)
c0000fa6:	0f 4d 45 14          	cmovge 0x14(%ebp),%eax
c0000faa:	89 45 ec             	mov    %eax,-0x14(%ebp)

    //write formatted number out in reverse order
    char* s = str + num_digits;
c0000fad:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0000fb0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000fb3:	01 d0                	add    %edx,%eax
c0000fb5:	89 45 f4             	mov    %eax,-0xc(%ebp)

    *(s--) = '\0'; //null termination
c0000fb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000fbb:	8d 50 ff             	lea    -0x1(%eax),%edx
c0000fbe:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0000fc1:	c6 00 00             	movb   $0x0,(%eax)

    //compute each digit from lowest to highest.
    unsigned int d;
    for(int nn=0;nn<num_digits; nn++)
c0000fc4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0000fcb:	eb 69                	jmp    c0001036 <format_uint+0xe2>
    {
        d = value % base;
c0000fcd:	8b 45 08             	mov    0x8(%ebp),%eax
c0000fd0:	ba 00 00 00 00       	mov    $0x0,%edx
c0000fd5:	f7 75 10             	divl   0x10(%ebp)
c0000fd8:	89 55 e8             	mov    %edx,-0x18(%ebp)
        value /= base;
c0000fdb:	8b 45 08             	mov    0x8(%ebp),%eax
c0000fde:	ba 00 00 00 00       	mov    $0x0,%edx
c0000fe3:	f7 75 10             	divl   0x10(%ebp)
c0000fe6:	89 45 08             	mov    %eax,0x8(%ebp)

        //write digit into string and decrement pointer
        if(d < 10)
c0000fe9:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
c0000fed:	77 15                	ja     c0001004 <format_uint+0xb0>
            *(s--) = d + '0';
c0000fef:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000ff2:	8d 48 30             	lea    0x30(%eax),%ecx
c0000ff5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000ff8:	8d 50 ff             	lea    -0x1(%eax),%edx
c0000ffb:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0000ffe:	89 ca                	mov    %ecx,%edx
c0001000:	88 10                	mov    %dl,(%eax)
c0001002:	eb 2e                	jmp    c0001032 <format_uint+0xde>
        else if(cap == 0)
c0001004:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
c0001008:	75 15                	jne    c000101f <format_uint+0xcb>
            *(s--) = d - 10 + 'a';
c000100a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000100d:	8d 48 57             	lea    0x57(%eax),%ecx
c0001010:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001013:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001016:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0001019:	89 ca                	mov    %ecx,%edx
c000101b:	88 10                	mov    %dl,(%eax)
c000101d:	eb 13                	jmp    c0001032 <format_uint+0xde>
        else
            *(s--) = d - 10 + 'A';
c000101f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001022:	8d 48 37             	lea    0x37(%eax),%ecx
c0001025:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001028:	8d 50 ff             	lea    -0x1(%eax),%edx
c000102b:	89 55 f4             	mov    %edx,-0xc(%ebp)
c000102e:	89 ca                	mov    %ecx,%edx
c0001030:	88 10                	mov    %dl,(%eax)
    for(int nn=0;nn<num_digits; nn++)
c0001032:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0001036:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001039:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c000103c:	7c 8f                	jl     c0000fcd <format_uint+0x79>
    }

    return num_digits;
c000103e:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c0001041:	c9                   	leave  
c0001042:	c3                   	ret    

c0001043 <numdigits_uint>:


//returns number of digits of unsigned int represented in given base
//num_digits is always >= 1
unsigned int numdigits_uint(unsigned int value, unsigned int base)
{
c0001043:	55                   	push   %ebp
c0001044:	89 e5                	mov    %esp,%ebp
c0001046:	83 ec 10             	sub    $0x10,%esp
    unsigned int num_digits = 1;
c0001049:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
    while(value >= base)
c0001050:	eb 12                	jmp    c0001064 <numdigits_uint+0x21>
    {
        num_digits++;
c0001052:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        value /= base;
c0001056:	8b 45 08             	mov    0x8(%ebp),%eax
c0001059:	ba 00 00 00 00       	mov    $0x0,%edx
c000105e:	f7 75 0c             	divl   0xc(%ebp)
c0001061:	89 45 08             	mov    %eax,0x8(%ebp)
    while(value >= base)
c0001064:	8b 45 08             	mov    0x8(%ebp),%eax
c0001067:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000106a:	73 e6                	jae    c0001052 <numdigits_uint+0xf>
    }
    return num_digits;
c000106c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c000106f:	c9                   	leave  
c0001070:	c3                   	ret    

c0001071 <kprintf_test>:



void kprintf_test()
{
c0001071:	55                   	push   %ebp
c0001072:	89 e5                	mov    %esp,%ebp
c0001074:	83 ec 18             	sub    $0x18,%esp
    int num = 12345678;    
c0001077:	c7 45 f4 4e 61 bc 00 	movl   $0xbc614e,-0xc(%ebp)
    kprintf("\nkprintf() tests...\n", num);
c000107e:	83 ec 08             	sub    $0x8,%esp
c0001081:	ff 75 f4             	pushl  -0xc(%ebp)
c0001084:	68 d0 41 00 c0       	push   $0xc00041d0
c0001089:	e8 f1 f3 ff ff       	call   c000047f <kprintf>
c000108e:	83 c4 10             	add    $0x10,%esp
    kprintf("Fixed width, right justify:\n");
c0001091:	83 ec 0c             	sub    $0xc,%esp
c0001094:	68 e5 41 00 c0       	push   $0xc00041e5
c0001099:	e8 e1 f3 ff ff       	call   c000047f <kprintf>
c000109e:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%15d]\n", num);
c00010a1:	83 ec 08             	sub    $0x8,%esp
c00010a4:	ff 75 f4             	pushl  -0xc(%ebp)
c00010a7:	68 02 42 00 c0       	push   $0xc0004202
c00010ac:	e8 ce f3 ff ff       	call   c000047f <kprintf>
c00010b1:	83 c4 10             	add    $0x10,%esp
    kprintf("Hex:     [%#15x]\n", num);
c00010b4:	83 ec 08             	sub    $0x8,%esp
c00010b7:	ff 75 f4             	pushl  -0xc(%ebp)
c00010ba:	68 13 42 00 c0       	push   $0xc0004213
c00010bf:	e8 bb f3 ff ff       	call   c000047f <kprintf>
c00010c4:	83 c4 10             	add    $0x10,%esp
    kprintf("Oct:     [%#15o]\n", num);
c00010c7:	83 ec 08             	sub    $0x8,%esp
c00010ca:	ff 75 f4             	pushl  -0xc(%ebp)
c00010cd:	68 25 42 00 c0       	push   $0xc0004225
c00010d2:	e8 a8 f3 ff ff       	call   c000047f <kprintf>
c00010d7:	83 c4 10             	add    $0x10,%esp
    kprintf("String:  [%15s]\n", "Hello World!");
c00010da:	83 ec 08             	sub    $0x8,%esp
c00010dd:	68 37 42 00 c0       	push   $0xc0004237
c00010e2:	68 44 42 00 c0       	push   $0xc0004244
c00010e7:	e8 93 f3 ff ff       	call   c000047f <kprintf>
c00010ec:	83 c4 10             	add    $0x10,%esp
    kprintf("Char:    [%15c]\n", '!');
c00010ef:	83 ec 08             	sub    $0x8,%esp
c00010f2:	6a 21                	push   $0x21
c00010f4:	68 55 42 00 c0       	push   $0xc0004255
c00010f9:	e8 81 f3 ff ff       	call   c000047f <kprintf>
c00010fe:	83 c4 10             	add    $0x10,%esp

    kprintf("\nFixed width, left justify:\n");
c0001101:	83 ec 0c             	sub    $0xc,%esp
c0001104:	68 66 42 00 c0       	push   $0xc0004266
c0001109:	e8 71 f3 ff ff       	call   c000047f <kprintf>
c000110e:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%-15d]\n", num);
c0001111:	83 ec 08             	sub    $0x8,%esp
c0001114:	ff 75 f4             	pushl  -0xc(%ebp)
c0001117:	68 83 42 00 c0       	push   $0xc0004283
c000111c:	e8 5e f3 ff ff       	call   c000047f <kprintf>
c0001121:	83 c4 10             	add    $0x10,%esp
    kprintf("Hex:     [%-#15x]\n", num);
c0001124:	83 ec 08             	sub    $0x8,%esp
c0001127:	ff 75 f4             	pushl  -0xc(%ebp)
c000112a:	68 95 42 00 c0       	push   $0xc0004295
c000112f:	e8 4b f3 ff ff       	call   c000047f <kprintf>
c0001134:	83 c4 10             	add    $0x10,%esp
    kprintf("String:  [%-15s]\n", "Hello World!");
c0001137:	83 ec 08             	sub    $0x8,%esp
c000113a:	68 37 42 00 c0       	push   $0xc0004237
c000113f:	68 a8 42 00 c0       	push   $0xc00042a8
c0001144:	e8 36 f3 ff ff       	call   c000047f <kprintf>
c0001149:	83 c4 10             	add    $0x10,%esp

    kprintf("\nFixed Precision:\n");
c000114c:	83 ec 0c             	sub    $0xc,%esp
c000114f:	68 ba 42 00 c0       	push   $0xc00042ba
c0001154:	e8 26 f3 ff ff       	call   c000047f <kprintf>
c0001159:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%15.10d]\nHex:     [%#15.10x]\nOct:     [%#15.10o]\nString:  [%15.10s]\n", 
c000115c:	83 ec 0c             	sub    $0xc,%esp
c000115f:	68 37 42 00 c0       	push   $0xc0004237
c0001164:	ff 75 f4             	pushl  -0xc(%ebp)
c0001167:	ff 75 f4             	pushl  -0xc(%ebp)
c000116a:	ff 75 f4             	pushl  -0xc(%ebp)
c000116d:	68 d0 42 00 c0       	push   $0xc00042d0
c0001172:	e8 08 f3 ff ff       	call   c000047f <kprintf>
c0001177:	83 c4 20             	add    $0x20,%esp
        num, num, num, "Hello World!");

    kprintf("\nLeading Zeros:\n");
c000117a:	83 ec 0c             	sub    $0xc,%esp
c000117d:	68 1f 43 00 c0       	push   $0xc000431f
c0001182:	e8 f8 f2 ff ff       	call   c000047f <kprintf>
c0001187:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%015.10d]\nHex:     [%#015.10x]\nOct:     [%#015.10o]\n",num, num, num);
c000118a:	ff 75 f4             	pushl  -0xc(%ebp)
c000118d:	ff 75 f4             	pushl  -0xc(%ebp)
c0001190:	ff 75 f4             	pushl  -0xc(%ebp)
c0001193:	68 30 43 00 c0       	push   $0xc0004330
c0001198:	e8 e2 f2 ff ff       	call   c000047f <kprintf>
c000119d:	83 c4 10             	add    $0x10,%esp

    kprintf("Signed (none):  [%d], [%d]\n",num, -num);
c00011a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00011a3:	f7 d8                	neg    %eax
c00011a5:	83 ec 04             	sub    $0x4,%esp
c00011a8:	50                   	push   %eax
c00011a9:	ff 75 f4             	pushl  -0xc(%ebp)
c00011ac:	68 6f 43 00 c0       	push   $0xc000436f
c00011b1:	e8 c9 f2 ff ff       	call   c000047f <kprintf>
c00011b6:	83 c4 10             	add    $0x10,%esp
    kprintf("Signed (space): [% d], [% d]\n",num, -num);
c00011b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00011bc:	f7 d8                	neg    %eax
c00011be:	83 ec 04             	sub    $0x4,%esp
c00011c1:	50                   	push   %eax
c00011c2:	ff 75 f4             	pushl  -0xc(%ebp)
c00011c5:	68 8b 43 00 c0       	push   $0xc000438b
c00011ca:	e8 b0 f2 ff ff       	call   c000047f <kprintf>
c00011cf:	83 c4 10             	add    $0x10,%esp
    kprintf("Signed (+):     [%+d], [%+d]\n",num, -num);
c00011d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00011d5:	f7 d8                	neg    %eax
c00011d7:	83 ec 04             	sub    $0x4,%esp
c00011da:	50                   	push   %eax
c00011db:	ff 75 f4             	pushl  -0xc(%ebp)
c00011de:	68 a9 43 00 c0       	push   $0xc00043a9
c00011e3:	e8 97 f2 ff ff       	call   c000047f <kprintf>
c00011e8:	83 c4 10             	add    $0x10,%esp

    float f = 1.23456789;
c00011eb:	d9 05 20 44 00 c0    	flds   0xc0004420
c00011f1:	d9 5d f0             	fstps  -0x10(%ebp)
    kprintf("\nfloat:     [%15.f]\n",f);
c00011f4:	d9 45 f0             	flds   -0x10(%ebp)
c00011f7:	83 ec 04             	sub    $0x4,%esp
c00011fa:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c00011fe:	dd 1c 24             	fstpl  (%esp)
c0001201:	68 c7 43 00 c0       	push   $0xc00043c7
c0001206:	e8 74 f2 ff ff       	call   c000047f <kprintf>
c000120b:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.3f]\n",f);
c000120e:	d9 45 f0             	flds   -0x10(%ebp)
c0001211:	83 ec 04             	sub    $0x4,%esp
c0001214:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001218:	dd 1c 24             	fstpl  (%esp)
c000121b:	68 dc 43 00 c0       	push   $0xc00043dc
c0001220:	e8 5a f2 ff ff       	call   c000047f <kprintf>
c0001225:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.10f]\n",f);
c0001228:	d9 45 f0             	flds   -0x10(%ebp)
c000122b:	83 ec 04             	sub    $0x4,%esp
c000122e:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001232:	dd 1c 24             	fstpl  (%esp)
c0001235:	68 f1 43 00 c0       	push   $0xc00043f1
c000123a:	e8 40 f2 ff ff       	call   c000047f <kprintf>
c000123f:	83 c4 10             	add    $0x10,%esp

    f = -12345.6789;
c0001242:	d9 05 24 44 00 c0    	flds   0xc0004424
c0001248:	d9 5d f0             	fstps  -0x10(%ebp)
    kprintf("float:     [%15f]\n",f);
c000124b:	d9 45 f0             	flds   -0x10(%ebp)
c000124e:	83 ec 04             	sub    $0x4,%esp
c0001251:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001255:	dd 1c 24             	fstpl  (%esp)
c0001258:	68 07 44 00 c0       	push   $0xc0004407
c000125d:	e8 1d f2 ff ff       	call   c000047f <kprintf>
c0001262:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.3f]\n",f);
c0001265:	d9 45 f0             	flds   -0x10(%ebp)
c0001268:	83 ec 04             	sub    $0x4,%esp
c000126b:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c000126f:	dd 1c 24             	fstpl  (%esp)
c0001272:	68 dc 43 00 c0       	push   $0xc00043dc
c0001277:	e8 03 f2 ff ff       	call   c000047f <kprintf>
c000127c:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.10f]\n",f);
c000127f:	d9 45 f0             	flds   -0x10(%ebp)
c0001282:	83 ec 04             	sub    $0x4,%esp
c0001285:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001289:	dd 1c 24             	fstpl  (%esp)
c000128c:	68 f1 43 00 c0       	push   $0xc00043f1
c0001291:	e8 e9 f1 ff ff       	call   c000047f <kprintf>
c0001296:	83 c4 10             	add    $0x10,%esp
}
c0001299:	90                   	nop
c000129a:	c9                   	leave  
c000129b:	c3                   	ret    

c000129c <panic>:
#include "common.h"
#include "kprintf.h"

void panic(char* str)
{
c000129c:	55                   	push   %ebp
c000129d:	89 e5                	mov    %esp,%ebp
c000129f:	83 ec 08             	sub    $0x8,%esp
    kprintf(str);
c00012a2:	83 ec 0c             	sub    $0xc,%esp
c00012a5:	ff 75 08             	pushl  0x8(%ebp)
c00012a8:	e8 d2 f1 ff ff       	call   c000047f <kprintf>
c00012ad:	83 c4 10             	add    $0x10,%esp
    while(1);
c00012b0:	eb fe                	jmp    c00012b0 <panic+0x14>

c00012b2 <strlen>:
}

size_t strlen(const char* str) 
{
c00012b2:	55                   	push   %ebp
c00012b3:	89 e5                	mov    %esp,%ebp
c00012b5:	83 ec 10             	sub    $0x10,%esp
	size_t len = 0;
c00012b8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while (str[len])
c00012bf:	eb 04                	jmp    c00012c5 <strlen+0x13>
		len++;
c00012c1:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
	while (str[len])
c00012c5:	8b 55 08             	mov    0x8(%ebp),%edx
c00012c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00012cb:	01 d0                	add    %edx,%eax
c00012cd:	0f b6 00             	movzbl (%eax),%eax
c00012d0:	84 c0                	test   %al,%al
c00012d2:	75 ed                	jne    c00012c1 <strlen+0xf>
	return len;
c00012d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00012d7:	c9                   	leave  
c00012d8:	c3                   	ret    

c00012d9 <memcpy>:

// copy n bytes from src to dest
void *memcpy(void *dest, const void *src, size_t n)
{
c00012d9:	55                   	push   %ebp
c00012da:	89 e5                	mov    %esp,%ebp
c00012dc:	83 ec 20             	sub    $0x20,%esp
    //system wordsize is equal to length of size_t
    size_t n_words = n/sizeof(size_t);
c00012df:	8b 45 10             	mov    0x10(%ebp),%eax
c00012e2:	c1 e8 02             	shr    $0x2,%eax
c00012e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t* dest_word = (size_t *) dest;
c00012e8:	8b 45 08             	mov    0x8(%ebp),%eax
c00012eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    size_t* src_word = (size_t *) src;
c00012ee:	8b 45 0c             	mov    0xc(%ebp),%eax
c00012f1:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for(size_t nn=0; nn<n_words; nn++)
c00012f4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00012fb:	eb 26                	jmp    c0001323 <memcpy+0x4a>
        dest_word[nn]=src_word[nn];
c00012fd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001300:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0001307:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000130a:	01 d0                	add    %edx,%eax
c000130c:	8b 55 fc             	mov    -0x4(%ebp),%edx
c000130f:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
c0001316:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001319:	01 ca                	add    %ecx,%edx
c000131b:	8b 00                	mov    (%eax),%eax
c000131d:	89 02                	mov    %eax,(%edx)
    for(size_t nn=0; nn<n_words; nn++)
c000131f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0001323:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001326:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0001329:	72 d2                	jb     c00012fd <memcpy+0x24>
    
    //copy remaining bytes
    size_t n_bytes = n - n_words*sizeof(size_t);
c000132b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000132e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0001335:	8b 45 10             	mov    0x10(%ebp),%eax
c0001338:	29 d0                	sub    %edx,%eax
c000133a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(n_bytes > 0)
c000133d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0001341:	74 36                	je     c0001379 <memcpy+0xa0>
    {
        char* dest_byte = (char *) dest;
c0001343:	8b 45 08             	mov    0x8(%ebp),%eax
c0001346:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        char* src_byte = (char *) src;
c0001349:	8b 45 0c             	mov    0xc(%ebp),%eax
c000134c:	89 45 e0             	mov    %eax,-0x20(%ebp)
        for(size_t nn=0; nn<n_bytes; nn++)
c000134f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0001356:	eb 19                	jmp    c0001371 <memcpy+0x98>
            dest_byte[nn]=src_byte[nn];
c0001358:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000135b:	8b 45 f8             	mov    -0x8(%ebp),%eax
c000135e:	01 d0                	add    %edx,%eax
c0001360:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c0001363:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0001366:	01 ca                	add    %ecx,%edx
c0001368:	0f b6 00             	movzbl (%eax),%eax
c000136b:	88 02                	mov    %al,(%edx)
        for(size_t nn=0; nn<n_bytes; nn++)
c000136d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0001371:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0001374:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0001377:	72 df                	jb     c0001358 <memcpy+0x7f>
    }

    return dest;
c0001379:	8b 45 08             	mov    0x8(%ebp),%eax
}
c000137c:	c9                   	leave  
c000137d:	c3                   	ret    

c000137e <memset>:

void* memset(void* addr, int val, size_t cnt)
{
c000137e:	55                   	push   %ebp
c000137f:	89 e5                	mov    %esp,%ebp
c0001381:	83 ec 10             	sub    $0x10,%esp
    char* m = (char*) addr;
c0001384:	8b 45 08             	mov    0x8(%ebp),%eax
c0001387:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for(size_t nn=0;nn<cnt; nn++)
c000138a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0001391:	eb 11                	jmp    c00013a4 <memset+0x26>
        m[nn] = val;
c0001393:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0001396:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001399:	01 d0                	add    %edx,%eax
c000139b:	8b 55 0c             	mov    0xc(%ebp),%edx
c000139e:	88 10                	mov    %dl,(%eax)
    for(size_t nn=0;nn<cnt; nn++)
c00013a0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c00013a4:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00013a7:	3b 45 10             	cmp    0x10(%ebp),%eax
c00013aa:	72 e7                	jb     c0001393 <memset+0x15>

    return addr;
c00013ac:	8b 45 08             	mov    0x8(%ebp),%eax
}
c00013af:	c9                   	leave  
c00013b0:	c3                   	ret    

c00013b1 <atoi>:


int atoi(const char* str)
{
c00013b1:	55                   	push   %ebp
c00013b2:	89 e5                	mov    %esp,%ebp
c00013b4:	83 ec 20             	sub    $0x20,%esp
    int p = 0;
c00013b7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    int neg = 0;
c00013be:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    //find start of number string, ignore whitespace
    while(str[p] == '-' || str[p] == ' ' || (str[p] >= 9 && str[p] <= 13))
c00013c5:	eb 41                	jmp    c0001408 <atoi+0x57>
    {
        if(str[p++] == '-')
c00013c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00013ca:	8d 50 01             	lea    0x1(%eax),%edx
c00013cd:	89 55 fc             	mov    %edx,-0x4(%ebp)
c00013d0:	89 c2                	mov    %eax,%edx
c00013d2:	8b 45 08             	mov    0x8(%ebp),%eax
c00013d5:	01 d0                	add    %edx,%eax
c00013d7:	0f b6 00             	movzbl (%eax),%eax
c00013da:	3c 2d                	cmp    $0x2d,%al
c00013dc:	75 09                	jne    c00013e7 <atoi+0x36>
        {
            neg=1;
c00013de:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
            break;
c00013e5:	eb 5d                	jmp    c0001444 <atoi+0x93>
        }
        if(str[p++] == '\0')
c00013e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00013ea:	8d 50 01             	lea    0x1(%eax),%edx
c00013ed:	89 55 fc             	mov    %edx,-0x4(%ebp)
c00013f0:	89 c2                	mov    %eax,%edx
c00013f2:	8b 45 08             	mov    0x8(%ebp),%eax
c00013f5:	01 d0                	add    %edx,%eax
c00013f7:	0f b6 00             	movzbl (%eax),%eax
c00013fa:	84 c0                	test   %al,%al
c00013fc:	75 0a                	jne    c0001408 <atoi+0x57>
            return 0; //invalid string (only whitespace found)
c00013fe:	b8 00 00 00 00       	mov    $0x0,%eax
c0001403:	e9 ee 00 00 00       	jmp    c00014f6 <atoi+0x145>
    while(str[p] == '-' || str[p] == ' ' || (str[p] >= 9 && str[p] <= 13))
c0001408:	8b 55 fc             	mov    -0x4(%ebp),%edx
c000140b:	8b 45 08             	mov    0x8(%ebp),%eax
c000140e:	01 d0                	add    %edx,%eax
c0001410:	0f b6 00             	movzbl (%eax),%eax
c0001413:	3c 2d                	cmp    $0x2d,%al
c0001415:	74 b0                	je     c00013c7 <atoi+0x16>
c0001417:	8b 55 fc             	mov    -0x4(%ebp),%edx
c000141a:	8b 45 08             	mov    0x8(%ebp),%eax
c000141d:	01 d0                	add    %edx,%eax
c000141f:	0f b6 00             	movzbl (%eax),%eax
c0001422:	3c 20                	cmp    $0x20,%al
c0001424:	74 a1                	je     c00013c7 <atoi+0x16>
c0001426:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0001429:	8b 45 08             	mov    0x8(%ebp),%eax
c000142c:	01 d0                	add    %edx,%eax
c000142e:	0f b6 00             	movzbl (%eax),%eax
c0001431:	3c 08                	cmp    $0x8,%al
c0001433:	7e 0f                	jle    c0001444 <atoi+0x93>
c0001435:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0001438:	8b 45 08             	mov    0x8(%ebp),%eax
c000143b:	01 d0                	add    %edx,%eax
c000143d:	0f b6 00             	movzbl (%eax),%eax
c0001440:	3c 0d                	cmp    $0xd,%al
c0001442:	7e 83                	jle    c00013c7 <atoi+0x16>
    }

    int num_start = p;
c0001444:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001447:	89 45 e8             	mov    %eax,-0x18(%ebp)

    //find end of integer string (ints only, no decimal point)
    while(str[p] >= '0' && str[p] <= '9')
c000144a:	eb 21                	jmp    c000146d <atoi+0xbc>
    {
        if(str[p++] == '\0')
c000144c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000144f:	8d 50 01             	lea    0x1(%eax),%edx
c0001452:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001455:	89 c2                	mov    %eax,%edx
c0001457:	8b 45 08             	mov    0x8(%ebp),%eax
c000145a:	01 d0                	add    %edx,%eax
c000145c:	0f b6 00             	movzbl (%eax),%eax
c000145f:	84 c0                	test   %al,%al
c0001461:	75 0a                	jne    c000146d <atoi+0xbc>
            return 0; //invalid string (only whitespace found)
c0001463:	b8 00 00 00 00       	mov    $0x0,%eax
c0001468:	e9 89 00 00 00       	jmp    c00014f6 <atoi+0x145>
    while(str[p] >= '0' && str[p] <= '9')
c000146d:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0001470:	8b 45 08             	mov    0x8(%ebp),%eax
c0001473:	01 d0                	add    %edx,%eax
c0001475:	0f b6 00             	movzbl (%eax),%eax
c0001478:	3c 2f                	cmp    $0x2f,%al
c000147a:	7e 0f                	jle    c000148b <atoi+0xda>
c000147c:	8b 55 fc             	mov    -0x4(%ebp),%edx
c000147f:	8b 45 08             	mov    0x8(%ebp),%eax
c0001482:	01 d0                	add    %edx,%eax
c0001484:	0f b6 00             	movzbl (%eax),%eax
c0001487:	3c 39                	cmp    $0x39,%al
c0001489:	7e c1                	jle    c000144c <atoi+0x9b>
    }

    if(num_start == p) return 0; //length 0 string
c000148b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000148e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c0001491:	75 07                	jne    c000149a <atoi+0xe9>
c0001493:	b8 00 00 00 00       	mov    $0x0,%eax
c0001498:	eb 5c                	jmp    c00014f6 <atoi+0x145>

    int number = 0;
c000149a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    int place = 1;
c00014a1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    //iterate backwards through number to add each digit
    for(int digit = p-1; digit >= num_start; digit--)
c00014a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00014ab:	83 e8 01             	sub    $0x1,%eax
c00014ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
c00014b1:	eb 2b                	jmp    c00014de <atoi+0x12d>
    {
        number += (int) (str[digit] - '0') * place;
c00014b3:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00014b6:	8b 45 08             	mov    0x8(%ebp),%eax
c00014b9:	01 d0                	add    %edx,%eax
c00014bb:	0f b6 00             	movzbl (%eax),%eax
c00014be:	0f be c0             	movsbl %al,%eax
c00014c1:	83 e8 30             	sub    $0x30,%eax
c00014c4:	0f af 45 f0          	imul   -0x10(%ebp),%eax
c00014c8:	01 45 f4             	add    %eax,-0xc(%ebp)
        place *= 10;
c00014cb:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00014ce:	89 d0                	mov    %edx,%eax
c00014d0:	c1 e0 02             	shl    $0x2,%eax
c00014d3:	01 d0                	add    %edx,%eax
c00014d5:	01 c0                	add    %eax,%eax
c00014d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for(int digit = p-1; digit >= num_start; digit--)
c00014da:	83 6d ec 01          	subl   $0x1,-0x14(%ebp)
c00014de:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00014e1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c00014e4:	7d cd                	jge    c00014b3 <atoi+0x102>
    }

    if(neg)
c00014e6:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c00014ea:	74 07                	je     c00014f3 <atoi+0x142>
        return -1*number;
c00014ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00014ef:	f7 d8                	neg    %eax
c00014f1:	eb 03                	jmp    c00014f6 <atoi+0x145>
    else
        return number;
c00014f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00014f6:	c9                   	leave  
c00014f7:	c3                   	ret    

c00014f8 <itoa>:

char* itoa( int value, char* str, int base)
{
c00014f8:	55                   	push   %ebp
c00014f9:	89 e5                	mov    %esp,%ebp
c00014fb:	83 ec 20             	sub    $0x20,%esp
    if(base < 2 || base > 32)
c00014fe:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c0001502:	7e 06                	jle    c000150a <itoa+0x12>
c0001504:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
c0001508:	7e 0a                	jle    c0001514 <itoa+0x1c>
        return NULL;
c000150a:	b8 00 00 00 00       	mov    $0x0,%eax
c000150f:	e9 df 00 00 00       	jmp    c00015f3 <itoa+0xfb>

    //handle zero as special case 
    if(value == 0)
c0001514:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0001518:	75 17                	jne    c0001531 <itoa+0x39>
    {
        str[0] = '0';
c000151a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000151d:	c6 00 30             	movb   $0x30,(%eax)
        str[1] = '\0';
c0001520:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001523:	83 c0 01             	add    $0x1,%eax
c0001526:	c6 00 00             	movb   $0x0,(%eax)
        return str;
c0001529:	8b 45 0c             	mov    0xc(%ebp),%eax
c000152c:	e9 c2 00 00 00       	jmp    c00015f3 <itoa+0xfb>
    }

    char* s = str;
c0001531:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001534:	89 45 fc             	mov    %eax,-0x4(%ebp)
    unsigned int residual; //holds the unsigned value still to be parsed
    if(base == 10 && value < 0)
c0001537:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
c000153b:	75 1c                	jne    c0001559 <itoa+0x61>
c000153d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0001541:	79 16                	jns    c0001559 <itoa+0x61>
    {
        residual = -value;
c0001543:	8b 45 08             	mov    0x8(%ebp),%eax
c0001546:	f7 d8                	neg    %eax
c0001548:	89 45 f8             	mov    %eax,-0x8(%ebp)
        *(s++) = '-';
c000154b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000154e:	8d 50 01             	lea    0x1(%eax),%edx
c0001551:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001554:	c6 00 2d             	movb   $0x2d,(%eax)
c0001557:	eb 06                	jmp    c000155f <itoa+0x67>
    }
    else
    {
        //all non-decimal numbers are treated as unsigned
        residual = (unsigned int) value;
c0001559:	8b 45 08             	mov    0x8(%ebp),%eax
c000155c:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    
    // find number of digits so that we can parse number
    // directly into string from lowest to highest digit    
    unsigned int num_digits = 0;
c000155f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    unsigned int temp = residual;
c0001566:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0001569:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(temp>0)
c000156c:	eb 14                	jmp    c0001582 <itoa+0x8a>
    {
        num_digits++;
c000156e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
        temp /= base;
c0001572:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0001575:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001578:	ba 00 00 00 00       	mov    $0x0,%edx
c000157d:	f7 f1                	div    %ecx
c000157f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(temp>0)
c0001582:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0001586:	75 e6                	jne    c000156e <itoa+0x76>
    }

    //point at end of string
    s += num_digits;
c0001588:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000158b:	01 45 fc             	add    %eax,-0x4(%ebp)
    *(s--) = '\0'; //null termination
c000158e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001591:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001594:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001597:	c6 00 00             	movb   $0x0,(%eax)

    //compute each digit from lowest to highest.
    unsigned int digit;
    while(residual>0)
c000159a:	eb 4e                	jmp    c00015ea <itoa+0xf2>
    {
        digit = residual % base;
c000159c:	8b 4d 10             	mov    0x10(%ebp),%ecx
c000159f:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00015a2:	ba 00 00 00 00       	mov    $0x0,%edx
c00015a7:	f7 f1                	div    %ecx
c00015a9:	89 55 ec             	mov    %edx,-0x14(%ebp)
        residual /= base;
c00015ac:	8b 4d 10             	mov    0x10(%ebp),%ecx
c00015af:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00015b2:	ba 00 00 00 00       	mov    $0x0,%edx
c00015b7:	f7 f1                	div    %ecx
c00015b9:	89 45 f8             	mov    %eax,-0x8(%ebp)

        //write digit into string and decrement pointer
        if(digit < 10)
c00015bc:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
c00015c0:	77 15                	ja     c00015d7 <itoa+0xdf>
            *(s--) = digit + '0';
c00015c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00015c5:	8d 48 30             	lea    0x30(%eax),%ecx
c00015c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00015cb:	8d 50 ff             	lea    -0x1(%eax),%edx
c00015ce:	89 55 fc             	mov    %edx,-0x4(%ebp)
c00015d1:	89 ca                	mov    %ecx,%edx
c00015d3:	88 10                	mov    %dl,(%eax)
c00015d5:	eb 13                	jmp    c00015ea <itoa+0xf2>
        else
            *(s--) = digit - 10 + 'A';        
c00015d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00015da:	8d 48 37             	lea    0x37(%eax),%ecx
c00015dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00015e0:	8d 50 ff             	lea    -0x1(%eax),%edx
c00015e3:	89 55 fc             	mov    %edx,-0x4(%ebp)
c00015e6:	89 ca                	mov    %ecx,%edx
c00015e8:	88 10                	mov    %dl,(%eax)
    while(residual>0)
c00015ea:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c00015ee:	75 ac                	jne    c000159c <itoa+0xa4>
    }

    return str;
c00015f0:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c00015f3:	c9                   	leave  
c00015f4:	c3                   	ret    

c00015f5 <printregs>:
#include "regs.h"
#include "kprintf.h"

void printregs(const reg_t* regs)
{
c00015f5:	55                   	push   %ebp
c00015f6:	89 e5                	mov    %esp,%ebp
c00015f8:	57                   	push   %edi
c00015f9:	56                   	push   %esi
c00015fa:	53                   	push   %ebx
c00015fb:	83 ec 0c             	sub    $0xc,%esp
    kprintf("Registers:\n");
c00015fe:	83 ec 0c             	sub    $0xc,%esp
c0001601:	68 28 44 00 c0       	push   $0xc0004428
c0001606:	e8 74 ee ff ff       	call   c000047f <kprintf>
c000160b:	83 c4 10             	add    $0x10,%esp
    kprintf("eax: 0x%x\n", regs->eax);
c000160e:	8b 45 08             	mov    0x8(%ebp),%eax
c0001611:	8b 00                	mov    (%eax),%eax
c0001613:	83 ec 08             	sub    $0x8,%esp
c0001616:	50                   	push   %eax
c0001617:	68 34 44 00 c0       	push   $0xc0004434
c000161c:	e8 5e ee ff ff       	call   c000047f <kprintf>
c0001621:	83 c4 10             	add    $0x10,%esp
    kprintf("ebx: 0x%x\n", regs->ebx);
c0001624:	8b 45 08             	mov    0x8(%ebp),%eax
c0001627:	8b 40 04             	mov    0x4(%eax),%eax
c000162a:	83 ec 08             	sub    $0x8,%esp
c000162d:	50                   	push   %eax
c000162e:	68 3f 44 00 c0       	push   $0xc000443f
c0001633:	e8 47 ee ff ff       	call   c000047f <kprintf>
c0001638:	83 c4 10             	add    $0x10,%esp
    kprintf("ecx: 0x%x\n", regs->ecx);
c000163b:	8b 45 08             	mov    0x8(%ebp),%eax
c000163e:	8b 40 08             	mov    0x8(%eax),%eax
c0001641:	83 ec 08             	sub    $0x8,%esp
c0001644:	50                   	push   %eax
c0001645:	68 4a 44 00 c0       	push   $0xc000444a
c000164a:	e8 30 ee ff ff       	call   c000047f <kprintf>
c000164f:	83 c4 10             	add    $0x10,%esp
    kprintf("edx: 0x%x\n", regs->edx);
c0001652:	8b 45 08             	mov    0x8(%ebp),%eax
c0001655:	8b 40 0c             	mov    0xc(%eax),%eax
c0001658:	83 ec 08             	sub    $0x8,%esp
c000165b:	50                   	push   %eax
c000165c:	68 55 44 00 c0       	push   $0xc0004455
c0001661:	e8 19 ee ff ff       	call   c000047f <kprintf>
c0001666:	83 c4 10             	add    $0x10,%esp
    kprintf("esi: 0x%x\n", regs->esi);
c0001669:	8b 45 08             	mov    0x8(%ebp),%eax
c000166c:	8b 40 10             	mov    0x10(%eax),%eax
c000166f:	83 ec 08             	sub    $0x8,%esp
c0001672:	50                   	push   %eax
c0001673:	68 60 44 00 c0       	push   $0xc0004460
c0001678:	e8 02 ee ff ff       	call   c000047f <kprintf>
c000167d:	83 c4 10             	add    $0x10,%esp
    kprintf("edi: 0x%x\n", regs->edi);
c0001680:	8b 45 08             	mov    0x8(%ebp),%eax
c0001683:	8b 40 14             	mov    0x14(%eax),%eax
c0001686:	83 ec 08             	sub    $0x8,%esp
c0001689:	50                   	push   %eax
c000168a:	68 6b 44 00 c0       	push   $0xc000446b
c000168f:	e8 eb ed ff ff       	call   c000047f <kprintf>
c0001694:	83 c4 10             	add    $0x10,%esp
    kprintf("ebp: 0x%x\n", regs->ebp);
c0001697:	8b 45 08             	mov    0x8(%ebp),%eax
c000169a:	8b 40 1c             	mov    0x1c(%eax),%eax
c000169d:	83 ec 08             	sub    $0x8,%esp
c00016a0:	50                   	push   %eax
c00016a1:	68 76 44 00 c0       	push   $0xc0004476
c00016a6:	e8 d4 ed ff ff       	call   c000047f <kprintf>
c00016ab:	83 c4 10             	add    $0x10,%esp
    kprintf("esp: 0x%x\n", regs->esp);
c00016ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00016b1:	8b 40 18             	mov    0x18(%eax),%eax
c00016b4:	83 ec 08             	sub    $0x8,%esp
c00016b7:	50                   	push   %eax
c00016b8:	68 81 44 00 c0       	push   $0xc0004481
c00016bd:	e8 bd ed ff ff       	call   c000047f <kprintf>
c00016c2:	83 c4 10             	add    $0x10,%esp
    kprintf("eip: 0x%x\n", regs->eip);
c00016c5:	8b 45 08             	mov    0x8(%ebp),%eax
c00016c8:	8b 40 20             	mov    0x20(%eax),%eax
c00016cb:	83 ec 08             	sub    $0x8,%esp
c00016ce:	50                   	push   %eax
c00016cf:	68 8c 44 00 c0       	push   $0xc000448c
c00016d4:	e8 a6 ed ff ff       	call   c000047f <kprintf>
c00016d9:	83 c4 10             	add    $0x10,%esp
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
                                                            (regs->eflags&EFLAGS_PF) == EFLAGS_PF,
                                                            (regs->eflags&EFLAGS_AF) == EFLAGS_AF,
                                                            (regs->eflags&EFLAGS_ZF) == EFLAGS_ZF,
                                                            (regs->eflags&EFLAGS_SF) == EFLAGS_SF,
                                                            (regs->eflags&EFLAGS_TF) == EFLAGS_TF);
c00016dc:	8b 45 08             	mov    0x8(%ebp),%eax
c00016df:	8b 40 24             	mov    0x24(%eax),%eax
c00016e2:	25 00 01 00 00       	and    $0x100,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c00016e7:	85 c0                	test   %eax,%eax
c00016e9:	0f 95 c0             	setne  %al
c00016ec:	0f b6 f8             	movzbl %al,%edi
                                                            (regs->eflags&EFLAGS_SF) == EFLAGS_SF,
c00016ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00016f2:	8b 40 24             	mov    0x24(%eax),%eax
c00016f5:	25 80 00 00 00       	and    $0x80,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c00016fa:	85 c0                	test   %eax,%eax
c00016fc:	0f 95 c0             	setne  %al
c00016ff:	0f b6 f0             	movzbl %al,%esi
                                                            (regs->eflags&EFLAGS_ZF) == EFLAGS_ZF,
c0001702:	8b 45 08             	mov    0x8(%ebp),%eax
c0001705:	8b 40 24             	mov    0x24(%eax),%eax
c0001708:	83 e0 40             	and    $0x40,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c000170b:	85 c0                	test   %eax,%eax
c000170d:	0f 95 c0             	setne  %al
c0001710:	0f b6 d8             	movzbl %al,%ebx
                                                            (regs->eflags&EFLAGS_AF) == EFLAGS_AF,
c0001713:	8b 45 08             	mov    0x8(%ebp),%eax
c0001716:	8b 40 24             	mov    0x24(%eax),%eax
c0001719:	83 e0 10             	and    $0x10,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c000171c:	85 c0                	test   %eax,%eax
c000171e:	0f 95 c0             	setne  %al
c0001721:	0f b6 c8             	movzbl %al,%ecx
                                                            (regs->eflags&EFLAGS_PF) == EFLAGS_PF,
c0001724:	8b 45 08             	mov    0x8(%ebp),%eax
c0001727:	8b 40 24             	mov    0x24(%eax),%eax
c000172a:	83 e0 04             	and    $0x4,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c000172d:	85 c0                	test   %eax,%eax
c000172f:	0f 95 c0             	setne  %al
c0001732:	0f b6 d0             	movzbl %al,%edx
c0001735:	8b 45 08             	mov    0x8(%ebp),%eax
c0001738:	8b 40 24             	mov    0x24(%eax),%eax
c000173b:	83 e0 01             	and    $0x1,%eax
c000173e:	85 c0                	test   %eax,%eax
c0001740:	0f 95 c0             	setne  %al
c0001743:	0f b6 c0             	movzbl %al,%eax
c0001746:	83 ec 04             	sub    $0x4,%esp
c0001749:	57                   	push   %edi
c000174a:	56                   	push   %esi
c000174b:	53                   	push   %ebx
c000174c:	51                   	push   %ecx
c000174d:	52                   	push   %edx
c000174e:	50                   	push   %eax
c000174f:	68 98 44 00 c0       	push   $0xc0004498
c0001754:	e8 26 ed ff ff       	call   c000047f <kprintf>
c0001759:	83 c4 20             	add    $0x20,%esp
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
                                                            (regs->eflags&EFLAGS_DF) == EFLAGS_DF,
                                                            (regs->eflags&EFLAGS_OF) == EFLAGS_OF,
                                                            (regs->eflags&EFLAGS_IOPL) >> 12,
                                                            (regs->eflags&EFLAGS_NT) == EFLAGS_NT,
                                                            (regs->eflags&EFLAGS_RF) == EFLAGS_RF);
c000175c:	8b 45 08             	mov    0x8(%ebp),%eax
c000175f:	8b 40 24             	mov    0x24(%eax),%eax
c0001762:	25 00 00 01 00       	and    $0x10000,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001767:	85 c0                	test   %eax,%eax
c0001769:	0f 95 c0             	setne  %al
c000176c:	0f b6 f0             	movzbl %al,%esi
                                                            (regs->eflags&EFLAGS_NT) == EFLAGS_NT,
c000176f:	8b 45 08             	mov    0x8(%ebp),%eax
c0001772:	8b 40 24             	mov    0x24(%eax),%eax
c0001775:	25 00 40 00 00       	and    $0x4000,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c000177a:	85 c0                	test   %eax,%eax
c000177c:	0f 95 c0             	setne  %al
c000177f:	0f b6 d8             	movzbl %al,%ebx
                                                            (regs->eflags&EFLAGS_IOPL) >> 12,
c0001782:	8b 45 08             	mov    0x8(%ebp),%eax
c0001785:	8b 40 24             	mov    0x24(%eax),%eax
c0001788:	c1 e8 0c             	shr    $0xc,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c000178b:	83 e0 03             	and    $0x3,%eax
c000178e:	89 c7                	mov    %eax,%edi
                                                            (regs->eflags&EFLAGS_OF) == EFLAGS_OF,
c0001790:	8b 45 08             	mov    0x8(%ebp),%eax
c0001793:	8b 40 24             	mov    0x24(%eax),%eax
c0001796:	25 00 08 00 00       	and    $0x800,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c000179b:	85 c0                	test   %eax,%eax
c000179d:	0f 95 c0             	setne  %al
c00017a0:	0f b6 c8             	movzbl %al,%ecx
                                                            (regs->eflags&EFLAGS_DF) == EFLAGS_DF,
c00017a3:	8b 45 08             	mov    0x8(%ebp),%eax
c00017a6:	8b 40 24             	mov    0x24(%eax),%eax
c00017a9:	25 00 04 00 00       	and    $0x400,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c00017ae:	85 c0                	test   %eax,%eax
c00017b0:	0f 95 c0             	setne  %al
c00017b3:	0f b6 d0             	movzbl %al,%edx
c00017b6:	8b 45 08             	mov    0x8(%ebp),%eax
c00017b9:	8b 40 24             	mov    0x24(%eax),%eax
c00017bc:	25 00 02 00 00       	and    $0x200,%eax
c00017c1:	85 c0                	test   %eax,%eax
c00017c3:	0f 95 c0             	setne  %al
c00017c6:	0f b6 c0             	movzbl %al,%eax
c00017c9:	83 ec 04             	sub    $0x4,%esp
c00017cc:	56                   	push   %esi
c00017cd:	53                   	push   %ebx
c00017ce:	57                   	push   %edi
c00017cf:	51                   	push   %ecx
c00017d0:	52                   	push   %edx
c00017d1:	50                   	push   %eax
c00017d2:	68 c8 44 00 c0       	push   $0xc00044c8
c00017d7:	e8 a3 ec ff ff       	call   c000047f <kprintf>
c00017dc:	83 c4 20             	add    $0x20,%esp
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
                                                            (regs->eflags&EFLAGS_AC) == EFLAGS_AC,
                                                            (regs->eflags&EFLAGS_VIF) == EFLAGS_VIF,
                                                            (regs->eflags&EFLAGS_VIP) == EFLAGS_VIP,
                                                            (regs->eflags&EFLAGS_ID) == EFLAGS_ID);
c00017df:	8b 45 08             	mov    0x8(%ebp),%eax
c00017e2:	8b 40 24             	mov    0x24(%eax),%eax
c00017e5:	25 00 00 20 00       	and    $0x200000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c00017ea:	85 c0                	test   %eax,%eax
c00017ec:	0f 95 c0             	setne  %al
c00017ef:	0f b6 f0             	movzbl %al,%esi
                                                            (regs->eflags&EFLAGS_VIP) == EFLAGS_VIP,
c00017f2:	8b 45 08             	mov    0x8(%ebp),%eax
c00017f5:	8b 40 24             	mov    0x24(%eax),%eax
c00017f8:	25 00 00 10 00       	and    $0x100000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c00017fd:	85 c0                	test   %eax,%eax
c00017ff:	0f 95 c0             	setne  %al
c0001802:	0f b6 d8             	movzbl %al,%ebx
                                                            (regs->eflags&EFLAGS_VIF) == EFLAGS_VIF,
c0001805:	8b 45 08             	mov    0x8(%ebp),%eax
c0001808:	8b 40 24             	mov    0x24(%eax),%eax
c000180b:	25 00 00 08 00       	and    $0x80000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c0001810:	85 c0                	test   %eax,%eax
c0001812:	0f 95 c0             	setne  %al
c0001815:	0f b6 c8             	movzbl %al,%ecx
                                                            (regs->eflags&EFLAGS_AC) == EFLAGS_AC,
c0001818:	8b 45 08             	mov    0x8(%ebp),%eax
c000181b:	8b 40 24             	mov    0x24(%eax),%eax
c000181e:	25 00 00 04 00       	and    $0x40000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c0001823:	85 c0                	test   %eax,%eax
c0001825:	0f 95 c0             	setne  %al
c0001828:	0f b6 d0             	movzbl %al,%edx
c000182b:	8b 45 08             	mov    0x8(%ebp),%eax
c000182e:	8b 40 24             	mov    0x24(%eax),%eax
c0001831:	25 00 00 02 00       	and    $0x20000,%eax
c0001836:	85 c0                	test   %eax,%eax
c0001838:	0f 95 c0             	setne  %al
c000183b:	0f b6 c0             	movzbl %al,%eax
c000183e:	83 ec 08             	sub    $0x8,%esp
c0001841:	56                   	push   %esi
c0001842:	53                   	push   %ebx
c0001843:	51                   	push   %ecx
c0001844:	52                   	push   %edx
c0001845:	50                   	push   %eax
c0001846:	68 f8 44 00 c0       	push   $0xc00044f8
c000184b:	e8 2f ec ff ff       	call   c000047f <kprintf>
c0001850:	83 c4 20             	add    $0x20,%esp
    kprintf("cr0: 0x%x\n", regs->cr0);
c0001853:	8b 45 08             	mov    0x8(%ebp),%eax
c0001856:	8b 40 28             	mov    0x28(%eax),%eax
c0001859:	83 ec 08             	sub    $0x8,%esp
c000185c:	50                   	push   %eax
c000185d:	68 21 45 00 c0       	push   $0xc0004521
c0001862:	e8 18 ec ff ff       	call   c000047f <kprintf>
c0001867:	83 c4 10             	add    $0x10,%esp
    kprintf("cr2: 0x%x\n", regs->cr2);
c000186a:	8b 45 08             	mov    0x8(%ebp),%eax
c000186d:	8b 40 2c             	mov    0x2c(%eax),%eax
c0001870:	83 ec 08             	sub    $0x8,%esp
c0001873:	50                   	push   %eax
c0001874:	68 2c 45 00 c0       	push   $0xc000452c
c0001879:	e8 01 ec ff ff       	call   c000047f <kprintf>
c000187e:	83 c4 10             	add    $0x10,%esp
    kprintf("cr3: 0x%x\n", regs->cr3);
c0001881:	8b 45 08             	mov    0x8(%ebp),%eax
c0001884:	8b 40 30             	mov    0x30(%eax),%eax
c0001887:	83 ec 08             	sub    $0x8,%esp
c000188a:	50                   	push   %eax
c000188b:	68 37 45 00 c0       	push   $0xc0004537
c0001890:	e8 ea eb ff ff       	call   c000047f <kprintf>
c0001895:	83 c4 10             	add    $0x10,%esp
    kprintf("cr4: 0x%x\n", regs->cr4);
c0001898:	8b 45 08             	mov    0x8(%ebp),%eax
c000189b:	8b 40 34             	mov    0x34(%eax),%eax
c000189e:	83 ec 08             	sub    $0x8,%esp
c00018a1:	50                   	push   %eax
c00018a2:	68 42 45 00 c0       	push   $0xc0004542
c00018a7:	e8 d3 eb ff ff       	call   c000047f <kprintf>
c00018ac:	83 c4 10             	add    $0x10,%esp
}
c00018af:	90                   	nop
c00018b0:	8d 65 f4             	lea    -0xc(%ebp),%esp
c00018b3:	5b                   	pop    %ebx
c00018b4:	5e                   	pop    %esi
c00018b5:	5f                   	pop    %edi
c00018b6:	5d                   	pop    %ebp
c00018b7:	c3                   	ret    

c00018b8 <memory_table>:
#include "multiboot.h"
#include "kprintf.h"

size_t memory_table(multiboot_info_t* mbd)
{
c00018b8:	55                   	push   %ebp
c00018b9:	89 e5                	mov    %esp,%ebp
c00018bb:	56                   	push   %esi
c00018bc:	53                   	push   %ebx
c00018bd:	83 ec 10             	sub    $0x10,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c00018c0:	8b 45 08             	mov    0x8(%ebp),%eax
c00018c3:	8b 40 30             	mov    0x30(%eax),%eax
c00018c6:	89 45 ec             	mov    %eax,-0x14(%ebp)
    size_t available_mem = 0;
c00018c9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c00018d0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00018d7:	e9 83 00 00 00       	jmp    c000195f <memory_table+0xa7>
	{
		if(mmap_table[nn].len>0 && mmap_table[nn].size>0)
c00018dc:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00018df:	89 d0                	mov    %edx,%eax
c00018e1:	01 c0                	add    %eax,%eax
c00018e3:	01 d0                	add    %edx,%eax
c00018e5:	c1 e0 03             	shl    $0x3,%eax
c00018e8:	89 c2                	mov    %eax,%edx
c00018ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00018ed:	01 d0                	add    %edx,%eax
c00018ef:	8b 50 10             	mov    0x10(%eax),%edx
c00018f2:	8b 40 0c             	mov    0xc(%eax),%eax
c00018f5:	89 c6                	mov    %eax,%esi
c00018f7:	83 f6 00             	xor    $0x0,%esi
c00018fa:	89 f1                	mov    %esi,%ecx
c00018fc:	89 d0                	mov    %edx,%eax
c00018fe:	80 f4 00             	xor    $0x0,%ah
c0001901:	89 c3                	mov    %eax,%ebx
c0001903:	89 d8                	mov    %ebx,%eax
c0001905:	09 c8                	or     %ecx,%eax
c0001907:	85 c0                	test   %eax,%eax
c0001909:	74 50                	je     c000195b <memory_table+0xa3>
c000190b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000190e:	89 d0                	mov    %edx,%eax
c0001910:	01 c0                	add    %eax,%eax
c0001912:	01 d0                	add    %edx,%eax
c0001914:	c1 e0 03             	shl    $0x3,%eax
c0001917:	89 c2                	mov    %eax,%edx
c0001919:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000191c:	01 d0                	add    %edx,%eax
c000191e:	8b 00                	mov    (%eax),%eax
c0001920:	85 c0                	test   %eax,%eax
c0001922:	74 37                	je     c000195b <memory_table+0xa3>
        {
            if(mmap_table[nn].type == 1)
c0001924:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001927:	89 d0                	mov    %edx,%eax
c0001929:	01 c0                	add    %eax,%eax
c000192b:	01 d0                	add    %edx,%eax
c000192d:	c1 e0 03             	shl    $0x3,%eax
c0001930:	89 c2                	mov    %eax,%edx
c0001932:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001935:	01 d0                	add    %edx,%eax
c0001937:	8b 40 14             	mov    0x14(%eax),%eax
c000193a:	83 f8 01             	cmp    $0x1,%eax
c000193d:	75 1c                	jne    c000195b <memory_table+0xa3>
            available_mem += mmap_table[nn].len;
c000193f:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001942:	89 d0                	mov    %edx,%eax
c0001944:	01 c0                	add    %eax,%eax
c0001946:	01 d0                	add    %edx,%eax
c0001948:	c1 e0 03             	shl    $0x3,%eax
c000194b:	89 c2                	mov    %eax,%edx
c000194d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001950:	01 d0                	add    %edx,%eax
c0001952:	8b 50 10             	mov    0x10(%eax),%edx
c0001955:	8b 40 0c             	mov    0xc(%eax),%eax
c0001958:	01 45 f4             	add    %eax,-0xc(%ebp)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c000195b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c000195f:	8b 45 08             	mov    0x8(%ebp),%eax
c0001962:	8b 40 2c             	mov    0x2c(%eax),%eax
c0001965:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0001968:	0f 82 6e ff ff ff    	jb     c00018dc <memory_table+0x24>
        }
		
	}

    return available_mem;
c000196e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0001971:	83 c4 10             	add    $0x10,%esp
c0001974:	5b                   	pop    %ebx
c0001975:	5e                   	pop    %esi
c0001976:	5d                   	pop    %ebp
c0001977:	c3                   	ret    

c0001978 <print_memory_table>:

int print_memory_table(multiboot_info_t* mbd)
{
c0001978:	55                   	push   %ebp
c0001979:	89 e5                	mov    %esp,%ebp
c000197b:	57                   	push   %edi
c000197c:	56                   	push   %esi
c000197d:	53                   	push   %ebx
c000197e:	83 ec 2c             	sub    $0x2c,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c0001981:	8b 45 08             	mov    0x8(%ebp),%eax
c0001984:	8b 40 30             	mov    0x30(%eax),%eax
c0001987:	89 45 e0             	mov    %eax,-0x20(%ebp)
	kprintf("Memory Table:\n");
c000198a:	83 ec 0c             	sub    $0xc,%esp
c000198d:	68 50 45 00 c0       	push   $0xc0004550
c0001992:	e8 e8 ea ff ff       	call   c000047f <kprintf>
c0001997:	83 c4 10             	add    $0x10,%esp
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c000199a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c00019a1:	e9 a6 01 00 00       	jmp    c0001b4c <print_memory_table+0x1d4>
	{
        if(mmap_table[nn].size == 0)
c00019a6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00019a9:	89 d0                	mov    %edx,%eax
c00019ab:	01 c0                	add    %eax,%eax
c00019ad:	01 d0                	add    %edx,%eax
c00019af:	c1 e0 03             	shl    $0x3,%eax
c00019b2:	89 c2                	mov    %eax,%edx
c00019b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00019b7:	01 d0                	add    %edx,%eax
c00019b9:	8b 00                	mov    (%eax),%eax
c00019bb:	85 c0                	test   %eax,%eax
c00019bd:	0f 84 9a 01 00 00    	je     c0001b5d <print_memory_table+0x1e5>
            break;

		if(mmap_table[nn].len>0)
c00019c3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00019c6:	89 d0                	mov    %edx,%eax
c00019c8:	01 c0                	add    %eax,%eax
c00019ca:	01 d0                	add    %edx,%eax
c00019cc:	c1 e0 03             	shl    $0x3,%eax
c00019cf:	89 c2                	mov    %eax,%edx
c00019d1:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00019d4:	01 d0                	add    %edx,%eax
c00019d6:	8b 50 10             	mov    0x10(%eax),%edx
c00019d9:	8b 40 0c             	mov    0xc(%eax),%eax
c00019dc:	89 c7                	mov    %eax,%edi
c00019de:	83 f7 00             	xor    $0x0,%edi
c00019e1:	89 7d d0             	mov    %edi,-0x30(%ebp)
c00019e4:	89 d0                	mov    %edx,%eax
c00019e6:	80 f4 00             	xor    $0x0,%ah
c00019e9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
c00019ec:	8b 5d d0             	mov    -0x30(%ebp),%ebx
c00019ef:	8b 75 d4             	mov    -0x2c(%ebp),%esi
c00019f2:	89 f0                	mov    %esi,%eax
c00019f4:	09 d8                	or     %ebx,%eax
c00019f6:	85 c0                	test   %eax,%eax
c00019f8:	0f 84 4a 01 00 00    	je     c0001b48 <print_memory_table+0x1d0>
		{
			if(mmap_table[nn].type == MULTIBOOT_MEMORY_AVAILABLE)
c00019fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001a01:	89 d0                	mov    %edx,%eax
c0001a03:	01 c0                	add    %eax,%eax
c0001a05:	01 d0                	add    %edx,%eax
c0001a07:	c1 e0 03             	shl    $0x3,%eax
c0001a0a:	89 c2                	mov    %eax,%edx
c0001a0c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001a0f:	01 d0                	add    %edx,%eax
c0001a11:	8b 40 14             	mov    0x14(%eax),%eax
c0001a14:	83 f8 01             	cmp    $0x1,%eax
c0001a17:	0f 85 98 00 00 00    	jne    c0001ab5 <print_memory_table+0x13d>
				kprintf("%.8llp - %.8llp [AVAILABLE] (%6llu kiB)\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c0001a1d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001a20:	89 d0                	mov    %edx,%eax
c0001a22:	01 c0                	add    %eax,%eax
c0001a24:	01 d0                	add    %edx,%eax
c0001a26:	c1 e0 03             	shl    $0x3,%eax
c0001a29:	89 c2                	mov    %eax,%edx
c0001a2b:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001a2e:	01 d0                	add    %edx,%eax
c0001a30:	8b 50 10             	mov    0x10(%eax),%edx
c0001a33:	8b 40 0c             	mov    0xc(%eax),%eax
c0001a36:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c0001a3a:	c1 ea 0a             	shr    $0xa,%edx
c0001a3d:	89 c6                	mov    %eax,%esi
c0001a3f:	89 d7                	mov    %edx,%edi
c0001a41:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001a44:	89 d0                	mov    %edx,%eax
c0001a46:	01 c0                	add    %eax,%eax
c0001a48:	01 d0                	add    %edx,%eax
c0001a4a:	c1 e0 03             	shl    $0x3,%eax
c0001a4d:	89 c2                	mov    %eax,%edx
c0001a4f:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001a52:	01 d0                	add    %edx,%eax
c0001a54:	8b 48 04             	mov    0x4(%eax),%ecx
c0001a57:	8b 58 08             	mov    0x8(%eax),%ebx
c0001a5a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001a5d:	89 d0                	mov    %edx,%eax
c0001a5f:	01 c0                	add    %eax,%eax
c0001a61:	01 d0                	add    %edx,%eax
c0001a63:	c1 e0 03             	shl    $0x3,%eax
c0001a66:	89 c2                	mov    %eax,%edx
c0001a68:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001a6b:	01 d0                	add    %edx,%eax
c0001a6d:	8b 50 10             	mov    0x10(%eax),%edx
c0001a70:	8b 40 0c             	mov    0xc(%eax),%eax
c0001a73:	01 c8                	add    %ecx,%eax
c0001a75:	11 da                	adc    %ebx,%edx
c0001a77:	83 c0 ff             	add    $0xffffffff,%eax
c0001a7a:	83 d2 ff             	adc    $0xffffffff,%edx
c0001a7d:	89 c1                	mov    %eax,%ecx
c0001a7f:	89 d3                	mov    %edx,%ebx
c0001a81:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001a84:	89 d0                	mov    %edx,%eax
c0001a86:	01 c0                	add    %eax,%eax
c0001a88:	01 d0                	add    %edx,%eax
c0001a8a:	c1 e0 03             	shl    $0x3,%eax
c0001a8d:	89 c2                	mov    %eax,%edx
c0001a8f:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001a92:	01 d0                	add    %edx,%eax
c0001a94:	8b 50 08             	mov    0x8(%eax),%edx
c0001a97:	8b 40 04             	mov    0x4(%eax),%eax
c0001a9a:	83 ec 04             	sub    $0x4,%esp
c0001a9d:	57                   	push   %edi
c0001a9e:	56                   	push   %esi
c0001a9f:	53                   	push   %ebx
c0001aa0:	51                   	push   %ecx
c0001aa1:	52                   	push   %edx
c0001aa2:	50                   	push   %eax
c0001aa3:	68 60 45 00 c0       	push   $0xc0004560
c0001aa8:	e8 d2 e9 ff ff       	call   c000047f <kprintf>
c0001aad:	83 c4 20             	add    $0x20,%esp
c0001ab0:	e9 93 00 00 00       	jmp    c0001b48 <print_memory_table+0x1d0>
			else
				kprintf("%.8llp - %.8llp [RESERVED]\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c0001ab5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001ab8:	89 d0                	mov    %edx,%eax
c0001aba:	01 c0                	add    %eax,%eax
c0001abc:	01 d0                	add    %edx,%eax
c0001abe:	c1 e0 03             	shl    $0x3,%eax
c0001ac1:	89 c2                	mov    %eax,%edx
c0001ac3:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001ac6:	01 d0                	add    %edx,%eax
c0001ac8:	8b 50 10             	mov    0x10(%eax),%edx
c0001acb:	8b 40 0c             	mov    0xc(%eax),%eax
c0001ace:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c0001ad2:	c1 ea 0a             	shr    $0xa,%edx
c0001ad5:	89 c6                	mov    %eax,%esi
c0001ad7:	89 d7                	mov    %edx,%edi
c0001ad9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001adc:	89 d0                	mov    %edx,%eax
c0001ade:	01 c0                	add    %eax,%eax
c0001ae0:	01 d0                	add    %edx,%eax
c0001ae2:	c1 e0 03             	shl    $0x3,%eax
c0001ae5:	89 c2                	mov    %eax,%edx
c0001ae7:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001aea:	01 d0                	add    %edx,%eax
c0001aec:	8b 48 04             	mov    0x4(%eax),%ecx
c0001aef:	8b 58 08             	mov    0x8(%eax),%ebx
c0001af2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001af5:	89 d0                	mov    %edx,%eax
c0001af7:	01 c0                	add    %eax,%eax
c0001af9:	01 d0                	add    %edx,%eax
c0001afb:	c1 e0 03             	shl    $0x3,%eax
c0001afe:	89 c2                	mov    %eax,%edx
c0001b00:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001b03:	01 d0                	add    %edx,%eax
c0001b05:	8b 50 10             	mov    0x10(%eax),%edx
c0001b08:	8b 40 0c             	mov    0xc(%eax),%eax
c0001b0b:	01 c8                	add    %ecx,%eax
c0001b0d:	11 da                	adc    %ebx,%edx
c0001b0f:	83 c0 ff             	add    $0xffffffff,%eax
c0001b12:	83 d2 ff             	adc    $0xffffffff,%edx
c0001b15:	89 c1                	mov    %eax,%ecx
c0001b17:	89 d3                	mov    %edx,%ebx
c0001b19:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001b1c:	89 d0                	mov    %edx,%eax
c0001b1e:	01 c0                	add    %eax,%eax
c0001b20:	01 d0                	add    %edx,%eax
c0001b22:	c1 e0 03             	shl    $0x3,%eax
c0001b25:	89 c2                	mov    %eax,%edx
c0001b27:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001b2a:	01 d0                	add    %edx,%eax
c0001b2c:	8b 50 08             	mov    0x8(%eax),%edx
c0001b2f:	8b 40 04             	mov    0x4(%eax),%eax
c0001b32:	83 ec 04             	sub    $0x4,%esp
c0001b35:	57                   	push   %edi
c0001b36:	56                   	push   %esi
c0001b37:	53                   	push   %ebx
c0001b38:	51                   	push   %ecx
c0001b39:	52                   	push   %edx
c0001b3a:	50                   	push   %eax
c0001b3b:	68 89 45 00 c0       	push   $0xc0004589
c0001b40:	e8 3a e9 ff ff       	call   c000047f <kprintf>
c0001b45:	83 c4 20             	add    $0x20,%esp
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001b48:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c0001b4c:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b4f:	8b 40 2c             	mov    0x2c(%eax),%eax
c0001b52:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c0001b55:	0f 82 4b fe ff ff    	jb     c00019a6 <print_memory_table+0x2e>
c0001b5b:	eb 01                	jmp    c0001b5e <print_memory_table+0x1e6>
            break;
c0001b5d:	90                   	nop
    //         kprintf("[%3u] %p (%#x)\n", nn, addr, flags);		
	// }

    // print_crs();

    return 0;
c0001b5e:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0001b63:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0001b66:	5b                   	pop    %ebx
c0001b67:	5e                   	pop    %esi
c0001b68:	5f                   	pop    %edi
c0001b69:	5d                   	pop    %ebp
c0001b6a:	c3                   	ret    

c0001b6b <inb>:
{
c0001b6b:	55                   	push   %ebp
c0001b6c:	89 e5                	mov    %esp,%ebp
c0001b6e:	83 ec 14             	sub    $0x14,%esp
c0001b71:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b74:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  __asm__ __volatile__ ("inb %w1,%0":"=a" (_v):"Nd" (__port));
c0001b78:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0001b7c:	89 c2                	mov    %eax,%edx
c0001b7e:	ec                   	in     (%dx),%al
c0001b7f:	88 45 ff             	mov    %al,-0x1(%ebp)
  return _v;
c0001b82:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0001b86:	c9                   	leave  
c0001b87:	c3                   	ret    

c0001b88 <outb>:
{
c0001b88:	55                   	push   %ebp
c0001b89:	89 e5                	mov    %esp,%ebp
c0001b8b:	83 ec 08             	sub    $0x8,%esp
c0001b8e:	8b 55 08             	mov    0x8(%ebp),%edx
c0001b91:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001b94:	88 55 fc             	mov    %dl,-0x4(%ebp)
c0001b97:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
c0001b9b:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0001b9f:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
c0001ba3:	ee                   	out    %al,(%dx)
}
c0001ba4:	90                   	nop
c0001ba5:	c9                   	leave  
c0001ba6:	c3                   	ret    

c0001ba7 <init_interrupts>:

idt_entry_t __aligned idt[NUM_INTERRUPT_HANDLERS] = {0};
idt_descriptor_t __aligned idtd;

void init_interrupts()
{
c0001ba7:	55                   	push   %ebp
c0001ba8:	89 e5                	mov    %esp,%ebp
c0001baa:	83 ec 08             	sub    $0x8,%esp
    /* init the PIC */
	outb(PIC_INIT, PIC1_CMD);  // init PIC 1
c0001bad:	6a 20                	push   $0x20
c0001baf:	6a 11                	push   $0x11
c0001bb1:	e8 d2 ff ff ff       	call   c0001b88 <outb>
c0001bb6:	83 c4 08             	add    $0x8,%esp
    outb(PIC_INIT, PIC2_CMD);  // init PIC 2
c0001bb9:	68 a0 00 00 00       	push   $0xa0
c0001bbe:	6a 11                	push   $0x11
c0001bc0:	e8 c3 ff ff ff       	call   c0001b88 <outb>
c0001bc5:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_OFFSET, PIC1_DATA); // map irq 0x0-0x7 to int 0x20-0x27
c0001bc8:	6a 21                	push   $0x21
c0001bca:	6a 20                	push   $0x20
c0001bcc:	e8 b7 ff ff ff       	call   c0001b88 <outb>
c0001bd1:	83 c4 08             	add    $0x8,%esp
    outb(PIC2_OFFSET, PIC2_DATA); // map irq 0x8-0xf to int 0x28-0x2f
c0001bd4:	68 a1 00 00 00       	push   $0xa1
c0001bd9:	6a 28                	push   $0x28
c0001bdb:	e8 a8 ff ff ff       	call   c0001b88 <outb>
c0001be0:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_MS, PIC1_DATA);     // pic1 is master, with slave at irq 2
c0001be3:	6a 21                	push   $0x21
c0001be5:	6a 04                	push   $0x4
c0001be7:	e8 9c ff ff ff       	call   c0001b88 <outb>
c0001bec:	83 c4 08             	add    $0x8,%esp
    outb(PIC2_MS, PIC2_DATA);     // pic2 is slave with id 2
c0001bef:	68 a1 00 00 00       	push   $0xa1
c0001bf4:	6a 02                	push   $0x2
c0001bf6:	e8 8d ff ff ff       	call   c0001b88 <outb>
c0001bfb:	83 c4 08             	add    $0x8,%esp
    outb(PIC_8086MODE, PIC1_DATA); //enable 8086 mode
c0001bfe:	6a 21                	push   $0x21
c0001c00:	6a 01                	push   $0x1
c0001c02:	e8 81 ff ff ff       	call   c0001b88 <outb>
c0001c07:	83 c4 08             	add    $0x8,%esp
    outb(PIC_8086MODE, PIC2_DATA); //enable 8086 mode
c0001c0a:	68 a1 00 00 00       	push   $0xa1
c0001c0f:	6a 01                	push   $0x1
c0001c11:	e8 72 ff ff ff       	call   c0001b88 <outb>
c0001c16:	83 c4 08             	add    $0x8,%esp
    // interrupt mask
    outb( ~(1<<1) , PIC1_DATA); //enable irq1 (keyboard)
c0001c19:	6a 21                	push   $0x21
c0001c1b:	68 fd 00 00 00       	push   $0xfd
c0001c20:	e8 63 ff ff ff       	call   c0001b88 <outb>
c0001c25:	83 c4 08             	add    $0x8,%esp
    outb(0xff, PIC2_DATA); //disable interrupts from slave
c0001c28:	68 a1 00 00 00       	push   $0xa1
c0001c2d:	68 ff 00 00 00       	push   $0xff
c0001c32:	e8 51 ff ff ff       	call   c0001b88 <outb>
c0001c37:	83 c4 08             	add    $0x8,%esp


    // individual handler routines defined in interrupt.S
    // these call back to exception_handler() and irq_handler()
    set_interrupt_handler(0,except_0);
c0001c3a:	83 ec 08             	sub    $0x8,%esp
c0001c3d:	68 b8 2f 00 c0       	push   $0xc0002fb8
c0001c42:	6a 00                	push   $0x0
c0001c44:	e8 94 02 00 00       	call   c0001edd <set_interrupt_handler>
c0001c49:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(1,except_1);
c0001c4c:	83 ec 08             	sub    $0x8,%esp
c0001c4f:	68 d8 2f 00 c0       	push   $0xc0002fd8
c0001c54:	6a 01                	push   $0x1
c0001c56:	e8 82 02 00 00       	call   c0001edd <set_interrupt_handler>
c0001c5b:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(2,except_2);
c0001c5e:	83 ec 08             	sub    $0x8,%esp
c0001c61:	68 f8 2f 00 c0       	push   $0xc0002ff8
c0001c66:	6a 02                	push   $0x2
c0001c68:	e8 70 02 00 00       	call   c0001edd <set_interrupt_handler>
c0001c6d:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(3,except_3);
c0001c70:	83 ec 08             	sub    $0x8,%esp
c0001c73:	68 18 30 00 c0       	push   $0xc0003018
c0001c78:	6a 03                	push   $0x3
c0001c7a:	e8 5e 02 00 00       	call   c0001edd <set_interrupt_handler>
c0001c7f:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(4,except_4);
c0001c82:	83 ec 08             	sub    $0x8,%esp
c0001c85:	68 38 30 00 c0       	push   $0xc0003038
c0001c8a:	6a 04                	push   $0x4
c0001c8c:	e8 4c 02 00 00       	call   c0001edd <set_interrupt_handler>
c0001c91:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(5,except_5);
c0001c94:	83 ec 08             	sub    $0x8,%esp
c0001c97:	68 58 30 00 c0       	push   $0xc0003058
c0001c9c:	6a 05                	push   $0x5
c0001c9e:	e8 3a 02 00 00       	call   c0001edd <set_interrupt_handler>
c0001ca3:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(6,except_6);
c0001ca6:	83 ec 08             	sub    $0x8,%esp
c0001ca9:	68 78 30 00 c0       	push   $0xc0003078
c0001cae:	6a 06                	push   $0x6
c0001cb0:	e8 28 02 00 00       	call   c0001edd <set_interrupt_handler>
c0001cb5:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(7,except_7);
c0001cb8:	83 ec 08             	sub    $0x8,%esp
c0001cbb:	68 98 30 00 c0       	push   $0xc0003098
c0001cc0:	6a 07                	push   $0x7
c0001cc2:	e8 16 02 00 00       	call   c0001edd <set_interrupt_handler>
c0001cc7:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(8,except_8);
c0001cca:	83 ec 08             	sub    $0x8,%esp
c0001ccd:	68 b8 30 00 c0       	push   $0xc00030b8
c0001cd2:	6a 08                	push   $0x8
c0001cd4:	e8 04 02 00 00       	call   c0001edd <set_interrupt_handler>
c0001cd9:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(10,except_10);
c0001cdc:	83 ec 08             	sub    $0x8,%esp
c0001cdf:	68 d8 30 00 c0       	push   $0xc00030d8
c0001ce4:	6a 0a                	push   $0xa
c0001ce6:	e8 f2 01 00 00       	call   c0001edd <set_interrupt_handler>
c0001ceb:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(11,except_11);
c0001cee:	83 ec 08             	sub    $0x8,%esp
c0001cf1:	68 f8 30 00 c0       	push   $0xc00030f8
c0001cf6:	6a 0b                	push   $0xb
c0001cf8:	e8 e0 01 00 00       	call   c0001edd <set_interrupt_handler>
c0001cfd:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(12,except_12);
c0001d00:	83 ec 08             	sub    $0x8,%esp
c0001d03:	68 18 31 00 c0       	push   $0xc0003118
c0001d08:	6a 0c                	push   $0xc
c0001d0a:	e8 ce 01 00 00       	call   c0001edd <set_interrupt_handler>
c0001d0f:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(13,except_13);
c0001d12:	83 ec 08             	sub    $0x8,%esp
c0001d15:	68 38 31 00 c0       	push   $0xc0003138
c0001d1a:	6a 0d                	push   $0xd
c0001d1c:	e8 bc 01 00 00       	call   c0001edd <set_interrupt_handler>
c0001d21:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(14,except_14);
c0001d24:	83 ec 08             	sub    $0x8,%esp
c0001d27:	68 58 31 00 c0       	push   $0xc0003158
c0001d2c:	6a 0e                	push   $0xe
c0001d2e:	e8 aa 01 00 00       	call   c0001edd <set_interrupt_handler>
c0001d33:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(16,except_16);
c0001d36:	83 ec 08             	sub    $0x8,%esp
c0001d39:	68 78 31 00 c0       	push   $0xc0003178
c0001d3e:	6a 10                	push   $0x10
c0001d40:	e8 98 01 00 00       	call   c0001edd <set_interrupt_handler>
c0001d45:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(17,except_17);
c0001d48:	83 ec 08             	sub    $0x8,%esp
c0001d4b:	68 98 31 00 c0       	push   $0xc0003198
c0001d50:	6a 11                	push   $0x11
c0001d52:	e8 86 01 00 00       	call   c0001edd <set_interrupt_handler>
c0001d57:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(18,except_18);
c0001d5a:	83 ec 08             	sub    $0x8,%esp
c0001d5d:	68 b8 31 00 c0       	push   $0xc00031b8
c0001d62:	6a 12                	push   $0x12
c0001d64:	e8 74 01 00 00       	call   c0001edd <set_interrupt_handler>
c0001d69:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(19,except_19);
c0001d6c:	83 ec 08             	sub    $0x8,%esp
c0001d6f:	68 d8 31 00 c0       	push   $0xc00031d8
c0001d74:	6a 13                	push   $0x13
c0001d76:	e8 62 01 00 00       	call   c0001edd <set_interrupt_handler>
c0001d7b:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(20,except_20);
c0001d7e:	83 ec 08             	sub    $0x8,%esp
c0001d81:	68 f8 31 00 c0       	push   $0xc00031f8
c0001d86:	6a 14                	push   $0x14
c0001d88:	e8 50 01 00 00       	call   c0001edd <set_interrupt_handler>
c0001d8d:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(30,except_30);
c0001d90:	83 ec 08             	sub    $0x8,%esp
c0001d93:	68 18 32 00 c0       	push   $0xc0003218
c0001d98:	6a 1e                	push   $0x1e
c0001d9a:	e8 3e 01 00 00       	call   c0001edd <set_interrupt_handler>
c0001d9f:	83 c4 10             	add    $0x10,%esp

    set_interrupt_handler(32,irq_0);
c0001da2:	83 ec 08             	sub    $0x8,%esp
c0001da5:	68 38 32 00 c0       	push   $0xc0003238
c0001daa:	6a 20                	push   $0x20
c0001dac:	e8 2c 01 00 00       	call   c0001edd <set_interrupt_handler>
c0001db1:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(33,irq_1);
c0001db4:	83 ec 08             	sub    $0x8,%esp
c0001db7:	68 4c 32 00 c0       	push   $0xc000324c
c0001dbc:	6a 21                	push   $0x21
c0001dbe:	e8 1a 01 00 00       	call   c0001edd <set_interrupt_handler>
c0001dc3:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(34,irq_2);
c0001dc6:	83 ec 08             	sub    $0x8,%esp
c0001dc9:	68 60 32 00 c0       	push   $0xc0003260
c0001dce:	6a 22                	push   $0x22
c0001dd0:	e8 08 01 00 00       	call   c0001edd <set_interrupt_handler>
c0001dd5:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(35,irq_3);
c0001dd8:	83 ec 08             	sub    $0x8,%esp
c0001ddb:	68 74 32 00 c0       	push   $0xc0003274
c0001de0:	6a 23                	push   $0x23
c0001de2:	e8 f6 00 00 00       	call   c0001edd <set_interrupt_handler>
c0001de7:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(36,irq_4);
c0001dea:	83 ec 08             	sub    $0x8,%esp
c0001ded:	68 88 32 00 c0       	push   $0xc0003288
c0001df2:	6a 24                	push   $0x24
c0001df4:	e8 e4 00 00 00       	call   c0001edd <set_interrupt_handler>
c0001df9:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(37,irq_5);
c0001dfc:	83 ec 08             	sub    $0x8,%esp
c0001dff:	68 9c 32 00 c0       	push   $0xc000329c
c0001e04:	6a 25                	push   $0x25
c0001e06:	e8 d2 00 00 00       	call   c0001edd <set_interrupt_handler>
c0001e0b:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(38,irq_6);
c0001e0e:	83 ec 08             	sub    $0x8,%esp
c0001e11:	68 b0 32 00 c0       	push   $0xc00032b0
c0001e16:	6a 26                	push   $0x26
c0001e18:	e8 c0 00 00 00       	call   c0001edd <set_interrupt_handler>
c0001e1d:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(39,irq_7);
c0001e20:	83 ec 08             	sub    $0x8,%esp
c0001e23:	68 c4 32 00 c0       	push   $0xc00032c4
c0001e28:	6a 27                	push   $0x27
c0001e2a:	e8 ae 00 00 00       	call   c0001edd <set_interrupt_handler>
c0001e2f:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(40,irq_8);
c0001e32:	83 ec 08             	sub    $0x8,%esp
c0001e35:	68 d8 32 00 c0       	push   $0xc00032d8
c0001e3a:	6a 28                	push   $0x28
c0001e3c:	e8 9c 00 00 00       	call   c0001edd <set_interrupt_handler>
c0001e41:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(41,irq_9);
c0001e44:	83 ec 08             	sub    $0x8,%esp
c0001e47:	68 ec 32 00 c0       	push   $0xc00032ec
c0001e4c:	6a 29                	push   $0x29
c0001e4e:	e8 8a 00 00 00       	call   c0001edd <set_interrupt_handler>
c0001e53:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(42,irq_10);
c0001e56:	83 ec 08             	sub    $0x8,%esp
c0001e59:	68 00 33 00 c0       	push   $0xc0003300
c0001e5e:	6a 2a                	push   $0x2a
c0001e60:	e8 78 00 00 00       	call   c0001edd <set_interrupt_handler>
c0001e65:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(43,irq_11);
c0001e68:	83 ec 08             	sub    $0x8,%esp
c0001e6b:	68 14 33 00 c0       	push   $0xc0003314
c0001e70:	6a 2b                	push   $0x2b
c0001e72:	e8 66 00 00 00       	call   c0001edd <set_interrupt_handler>
c0001e77:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(44,irq_12);
c0001e7a:	83 ec 08             	sub    $0x8,%esp
c0001e7d:	68 28 33 00 c0       	push   $0xc0003328
c0001e82:	6a 2c                	push   $0x2c
c0001e84:	e8 54 00 00 00       	call   c0001edd <set_interrupt_handler>
c0001e89:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(45,irq_13);
c0001e8c:	83 ec 08             	sub    $0x8,%esp
c0001e8f:	68 3c 33 00 c0       	push   $0xc000333c
c0001e94:	6a 2d                	push   $0x2d
c0001e96:	e8 42 00 00 00       	call   c0001edd <set_interrupt_handler>
c0001e9b:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(46,irq_14);
c0001e9e:	83 ec 08             	sub    $0x8,%esp
c0001ea1:	68 50 33 00 c0       	push   $0xc0003350
c0001ea6:	6a 2e                	push   $0x2e
c0001ea8:	e8 30 00 00 00       	call   c0001edd <set_interrupt_handler>
c0001ead:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(47,irq_15);
c0001eb0:	83 ec 08             	sub    $0x8,%esp
c0001eb3:	68 64 33 00 c0       	push   $0xc0003364
c0001eb8:	6a 2f                	push   $0x2f
c0001eba:	e8 1e 00 00 00       	call   c0001edd <set_interrupt_handler>
c0001ebf:	83 c4 10             	add    $0x10,%esp



    idtd.base = (uint32_t) idt;
c0001ec2:	b8 20 00 01 c0       	mov    $0xc0010020,%eax
c0001ec7:	a3 22 08 01 c0       	mov    %eax,0xc0010822
    idtd.limit = sizeof(idt_entry_t) * NUM_INTERRUPT_HANDLERS - 1;
c0001ecc:	66 c7 05 20 08 01 c0 	movw   $0x7ff,0xc0010820
c0001ed3:	ff 07 
    load_idt();
c0001ed5:	e8 ce 10 00 00       	call   c0002fa8 <load_idt>
}
c0001eda:	90                   	nop
c0001edb:	c9                   	leave  
c0001edc:	c3                   	ret    

c0001edd <set_interrupt_handler>:

void set_interrupt_handler(int int_num, void* handler)
{
c0001edd:	55                   	push   %ebp
c0001ede:	89 e5                	mov    %esp,%ebp
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c0001ee0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001ee3:	89 c2                	mov    %eax,%edx
c0001ee5:	8b 45 08             	mov    0x8(%ebp),%eax
c0001ee8:	66 89 14 c5 20 00 01 	mov    %dx,-0x3ffeffe0(,%eax,8)
c0001eef:	c0 
	idt[int_num].segment = KERNEL_CODE_SEGMENT;
c0001ef0:	8b 45 08             	mov    0x8(%ebp),%eax
c0001ef3:	66 c7 04 c5 22 00 01 	movw   $0x8,-0x3ffeffde(,%eax,8)
c0001efa:	c0 08 00 
	idt[int_num].zero = 0;
c0001efd:	8b 45 08             	mov    0x8(%ebp),%eax
c0001f00:	c6 04 c5 24 00 01 c0 	movb   $0x0,-0x3ffeffdc(,%eax,8)
c0001f07:	00 
	idt[int_num].type = 0x8e; /* INTERRUPT_GATE */
c0001f08:	8b 45 08             	mov    0x8(%ebp),%eax
c0001f0b:	c6 04 c5 25 00 01 c0 	movb   $0x8e,-0x3ffeffdb(,%eax,8)
c0001f12:	8e 
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c0001f13:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001f16:	c1 e8 10             	shr    $0x10,%eax
c0001f19:	89 c2                	mov    %eax,%edx
c0001f1b:	8b 45 08             	mov    0x8(%ebp),%eax
c0001f1e:	66 89 14 c5 26 00 01 	mov    %dx,-0x3ffeffda(,%eax,8)
c0001f25:	c0 
}
c0001f26:	90                   	nop
c0001f27:	5d                   	pop    %ebp
c0001f28:	c3                   	ret    

c0001f29 <page_fault_handler>:

void page_fault_handler(uint32_t code, void* fault_ip)
{
c0001f29:	55                   	push   %ebp
c0001f2a:	89 e5                	mov    %esp,%ebp
c0001f2c:	83 ec 08             	sub    $0x8,%esp

    if(code & PF_CODE_WRITE)
c0001f2f:	8b 45 08             	mov    0x8(%ebp),%eax
c0001f32:	83 e0 02             	and    $0x2,%eax
c0001f35:	85 c0                	test   %eax,%eax
c0001f37:	74 1b                	je     c0001f54 <page_fault_handler+0x2b>
        kprintf("\n\nPage Fault writing to 0x%x (instruction 0x%x)\n", pf_addr(), fault_ip);
c0001f39:	e8 76 10 00 00       	call   c0002fb4 <pf_addr>
c0001f3e:	83 ec 04             	sub    $0x4,%esp
c0001f41:	ff 75 0c             	pushl  0xc(%ebp)
c0001f44:	50                   	push   %eax
c0001f45:	68 a8 45 00 c0       	push   $0xc00045a8
c0001f4a:	e8 30 e5 ff ff       	call   c000047f <kprintf>
c0001f4f:	83 c4 10             	add    $0x10,%esp
c0001f52:	eb 19                	jmp    c0001f6d <page_fault_handler+0x44>
    else        
        kprintf("\n\nPage Fault reading from 0x%x (instruction 0x%x)\n", pf_addr(), fault_ip);
c0001f54:	e8 5b 10 00 00       	call   c0002fb4 <pf_addr>
c0001f59:	83 ec 04             	sub    $0x4,%esp
c0001f5c:	ff 75 0c             	pushl  0xc(%ebp)
c0001f5f:	50                   	push   %eax
c0001f60:	68 dc 45 00 c0       	push   $0xc00045dc
c0001f65:	e8 15 e5 ff ff       	call   c000047f <kprintf>
c0001f6a:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_PGPROT)
c0001f6d:	8b 45 08             	mov    0x8(%ebp),%eax
c0001f70:	83 e0 01             	and    $0x1,%eax
c0001f73:	85 c0                	test   %eax,%eax
c0001f75:	74 12                	je     c0001f89 <page_fault_handler+0x60>
        kprintf("Page protection violation\n");
c0001f77:	83 ec 0c             	sub    $0xc,%esp
c0001f7a:	68 0f 46 00 c0       	push   $0xc000460f
c0001f7f:	e8 fb e4 ff ff       	call   c000047f <kprintf>
c0001f84:	83 c4 10             	add    $0x10,%esp
c0001f87:	eb 10                	jmp    c0001f99 <page_fault_handler+0x70>
    else
        kprintf("Page not present\n");
c0001f89:	83 ec 0c             	sub    $0xc,%esp
c0001f8c:	68 2a 46 00 c0       	push   $0xc000462a
c0001f91:	e8 e9 e4 ff ff       	call   c000047f <kprintf>
c0001f96:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_USER)
c0001f99:	8b 45 08             	mov    0x8(%ebp),%eax
c0001f9c:	83 e0 04             	and    $0x4,%eax
c0001f9f:	85 c0                	test   %eax,%eax
c0001fa1:	74 10                	je     c0001fb3 <page_fault_handler+0x8a>
        kprintf("\n\nFault caused by user code\n");
c0001fa3:	83 ec 0c             	sub    $0xc,%esp
c0001fa6:	68 3c 46 00 c0       	push   $0xc000463c
c0001fab:	e8 cf e4 ff ff       	call   c000047f <kprintf>
c0001fb0:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_RES)
c0001fb3:	8b 45 08             	mov    0x8(%ebp),%eax
c0001fb6:	83 e0 08             	and    $0x8,%eax
c0001fb9:	85 c0                	test   %eax,%eax
c0001fbb:	74 10                	je     c0001fcd <page_fault_handler+0xa4>
        kprintf("Page reserved bit set\n");
c0001fbd:	83 ec 0c             	sub    $0xc,%esp
c0001fc0:	68 59 46 00 c0       	push   $0xc0004659
c0001fc5:	e8 b5 e4 ff ff       	call   c000047f <kprintf>
c0001fca:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_IF)
c0001fcd:	8b 45 08             	mov    0x8(%ebp),%eax
c0001fd0:	83 e0 10             	and    $0x10,%eax
c0001fd3:	85 c0                	test   %eax,%eax
c0001fd5:	74 10                	je     c0001fe7 <page_fault_handler+0xbe>
        kprintf("Fault caused by instruction fetch\n");
c0001fd7:	83 ec 0c             	sub    $0xc,%esp
c0001fda:	68 70 46 00 c0       	push   $0xc0004670
c0001fdf:	e8 9b e4 ff ff       	call   c000047f <kprintf>
c0001fe4:	83 c4 10             	add    $0x10,%esp

    while(1);
c0001fe7:	eb fe                	jmp    c0001fe7 <page_fault_handler+0xbe>

c0001fe9 <exception_handler>:
}


void exception_handler(uint32_t exception_num, uint32_t code, void* fault_ip)
{
c0001fe9:	55                   	push   %ebp
c0001fea:	89 e5                	mov    %esp,%ebp
c0001fec:	83 ec 08             	sub    $0x8,%esp
    if(exception_num==14)
c0001fef:	83 7d 08 0e          	cmpl   $0xe,0x8(%ebp)
c0001ff3:	75 13                	jne    c0002008 <exception_handler+0x1f>
        page_fault_handler(code, fault_ip);
c0001ff5:	83 ec 08             	sub    $0x8,%esp
c0001ff8:	ff 75 10             	pushl  0x10(%ebp)
c0001ffb:	ff 75 0c             	pushl  0xc(%ebp)
c0001ffe:	e8 26 ff ff ff       	call   c0001f29 <page_fault_handler>
c0002003:	83 c4 10             	add    $0x10,%esp
c0002006:	eb 16                	jmp    c000201e <exception_handler+0x35>
    else
        kprintf("\n\nException %u with code 0x%x at instruction 0x%x\n", exception_num, code, fault_ip);
c0002008:	ff 75 10             	pushl  0x10(%ebp)
c000200b:	ff 75 0c             	pushl  0xc(%ebp)
c000200e:	ff 75 08             	pushl  0x8(%ebp)
c0002011:	68 94 46 00 c0       	push   $0xc0004694
c0002016:	e8 64 e4 ff ff       	call   c000047f <kprintf>
c000201b:	83 c4 10             	add    $0x10,%esp
    while(1);
c000201e:	eb fe                	jmp    c000201e <exception_handler+0x35>

c0002020 <irq_handler>:
}

void irq_handler(uint32_t irq_num)
{
c0002020:	55                   	push   %ebp
c0002021:	89 e5                	mov    %esp,%ebp
c0002023:	83 ec 18             	sub    $0x18,%esp
    if(irq_num == 1)
c0002026:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c000202a:	75 36                	jne    c0002062 <irq_handler+0x42>
    {
        unsigned char scan_code = inb(0x60);
c000202c:	6a 60                	push   $0x60
c000202e:	e8 38 fb ff ff       	call   c0001b6b <inb>
c0002033:	83 c4 04             	add    $0x4,%esp
c0002036:	88 45 f7             	mov    %al,-0x9(%ebp)
        char key_ascii = scancode_to_ascii(scan_code);
c0002039:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000203d:	83 ec 0c             	sub    $0xc,%esp
c0002040:	50                   	push   %eax
c0002041:	e8 fe 0b 00 00       	call   c0002c44 <scancode_to_ascii>
c0002046:	83 c4 10             	add    $0x10,%esp
c0002049:	88 45 f6             	mov    %al,-0xa(%ebp)
        // kprintf("code: 0x%x, ascii:%c\n", scan_code, key_ascii);
        if(key_ascii>0)
c000204c:	80 7d f6 00          	cmpb   $0x0,-0xa(%ebp)
c0002050:	7e 10                	jle    c0002062 <irq_handler+0x42>
            kprint_char(key_ascii);
c0002052:	0f be 45 f6          	movsbl -0xa(%ebp),%eax
c0002056:	83 ec 0c             	sub    $0xc,%esp
c0002059:	50                   	push   %eax
c000205a:	e8 cf e3 ff ff       	call   c000042e <kprint_char>
c000205f:	83 c4 10             	add    $0x10,%esp
    
    }

    // notify PIC that interrupt handling is complete
    if(irq_num >= 8)
c0002062:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
c0002066:	76 12                	jbe    c000207a <irq_handler+0x5a>
        outb(PIC_EOI, PIC2_CMD);
c0002068:	83 ec 08             	sub    $0x8,%esp
c000206b:	68 a0 00 00 00       	push   $0xa0
c0002070:	6a 20                	push   $0x20
c0002072:	e8 11 fb ff ff       	call   c0001b88 <outb>
c0002077:	83 c4 10             	add    $0x10,%esp

    outb(PIC_EOI, PIC1_CMD);
c000207a:	83 ec 08             	sub    $0x8,%esp
c000207d:	6a 20                	push   $0x20
c000207f:	6a 20                	push   $0x20
c0002081:	e8 02 fb ff ff       	call   c0001b88 <outb>
c0002086:	83 c4 10             	add    $0x10,%esp

    return;
c0002089:	90                   	nop
}
c000208a:	c9                   	leave  
c000208b:	c3                   	ret    

c000208c <initialize_multitasking>:
task_control_block_t kernel_main_task;

uint32_t pid_counter;

void initialize_multitasking()
{    
c000208c:	55                   	push   %ebp
c000208d:	89 e5                	mov    %esp,%ebp
c000208f:	83 ec 08             	sub    $0x8,%esp
    // initialize current task as initial task
    kernel_main_task.pid = pid_counter = 0;
c0002092:	c7 05 80 08 01 c0 00 	movl   $0x0,0xc0010880
c0002099:	00 00 00 
c000209c:	a1 80 08 01 c0       	mov    0xc0010880,%eax
c00020a1:	a3 60 08 01 c0       	mov    %eax,0xc0010860
    kernel_main_task.state = RUNNING;
c00020a6:	c7 05 64 08 01 c0 00 	movl   $0x0,0xc0010864
c00020ad:	00 00 00 
    kernel_main_task.esp = NULL; //this is initialized only on task switch
c00020b0:	c7 05 68 08 01 c0 00 	movl   $0x0,0xc0010868
c00020b7:	00 00 00 
    kernel_main_task.pd = get_page_dir();
c00020ba:	e8 39 13 00 00       	call   c00033f8 <get_page_dir>
c00020bf:	a3 70 08 01 c0       	mov    %eax,0xc0010870

    // this is the only task so far
    //as we add tasks this becomes circular linked list
    kernel_main_task.next_task = &kernel_main_task;
c00020c4:	c7 05 74 08 01 c0 60 	movl   $0xc0010860,0xc0010874
c00020cb:	08 01 c0 
    current_task = &kernel_main_task;
c00020ce:	c7 05 40 08 01 c0 60 	movl   $0xc0010860,0xc0010840
c00020d5:	08 01 c0 
}
c00020d8:	90                   	nop
c00020d9:	c9                   	leave  
c00020da:	c3                   	ret    

c00020db <new_kernel_task>:

task_control_block_t* new_kernel_task(int32_t (*task_entry) (void))
{
c00020db:	55                   	push   %ebp
c00020dc:	89 e5                	mov    %esp,%ebp
c00020de:	83 ec 18             	sub    $0x18,%esp
    task_control_block_t* new_task = kmalloc(sizeof(task_control_block_t));
c00020e1:	83 ec 0c             	sub    $0xc,%esp
c00020e4:	6a 20                	push   $0x20
c00020e6:	e8 41 0b 00 00       	call   c0002c2c <kmalloc>
c00020eb:	83 c4 10             	add    $0x10,%esp
c00020ee:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void* new_stack = kmalloc(KERNEL_STACK_SIZE);
c00020f1:	83 ec 0c             	sub    $0xc,%esp
c00020f4:	68 00 80 00 00       	push   $0x8000
c00020f9:	e8 2e 0b 00 00       	call   c0002c2c <kmalloc>
c00020fe:	83 c4 10             	add    $0x10,%esp
c0002101:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint32_t* esp0 = (uint32_t*) (new_stack + KERNEL_STACK_SIZE);
c0002104:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002107:	05 00 80 00 00       	add    $0x8000,%eax
c000210c:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // init new stack with valid context to launch new task
    *(--esp0) = (uint32_t) new_task; //argument to launch_task
c000210f:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c0002113:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002116:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002119:	89 10                	mov    %edx,(%eax)
    *(--esp0) = (uint32_t) terminate_task; // launch_task() returns to here, to close out task
c000211b:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c000211f:	ba ad 33 00 c0       	mov    $0xc00033ad,%edx
c0002124:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002127:	89 10                	mov    %edx,(%eax)
    *(--esp0) = (uint32_t) launch_task; //common entry function for new tasks
c0002129:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c000212d:	ba 98 22 00 c0       	mov    $0xc0002298,%edx
c0002132:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002135:	89 10                	mov    %edx,(%eax)
    *(--esp0) = 0; //push ebx
c0002137:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c000213b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000213e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp0) = 0; //push esi
c0002144:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c0002148:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000214b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp0) = 0; //push edi
c0002151:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c0002155:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002158:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp0) = 0; //push ebp
c000215e:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c0002162:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002165:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    update_kstack(esp0); //update tss with esp0
c000216b:	83 ec 0c             	sub    $0xc,%esp
c000216e:	ff 75 ec             	pushl  -0x14(%ebp)
c0002171:	e8 99 0d 00 00       	call   c0002f0f <update_kstack>
c0002176:	83 c4 10             	add    $0x10,%esp

    //create copy of kernel page_dir
    void* new_pd = kmalloc_aligned(PAGE_SIZE, PAGE_SIZE);
c0002179:	83 ec 08             	sub    $0x8,%esp
c000217c:	68 00 10 00 00       	push   $0x1000
c0002181:	68 00 10 00 00       	push   $0x1000
c0002186:	e8 dc 09 00 00       	call   c0002b67 <kmalloc_aligned>
c000218b:	83 c4 10             	add    $0x10,%esp
c000218e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    memcpy(new_pd, (void*) &pd->dir,PAGE_SIZE);
c0002191:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c0002196:	05 00 f0 3f 00       	add    $0x3ff000,%eax
c000219b:	83 ec 04             	sub    $0x4,%esp
c000219e:	68 00 10 00 00       	push   $0x1000
c00021a3:	50                   	push   %eax
c00021a4:	ff 75 e8             	pushl  -0x18(%ebp)
c00021a7:	e8 2d f1 ff ff       	call   c00012d9 <memcpy>
c00021ac:	83 c4 10             	add    $0x10,%esp
    new_task->pd = get_physaddr(new_pd); //page dir is physical address.
c00021af:	83 ec 0c             	sub    $0xc,%esp
c00021b2:	ff 75 e8             	pushl  -0x18(%ebp)
c00021b5:	e8 0a 02 00 00       	call   c00023c4 <get_physaddr>
c00021ba:	83 c4 10             	add    $0x10,%esp
c00021bd:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00021c0:	89 42 10             	mov    %eax,0x10(%edx)


    new_task->pid = ++pid_counter;
c00021c3:	a1 80 08 01 c0       	mov    0xc0010880,%eax
c00021c8:	83 c0 01             	add    $0x1,%eax
c00021cb:	a3 80 08 01 c0       	mov    %eax,0xc0010880
c00021d0:	8b 15 80 08 01 c0    	mov    0xc0010880,%edx
c00021d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00021d9:	89 10                	mov    %edx,(%eax)
    new_task->state = WAITING;
c00021db:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00021de:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
    new_task->esp = esp0;
c00021e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00021e8:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00021eb:	89 50 08             	mov    %edx,0x8(%eax)
    new_task->task_entry = task_entry;
c00021ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00021f1:	8b 55 08             	mov    0x8(%ebp),%edx
c00021f4:	89 50 18             	mov    %edx,0x18(%eax)
    new_task->return_val = -1;
c00021f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00021fa:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%eax)

    //insert task into the ll
    new_task->next_task = current_task->next_task;
c0002201:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c0002206:	8b 50 14             	mov    0x14(%eax),%edx
c0002209:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000220c:	89 50 14             	mov    %edx,0x14(%eax)
    current_task->next_task = new_task;
c000220f:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c0002214:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002217:	89 50 14             	mov    %edx,0x14(%eax)

    return new_task;
c000221a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c000221d:	c9                   	leave  
c000221e:	c3                   	ret    

c000221f <yield>:

void yield(void)
{
c000221f:	55                   	push   %ebp
c0002220:	89 e5                	mov    %esp,%ebp
c0002222:	83 ec 08             	sub    $0x8,%esp
    current_task->state = WAITING;
c0002225:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c000222a:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
    current_task->next_task->state = RUNNING;    
c0002231:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c0002236:	8b 40 14             	mov    0x14(%eax),%eax
c0002239:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    switch_to_task(current_task->next_task);
c0002240:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c0002245:	8b 40 14             	mov    0x14(%eax),%eax
c0002248:	83 ec 0c             	sub    $0xc,%esp
c000224b:	50                   	push   %eax
c000224c:	e8 27 11 00 00       	call   c0003378 <switch_to_task>
c0002251:	83 c4 10             	add    $0x10,%esp
}
c0002254:	90                   	nop
c0002255:	c9                   	leave  
c0002256:	c3                   	ret    

c0002257 <join>:

int32_t join(task_control_block_t* task)
{
c0002257:	55                   	push   %ebp
c0002258:	89 e5                	mov    %esp,%ebp
c000225a:	83 ec 08             	sub    $0x8,%esp
    // make sure we are not trying to join the current task or the main kernel task
    if(task == current_task || task == &kernel_main_task)
c000225d:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c0002262:	39 45 08             	cmp    %eax,0x8(%ebp)
c0002265:	74 09                	je     c0002270 <join+0x19>
c0002267:	81 7d 08 60 08 01 c0 	cmpl   $0xc0010860,0x8(%ebp)
c000226e:	75 0c                	jne    c000227c <join+0x25>
        return -1; 
c0002270:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002275:	eb 1f                	jmp    c0002296 <join+0x3f>

    while(task->state == WAITING || task->state == RUNNING)
        yield();
c0002277:	e8 a3 ff ff ff       	call   c000221f <yield>
    while(task->state == WAITING || task->state == RUNNING)
c000227c:	8b 45 08             	mov    0x8(%ebp),%eax
c000227f:	8b 40 04             	mov    0x4(%eax),%eax
c0002282:	83 f8 02             	cmp    $0x2,%eax
c0002285:	74 f0                	je     c0002277 <join+0x20>
c0002287:	8b 45 08             	mov    0x8(%ebp),%eax
c000228a:	8b 40 04             	mov    0x4(%eax),%eax
c000228d:	85 c0                	test   %eax,%eax
c000228f:	74 e6                	je     c0002277 <join+0x20>

    // free task memory: stack, heap and paging structures
    // free tcb? << what should lifetime be?  Want to interrogate after process completes, but dont want it to live forever...
    // before I can do any of this, I need to actually implement free() :)

    return 0;
c0002291:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002296:	c9                   	leave  
c0002297:	c3                   	ret    

c0002298 <launch_task>:


void launch_task(task_control_block_t* task)
{
c0002298:	55                   	push   %ebp
c0002299:	89 e5                	mov    %esp,%ebp
c000229b:	83 ec 18             	sub    $0x18,%esp
    task->state = RUNNING;
c000229e:	8b 45 08             	mov    0x8(%ebp),%eax
c00022a1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

   // call task main function
    task->return_val = (*task->task_entry)();
c00022a8:	8b 45 08             	mov    0x8(%ebp),%eax
c00022ab:	8b 40 18             	mov    0x18(%eax),%eax
c00022ae:	ff d0                	call   *%eax
c00022b0:	8b 55 08             	mov    0x8(%ebp),%edx
c00022b3:	89 42 1c             	mov    %eax,0x1c(%edx)

    //remove this task from active task list
    task_control_block_t* t = task->next_task;
c00022b6:	8b 45 08             	mov    0x8(%ebp),%eax
c00022b9:	8b 40 14             	mov    0x14(%eax),%eax
c00022bc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while( t->next_task != task)
c00022bf:	eb 09                	jmp    c00022ca <launch_task+0x32>
        t = t->next_task;
c00022c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00022c4:	8b 40 14             	mov    0x14(%eax),%eax
c00022c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while( t->next_task != task)
c00022ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00022cd:	8b 40 14             	mov    0x14(%eax),%eax
c00022d0:	39 45 08             	cmp    %eax,0x8(%ebp)
c00022d3:	75 ec                	jne    c00022c1 <launch_task+0x29>
    t->next_task = t->next_task->next_task;
c00022d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00022d8:	8b 40 14             	mov    0x14(%eax),%eax
c00022db:	8b 50 14             	mov    0x14(%eax),%edx
c00022de:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00022e1:	89 50 14             	mov    %edx,0x14(%eax)

    task->state = COMPLETE;
c00022e4:	8b 45 08             	mov    0x8(%ebp),%eax
c00022e7:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)

    // this will "return" to terminite_task 
}
c00022ee:	90                   	nop
c00022ef:	c9                   	leave  
c00022f0:	c3                   	ret    

c00022f1 <num_tasks>:

int num_tasks()
{
c00022f1:	55                   	push   %ebp
c00022f2:	89 e5                	mov    %esp,%ebp
c00022f4:	83 ec 10             	sub    $0x10,%esp
    task_control_block_t* t = current_task;
c00022f7:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c00022fc:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int nn = 1;
c00022ff:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    while( t->next_task != current_task)
c0002306:	eb 0d                	jmp    c0002315 <num_tasks+0x24>
    {
        t = t->next_task;
c0002308:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000230b:	8b 40 14             	mov    0x14(%eax),%eax
c000230e:	89 45 fc             	mov    %eax,-0x4(%ebp)
        nn++;
c0002311:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while( t->next_task != current_task)
c0002315:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002318:	8b 50 14             	mov    0x14(%eax),%edx
c000231b:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c0002320:	39 c2                	cmp    %eax,%edx
c0002322:	75 e4                	jne    c0002308 <num_tasks+0x17>
    }
    return nn;
c0002324:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c0002327:	c9                   	leave  
c0002328:	c3                   	ret    

c0002329 <user_test>:
int user_test()
{
c0002329:	55                   	push   %ebp
c000232a:	89 e5                	mov    %esp,%ebp
c000232c:	83 ec 10             	sub    $0x10,%esp
    int a = 1;
c000232f:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
    int b = 2;
c0002336:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
    int c = b/a;
c000233d:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0002340:	99                   	cltd   
c0002341:	f7 7d fc             	idivl  -0x4(%ebp)
c0002344:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return c;
c0002347:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000234a:	c9                   	leave  
c000234b:	c3                   	ret    

c000234c <get_ptindex>:
//global pointer to page directory
extern page_directory_virt_t* pd;   //initialized in paging_asm.S

// return page table index for virtual address
static inline uint32_t get_ptindex(void* addr)
{
c000234c:	55                   	push   %ebp
c000234d:	89 e5                	mov    %esp,%ebp
    return (((uint32_t) addr) & PAGE_PTE_MASK ) >> 12;
c000234f:	8b 45 08             	mov    0x8(%ebp),%eax
c0002352:	c1 e8 0c             	shr    $0xc,%eax
c0002355:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c000235a:	5d                   	pop    %ebp
c000235b:	c3                   	ret    

c000235c <get_pdindex>:

// return page directory index for virtual address
static inline uint32_t get_pdindex(void* addr)
{
c000235c:	55                   	push   %ebp
c000235d:	89 e5                	mov    %esp,%ebp
    return ((uint32_t) addr) >> 22;
c000235f:	8b 45 08             	mov    0x8(%ebp),%eax
c0002362:	c1 e8 16             	shr    $0x16,%eax
}
c0002365:	5d                   	pop    %ebp
c0002366:	c3                   	ret    

c0002367 <get_page_offset>:

// return offset into page
static inline uint32_t get_page_offset(void* addr)
{
c0002367:	55                   	push   %ebp
c0002368:	89 e5                	mov    %esp,%ebp
    return ((uint32_t) addr) & ~PAGE_ADDRMASK;
c000236a:	8b 45 08             	mov    0x8(%ebp),%eax
c000236d:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c0002372:	5d                   	pop    %ebp
c0002373:	c3                   	ret    

c0002374 <get_table>:

page_directory_virt_t* pd = (page_directory_virt_t*) PD_ADDR;

// return page directory index for virtual address
page_table_t* get_table(void* addr)
{
c0002374:	55                   	push   %ebp
c0002375:	89 e5                	mov    %esp,%ebp
c0002377:	53                   	push   %ebx
c0002378:	83 ec 10             	sub    $0x10,%esp
    uint32_t idx = get_pdindex(addr);
c000237b:	ff 75 08             	pushl  0x8(%ebp)
c000237e:	e8 d9 ff ff ff       	call   c000235c <get_pdindex>
c0002383:	83 c4 04             	add    $0x4,%esp
c0002386:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(pd->dir.pde[idx] & PAGE_FLAG_PRESENT)
c0002389:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c000238e:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0002391:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c0002397:	8b 04 90             	mov    (%eax,%edx,4),%eax
c000239a:	83 e0 01             	and    $0x1,%eax
c000239d:	85 c0                	test   %eax,%eax
c000239f:	74 19                	je     c00023ba <get_table+0x46>
        return pd->tables + get_pdindex(addr);
c00023a1:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c00023a6:	89 c3                	mov    %eax,%ebx
c00023a8:	ff 75 08             	pushl  0x8(%ebp)
c00023ab:	e8 ac ff ff ff       	call   c000235c <get_pdindex>
c00023b0:	83 c4 04             	add    $0x4,%esp
c00023b3:	c1 e0 0c             	shl    $0xc,%eax
c00023b6:	01 d8                	add    %ebx,%eax
c00023b8:	eb 05                	jmp    c00023bf <get_table+0x4b>
    else 
        return NULL;
c00023ba:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00023bf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00023c2:	c9                   	leave  
c00023c3:	c3                   	ret    

c00023c4 <get_physaddr>:

// return physical addr from virt addr
void* get_physaddr(void* addr)
{
c00023c4:	55                   	push   %ebp
c00023c5:	89 e5                	mov    %esp,%ebp
c00023c7:	53                   	push   %ebx
c00023c8:	83 ec 10             	sub    $0x10,%esp
    //check pd entry is present
    uint32_t pdi = get_pdindex(addr);
c00023cb:	ff 75 08             	pushl  0x8(%ebp)
c00023ce:	e8 89 ff ff ff       	call   c000235c <get_pdindex>
c00023d3:	83 c4 04             	add    $0x4,%esp
c00023d6:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(! pd->dir.pde[pdi] & PAGE_FLAG_PRESENT)
c00023d9:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c00023de:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00023e1:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c00023e7:	8b 04 90             	mov    (%eax,%edx,4),%eax
c00023ea:	85 c0                	test   %eax,%eax
c00023ec:	75 07                	jne    c00023f5 <get_physaddr+0x31>
        return NULL;
c00023ee:	b8 00 00 00 00       	mov    $0x0,%eax
c00023f3:	eb 45                	jmp    c000243a <get_physaddr+0x76>

    //check pt entry is present
    uint32_t pte = pd->tables[pdi].pte[get_ptindex(addr)];
c00023f5:	8b 1d 00 50 00 c0    	mov    0xc0005000,%ebx
c00023fb:	ff 75 08             	pushl  0x8(%ebp)
c00023fe:	e8 49 ff ff ff       	call   c000234c <get_ptindex>
c0002403:	83 c4 04             	add    $0x4,%esp
c0002406:	89 c2                	mov    %eax,%edx
c0002408:	8b 45 f8             	mov    -0x8(%ebp),%eax
c000240b:	c1 e0 0a             	shl    $0xa,%eax
c000240e:	01 d0                	add    %edx,%eax
c0002410:	8b 04 83             	mov    (%ebx,%eax,4),%eax
c0002413:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(! pte & PAGE_FLAG_PRESENT)
c0002416:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c000241a:	75 07                	jne    c0002423 <get_physaddr+0x5f>
        return NULL;
c000241c:	b8 00 00 00 00       	mov    $0x0,%eax
c0002421:	eb 17                	jmp    c000243a <get_physaddr+0x76>

    return (void*) ((pte & PAGE_ADDRMASK) +  get_page_offset(addr) );
c0002423:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002426:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c000242b:	89 c3                	mov    %eax,%ebx
c000242d:	ff 75 08             	pushl  0x8(%ebp)
c0002430:	e8 32 ff ff ff       	call   c0002367 <get_page_offset>
c0002435:	83 c4 04             	add    $0x4,%esp
c0002438:	01 d8                	add    %ebx,%eax
}
c000243a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000243d:	c9                   	leave  
c000243e:	c3                   	ret    

c000243f <get_ptindex>:
{
c000243f:	55                   	push   %ebp
c0002440:	89 e5                	mov    %esp,%ebp
    return (((uint32_t) addr) & PAGE_PTE_MASK ) >> 12;
c0002442:	8b 45 08             	mov    0x8(%ebp),%eax
c0002445:	c1 e8 0c             	shr    $0xc,%eax
c0002448:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c000244d:	5d                   	pop    %ebp
c000244e:	c3                   	ret    

c000244f <get_pdindex>:
{
c000244f:	55                   	push   %ebp
c0002450:	89 e5                	mov    %esp,%ebp
    return ((uint32_t) addr) >> 22;
c0002452:	8b 45 08             	mov    0x8(%ebp),%eax
c0002455:	c1 e8 16             	shr    $0x16,%eax
}
c0002458:	5d                   	pop    %ebp
c0002459:	c3                   	ret    

c000245a <align_addr>:
page_t* map_page(page_t* page_virt, uint32_t flags);
page_t* map_page_at(page_t* page_virt, page_t* page_phys, uint32_t flags);
page_table_t* new_page_table(void* addr, uint32_t flags);

static inline void* align_addr(void* addr, uint32_t alignment)
{
c000245a:	55                   	push   %ebp
c000245b:	89 e5                	mov    %esp,%ebp
c000245d:	83 ec 10             	sub    $0x10,%esp
    uint32_t am = alignment - 1;
c0002460:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002463:	83 e8 01             	sub    $0x1,%eax
c0002466:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (char*) (((uint32_t)addr + am) & ~am);
c0002469:	8b 55 08             	mov    0x8(%ebp),%edx
c000246c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000246f:	01 c2                	add    %eax,%edx
c0002471:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002474:	f7 d0                	not    %eax
c0002476:	21 d0                	and    %edx,%eax
}
c0002478:	c9                   	leave  
c0002479:	c3                   	ret    

c000247a <pop_free_page>:
page_t** free_stack_base;   //end of stack data
page_t*  free_stack_brk;   //end of allocated memory for page allocation stack

// allocate a physical page from the stack
page_t* pop_free_page()
{
c000247a:	55                   	push   %ebp
c000247b:	89 e5                	mov    %esp,%ebp
c000247d:	83 ec 10             	sub    $0x10,%esp
    page_t* free_page = *(free_stack_top++);
c0002480:	a1 98 08 01 c0       	mov    0xc0010898,%eax
c0002485:	8d 50 04             	lea    0x4(%eax),%edx
c0002488:	89 15 98 08 01 c0    	mov    %edx,0xc0010898
c000248e:	8b 00                	mov    (%eax),%eax
c0002490:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(free_stack_top<free_stack_base)
c0002493:	8b 15 98 08 01 c0    	mov    0xc0010898,%edx
c0002499:	a1 9c 08 01 c0       	mov    0xc001089c,%eax
c000249e:	39 c2                	cmp    %eax,%edx
c00024a0:	73 05                	jae    c00024a7 <pop_free_page+0x2d>
        return free_page;
c00024a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00024a5:	eb 05                	jmp    c00024ac <pop_free_page+0x32>
    else
        return NULL; //out of memory!    
c00024a7:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00024ac:	c9                   	leave  
c00024ad:	c3                   	ret    

c00024ae <push_free_page>:

// free a physical page back to the stack
int push_free_page(page_t* free_page)
{
c00024ae:	55                   	push   %ebp
c00024af:	89 e5                	mov    %esp,%ebp
    if(free_stack_top<=free_stack_start)
c00024b1:	8b 15 98 08 01 c0    	mov    0xc0010898,%edx
c00024b7:	a1 94 08 01 c0       	mov    0xc0010894,%eax
c00024bc:	39 c2                	cmp    %eax,%edx
c00024be:	77 07                	ja     c00024c7 <push_free_page+0x19>
        return -1;
c00024c0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00024c5:	eb 18                	jmp    c00024df <push_free_page+0x31>

    *(free_stack_top--) = free_page;
c00024c7:	a1 98 08 01 c0       	mov    0xc0010898,%eax
c00024cc:	8d 50 fc             	lea    -0x4(%eax),%edx
c00024cf:	89 15 98 08 01 c0    	mov    %edx,0xc0010898
c00024d5:	8b 55 08             	mov    0x8(%ebp),%edx
c00024d8:	89 10                	mov    %edx,(%eax)
    return 0;
c00024da:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00024df:	5d                   	pop    %ebp
c00024e0:	c3                   	ret    

c00024e1 <init_page_stack>:


// set up a stack will all free pages of physical memory
void init_page_stack(multiboot_info_t* mbd)
{
c00024e1:	55                   	push   %ebp
c00024e2:	89 e5                	mov    %esp,%ebp
c00024e4:	57                   	push   %edi
c00024e5:	56                   	push   %esi
c00024e6:	83 ec 30             	sub    $0x30,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c00024e9:	8b 45 08             	mov    0x8(%ebp),%eax
c00024ec:	8b 40 30             	mov    0x30(%eax),%eax
c00024ef:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // We will start looking for free physical memory just above the kernel
    page_t* first_free_page = align_addr( &_kernel_end_phys, PAGE_SIZE); //physical address of first free page after the kernel
c00024f2:	68 00 10 00 00       	push   $0x1000
c00024f7:	68 88 19 11 00       	push   $0x111988
c00024fc:	e8 59 ff ff ff       	call   c000245a <align_addr>
c0002501:	83 c4 08             	add    $0x8,%esp
c0002504:	89 45 e8             	mov    %eax,-0x18(%ebp)

    // Map the stack just past the end of the kernel in virtual mem

    // stack_break points to the end of the allocated region for the stack  
    free_stack_brk = align_addr( &_kernel_end, PAGE_SIZE);
c0002507:	68 00 10 00 00       	push   $0x1000
c000250c:	68 88 09 01 c0       	push   $0xc0010988
c0002511:	e8 44 ff ff ff       	call   c000245a <align_addr>
c0002516:	83 c4 08             	add    $0x8,%esp
c0002519:	a3 a0 08 01 c0       	mov    %eax,0xc00108a0

    // initialize stack pointers
    // we will initialize the stack by adding new pages to the base
    // first pages (in low mem) will be at top of the stack
    free_stack_start = (page_t**) free_stack_brk;
c000251e:	a1 a0 08 01 c0       	mov    0xc00108a0,%eax
c0002523:	a3 94 08 01 c0       	mov    %eax,0xc0010894
    free_stack_top = free_stack_start;
c0002528:	a1 94 08 01 c0       	mov    0xc0010894,%eax
c000252d:	a3 98 08 01 c0       	mov    %eax,0xc0010898
    free_stack_base = free_stack_top;
c0002532:	a1 98 08 01 c0       	mov    0xc0010898,%eax
c0002537:	a3 9c 08 01 c0       	mov    %eax,0xc001089c

    // allocate one page for the stack, incrementing the stack_break and first_free_page pointers
    // We will allocate more pages for the stack as we go as needed
    if(!map_page_at(free_stack_brk++, first_free_page++, PAGE_FLAG_WRITE))
c000253c:	8b 55 e8             	mov    -0x18(%ebp),%edx
c000253f:	8d 82 00 10 00 00    	lea    0x1000(%edx),%eax
c0002545:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0002548:	a1 a0 08 01 c0       	mov    0xc00108a0,%eax
c000254d:	8d 88 00 10 00 00    	lea    0x1000(%eax),%ecx
c0002553:	89 0d a0 08 01 c0    	mov    %ecx,0xc00108a0
c0002559:	83 ec 04             	sub    $0x4,%esp
c000255c:	6a 02                	push   $0x2
c000255e:	52                   	push   %edx
c000255f:	50                   	push   %eax
c0002560:	e8 48 04 00 00       	call   c00029ad <map_page_at>
c0002565:	83 c4 10             	add    $0x10,%esp
c0002568:	85 c0                	test   %eax,%eax
c000256a:	75 10                	jne    c000257c <init_page_stack+0x9b>
        panic("Error reserving memory for physical page allocation!");
c000256c:	83 ec 0c             	sub    $0xc,%esp
c000256f:	68 c8 46 00 c0       	push   $0xc00046c8
c0002574:	e8 23 ed ff ff       	call   c000129c <panic>
c0002579:	83 c4 10             	add    $0x10,%esp

    // loop through each block of memory defined in the multiboot record
    // for each block of memory, add free pages to stack
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c000257c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0002583:	e9 50 01 00 00       	jmp    c00026d8 <init_page_stack+0x1f7>
	{
        if(mmap_table[nn].size == 0) // end of table
c0002588:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000258b:	89 d0                	mov    %edx,%eax
c000258d:	01 c0                	add    %eax,%eax
c000258f:	01 d0                	add    %edx,%eax
c0002591:	c1 e0 03             	shl    $0x3,%eax
c0002594:	89 c2                	mov    %eax,%edx
c0002596:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002599:	01 d0                	add    %edx,%eax
c000259b:	8b 00                	mov    (%eax),%eax
c000259d:	85 c0                	test   %eax,%eax
c000259f:	0f 84 44 01 00 00    	je     c00026e9 <init_page_stack+0x208>
            break;

        if(mmap_table[nn].addr >> 32) // ignore anything above 32bits
c00025a5:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00025a8:	89 d0                	mov    %edx,%eax
c00025aa:	01 c0                	add    %eax,%eax
c00025ac:	01 d0                	add    %edx,%eax
c00025ae:	c1 e0 03             	shl    $0x3,%eax
c00025b1:	89 c2                	mov    %eax,%edx
c00025b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00025b6:	01 d0                	add    %edx,%eax
c00025b8:	8b 50 08             	mov    0x8(%eax),%edx
c00025bb:	8b 40 04             	mov    0x4(%eax),%eax
c00025be:	89 d0                	mov    %edx,%eax
c00025c0:	31 d2                	xor    %edx,%edx
c00025c2:	89 c1                	mov    %eax,%ecx
c00025c4:	80 f5 00             	xor    $0x0,%ch
c00025c7:	89 ce                	mov    %ecx,%esi
c00025c9:	89 d0                	mov    %edx,%eax
c00025cb:	80 f4 00             	xor    $0x0,%ah
c00025ce:	89 c7                	mov    %eax,%edi
c00025d0:	89 f8                	mov    %edi,%eax
c00025d2:	09 f0                	or     %esi,%eax
c00025d4:	85 c0                	test   %eax,%eax
c00025d6:	0f 85 f7 00 00 00    	jne    c00026d3 <init_page_stack+0x1f2>
            continue;

		if(mmap_table[nn].type == MULTIBOOT_MEMORY_AVAILABLE)
c00025dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00025df:	89 d0                	mov    %edx,%eax
c00025e1:	01 c0                	add    %eax,%eax
c00025e3:	01 d0                	add    %edx,%eax
c00025e5:	c1 e0 03             	shl    $0x3,%eax
c00025e8:	89 c2                	mov    %eax,%edx
c00025ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00025ed:	01 d0                	add    %edx,%eax
c00025ef:	8b 40 14             	mov    0x14(%eax),%eax
c00025f2:	83 f8 01             	cmp    $0x1,%eax
c00025f5:	0f 85 d9 00 00 00    	jne    c00026d4 <init_page_stack+0x1f3>
        {
            //pointers to the first and last page in this memory block 
            size_t block_addr = mmap_table[nn].addr;
c00025fb:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00025fe:	89 d0                	mov    %edx,%eax
c0002600:	01 c0                	add    %eax,%eax
c0002602:	01 d0                	add    %edx,%eax
c0002604:	c1 e0 03             	shl    $0x3,%eax
c0002607:	89 c2                	mov    %eax,%edx
c0002609:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000260c:	01 d0                	add    %edx,%eax
c000260e:	8b 50 08             	mov    0x8(%eax),%edx
c0002611:	8b 40 04             	mov    0x4(%eax),%eax
c0002614:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            size_t block_len = mmap_table[nn].len;
c0002617:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000261a:	89 d0                	mov    %edx,%eax
c000261c:	01 c0                	add    %eax,%eax
c000261e:	01 d0                	add    %edx,%eax
c0002620:	c1 e0 03             	shl    $0x3,%eax
c0002623:	89 c2                	mov    %eax,%edx
c0002625:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002628:	01 d0                	add    %edx,%eax
c000262a:	8b 50 10             	mov    0x10(%eax),%edx
c000262d:	8b 40 0c             	mov    0xc(%eax),%eax
c0002630:	89 45 e0             	mov    %eax,-0x20(%ebp)
            page_t* pg = align_addr( (char*) block_addr, PAGE_SIZE); // first whole page in block
c0002633:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0002636:	83 ec 08             	sub    $0x8,%esp
c0002639:	68 00 10 00 00       	push   $0x1000
c000263e:	50                   	push   %eax
c000263f:	e8 16 fe ff ff       	call   c000245a <align_addr>
c0002644:	83 c4 10             	add    $0x10,%esp
c0002647:	89 45 f0             	mov    %eax,-0x10(%ebp)
            page_t* pg_end = (page_t*) ((block_addr+block_len) & PAGE_ADDRMASK); // first page *after* last whole page in block
c000264a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c000264d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0002650:	01 d0                	add    %edx,%eax
c0002652:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002657:	89 45 dc             	mov    %eax,-0x24(%ebp)

            //don't map any memory before end of the kernel
            pg = pg<first_free_page ? first_free_page : pg; 
c000265a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000265d:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0002660:	0f 43 45 f0          	cmovae -0x10(%ebp),%eax
c0002664:	89 45 f0             	mov    %eax,-0x10(%ebp)

            //fill stack with pointers to each page in the block
            for(; pg<pg_end; pg++)
c0002667:	eb 60                	jmp    c00026c9 <init_page_stack+0x1e8>
            {
                // extend end of stack and make sure we have allocated enough memory
                if( (void*) ++free_stack_base >= (void*) free_stack_brk)
c0002669:	a1 9c 08 01 c0       	mov    0xc001089c,%eax
c000266e:	83 c0 04             	add    $0x4,%eax
c0002671:	a3 9c 08 01 c0       	mov    %eax,0xc001089c
c0002676:	8b 15 9c 08 01 c0    	mov    0xc001089c,%edx
c000267c:	a1 a0 08 01 c0       	mov    0xc00108a0,%eax
c0002681:	39 c2                	cmp    %eax,%edx
c0002683:	72 33                	jb     c00026b8 <init_page_stack+0x1d7>
                {
                    // map a new page at the end of the stack
                    // note that this will pop a free page off the top of the stack
                    if(!map_page(free_stack_brk++, PAGE_FLAG_WRITE))
c0002685:	a1 a0 08 01 c0       	mov    0xc00108a0,%eax
c000268a:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c0002690:	89 15 a0 08 01 c0    	mov    %edx,0xc00108a0
c0002696:	83 ec 08             	sub    $0x8,%esp
c0002699:	6a 02                	push   $0x2
c000269b:	50                   	push   %eax
c000269c:	e8 9c 03 00 00       	call   c0002a3d <map_page>
c00026a1:	83 c4 10             	add    $0x10,%esp
c00026a4:	85 c0                	test   %eax,%eax
c00026a6:	75 10                	jne    c00026b8 <init_page_stack+0x1d7>
                        panic("Error reserving memory for physical page allocation!");
c00026a8:	83 ec 0c             	sub    $0xc,%esp
c00026ab:	68 c8 46 00 c0       	push   $0xc00046c8
c00026b0:	e8 e7 eb ff ff       	call   c000129c <panic>
c00026b5:	83 c4 10             	add    $0x10,%esp
                }

                //record physical page at end stack
                *free_stack_base = pg;
c00026b8:	a1 9c 08 01 c0       	mov    0xc001089c,%eax
c00026bd:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00026c0:	89 10                	mov    %edx,(%eax)
            for(; pg<pg_end; pg++)
c00026c2:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
c00026c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00026cc:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c00026cf:	72 98                	jb     c0002669 <init_page_stack+0x188>
c00026d1:	eb 01                	jmp    c00026d4 <init_page_stack+0x1f3>
            continue;
c00026d3:	90                   	nop
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c00026d4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00026d8:	8b 45 08             	mov    0x8(%ebp),%eax
c00026db:	8b 40 2c             	mov    0x2c(%eax),%eax
c00026de:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c00026e1:	0f 82 a1 fe ff ff    	jb     c0002588 <init_page_stack+0xa7>
c00026e7:	eb 01                	jmp    c00026ea <init_page_stack+0x209>
            break;
c00026e9:	90                   	nop
            }
        }
	}

    size_t free_pages = free_stack_base-free_stack_top;
c00026ea:	a1 9c 08 01 c0       	mov    0xc001089c,%eax
c00026ef:	8b 15 98 08 01 c0    	mov    0xc0010898,%edx
c00026f5:	29 d0                	sub    %edx,%eax
c00026f7:	c1 f8 02             	sar    $0x2,%eax
c00026fa:	89 45 d8             	mov    %eax,-0x28(%ebp)
	kprintf("\nFound %d pages (%f MB)\n", free_pages, free_pages*PAGE_SIZE/1e6);
c00026fd:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0002700:	c1 e0 0c             	shl    $0xc,%eax
c0002703:	89 45 d0             	mov    %eax,-0x30(%ebp)
c0002706:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
c000270d:	df 6d d0             	fildll -0x30(%ebp)
c0002710:	dd 05 40 47 00 c0    	fldl   0xc0004740
c0002716:	de f9                	fdivrp %st,%st(1)
c0002718:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c000271c:	dd 1c 24             	fstpl  (%esp)
c000271f:	ff 75 d8             	pushl  -0x28(%ebp)
c0002722:	68 fd 46 00 c0       	push   $0xc00046fd
c0002727:	e8 53 dd ff ff       	call   c000047f <kprintf>
c000272c:	83 c4 10             	add    $0x10,%esp

}
c000272f:	90                   	nop
c0002730:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0002733:	5e                   	pop    %esi
c0002734:	5f                   	pop    %edi
c0002735:	5d                   	pop    %ebp
c0002736:	c3                   	ret    

c0002737 <ksbrk>:


// increment heap size, return pointer to *old* break (beginning of newly allocated memory)
void* ksbrk(size_t increment)
{
c0002737:	55                   	push   %ebp
c0002738:	89 e5                	mov    %esp,%ebp
c000273a:	83 ec 18             	sub    $0x18,%esp
    if(increment == 0) return kheap_brk;
c000273d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002741:	75 07                	jne    c000274a <ksbrk+0x13>
c0002743:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
c0002748:	eb 2d                	jmp    c0002777 <ksbrk+0x40>

    page_t* old_brk = kheap_brk;
c000274a:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
c000274f:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(kbrk(((char*)kheap_brk) + increment)) return NULL;
c0002752:	8b 15 8c 08 01 c0    	mov    0xc001088c,%edx
c0002758:	8b 45 08             	mov    0x8(%ebp),%eax
c000275b:	01 d0                	add    %edx,%eax
c000275d:	83 ec 0c             	sub    $0xc,%esp
c0002760:	50                   	push   %eax
c0002761:	e8 13 00 00 00       	call   c0002779 <kbrk>
c0002766:	83 c4 10             	add    $0x10,%esp
c0002769:	85 c0                	test   %eax,%eax
c000276b:	74 07                	je     c0002774 <ksbrk+0x3d>
c000276d:	b8 00 00 00 00       	mov    $0x0,%eax
c0002772:	eb 03                	jmp    c0002777 <ksbrk+0x40>

    return old_brk;
c0002774:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0002777:	c9                   	leave  
c0002778:	c3                   	ret    

c0002779 <kbrk>:

// set kheap break to addr, growing or shrinking heap accordingly
// returns 0 on success
int kbrk(void* addr)
{
c0002779:	55                   	push   %ebp
c000277a:	89 e5                	mov    %esp,%ebp
c000277c:	83 ec 18             	sub    $0x18,%esp
    //make sure this is a valid break (not before heap begins or into stack)
    if(addr < (void*) kheap_base || addr >= (void*) kstack_brk)
c000277f:	a1 90 08 01 c0       	mov    0xc0010890,%eax
c0002784:	39 45 08             	cmp    %eax,0x8(%ebp)
c0002787:	72 0a                	jb     c0002793 <kbrk+0x1a>
c0002789:	a1 88 08 01 c0       	mov    0xc0010888,%eax
c000278e:	39 45 08             	cmp    %eax,0x8(%ebp)
c0002791:	72 0a                	jb     c000279d <kbrk+0x24>
        return -1; 
c0002793:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002798:	e9 a5 00 00 00       	jmp    c0002842 <kbrk+0xc9>

    page_t* pg_addr = align_addr(addr, PAGE_SIZE); // align addr to a page
c000279d:	68 00 10 00 00       	push   $0x1000
c00027a2:	ff 75 08             	pushl  0x8(%ebp)
c00027a5:	e8 b0 fc ff ff       	call   c000245a <align_addr>
c00027aa:	83 c4 08             	add    $0x8,%esp
c00027ad:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(pg_addr > kheap_brk)
c00027b0:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
c00027b5:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c00027b8:	76 63                	jbe    c000281d <kbrk+0xa4>
    {
        // we are increasing size of the heap
        while(pg_addr > kheap_brk)
c00027ba:	eb 2a                	jmp    c00027e6 <kbrk+0x6d>
        {
            // allocate a new page and map to end of heap
            if(!map_page(kheap_brk++, PAGE_FLAG_WRITE))
c00027bc:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
c00027c1:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c00027c7:	89 15 8c 08 01 c0    	mov    %edx,0xc001088c
c00027cd:	83 ec 08             	sub    $0x8,%esp
c00027d0:	6a 02                	push   $0x2
c00027d2:	50                   	push   %eax
c00027d3:	e8 65 02 00 00       	call   c0002a3d <map_page>
c00027d8:	83 c4 10             	add    $0x10,%esp
c00027db:	85 c0                	test   %eax,%eax
c00027dd:	75 07                	jne    c00027e6 <kbrk+0x6d>
                return -1; // out of physical memory
c00027df:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00027e4:	eb 5c                	jmp    c0002842 <kbrk+0xc9>
        while(pg_addr > kheap_brk)
c00027e6:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
c00027eb:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c00027ee:	77 cc                	ja     c00027bc <kbrk+0x43>
c00027f0:	eb 35                	jmp    c0002827 <kbrk+0xae>
    {
        // we are decreasing size of the heap
        while(pg_addr < kheap_brk)
        {
            //free page from end of heap
            if(unmap_page(--kheap_brk))
c00027f2:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
c00027f7:	2d 00 10 00 00       	sub    $0x1000,%eax
c00027fc:	a3 8c 08 01 c0       	mov    %eax,0xc001088c
c0002801:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
c0002806:	83 ec 0c             	sub    $0xc,%esp
c0002809:	50                   	push   %eax
c000280a:	e8 4d 02 00 00       	call   c0002a5c <unmap_page>
c000280f:	83 c4 10             	add    $0x10,%esp
c0002812:	85 c0                	test   %eax,%eax
c0002814:	74 07                	je     c000281d <kbrk+0xa4>
                return -1; // error!
c0002816:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000281b:	eb 25                	jmp    c0002842 <kbrk+0xc9>
        while(pg_addr < kheap_brk)
c000281d:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
c0002822:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0002825:	72 cb                	jb     c00027f2 <kbrk+0x79>
        }
    }

	kprintf("Setting kernel heap break to 0x%x\n", kheap_brk);
c0002827:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
c000282c:	83 ec 08             	sub    $0x8,%esp
c000282f:	50                   	push   %eax
c0002830:	68 18 47 00 c0       	push   $0xc0004718
c0002835:	e8 45 dc ff ff       	call   c000047f <kprintf>
c000283a:	83 c4 10             	add    $0x10,%esp
    
    return 0;
c000283d:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002842:	c9                   	leave  
c0002843:	c3                   	ret    

c0002844 <memory_init>:


int memory_init(multiboot_info_t* mbd)
{
c0002844:	55                   	push   %ebp
c0002845:	89 e5                	mov    %esp,%ebp
c0002847:	83 ec 08             	sub    $0x8,%esp
    init_page_stack(mbd);
c000284a:	83 ec 0c             	sub    $0xc,%esp
c000284d:	ff 75 08             	pushl  0x8(%ebp)
c0002850:	e8 8c fc ff ff       	call   c00024e1 <init_page_stack>
c0002855:	83 c4 10             	add    $0x10,%esp

    // define some dummy pointers for where we will put the stack
    // TODO: actually set up a stack here
    kstack_base = (page_t*) 0xffb00000; 
c0002858:	c7 05 84 08 01 c0 00 	movl   $0xffb00000,0xc0010884
c000285f:	00 b0 ff 
    kstack_brk = (page_t*)  0xf0000000;
c0002862:	c7 05 88 08 01 c0 00 	movl   $0xf0000000,0xc0010888
c0002869:	00 00 f0 

    kheap_base = free_stack_brk; //start heap after the page stack allocator
c000286c:	a1 a0 08 01 c0       	mov    0xc00108a0,%eax
c0002871:	a3 90 08 01 c0       	mov    %eax,0xc0010890
    kheap_brk = kheap_base;     // heap starts empty - increase with ksbrk
c0002876:	a1 90 08 01 c0       	mov    0xc0010890,%eax
c000287b:	a3 8c 08 01 c0       	mov    %eax,0xc001088c

    // we don't need the 1st MB anymore so unmap it
	if( unmap_lowmem() )
c0002880:	e8 22 00 00 00       	call   c00028a7 <unmap_lowmem>
c0002885:	85 c0                	test   %eax,%eax
c0002887:	74 07                	je     c0002890 <memory_init+0x4c>
        return -1;
c0002889:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000288e:	eb 15                	jmp    c00028a5 <memory_init+0x61>

    // except for VGA memory - still need that..
	if(! map_vga() )
c0002890:	e8 33 00 00 00       	call   c00028c8 <map_vga>
c0002895:	85 c0                	test   %eax,%eax
c0002897:	75 07                	jne    c00028a0 <memory_init+0x5c>
        return -1;
c0002899:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000289e:	eb 05                	jmp    c00028a5 <memory_init+0x61>

    return 0;
c00028a0:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00028a5:	c9                   	leave  
c00028a6:	c3                   	ret    

c00028a7 <unmap_lowmem>:

int unmap_lowmem()
{
c00028a7:	55                   	push   %ebp
c00028a8:	89 e5                	mov    %esp,%ebp
c00028aa:	83 ec 08             	sub    $0x8,%esp
    pd->dir.pde[0] = PAGE_FLAG_EMPTY;
c00028ad:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c00028b2:	c7 80 00 f0 3f 00 00 	movl   $0x0,0x3ff000(%eax)
c00028b9:	00 00 00 
    refresh_tlb();
c00028bc:	e8 3b 0b 00 00       	call   c00033fc <refresh_tlb>
    return 0;
c00028c1:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00028c6:	c9                   	leave  
c00028c7:	c3                   	ret    

c00028c8 <map_vga>:
// {

// }

char* map_vga()
{
c00028c8:	55                   	push   %ebp
c00028c9:	89 e5                	mov    %esp,%ebp
c00028cb:	83 ec 18             	sub    $0x18,%esp
    page_t* vga_buf = (page_t*) VGA_BUFFER;
c00028ce:	c7 45 f4 00 80 0b 00 	movl   $0xb8000,-0xc(%ebp)

    //map 6 pages of vga memory    
    map_page_at(vga_buf,vga_buf, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c00028d5:	83 ec 04             	sub    $0x4,%esp
c00028d8:	6a 06                	push   $0x6
c00028da:	ff 75 f4             	pushl  -0xc(%ebp)
c00028dd:	ff 75 f4             	pushl  -0xc(%ebp)
c00028e0:	e8 c8 00 00 00       	call   c00029ad <map_page_at>
c00028e5:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+1,vga_buf+1, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c00028e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00028eb:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c00028f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00028f4:	05 00 10 00 00       	add    $0x1000,%eax
c00028f9:	83 ec 04             	sub    $0x4,%esp
c00028fc:	6a 06                	push   $0x6
c00028fe:	52                   	push   %edx
c00028ff:	50                   	push   %eax
c0002900:	e8 a8 00 00 00       	call   c00029ad <map_page_at>
c0002905:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+2,vga_buf+2, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c0002908:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000290b:	8d 90 00 20 00 00    	lea    0x2000(%eax),%edx
c0002911:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002914:	05 00 20 00 00       	add    $0x2000,%eax
c0002919:	83 ec 04             	sub    $0x4,%esp
c000291c:	6a 06                	push   $0x6
c000291e:	52                   	push   %edx
c000291f:	50                   	push   %eax
c0002920:	e8 88 00 00 00       	call   c00029ad <map_page_at>
c0002925:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+3,vga_buf+3, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c0002928:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000292b:	8d 90 00 30 00 00    	lea    0x3000(%eax),%edx
c0002931:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002934:	05 00 30 00 00       	add    $0x3000,%eax
c0002939:	83 ec 04             	sub    $0x4,%esp
c000293c:	6a 06                	push   $0x6
c000293e:	52                   	push   %edx
c000293f:	50                   	push   %eax
c0002940:	e8 68 00 00 00       	call   c00029ad <map_page_at>
c0002945:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+4,vga_buf+4, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c0002948:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000294b:	8d 90 00 40 00 00    	lea    0x4000(%eax),%edx
c0002951:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002954:	05 00 40 00 00       	add    $0x4000,%eax
c0002959:	83 ec 04             	sub    $0x4,%esp
c000295c:	6a 06                	push   $0x6
c000295e:	52                   	push   %edx
c000295f:	50                   	push   %eax
c0002960:	e8 48 00 00 00       	call   c00029ad <map_page_at>
c0002965:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+5,vga_buf+5, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c0002968:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000296b:	8d 90 00 50 00 00    	lea    0x5000(%eax),%edx
c0002971:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002974:	05 00 50 00 00       	add    $0x5000,%eax
c0002979:	83 ec 04             	sub    $0x4,%esp
c000297c:	6a 06                	push   $0x6
c000297e:	52                   	push   %edx
c000297f:	50                   	push   %eax
c0002980:	e8 28 00 00 00       	call   c00029ad <map_page_at>
c0002985:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+6,vga_buf+6, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c0002988:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000298b:	8d 90 00 60 00 00    	lea    0x6000(%eax),%edx
c0002991:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002994:	05 00 60 00 00       	add    $0x6000,%eax
c0002999:	83 ec 04             	sub    $0x4,%esp
c000299c:	6a 06                	push   $0x6
c000299e:	52                   	push   %edx
c000299f:	50                   	push   %eax
c00029a0:	e8 08 00 00 00       	call   c00029ad <map_page_at>
c00029a5:	83 c4 10             	add    $0x10,%esp

    return (char*) vga_buf;
c00029a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00029ab:	c9                   	leave  
c00029ac:	c3                   	ret    

c00029ad <map_page_at>:

page_t* map_page_at(page_t* page_virt, page_t* page_phys, uint32_t flags)
{
c00029ad:	55                   	push   %ebp
c00029ae:	89 e5                	mov    %esp,%ebp
c00029b0:	53                   	push   %ebx
c00029b1:	83 ec 14             	sub    $0x14,%esp
    page_table_t* pt = get_table(page_virt);
c00029b4:	83 ec 0c             	sub    $0xc,%esp
c00029b7:	ff 75 08             	pushl  0x8(%ebp)
c00029ba:	e8 b5 f9 ff ff       	call   c0002374 <get_table>
c00029bf:	83 c4 10             	add    $0x10,%esp
c00029c2:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(!pt)
c00029c5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00029c9:	75 14                	jne    c00029df <map_page_at+0x32>
        pt = new_page_table(page_virt, flags); // page table is not present, allocate a new one
c00029cb:	83 ec 08             	sub    $0x8,%esp
c00029ce:	ff 75 10             	pushl  0x10(%ebp)
c00029d1:	ff 75 08             	pushl  0x8(%ebp)
c00029d4:	e8 a5 00 00 00       	call   c0002a7e <new_page_table>
c00029d9:	83 c4 10             	add    $0x10,%esp
c00029dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    
    if(pt->pte[get_ptindex(page_virt)] & PAGE_FLAG_PRESENT)
c00029df:	83 ec 0c             	sub    $0xc,%esp
c00029e2:	ff 75 08             	pushl  0x8(%ebp)
c00029e5:	e8 55 fa ff ff       	call   c000243f <get_ptindex>
c00029ea:	83 c4 10             	add    $0x10,%esp
c00029ed:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00029f0:	8b 04 82             	mov    (%edx,%eax,4),%eax
c00029f3:	83 e0 01             	and    $0x1,%eax
c00029f6:	85 c0                	test   %eax,%eax
c00029f8:	74 07                	je     c0002a01 <map_page_at+0x54>
        return NULL; //page already mapped
c00029fa:	b8 00 00 00 00       	mov    $0x0,%eax
c00029ff:	eb 37                	jmp    c0002a38 <map_page_at+0x8b>

    // map page
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0002a01:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002a04:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002a09:	0b 45 10             	or     0x10(%ebp),%eax
c0002a0c:	89 c3                	mov    %eax,%ebx
c0002a0e:	83 ec 0c             	sub    $0xc,%esp
c0002a11:	ff 75 08             	pushl  0x8(%ebp)
c0002a14:	e8 26 fa ff ff       	call   c000243f <get_ptindex>
c0002a19:	83 c4 10             	add    $0x10,%esp
c0002a1c:	89 d9                	mov    %ebx,%ecx
c0002a1e:	83 c9 01             	or     $0x1,%ecx
c0002a21:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002a24:	89 0c 82             	mov    %ecx,(%edx,%eax,4)

    refresh_page(page_virt);
c0002a27:	83 ec 0c             	sub    $0xc,%esp
c0002a2a:	ff 75 08             	pushl  0x8(%ebp)
c0002a2d:	e8 d2 09 00 00       	call   c0003404 <refresh_page>
c0002a32:	83 c4 10             	add    $0x10,%esp
    return page_virt;
c0002a35:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0002a38:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0002a3b:	c9                   	leave  
c0002a3c:	c3                   	ret    

c0002a3d <map_page>:

page_t* map_page(page_t* page_virt, uint32_t flags)
{
c0002a3d:	55                   	push   %ebp
c0002a3e:	89 e5                	mov    %esp,%ebp
c0002a40:	83 ec 08             	sub    $0x8,%esp
    return map_page_at(page_virt, pop_free_page(), flags);
c0002a43:	e8 32 fa ff ff       	call   c000247a <pop_free_page>
c0002a48:	83 ec 04             	sub    $0x4,%esp
c0002a4b:	ff 75 0c             	pushl  0xc(%ebp)
c0002a4e:	50                   	push   %eax
c0002a4f:	ff 75 08             	pushl  0x8(%ebp)
c0002a52:	e8 56 ff ff ff       	call   c00029ad <map_page_at>
c0002a57:	83 c4 10             	add    $0x10,%esp
}
c0002a5a:	c9                   	leave  
c0002a5b:	c3                   	ret    

c0002a5c <unmap_page>:

int unmap_page(page_t* page_virt)
{
c0002a5c:	55                   	push   %ebp
c0002a5d:	89 e5                	mov    %esp,%ebp
c0002a5f:	83 ec 08             	sub    $0x8,%esp
    return push_free_page(get_physaddr(page_virt));
c0002a62:	83 ec 0c             	sub    $0xc,%esp
c0002a65:	ff 75 08             	pushl  0x8(%ebp)
c0002a68:	e8 57 f9 ff ff       	call   c00023c4 <get_physaddr>
c0002a6d:	83 c4 10             	add    $0x10,%esp
c0002a70:	83 ec 0c             	sub    $0xc,%esp
c0002a73:	50                   	push   %eax
c0002a74:	e8 35 fa ff ff       	call   c00024ae <push_free_page>
c0002a79:	83 c4 10             	add    $0x10,%esp
}
c0002a7c:	c9                   	leave  
c0002a7d:	c3                   	ret    

c0002a7e <new_page_table>:

page_table_t* new_page_table(void* addr, uint32_t flags)
{
c0002a7e:	55                   	push   %ebp
c0002a7f:	89 e5                	mov    %esp,%ebp
c0002a81:	83 ec 18             	sub    $0x18,%esp
    uint32_t pdindex = get_pdindex(addr);      // index into page dir (which table does this address point to)
c0002a84:	ff 75 08             	pushl  0x8(%ebp)
c0002a87:	e8 c3 f9 ff ff       	call   c000244f <get_pdindex>
c0002a8c:	83 c4 04             	add    $0x4,%esp
c0002a8f:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // is this table already mapped?
    if(pd->dir.pde[pdindex] & PAGE_FLAG_PRESENT)
c0002a92:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c0002a97:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002a9a:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c0002aa0:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0002aa3:	83 e0 01             	and    $0x1,%eax
c0002aa6:	85 c0                	test   %eax,%eax
c0002aa8:	74 07                	je     c0002ab1 <new_page_table+0x33>
        return NULL;
c0002aaa:	b8 00 00 00 00       	mov    $0x0,%eax
c0002aaf:	eb 70                	jmp    c0002b21 <new_page_table+0xa3>

    page_t* pp = pop_free_page();         // find a free page in physical mem for page table
c0002ab1:	e8 c4 f9 ff ff       	call   c000247a <pop_free_page>
c0002ab6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!pp) return NULL; // OOM
c0002ab9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0002abd:	75 07                	jne    c0002ac6 <new_page_table+0x48>
c0002abf:	b8 00 00 00 00       	mov    $0x0,%eax
c0002ac4:	eb 5b                	jmp    c0002b21 <new_page_table+0xa3>

    // we don't need to allocate virtual memory space, since table lives in our paging structure
    page_table_t* pv = pd->tables + pdindex;        // pointer to table (virtual)
c0002ac6:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c0002acb:	89 c2                	mov    %eax,%edx
c0002acd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002ad0:	c1 e0 0c             	shl    $0xc,%eax
c0002ad3:	01 d0                	add    %edx,%eax
c0002ad5:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // map table: point the pd entry at the physical page we just reserved, and set flags
    pd->dir.pde[pdindex] = (((uint32_t) pp) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0002ad8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002adb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002ae0:	0b 45 0c             	or     0xc(%ebp),%eax
c0002ae3:	89 c2                	mov    %eax,%edx
c0002ae5:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c0002aea:	89 d1                	mov    %edx,%ecx
c0002aec:	83 c9 01             	or     $0x1,%ecx
c0002aef:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002af2:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c0002af8:	89 0c 90             	mov    %ecx,(%eax,%edx,4)

    // flush the tlb
    refresh_page(pv);
c0002afb:	83 ec 0c             	sub    $0xc,%esp
c0002afe:	ff 75 ec             	pushl  -0x14(%ebp)
c0002b01:	e8 fe 08 00 00       	call   c0003404 <refresh_page>
c0002b06:	83 c4 10             	add    $0x10,%esp

    //clear table
    memset((char*) pv, 0, PAGE_SIZE);     
c0002b09:	83 ec 04             	sub    $0x4,%esp
c0002b0c:	68 00 10 00 00       	push   $0x1000
c0002b11:	6a 00                	push   $0x0
c0002b13:	ff 75 ec             	pushl  -0x14(%ebp)
c0002b16:	e8 63 e8 ff ff       	call   c000137e <memset>
c0002b1b:	83 c4 10             	add    $0x10,%esp

    // return pointer to table (virtual)
    return pv;
c0002b1e:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c0002b21:	c9                   	leave  
c0002b22:	c3                   	ret    

c0002b23 <align_addr>:
{
c0002b23:	55                   	push   %ebp
c0002b24:	89 e5                	mov    %esp,%ebp
c0002b26:	83 ec 10             	sub    $0x10,%esp
    uint32_t am = alignment - 1;
c0002b29:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002b2c:	83 e8 01             	sub    $0x1,%eax
c0002b2f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (char*) (((uint32_t)addr + am) & ~am);
c0002b32:	8b 55 08             	mov    0x8(%ebp),%edx
c0002b35:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002b38:	01 c2                	add    %eax,%edx
c0002b3a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002b3d:	f7 d0                	not    %eax
c0002b3f:	21 d0                	and    %edx,%eax
}
c0002b41:	c9                   	leave  
c0002b42:	c3                   	ret    

c0002b43 <is_pow_of_two>:

static inline int is_pow_of_two(uint32_t x)
{
c0002b43:	55                   	push   %ebp
c0002b44:	89 e5                	mov    %esp,%ebp
    return (x != 0) && ((x & (x - 1)) == 0);
c0002b46:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002b4a:	74 14                	je     c0002b60 <is_pow_of_two+0x1d>
c0002b4c:	8b 45 08             	mov    0x8(%ebp),%eax
c0002b4f:	83 e8 01             	sub    $0x1,%eax
c0002b52:	23 45 08             	and    0x8(%ebp),%eax
c0002b55:	85 c0                	test   %eax,%eax
c0002b57:	75 07                	jne    c0002b60 <is_pow_of_two+0x1d>
c0002b59:	b8 01 00 00 00       	mov    $0x1,%eax
c0002b5e:	eb 05                	jmp    c0002b65 <is_pow_of_two+0x22>
c0002b60:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002b65:	5d                   	pop    %ebp
c0002b66:	c3                   	ret    

c0002b67 <kmalloc_aligned>:
#include "mman.h"

void* kheap = NULL;

void* kmalloc_aligned(size_t sz, size_t alignment)
{
c0002b67:	55                   	push   %ebp
c0002b68:	89 e5                	mov    %esp,%ebp
c0002b6a:	83 ec 18             	sub    $0x18,%esp
    if( sz == 0 || alignment < sizeof(size_t) || !is_pow_of_two(alignment) ) return NULL;
c0002b6d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002b71:	74 15                	je     c0002b88 <kmalloc_aligned+0x21>
c0002b73:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
c0002b77:	76 0f                	jbe    c0002b88 <kmalloc_aligned+0x21>
c0002b79:	ff 75 0c             	pushl  0xc(%ebp)
c0002b7c:	e8 c2 ff ff ff       	call   c0002b43 <is_pow_of_two>
c0002b81:	83 c4 04             	add    $0x4,%esp
c0002b84:	85 c0                	test   %eax,%eax
c0002b86:	75 0a                	jne    c0002b92 <kmalloc_aligned+0x2b>
c0002b88:	b8 00 00 00 00       	mov    $0x0,%eax
c0002b8d:	e9 98 00 00 00       	jmp    c0002c2a <kmalloc_aligned+0xc3>

    if(!kheap)
c0002b92:	a1 a4 08 01 c0       	mov    0xc00108a4,%eax
c0002b97:	85 c0                	test   %eax,%eax
c0002b99:	75 22                	jne    c0002bbd <kmalloc_aligned+0x56>
    {
        kheap = ksbrk(0);
c0002b9b:	83 ec 0c             	sub    $0xc,%esp
c0002b9e:	6a 00                	push   $0x0
c0002ba0:	e8 92 fb ff ff       	call   c0002737 <ksbrk>
c0002ba5:	83 c4 10             	add    $0x10,%esp
c0002ba8:	a3 a4 08 01 c0       	mov    %eax,0xc00108a4
        if(!kheap) return NULL;
c0002bad:	a1 a4 08 01 c0       	mov    0xc00108a4,%eax
c0002bb2:	85 c0                	test   %eax,%eax
c0002bb4:	75 07                	jne    c0002bbd <kmalloc_aligned+0x56>
c0002bb6:	b8 00 00 00 00       	mov    $0x0,%eax
c0002bbb:	eb 6d                	jmp    c0002c2a <kmalloc_aligned+0xc3>
    }

    // just keep track of pointer at end of allocated heap, and add new allocations on end
    // note - this won't let us free!
    void* mem = align_addr(kheap, alignment); //start of requested region
c0002bbd:	a1 a4 08 01 c0       	mov    0xc00108a4,%eax
c0002bc2:	83 ec 08             	sub    $0x8,%esp
c0002bc5:	ff 75 0c             	pushl  0xc(%ebp)
c0002bc8:	50                   	push   %eax
c0002bc9:	e8 55 ff ff ff       	call   c0002b23 <align_addr>
c0002bce:	83 c4 10             	add    $0x10,%esp
c0002bd1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void* mem_end = align_addr(mem+sz, alignment); //end of requested region
c0002bd4:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002bd7:	8b 45 08             	mov    0x8(%ebp),%eax
c0002bda:	01 d0                	add    %edx,%eax
c0002bdc:	83 ec 08             	sub    $0x8,%esp
c0002bdf:	ff 75 0c             	pushl  0xc(%ebp)
c0002be2:	50                   	push   %eax
c0002be3:	e8 3b ff ff ff       	call   c0002b23 <align_addr>
c0002be8:	83 c4 10             	add    $0x10,%esp
c0002beb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    
    // if this allocation exceeds the current heap, request more heap
    void* kheap_brk = ksbrk(0);
c0002bee:	83 ec 0c             	sub    $0xc,%esp
c0002bf1:	6a 00                	push   $0x0
c0002bf3:	e8 3f fb ff ff       	call   c0002737 <ksbrk>
c0002bf8:	83 c4 10             	add    $0x10,%esp
c0002bfb:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(mem_end > kheap_brk)
c0002bfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002c01:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0002c04:	76 19                	jbe    c0002c1f <kmalloc_aligned+0xb8>
        if(kbrk(mem_end))
c0002c06:	83 ec 0c             	sub    $0xc,%esp
c0002c09:	ff 75 f0             	pushl  -0x10(%ebp)
c0002c0c:	e8 68 fb ff ff       	call   c0002779 <kbrk>
c0002c11:	83 c4 10             	add    $0x10,%esp
c0002c14:	85 c0                	test   %eax,%eax
c0002c16:	74 07                	je     c0002c1f <kmalloc_aligned+0xb8>
            return NULL;
c0002c18:	b8 00 00 00 00       	mov    $0x0,%eax
c0002c1d:	eb 0b                	jmp    c0002c2a <kmalloc_aligned+0xc3>

    kheap = mem_end;    //update heap pointer;
c0002c1f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002c22:	a3 a4 08 01 c0       	mov    %eax,0xc00108a4

    return mem;
c0002c27:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0002c2a:	c9                   	leave  
c0002c2b:	c3                   	ret    

c0002c2c <kmalloc>:


void* kmalloc(size_t sz)
{
c0002c2c:	55                   	push   %ebp
c0002c2d:	89 e5                	mov    %esp,%ebp
c0002c2f:	83 ec 08             	sub    $0x8,%esp
    return kmalloc_aligned(sz, 4);
c0002c32:	83 ec 08             	sub    $0x8,%esp
c0002c35:	6a 04                	push   $0x4
c0002c37:	ff 75 08             	pushl  0x8(%ebp)
c0002c3a:	e8 28 ff ff ff       	call   c0002b67 <kmalloc_aligned>
c0002c3f:	83 c4 10             	add    $0x10,%esp
}
c0002c42:	c9                   	leave  
c0002c43:	c3                   	ret    

c0002c44 <scancode_to_ascii>:
    0,  /* F12 Key */
    0,  /* All other keys are undefined */
};

char scancode_to_ascii(uint8_t scancode)
{
c0002c44:	55                   	push   %ebp
c0002c45:	89 e5                	mov    %esp,%ebp
c0002c47:	83 ec 04             	sub    $0x4,%esp
c0002c4a:	8b 45 08             	mov    0x8(%ebp),%eax
c0002c4d:	88 45 fc             	mov    %al,-0x4(%ebp)
    return kbd_US[scancode];
c0002c50:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0002c54:	0f b6 80 20 50 00 c0 	movzbl -0x3fffafe0(%eax),%eax
}
c0002c5b:	c9                   	leave  
c0002c5c:	c3                   	ret    

c0002c5d <test_multitasking2>:
#if defined(__linux__)  || !defined(__i386__)
#error "This kernel requires ix86-elf cross compiler"
#endif

int32_t test_multitasking2()
{
c0002c5d:	55                   	push   %ebp
c0002c5e:	89 e5                	mov    %esp,%ebp
c0002c60:	83 ec 18             	sub    $0x18,%esp
	int nn;
	for(nn=0;nn<5;nn++)
c0002c63:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0002c6a:	eb 22                	jmp    c0002c8e <test_multitasking2+0x31>
	{
		kprintf("task 2, count %d, [%d active tasks]\n", nn, num_tasks());
c0002c6c:	e8 80 f6 ff ff       	call   c00022f1 <num_tasks>
c0002c71:	83 ec 04             	sub    $0x4,%esp
c0002c74:	50                   	push   %eax
c0002c75:	ff 75 f4             	pushl  -0xc(%ebp)
c0002c78:	68 48 47 00 c0       	push   $0xc0004748
c0002c7d:	e8 fd d7 ff ff       	call   c000047f <kprintf>
c0002c82:	83 c4 10             	add    $0x10,%esp
		yield();
c0002c85:	e8 95 f5 ff ff       	call   c000221f <yield>
	for(nn=0;nn<5;nn++)
c0002c8a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0002c8e:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
c0002c92:	7e d8                	jle    c0002c6c <test_multitasking2+0xf>
	}
	return nn;
c0002c94:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0002c97:	c9                   	leave  
c0002c98:	c3                   	ret    

c0002c99 <test_multitasking1>:

void test_multitasking1()
{
c0002c99:	55                   	push   %ebp
c0002c9a:	89 e5                	mov    %esp,%ebp
c0002c9c:	83 ec 18             	sub    $0x18,%esp
	task_control_block_t* task2 = new_kernel_task( &test_multitasking2 );
c0002c9f:	83 ec 0c             	sub    $0xc,%esp
c0002ca2:	68 5d 2c 00 c0       	push   $0xc0002c5d
c0002ca7:	e8 2f f4 ff ff       	call   c00020db <new_kernel_task>
c0002cac:	83 c4 10             	add    $0x10,%esp
c0002caf:	89 45 f0             	mov    %eax,-0x10(%ebp)

	int nn;
	for(nn=0;nn<10;nn++)
c0002cb2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0002cb9:	eb 22                	jmp    c0002cdd <test_multitasking1+0x44>
	{
		kprintf("task 1, count %d  [%d active tasks]\n", nn, num_tasks());
c0002cbb:	e8 31 f6 ff ff       	call   c00022f1 <num_tasks>
c0002cc0:	83 ec 04             	sub    $0x4,%esp
c0002cc3:	50                   	push   %eax
c0002cc4:	ff 75 f4             	pushl  -0xc(%ebp)
c0002cc7:	68 70 47 00 c0       	push   $0xc0004770
c0002ccc:	e8 ae d7 ff ff       	call   c000047f <kprintf>
c0002cd1:	83 c4 10             	add    $0x10,%esp
		yield();
c0002cd4:	e8 46 f5 ff ff       	call   c000221f <yield>
	for(nn=0;nn<10;nn++)
c0002cd9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0002cdd:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c0002ce1:	7e d8                	jle    c0002cbb <test_multitasking1+0x22>
	}	

	kprintf("Waiting for task 2...\n");	
c0002ce3:	83 ec 0c             	sub    $0xc,%esp
c0002ce6:	68 95 47 00 c0       	push   $0xc0004795
c0002ceb:	e8 8f d7 ff ff       	call   c000047f <kprintf>
c0002cf0:	83 c4 10             	add    $0x10,%esp
	join(task2);
c0002cf3:	83 ec 0c             	sub    $0xc,%esp
c0002cf6:	ff 75 f0             	pushl  -0x10(%ebp)
c0002cf9:	e8 59 f5 ff ff       	call   c0002257 <join>
c0002cfe:	83 c4 10             	add    $0x10,%esp
	kprintf("Task 2 complete, ran %dx\n", task2->return_val);
c0002d01:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002d04:	8b 40 1c             	mov    0x1c(%eax),%eax
c0002d07:	83 ec 08             	sub    $0x8,%esp
c0002d0a:	50                   	push   %eax
c0002d0b:	68 ac 47 00 c0       	push   $0xc00047ac
c0002d10:	e8 6a d7 ff ff       	call   c000047f <kprintf>
c0002d15:	83 c4 10             	add    $0x10,%esp
}
c0002d18:	90                   	nop
c0002d19:	c9                   	leave  
c0002d1a:	c3                   	ret    

c0002d1b <kernel_main>:

void kernel_main(multiboot_info_t* mbd)
{
c0002d1b:	55                   	push   %ebp
c0002d1c:	89 e5                	mov    %esp,%ebp
c0002d1e:	83 ec 08             	sub    $0x8,%esp
	init_gdt();
c0002d21:	e8 2e 01 00 00       	call   c0002e54 <init_gdt>
	init_interrupts();
c0002d26:	e8 7c ee ff ff       	call   c0001ba7 <init_interrupts>

	terminal_init(&stdout);
c0002d2b:	83 ec 0c             	sub    $0xc,%esp
c0002d2e:	68 00 00 01 c0       	push   $0xc0010000
c0002d33:	e8 20 d3 ff ff       	call   c0000058 <terminal_init>
c0002d38:	83 c4 10             	add    $0x10,%esp

    // terminal_setcolor(&stdout, VGA_COLOR_WHITE);
	kprintf("Let's learn about Operating Systems!\n");
c0002d3b:	83 ec 0c             	sub    $0xc,%esp
c0002d3e:	68 c8 47 00 c0       	push   $0xc00047c8
c0002d43:	e8 37 d7 ff ff       	call   c000047f <kprintf>
c0002d48:	83 c4 10             	add    $0x10,%esp
	kprintf("Jon Doane, 2020\n\n");
c0002d4b:	83 ec 0c             	sub    $0xc,%esp
c0002d4e:	68 ee 47 00 c0       	push   $0xc00047ee
c0002d53:	e8 27 d7 ff ff       	call   c000047f <kprintf>
c0002d58:	83 c4 10             	add    $0x10,%esp

	print_memory_table(mbd);
c0002d5b:	83 ec 0c             	sub    $0xc,%esp
c0002d5e:	ff 75 08             	pushl  0x8(%ebp)
c0002d61:	e8 12 ec ff ff       	call   c0001978 <print_memory_table>
c0002d66:	83 c4 10             	add    $0x10,%esp
	memory_init(mbd);	//after this the multiboot structure is unmapped
c0002d69:	83 ec 0c             	sub    $0xc,%esp
c0002d6c:	ff 75 08             	pushl  0x8(%ebp)
c0002d6f:	e8 d0 fa ff ff       	call   c0002844 <memory_init>
c0002d74:	83 c4 10             	add    $0x10,%esp
	initialize_multitasking();
c0002d77:	e8 10 f3 ff ff       	call   c000208c <initialize_multitasking>
    // reg_t regs;
    // getregs(&regs);
	// printregs(&regs);


	test_multitasking1();
c0002d7c:	e8 18 ff ff ff       	call   c0002c99 <test_multitasking1>

	while(1);
c0002d81:	eb fe                	jmp    c0002d81 <kernel_main+0x66>

c0002d83 <populate_gdt_entry>:
   uint16_t iomap_base;
} tss_entry_t;


static inline void populate_gdt_entry(gdt_entry_t* sd, uint32_t base, uint32_t limit, uint8_t access, uint8_t flags)
{
c0002d83:	55                   	push   %ebp
c0002d84:	89 e5                	mov    %esp,%ebp
c0002d86:	53                   	push   %ebx
c0002d87:	83 ec 08             	sub    $0x8,%esp
c0002d8a:	8b 55 14             	mov    0x14(%ebp),%edx
c0002d8d:	8b 45 18             	mov    0x18(%ebp),%eax
c0002d90:	88 55 f8             	mov    %dl,-0x8(%ebp)
c0002d93:	88 45 f4             	mov    %al,-0xc(%ebp)
    sd->limit_low = limit & SEGMENT_LIMIT_LOW_MASK;
c0002d96:	8b 45 10             	mov    0x10(%ebp),%eax
c0002d99:	89 c2                	mov    %eax,%edx
c0002d9b:	8b 45 08             	mov    0x8(%ebp),%eax
c0002d9e:	0f b7 ca             	movzwl %dx,%ecx
c0002da1:	0f b6 d9             	movzbl %cl,%ebx
c0002da4:	0f b6 08             	movzbl (%eax),%ecx
c0002da7:	83 e1 00             	and    $0x0,%ecx
c0002daa:	09 d9                	or     %ebx,%ecx
c0002dac:	88 08                	mov    %cl,(%eax)
c0002dae:	66 c1 ea 08          	shr    $0x8,%dx
c0002db2:	0f b7 ca             	movzwl %dx,%ecx
c0002db5:	0f b6 50 01          	movzbl 0x1(%eax),%edx
c0002db9:	83 e2 00             	and    $0x0,%edx
c0002dbc:	09 ca                	or     %ecx,%edx
c0002dbe:	88 50 01             	mov    %dl,0x1(%eax)
    sd->limit_high = (limit & SEGMENT_LIMIT_HIGH_MASK) >> 16;
c0002dc1:	8b 45 10             	mov    0x10(%ebp),%eax
c0002dc4:	c1 e8 10             	shr    $0x10,%eax
c0002dc7:	83 e0 0f             	and    $0xf,%eax
c0002dca:	8b 55 08             	mov    0x8(%ebp),%edx
c0002dcd:	83 e0 0f             	and    $0xf,%eax
c0002dd0:	89 c1                	mov    %eax,%ecx
c0002dd2:	0f b6 42 06          	movzbl 0x6(%edx),%eax
c0002dd6:	83 e0 f0             	and    $0xfffffff0,%eax
c0002dd9:	09 c8                	or     %ecx,%eax
c0002ddb:	88 42 06             	mov    %al,0x6(%edx)
    sd->base_low = base & SEGMENT_BASE_LOW_MASK;
c0002dde:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002de1:	89 c2                	mov    %eax,%edx
c0002de3:	8b 45 08             	mov    0x8(%ebp),%eax
c0002de6:	0f b7 ca             	movzwl %dx,%ecx
c0002de9:	0f b6 d9             	movzbl %cl,%ebx
c0002dec:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
c0002df0:	83 e1 00             	and    $0x0,%ecx
c0002df3:	09 d9                	or     %ebx,%ecx
c0002df5:	88 48 02             	mov    %cl,0x2(%eax)
c0002df8:	66 c1 ea 08          	shr    $0x8,%dx
c0002dfc:	0f b7 ca             	movzwl %dx,%ecx
c0002dff:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c0002e03:	83 e2 00             	and    $0x0,%edx
c0002e06:	09 ca                	or     %ecx,%edx
c0002e08:	88 50 03             	mov    %dl,0x3(%eax)
    sd->base_mid = (base & SEGMENT_BASE_MID_MASK) >> 16;
c0002e0b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002e0e:	c1 e8 10             	shr    $0x10,%eax
c0002e11:	89 c2                	mov    %eax,%edx
c0002e13:	8b 45 08             	mov    0x8(%ebp),%eax
c0002e16:	88 50 04             	mov    %dl,0x4(%eax)
    sd->base_high = (base & SEGMENT_BASE_HIGH_MASK) >> 24;
c0002e19:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002e1c:	c1 e8 18             	shr    $0x18,%eax
c0002e1f:	89 c2                	mov    %eax,%edx
c0002e21:	8b 45 08             	mov    0x8(%ebp),%eax
c0002e24:	88 50 07             	mov    %dl,0x7(%eax)
    sd->access = access;
c0002e27:	8b 45 08             	mov    0x8(%ebp),%eax
c0002e2a:	0f b6 55 f8          	movzbl -0x8(%ebp),%edx
c0002e2e:	88 50 05             	mov    %dl,0x5(%eax)
    sd->flags = flags;
c0002e31:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0002e35:	83 e0 0f             	and    $0xf,%eax
c0002e38:	89 c2                	mov    %eax,%edx
c0002e3a:	8b 45 08             	mov    0x8(%ebp),%eax
c0002e3d:	89 d1                	mov    %edx,%ecx
c0002e3f:	c1 e1 04             	shl    $0x4,%ecx
c0002e42:	0f b6 50 06          	movzbl 0x6(%eax),%edx
c0002e46:	83 e2 0f             	and    $0xf,%edx
c0002e49:	09 ca                	or     %ecx,%edx
c0002e4b:	88 50 06             	mov    %dl,0x6(%eax)
}
c0002e4e:	90                   	nop
c0002e4f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0002e52:	c9                   	leave  
c0002e53:	c3                   	ret    

c0002e54 <init_gdt>:
gdt_description_t __aligned  gdtd;

tss_entry_t tss = {0};

void init_gdt()
{
c0002e54:	55                   	push   %ebp
c0002e55:	89 e5                	mov    %esp,%ebp
c0002e57:	83 ec 08             	sub    $0x8,%esp
    // gdt[0] unused
    populate_gdt_entry(&gdt[1], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(0) | SEG_DESCTYPE(1) | SEG_CODE_EXRD, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // priv code, seg 0x008
c0002e5a:	6a 0c                	push   $0xc
c0002e5c:	68 9a 00 00 00       	push   $0x9a
c0002e61:	6a ff                	push   $0xffffffff
c0002e63:	6a 00                	push   $0x0
c0002e65:	68 c8 08 01 c0       	push   $0xc00108c8
c0002e6a:	e8 14 ff ff ff       	call   c0002d83 <populate_gdt_entry>
c0002e6f:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[2], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(0) | SEG_DESCTYPE(1) | SEG_DATA_RDWR, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // priv data, seg 0x010
c0002e72:	6a 0c                	push   $0xc
c0002e74:	68 92 00 00 00       	push   $0x92
c0002e79:	6a ff                	push   $0xffffffff
c0002e7b:	6a 00                	push   $0x0
c0002e7d:	68 d0 08 01 c0       	push   $0xc00108d0
c0002e82:	e8 fc fe ff ff       	call   c0002d83 <populate_gdt_entry>
c0002e87:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[3], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(3) | SEG_DESCTYPE(1) | SEG_CODE_EXRD, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // user code, seg 0x018
c0002e8a:	6a 0c                	push   $0xc
c0002e8c:	68 fa 00 00 00       	push   $0xfa
c0002e91:	6a ff                	push   $0xffffffff
c0002e93:	6a 00                	push   $0x0
c0002e95:	68 d8 08 01 c0       	push   $0xc00108d8
c0002e9a:	e8 e4 fe ff ff       	call   c0002d83 <populate_gdt_entry>
c0002e9f:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[4], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(3) | SEG_DESCTYPE(1) | SEG_DATA_RDWR, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // user data  seg 0x020
c0002ea2:	6a 0c                	push   $0xc
c0002ea4:	68 f2 00 00 00       	push   $0xf2
c0002ea9:	6a ff                	push   $0xffffffff
c0002eab:	6a 00                	push   $0x0
c0002ead:	68 e0 08 01 c0       	push   $0xc00108e0
c0002eb2:	e8 cc fe ff ff       	call   c0002d83 <populate_gdt_entry>
c0002eb7:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[5], (uint32_t) &tss, sizeof(tss_entry_t), SEG_TSS, SEG_FLAG_TSS); // tss, seg 0x028
c0002eba:	b8 20 09 01 c0       	mov    $0xc0010920,%eax
c0002ebf:	6a 04                	push   $0x4
c0002ec1:	68 89 00 00 00       	push   $0x89
c0002ec6:	6a 68                	push   $0x68
c0002ec8:	50                   	push   %eax
c0002ec9:	68 e8 08 01 c0       	push   $0xc00108e8
c0002ece:	e8 b0 fe ff ff       	call   c0002d83 <populate_gdt_entry>
c0002ed3:	83 c4 14             	add    $0x14,%esp

    //tss.esp0 = XXXXX
    tss.ss0 = KERNEL_DATA_SEGMENT; //kernel data segment    
c0002ed6:	c7 05 28 09 01 c0 10 	movl   $0x10,0xc0010928
c0002edd:	00 00 00 
    tss.iomap_base = sizeof(tss_entry_t);
c0002ee0:	66 c7 05 86 09 01 c0 	movw   $0x68,0xc0010986
c0002ee7:	68 00 
    // before we can actually switch tasks, we must first set the kernel stack pointer, with update_tss()

    gdtd.addr = (uint32_t) gdt;
c0002ee9:	b8 c0 08 01 c0       	mov    $0xc00108c0,%eax
c0002eee:	a3 02 09 01 c0       	mov    %eax,0xc0010902
    gdtd.size = sizeof(gdt);    
c0002ef3:	66 c7 05 00 09 01 c0 	movw   $0x30,0xc0010900
c0002efa:	30 00 
    load_gdt(&gdtd);
c0002efc:	83 ec 0c             	sub    $0xc,%esp
c0002eff:	68 00 09 01 c0       	push   $0xc0010900
c0002f04:	e8 1f 00 00 00       	call   c0002f28 <load_gdt>
c0002f09:	83 c4 10             	add    $0x10,%esp
}
c0002f0c:	90                   	nop
c0002f0d:	c9                   	leave  
c0002f0e:	c3                   	ret    

c0002f0f <update_kstack>:

void update_kstack(void* kernel_stack_ptr)
{
c0002f0f:	55                   	push   %ebp
c0002f10:	89 e5                	mov    %esp,%ebp
c0002f12:	83 ec 08             	sub    $0x8,%esp
    tss.esp0 = (uint32_t) kernel_stack_ptr; //kernel stack ptr
c0002f15:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f18:	a3 24 09 01 c0       	mov    %eax,0xc0010924
    load_tss();
c0002f1d:	e8 26 00 00 00       	call   c0002f48 <load_tss>
}
c0002f22:	90                   	nop
c0002f23:	c9                   	leave  
c0002f24:	c3                   	ret    
c0002f25:	66 90                	xchg   %ax,%ax
c0002f27:	90                   	nop

c0002f28 <load_gdt>:
c0002f28:	0f 01 15 00 09 01 c0 	lgdtl  0xc0010900
c0002f2f:	ea 36 2f 00 c0 08 00 	ljmp   $0x8,$0xc0002f36

c0002f36 <complete_flush>:
c0002f36:	66 b8 10 00          	mov    $0x10,%ax
c0002f3a:	8e d8                	mov    %eax,%ds
c0002f3c:	8e c0                	mov    %eax,%es
c0002f3e:	8e e0                	mov    %eax,%fs
c0002f40:	8e e8                	mov    %eax,%gs
c0002f42:	8e d0                	mov    %eax,%ss
c0002f44:	c3                   	ret    
c0002f45:	8d 76 00             	lea    0x0(%esi),%esi

c0002f48 <load_tss>:
c0002f48:	66 b8 28 00          	mov    $0x28,%ax
c0002f4c:	66 83 c8 03          	or     $0x3,%ax
c0002f50:	0f 00 d8             	ltr    %ax
c0002f53:	c3                   	ret    

c0002f54 <getregs>:
c0002f54:	55                   	push   %ebp
c0002f55:	89 e5                	mov    %esp,%ebp
c0002f57:	53                   	push   %ebx
c0002f58:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0002f5b:	89 03                	mov    %eax,(%ebx)
c0002f5d:	8b 04 24             	mov    (%esp),%eax
c0002f60:	89 43 04             	mov    %eax,0x4(%ebx)
c0002f63:	89 4b 08             	mov    %ecx,0x8(%ebx)
c0002f66:	89 53 0c             	mov    %edx,0xc(%ebx)
c0002f69:	89 73 10             	mov    %esi,0x10(%ebx)
c0002f6c:	89 7b 14             	mov    %edi,0x14(%ebx)
c0002f6f:	89 e8                	mov    %ebp,%eax
c0002f71:	83 c0 0c             	add    $0xc,%eax
c0002f74:	89 43 18             	mov    %eax,0x18(%ebx)
c0002f77:	8b 45 00             	mov    0x0(%ebp),%eax
c0002f7a:	89 43 1c             	mov    %eax,0x1c(%ebx)
c0002f7d:	8b 45 04             	mov    0x4(%ebp),%eax
c0002f80:	89 43 20             	mov    %eax,0x20(%ebx)
c0002f83:	b8 00 00 00 00       	mov    $0x0,%eax
c0002f88:	9f                   	lahf   
c0002f89:	89 43 24             	mov    %eax,0x24(%ebx)
c0002f8c:	0f 20 c0             	mov    %cr0,%eax
c0002f8f:	89 43 28             	mov    %eax,0x28(%ebx)
c0002f92:	0f 20 d0             	mov    %cr2,%eax
c0002f95:	89 43 2c             	mov    %eax,0x2c(%ebx)
c0002f98:	0f 20 d8             	mov    %cr3,%eax
c0002f9b:	89 43 30             	mov    %eax,0x30(%ebx)
c0002f9e:	0f 20 e0             	mov    %cr4,%eax
c0002fa1:	89 43 34             	mov    %eax,0x34(%ebx)
c0002fa4:	5b                   	pop    %ebx
c0002fa5:	5d                   	pop    %ebp
c0002fa6:	c3                   	ret    
c0002fa7:	90                   	nop

c0002fa8 <load_idt>:
c0002fa8:	0f 01 1d 20 08 01 c0 	lidtl  0xc0010820
c0002faf:	fb                   	sti    
c0002fb0:	c3                   	ret    
c0002fb1:	8d 76 00             	lea    0x0(%esi),%esi

c0002fb4 <pf_addr>:
c0002fb4:	0f 20 d0             	mov    %cr2,%eax
c0002fb7:	c3                   	ret    

c0002fb8 <except_0>:
c0002fb8:	55                   	push   %ebp
c0002fb9:	89 e5                	mov    %esp,%ebp
c0002fbb:	60                   	pusha  
c0002fbc:	8b 45 04             	mov    0x4(%ebp),%eax
c0002fbf:	50                   	push   %eax
c0002fc0:	b8 00 00 00 00       	mov    $0x0,%eax
c0002fc5:	50                   	push   %eax
c0002fc6:	b8 00 00 00 00       	mov    $0x0,%eax
c0002fcb:	50                   	push   %eax
c0002fcc:	e8 18 f0 ff ff       	call   c0001fe9 <exception_handler>
c0002fd1:	83 c4 0c             	add    $0xc,%esp
c0002fd4:	61                   	popa   
c0002fd5:	5d                   	pop    %ebp
c0002fd6:	cf                   	iret   
c0002fd7:	90                   	nop

c0002fd8 <except_1>:
c0002fd8:	55                   	push   %ebp
c0002fd9:	89 e5                	mov    %esp,%ebp
c0002fdb:	60                   	pusha  
c0002fdc:	8b 45 04             	mov    0x4(%ebp),%eax
c0002fdf:	50                   	push   %eax
c0002fe0:	b8 00 00 00 00       	mov    $0x0,%eax
c0002fe5:	50                   	push   %eax
c0002fe6:	b8 01 00 00 00       	mov    $0x1,%eax
c0002feb:	50                   	push   %eax
c0002fec:	e8 f8 ef ff ff       	call   c0001fe9 <exception_handler>
c0002ff1:	83 c4 0c             	add    $0xc,%esp
c0002ff4:	61                   	popa   
c0002ff5:	5d                   	pop    %ebp
c0002ff6:	cf                   	iret   
c0002ff7:	90                   	nop

c0002ff8 <except_2>:
c0002ff8:	55                   	push   %ebp
c0002ff9:	89 e5                	mov    %esp,%ebp
c0002ffb:	60                   	pusha  
c0002ffc:	8b 45 04             	mov    0x4(%ebp),%eax
c0002fff:	50                   	push   %eax
c0003000:	b8 00 00 00 00       	mov    $0x0,%eax
c0003005:	50                   	push   %eax
c0003006:	b8 02 00 00 00       	mov    $0x2,%eax
c000300b:	50                   	push   %eax
c000300c:	e8 d8 ef ff ff       	call   c0001fe9 <exception_handler>
c0003011:	83 c4 0c             	add    $0xc,%esp
c0003014:	61                   	popa   
c0003015:	5d                   	pop    %ebp
c0003016:	cf                   	iret   
c0003017:	90                   	nop

c0003018 <except_3>:
c0003018:	55                   	push   %ebp
c0003019:	89 e5                	mov    %esp,%ebp
c000301b:	60                   	pusha  
c000301c:	8b 45 04             	mov    0x4(%ebp),%eax
c000301f:	50                   	push   %eax
c0003020:	b8 00 00 00 00       	mov    $0x0,%eax
c0003025:	50                   	push   %eax
c0003026:	b8 03 00 00 00       	mov    $0x3,%eax
c000302b:	50                   	push   %eax
c000302c:	e8 b8 ef ff ff       	call   c0001fe9 <exception_handler>
c0003031:	83 c4 0c             	add    $0xc,%esp
c0003034:	61                   	popa   
c0003035:	5d                   	pop    %ebp
c0003036:	cf                   	iret   
c0003037:	90                   	nop

c0003038 <except_4>:
c0003038:	55                   	push   %ebp
c0003039:	89 e5                	mov    %esp,%ebp
c000303b:	60                   	pusha  
c000303c:	8b 45 04             	mov    0x4(%ebp),%eax
c000303f:	50                   	push   %eax
c0003040:	b8 00 00 00 00       	mov    $0x0,%eax
c0003045:	50                   	push   %eax
c0003046:	b8 04 00 00 00       	mov    $0x4,%eax
c000304b:	50                   	push   %eax
c000304c:	e8 98 ef ff ff       	call   c0001fe9 <exception_handler>
c0003051:	83 c4 0c             	add    $0xc,%esp
c0003054:	61                   	popa   
c0003055:	5d                   	pop    %ebp
c0003056:	cf                   	iret   
c0003057:	90                   	nop

c0003058 <except_5>:
c0003058:	55                   	push   %ebp
c0003059:	89 e5                	mov    %esp,%ebp
c000305b:	60                   	pusha  
c000305c:	8b 45 04             	mov    0x4(%ebp),%eax
c000305f:	50                   	push   %eax
c0003060:	b8 00 00 00 00       	mov    $0x0,%eax
c0003065:	50                   	push   %eax
c0003066:	b8 05 00 00 00       	mov    $0x5,%eax
c000306b:	50                   	push   %eax
c000306c:	e8 78 ef ff ff       	call   c0001fe9 <exception_handler>
c0003071:	83 c4 0c             	add    $0xc,%esp
c0003074:	61                   	popa   
c0003075:	5d                   	pop    %ebp
c0003076:	cf                   	iret   
c0003077:	90                   	nop

c0003078 <except_6>:
c0003078:	55                   	push   %ebp
c0003079:	89 e5                	mov    %esp,%ebp
c000307b:	60                   	pusha  
c000307c:	8b 45 04             	mov    0x4(%ebp),%eax
c000307f:	50                   	push   %eax
c0003080:	b8 00 00 00 00       	mov    $0x0,%eax
c0003085:	50                   	push   %eax
c0003086:	b8 06 00 00 00       	mov    $0x6,%eax
c000308b:	50                   	push   %eax
c000308c:	e8 58 ef ff ff       	call   c0001fe9 <exception_handler>
c0003091:	83 c4 0c             	add    $0xc,%esp
c0003094:	61                   	popa   
c0003095:	5d                   	pop    %ebp
c0003096:	cf                   	iret   
c0003097:	90                   	nop

c0003098 <except_7>:
c0003098:	55                   	push   %ebp
c0003099:	89 e5                	mov    %esp,%ebp
c000309b:	60                   	pusha  
c000309c:	8b 45 04             	mov    0x4(%ebp),%eax
c000309f:	50                   	push   %eax
c00030a0:	b8 00 00 00 00       	mov    $0x0,%eax
c00030a5:	50                   	push   %eax
c00030a6:	b8 07 00 00 00       	mov    $0x7,%eax
c00030ab:	50                   	push   %eax
c00030ac:	e8 38 ef ff ff       	call   c0001fe9 <exception_handler>
c00030b1:	83 c4 0c             	add    $0xc,%esp
c00030b4:	61                   	popa   
c00030b5:	5d                   	pop    %ebp
c00030b6:	cf                   	iret   
c00030b7:	90                   	nop

c00030b8 <except_8>:
c00030b8:	55                   	push   %ebp
c00030b9:	89 e5                	mov    %esp,%ebp
c00030bb:	60                   	pusha  
c00030bc:	8b 45 08             	mov    0x8(%ebp),%eax
c00030bf:	50                   	push   %eax
c00030c0:	8b 45 04             	mov    0x4(%ebp),%eax
c00030c3:	50                   	push   %eax
c00030c4:	b8 08 00 00 00       	mov    $0x8,%eax
c00030c9:	50                   	push   %eax
c00030ca:	e8 1a ef ff ff       	call   c0001fe9 <exception_handler>
c00030cf:	83 c4 0c             	add    $0xc,%esp
c00030d2:	61                   	popa   
c00030d3:	5d                   	pop    %ebp
c00030d4:	83 c4 04             	add    $0x4,%esp
c00030d7:	cf                   	iret   

c00030d8 <except_10>:
c00030d8:	55                   	push   %ebp
c00030d9:	89 e5                	mov    %esp,%ebp
c00030db:	60                   	pusha  
c00030dc:	8b 45 08             	mov    0x8(%ebp),%eax
c00030df:	50                   	push   %eax
c00030e0:	8b 45 04             	mov    0x4(%ebp),%eax
c00030e3:	50                   	push   %eax
c00030e4:	b8 0a 00 00 00       	mov    $0xa,%eax
c00030e9:	50                   	push   %eax
c00030ea:	e8 fa ee ff ff       	call   c0001fe9 <exception_handler>
c00030ef:	83 c4 0c             	add    $0xc,%esp
c00030f2:	61                   	popa   
c00030f3:	5d                   	pop    %ebp
c00030f4:	83 c4 04             	add    $0x4,%esp
c00030f7:	cf                   	iret   

c00030f8 <except_11>:
c00030f8:	55                   	push   %ebp
c00030f9:	89 e5                	mov    %esp,%ebp
c00030fb:	60                   	pusha  
c00030fc:	8b 45 08             	mov    0x8(%ebp),%eax
c00030ff:	50                   	push   %eax
c0003100:	8b 45 04             	mov    0x4(%ebp),%eax
c0003103:	50                   	push   %eax
c0003104:	b8 0b 00 00 00       	mov    $0xb,%eax
c0003109:	50                   	push   %eax
c000310a:	e8 da ee ff ff       	call   c0001fe9 <exception_handler>
c000310f:	83 c4 0c             	add    $0xc,%esp
c0003112:	61                   	popa   
c0003113:	5d                   	pop    %ebp
c0003114:	83 c4 04             	add    $0x4,%esp
c0003117:	cf                   	iret   

c0003118 <except_12>:
c0003118:	55                   	push   %ebp
c0003119:	89 e5                	mov    %esp,%ebp
c000311b:	60                   	pusha  
c000311c:	8b 45 08             	mov    0x8(%ebp),%eax
c000311f:	50                   	push   %eax
c0003120:	8b 45 04             	mov    0x4(%ebp),%eax
c0003123:	50                   	push   %eax
c0003124:	b8 0c 00 00 00       	mov    $0xc,%eax
c0003129:	50                   	push   %eax
c000312a:	e8 ba ee ff ff       	call   c0001fe9 <exception_handler>
c000312f:	83 c4 0c             	add    $0xc,%esp
c0003132:	61                   	popa   
c0003133:	5d                   	pop    %ebp
c0003134:	83 c4 04             	add    $0x4,%esp
c0003137:	cf                   	iret   

c0003138 <except_13>:
c0003138:	55                   	push   %ebp
c0003139:	89 e5                	mov    %esp,%ebp
c000313b:	60                   	pusha  
c000313c:	8b 45 08             	mov    0x8(%ebp),%eax
c000313f:	50                   	push   %eax
c0003140:	8b 45 04             	mov    0x4(%ebp),%eax
c0003143:	50                   	push   %eax
c0003144:	b8 0d 00 00 00       	mov    $0xd,%eax
c0003149:	50                   	push   %eax
c000314a:	e8 9a ee ff ff       	call   c0001fe9 <exception_handler>
c000314f:	83 c4 0c             	add    $0xc,%esp
c0003152:	61                   	popa   
c0003153:	5d                   	pop    %ebp
c0003154:	83 c4 04             	add    $0x4,%esp
c0003157:	cf                   	iret   

c0003158 <except_14>:
c0003158:	55                   	push   %ebp
c0003159:	89 e5                	mov    %esp,%ebp
c000315b:	60                   	pusha  
c000315c:	8b 45 08             	mov    0x8(%ebp),%eax
c000315f:	50                   	push   %eax
c0003160:	8b 45 04             	mov    0x4(%ebp),%eax
c0003163:	50                   	push   %eax
c0003164:	b8 0e 00 00 00       	mov    $0xe,%eax
c0003169:	50                   	push   %eax
c000316a:	e8 7a ee ff ff       	call   c0001fe9 <exception_handler>
c000316f:	83 c4 0c             	add    $0xc,%esp
c0003172:	61                   	popa   
c0003173:	5d                   	pop    %ebp
c0003174:	83 c4 04             	add    $0x4,%esp
c0003177:	cf                   	iret   

c0003178 <except_16>:
c0003178:	55                   	push   %ebp
c0003179:	89 e5                	mov    %esp,%ebp
c000317b:	60                   	pusha  
c000317c:	8b 45 08             	mov    0x8(%ebp),%eax
c000317f:	50                   	push   %eax
c0003180:	8b 45 04             	mov    0x4(%ebp),%eax
c0003183:	50                   	push   %eax
c0003184:	b8 10 00 00 00       	mov    $0x10,%eax
c0003189:	50                   	push   %eax
c000318a:	e8 5a ee ff ff       	call   c0001fe9 <exception_handler>
c000318f:	83 c4 0c             	add    $0xc,%esp
c0003192:	61                   	popa   
c0003193:	5d                   	pop    %ebp
c0003194:	83 c4 04             	add    $0x4,%esp
c0003197:	cf                   	iret   

c0003198 <except_17>:
c0003198:	55                   	push   %ebp
c0003199:	89 e5                	mov    %esp,%ebp
c000319b:	60                   	pusha  
c000319c:	8b 45 08             	mov    0x8(%ebp),%eax
c000319f:	50                   	push   %eax
c00031a0:	8b 45 04             	mov    0x4(%ebp),%eax
c00031a3:	50                   	push   %eax
c00031a4:	b8 11 00 00 00       	mov    $0x11,%eax
c00031a9:	50                   	push   %eax
c00031aa:	e8 3a ee ff ff       	call   c0001fe9 <exception_handler>
c00031af:	83 c4 0c             	add    $0xc,%esp
c00031b2:	61                   	popa   
c00031b3:	5d                   	pop    %ebp
c00031b4:	83 c4 04             	add    $0x4,%esp
c00031b7:	cf                   	iret   

c00031b8 <except_18>:
c00031b8:	55                   	push   %ebp
c00031b9:	89 e5                	mov    %esp,%ebp
c00031bb:	60                   	pusha  
c00031bc:	8b 45 08             	mov    0x8(%ebp),%eax
c00031bf:	50                   	push   %eax
c00031c0:	8b 45 04             	mov    0x4(%ebp),%eax
c00031c3:	50                   	push   %eax
c00031c4:	b8 12 00 00 00       	mov    $0x12,%eax
c00031c9:	50                   	push   %eax
c00031ca:	e8 1a ee ff ff       	call   c0001fe9 <exception_handler>
c00031cf:	83 c4 0c             	add    $0xc,%esp
c00031d2:	61                   	popa   
c00031d3:	5d                   	pop    %ebp
c00031d4:	83 c4 04             	add    $0x4,%esp
c00031d7:	cf                   	iret   

c00031d8 <except_19>:
c00031d8:	55                   	push   %ebp
c00031d9:	89 e5                	mov    %esp,%ebp
c00031db:	60                   	pusha  
c00031dc:	8b 45 08             	mov    0x8(%ebp),%eax
c00031df:	50                   	push   %eax
c00031e0:	8b 45 04             	mov    0x4(%ebp),%eax
c00031e3:	50                   	push   %eax
c00031e4:	b8 13 00 00 00       	mov    $0x13,%eax
c00031e9:	50                   	push   %eax
c00031ea:	e8 fa ed ff ff       	call   c0001fe9 <exception_handler>
c00031ef:	83 c4 0c             	add    $0xc,%esp
c00031f2:	61                   	popa   
c00031f3:	5d                   	pop    %ebp
c00031f4:	83 c4 04             	add    $0x4,%esp
c00031f7:	cf                   	iret   

c00031f8 <except_20>:
c00031f8:	55                   	push   %ebp
c00031f9:	89 e5                	mov    %esp,%ebp
c00031fb:	60                   	pusha  
c00031fc:	8b 45 08             	mov    0x8(%ebp),%eax
c00031ff:	50                   	push   %eax
c0003200:	8b 45 04             	mov    0x4(%ebp),%eax
c0003203:	50                   	push   %eax
c0003204:	b8 14 00 00 00       	mov    $0x14,%eax
c0003209:	50                   	push   %eax
c000320a:	e8 da ed ff ff       	call   c0001fe9 <exception_handler>
c000320f:	83 c4 0c             	add    $0xc,%esp
c0003212:	61                   	popa   
c0003213:	5d                   	pop    %ebp
c0003214:	83 c4 04             	add    $0x4,%esp
c0003217:	cf                   	iret   

c0003218 <except_30>:
c0003218:	55                   	push   %ebp
c0003219:	89 e5                	mov    %esp,%ebp
c000321b:	60                   	pusha  
c000321c:	8b 45 08             	mov    0x8(%ebp),%eax
c000321f:	50                   	push   %eax
c0003220:	8b 45 04             	mov    0x4(%ebp),%eax
c0003223:	50                   	push   %eax
c0003224:	b8 1e 00 00 00       	mov    $0x1e,%eax
c0003229:	50                   	push   %eax
c000322a:	e8 ba ed ff ff       	call   c0001fe9 <exception_handler>
c000322f:	83 c4 0c             	add    $0xc,%esp
c0003232:	61                   	popa   
c0003233:	5d                   	pop    %ebp
c0003234:	83 c4 04             	add    $0x4,%esp
c0003237:	cf                   	iret   

c0003238 <irq_0>:
c0003238:	60                   	pusha  
c0003239:	b8 00 00 00 00       	mov    $0x0,%eax
c000323e:	50                   	push   %eax
c000323f:	e8 dc ed ff ff       	call   c0002020 <irq_handler>
c0003244:	83 c4 04             	add    $0x4,%esp
c0003247:	61                   	popa   
c0003248:	cf                   	iret   
c0003249:	8d 76 00             	lea    0x0(%esi),%esi

c000324c <irq_1>:
c000324c:	60                   	pusha  
c000324d:	b8 01 00 00 00       	mov    $0x1,%eax
c0003252:	50                   	push   %eax
c0003253:	e8 c8 ed ff ff       	call   c0002020 <irq_handler>
c0003258:	83 c4 04             	add    $0x4,%esp
c000325b:	61                   	popa   
c000325c:	cf                   	iret   
c000325d:	8d 76 00             	lea    0x0(%esi),%esi

c0003260 <irq_2>:
c0003260:	60                   	pusha  
c0003261:	b8 02 00 00 00       	mov    $0x2,%eax
c0003266:	50                   	push   %eax
c0003267:	e8 b4 ed ff ff       	call   c0002020 <irq_handler>
c000326c:	83 c4 04             	add    $0x4,%esp
c000326f:	61                   	popa   
c0003270:	cf                   	iret   
c0003271:	8d 76 00             	lea    0x0(%esi),%esi

c0003274 <irq_3>:
c0003274:	60                   	pusha  
c0003275:	b8 03 00 00 00       	mov    $0x3,%eax
c000327a:	50                   	push   %eax
c000327b:	e8 a0 ed ff ff       	call   c0002020 <irq_handler>
c0003280:	83 c4 04             	add    $0x4,%esp
c0003283:	61                   	popa   
c0003284:	cf                   	iret   
c0003285:	8d 76 00             	lea    0x0(%esi),%esi

c0003288 <irq_4>:
c0003288:	60                   	pusha  
c0003289:	b8 04 00 00 00       	mov    $0x4,%eax
c000328e:	50                   	push   %eax
c000328f:	e8 8c ed ff ff       	call   c0002020 <irq_handler>
c0003294:	83 c4 04             	add    $0x4,%esp
c0003297:	61                   	popa   
c0003298:	cf                   	iret   
c0003299:	8d 76 00             	lea    0x0(%esi),%esi

c000329c <irq_5>:
c000329c:	60                   	pusha  
c000329d:	b8 05 00 00 00       	mov    $0x5,%eax
c00032a2:	50                   	push   %eax
c00032a3:	e8 78 ed ff ff       	call   c0002020 <irq_handler>
c00032a8:	83 c4 04             	add    $0x4,%esp
c00032ab:	61                   	popa   
c00032ac:	cf                   	iret   
c00032ad:	8d 76 00             	lea    0x0(%esi),%esi

c00032b0 <irq_6>:
c00032b0:	60                   	pusha  
c00032b1:	b8 06 00 00 00       	mov    $0x6,%eax
c00032b6:	50                   	push   %eax
c00032b7:	e8 64 ed ff ff       	call   c0002020 <irq_handler>
c00032bc:	83 c4 04             	add    $0x4,%esp
c00032bf:	61                   	popa   
c00032c0:	cf                   	iret   
c00032c1:	8d 76 00             	lea    0x0(%esi),%esi

c00032c4 <irq_7>:
c00032c4:	60                   	pusha  
c00032c5:	b8 07 00 00 00       	mov    $0x7,%eax
c00032ca:	50                   	push   %eax
c00032cb:	e8 50 ed ff ff       	call   c0002020 <irq_handler>
c00032d0:	83 c4 04             	add    $0x4,%esp
c00032d3:	61                   	popa   
c00032d4:	cf                   	iret   
c00032d5:	8d 76 00             	lea    0x0(%esi),%esi

c00032d8 <irq_8>:
c00032d8:	60                   	pusha  
c00032d9:	b8 08 00 00 00       	mov    $0x8,%eax
c00032de:	50                   	push   %eax
c00032df:	e8 3c ed ff ff       	call   c0002020 <irq_handler>
c00032e4:	83 c4 04             	add    $0x4,%esp
c00032e7:	61                   	popa   
c00032e8:	cf                   	iret   
c00032e9:	8d 76 00             	lea    0x0(%esi),%esi

c00032ec <irq_9>:
c00032ec:	60                   	pusha  
c00032ed:	b8 09 00 00 00       	mov    $0x9,%eax
c00032f2:	50                   	push   %eax
c00032f3:	e8 28 ed ff ff       	call   c0002020 <irq_handler>
c00032f8:	83 c4 04             	add    $0x4,%esp
c00032fb:	61                   	popa   
c00032fc:	cf                   	iret   
c00032fd:	8d 76 00             	lea    0x0(%esi),%esi

c0003300 <irq_10>:
c0003300:	60                   	pusha  
c0003301:	b8 0a 00 00 00       	mov    $0xa,%eax
c0003306:	50                   	push   %eax
c0003307:	e8 14 ed ff ff       	call   c0002020 <irq_handler>
c000330c:	83 c4 04             	add    $0x4,%esp
c000330f:	61                   	popa   
c0003310:	cf                   	iret   
c0003311:	8d 76 00             	lea    0x0(%esi),%esi

c0003314 <irq_11>:
c0003314:	60                   	pusha  
c0003315:	b8 0b 00 00 00       	mov    $0xb,%eax
c000331a:	50                   	push   %eax
c000331b:	e8 00 ed ff ff       	call   c0002020 <irq_handler>
c0003320:	83 c4 04             	add    $0x4,%esp
c0003323:	61                   	popa   
c0003324:	cf                   	iret   
c0003325:	8d 76 00             	lea    0x0(%esi),%esi

c0003328 <irq_12>:
c0003328:	60                   	pusha  
c0003329:	b8 0c 00 00 00       	mov    $0xc,%eax
c000332e:	50                   	push   %eax
c000332f:	e8 ec ec ff ff       	call   c0002020 <irq_handler>
c0003334:	83 c4 04             	add    $0x4,%esp
c0003337:	61                   	popa   
c0003338:	cf                   	iret   
c0003339:	8d 76 00             	lea    0x0(%esi),%esi

c000333c <irq_13>:
c000333c:	60                   	pusha  
c000333d:	b8 0d 00 00 00       	mov    $0xd,%eax
c0003342:	50                   	push   %eax
c0003343:	e8 d8 ec ff ff       	call   c0002020 <irq_handler>
c0003348:	83 c4 04             	add    $0x4,%esp
c000334b:	61                   	popa   
c000334c:	cf                   	iret   
c000334d:	8d 76 00             	lea    0x0(%esi),%esi

c0003350 <irq_14>:
c0003350:	60                   	pusha  
c0003351:	b8 0e 00 00 00       	mov    $0xe,%eax
c0003356:	50                   	push   %eax
c0003357:	e8 c4 ec ff ff       	call   c0002020 <irq_handler>
c000335c:	83 c4 04             	add    $0x4,%esp
c000335f:	61                   	popa   
c0003360:	cf                   	iret   
c0003361:	8d 76 00             	lea    0x0(%esi),%esi

c0003364 <irq_15>:
c0003364:	60                   	pusha  
c0003365:	b8 0f 00 00 00       	mov    $0xf,%eax
c000336a:	50                   	push   %eax
c000336b:	e8 b0 ec ff ff       	call   c0002020 <irq_handler>
c0003370:	83 c4 04             	add    $0x4,%esp
c0003373:	61                   	popa   
c0003374:	cf                   	iret   
c0003375:	66 90                	xchg   %ax,%ax
c0003377:	90                   	nop

c0003378 <switch_to_task>:
c0003378:	53                   	push   %ebx
c0003379:	56                   	push   %esi
c000337a:	57                   	push   %edi
c000337b:	55                   	push   %ebp
c000337c:	8b 3d 40 08 01 c0    	mov    0xc0010840,%edi
c0003382:	89 67 08             	mov    %esp,0x8(%edi)
c0003385:	8b 74 24 14          	mov    0x14(%esp),%esi
c0003389:	89 35 40 08 01 c0    	mov    %esi,0xc0010840
c000338f:	8b 66 08             	mov    0x8(%esi),%esp
c0003392:	8b 5e 0c             	mov    0xc(%esi),%ebx
c0003395:	8b 46 10             	mov    0x10(%esi),%eax
c0003398:	89 1d 24 09 01 c0    	mov    %ebx,0xc0010924
c000339e:	0f 20 d9             	mov    %cr3,%ecx
c00033a1:	39 c8                	cmp    %ecx,%eax
c00033a3:	74 03                	je     c00033a8 <.done>
c00033a5:	0f 22 d8             	mov    %eax,%cr3

c00033a8 <.done>:
c00033a8:	5d                   	pop    %ebp
c00033a9:	5f                   	pop    %edi
c00033aa:	5e                   	pop    %esi
c00033ab:	5b                   	pop    %ebx
c00033ac:	c3                   	ret    

c00033ad <terminate_task>:
c00033ad:	8d 35 60 08 01 c0    	lea    0xc0010860,%esi
c00033b3:	89 35 40 08 01 c0    	mov    %esi,0xc0010840
c00033b9:	8b 66 08             	mov    0x8(%esi),%esp
c00033bc:	8b 5e 0c             	mov    0xc(%esi),%ebx
c00033bf:	8b 46 10             	mov    0x10(%esi),%eax
c00033c2:	89 1d 24 09 01 c0    	mov    %ebx,0xc0010924
c00033c8:	0f 20 d9             	mov    %cr3,%ecx
c00033cb:	39 c8                	cmp    %ecx,%eax
c00033cd:	74 d9                	je     c00033a8 <.done>
c00033cf:	0f 22 d8             	mov    %eax,%cr3

c00033d2 <.done2>:
c00033d2:	5d                   	pop    %ebp
c00033d3:	5f                   	pop    %edi
c00033d4:	5e                   	pop    %esi
c00033d5:	5b                   	pop    %ebx
c00033d6:	c3                   	ret    
c00033d7:	90                   	nop

c00033d8 <enable_paging>:
c00033d8:	55                   	push   %ebp
c00033d9:	89 e5                	mov    %esp,%ebp
c00033db:	8b 45 08             	mov    0x8(%ebp),%eax
c00033de:	0f 22 d8             	mov    %eax,%cr3
c00033e1:	0f 20 c0             	mov    %cr0,%eax
c00033e4:	0d 01 00 00 80       	or     $0x80000001,%eax
c00033e9:	0f 22 c0             	mov    %eax,%cr0
c00033ec:	89 ec                	mov    %ebp,%esp
c00033ee:	5d                   	pop    %ebp
c00033ef:	c3                   	ret    

c00033f0 <set_page_dir>:
c00033f0:	8b 44 24 04          	mov    0x4(%esp),%eax
c00033f4:	0f 22 d8             	mov    %eax,%cr3
c00033f7:	c3                   	ret    

c00033f8 <get_page_dir>:
c00033f8:	0f 20 d8             	mov    %cr3,%eax
c00033fb:	c3                   	ret    

c00033fc <refresh_tlb>:
c00033fc:	0f 20 d8             	mov    %cr3,%eax
c00033ff:	0f 22 d8             	mov    %eax,%cr3
c0003402:	c3                   	ret    
c0003403:	90                   	nop

c0003404 <refresh_page>:
c0003404:	8b 44 24 04          	mov    0x4(%esp),%eax
c0003408:	0f 01 38             	invlpg (%eax)
c000340b:	c3                   	ret    
