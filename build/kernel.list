
build/kernel:     file format elf32-i386


Disassembly of section .text.boot:

00100000 <_start-0xc>:
  100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fb                   	sti    
  100009:	4f                   	dec    %edi
  10000a:	52                   	push   %edx
  10000b:	e4                   	.byte 0xe4

0010000c <_start>:
  10000c:	3d 02 b0 ad 2b       	cmp    $0x2badb002,%eax
  100011:	0f 85 c1 00 00 00    	jne    1000d8 <kpanic>
  100017:	8d 25 00 a0 10 00    	lea    0x10a000,%esp
  10001d:	53                   	push   %ebx
  10001e:	8d 3d 00 a0 10 00    	lea    0x10a000,%edi
  100024:	b8 83 00 00 00       	mov    $0x83,%eax
  100029:	89 07                	mov    %eax,(%edi)
  10002b:	0f 20 e0             	mov    %cr4,%eax
  10002e:	83 c8 10             	or     $0x10,%eax
  100031:	0f 22 e0             	mov    %eax,%cr4
  100034:	8d 35 00 b0 10 00    	lea    0x10b000,%esi
  10003a:	83 ce 03             	or     $0x3,%esi
  10003d:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  100043:	c1 e8 16             	shr    $0x16,%eax
  100046:	bb 04 00 00 00       	mov    $0x4,%ebx
  10004b:	f7 e3                	mul    %ebx
  10004d:	8d 3d 00 a0 10 00    	lea    0x10a000,%edi
  100053:	01 c7                	add    %eax,%edi
  100055:	89 37                	mov    %esi,(%edi)
  100057:	8d 1d 00 00 00 c0    	lea    0xc0000000,%ebx
  10005d:	c1 eb 0c             	shr    $0xc,%ebx
  100060:	8d 0d 24 b0 00 c0    	lea    0xc000b024,%ecx
  100066:	81 c1 ff 0f 00 00    	add    $0xfff,%ecx
  10006c:	c1 e9 0c             	shr    $0xc,%ecx
  10006f:	29 d9                	sub    %ebx,%ecx
  100071:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  100077:	25 00 f0 3f 00       	and    $0x3ff000,%eax
  10007c:	c1 e8 0c             	shr    $0xc,%eax
  10007f:	bb 04 00 00 00       	mov    $0x4,%ebx
  100084:	f7 e3                	mul    %ebx
  100086:	8d 3d 00 b0 10 00    	lea    0x10b000,%edi
  10008c:	01 c7                	add    %eax,%edi
  10008e:	8d 05 00 10 10 00    	lea    0x101000,%eax
  100094:	83 c8 03             	or     $0x3,%eax
  100097:	fc                   	cld    

00100098 <.nextpte>:
  100098:	ab                   	stos   %eax,%es:(%edi)
  100099:	05 00 10 00 00       	add    $0x1000,%eax
  10009e:	e2 f8                	loop   100098 <.nextpte>
  1000a0:	8d 35 00 a0 10 00    	lea    0x10a000,%esi
  1000a6:	89 f7                	mov    %esi,%edi
  1000a8:	81 c7 fc 0f 00 00    	add    $0xffc,%edi
  1000ae:	83 ce 03             	or     $0x3,%esi
  1000b1:	89 37                	mov    %esi,(%edi)
  1000b3:	5b                   	pop    %ebx

001000b4 <_enable_paging>:
  1000b4:	8d 05 00 a0 10 00    	lea    0x10a000,%eax
  1000ba:	0f 22 d8             	mov    %eax,%cr3
  1000bd:	0f 20 c0             	mov    %cr0,%eax
  1000c0:	0d 00 00 01 80       	or     $0x80010000,%eax
  1000c5:	0f 22 c0             	mov    %eax,%cr0
  1000c8:	8d 25 00 90 00 c0    	lea    0xc0009000,%esp
  1000ce:	50                   	push   %eax
  1000cf:	50                   	push   %eax
  1000d0:	50                   	push   %eax
  1000d1:	53                   	push   %ebx
  1000d2:	e8 79 22 f0 bf       	call   c0002350 <kernel_main>
  1000d7:	fa                   	cli    

001000d8 <kpanic>:
  1000d8:	f4                   	hlt    
  1000d9:	eb fd                	jmp    1000d8 <kpanic>

Disassembly of section .text:

c0000000 <kprint>:
unsigned int numdigits_uint(unsigned int value, unsigned int base);

int format_uint(unsigned int value, char* str, unsigned int base, int precision, int cap);

int kprint(const char* str)
{
c0000000:	55                   	push   %ebp
c0000001:	89 e5                	mov    %esp,%ebp
c0000003:	53                   	push   %ebx
c0000004:	83 ec 0c             	sub    $0xc,%esp
c0000007:	8b 5d 08             	mov    0x8(%ebp),%ebx
    terminal_writestring(&stdout, str);
c000000a:	53                   	push   %ebx
c000000b:	68 00 b0 00 c0       	push   $0xc000b000
c0000010:	e8 8b 1a 00 00       	call   c0001aa0 <terminal_writestring>
    return strlen(str);
c0000015:	89 5d 08             	mov    %ebx,0x8(%ebp)
c0000018:	83 c4 10             	add    $0x10,%esp
}
c000001b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000001e:	c9                   	leave  
    return strlen(str);
c000001f:	e9 dc 11 00 00       	jmp    c0001200 <strlen>
c0000024:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000002b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c000002f:	90                   	nop

c0000030 <kprintn>:

int kprintn(const char* str, size_t len)
{
c0000030:	55                   	push   %ebp
c0000031:	89 e5                	mov    %esp,%ebp
c0000033:	53                   	push   %ebx
c0000034:	83 ec 08             	sub    $0x8,%esp
c0000037:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    terminal_write(&stdout, str, len);
c000003a:	53                   	push   %ebx
c000003b:	ff 75 08             	pushl  0x8(%ebp)
c000003e:	68 00 b0 00 c0       	push   $0xc000b000
c0000043:	e8 f8 18 00 00       	call   c0001940 <terminal_write>
    return len;
}
c0000048:	89 d8                	mov    %ebx,%eax
c000004a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000004d:	c9                   	leave  
c000004e:	c3                   	ret    
c000004f:	90                   	nop

c0000050 <kprint_char>:

int kprint_char(char c)
{
c0000050:	55                   	push   %ebp
c0000051:	89 e5                	mov    %esp,%ebp
c0000053:	83 ec 10             	sub    $0x10,%esp
    terminal_putchar(&stdout, c); 
c0000056:	0f be 45 08          	movsbl 0x8(%ebp),%eax
c000005a:	50                   	push   %eax
c000005b:	68 00 b0 00 c0       	push   $0xc000b000
c0000060:	e8 eb 17 00 00       	call   c0001850 <terminal_putchar>
    return 1;
}
c0000065:	b8 01 00 00 00       	mov    $0x1,%eax
c000006a:	c9                   	leave  
c000006b:	c3                   	ret    
c000006c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

c0000070 <kprintn_char>:

int kprintn_char(char c, size_t rpt)
{
c0000070:	55                   	push   %ebp
c0000071:	89 e5                	mov    %esp,%ebp
c0000073:	53                   	push   %ebx
c0000074:	83 ec 08             	sub    $0x8,%esp
c0000077:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    terminal_putcharn(&stdout, c, rpt); 
c000007a:	0f be 45 08          	movsbl 0x8(%ebp),%eax
c000007e:	53                   	push   %ebx
c000007f:	50                   	push   %eax
c0000080:	68 00 b0 00 c0       	push   $0xc000b000
c0000085:	e8 e6 15 00 00       	call   c0001670 <terminal_putcharn>
    return rpt;
}
c000008a:	89 d8                	mov    %ebx,%eax
c000008c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000008f:	c9                   	leave  
c0000090:	c3                   	ret    
c0000091:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0000098:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000009f:	90                   	nop

c00000a0 <format_uint>:
// base may be 2-32
// precision is per printf format, precision<0 represents default (unspecified) 
// cap = 0, alpha-numbers are capitalized [base>10 only]
// returns length of string (not counting null termination)
int format_uint(unsigned int value, char* str, unsigned int base, int precision, int cap)
{
c00000a0:	55                   	push   %ebp
c00000a1:	89 e5                	mov    %esp,%ebp
c00000a3:	57                   	push   %edi
c00000a4:	56                   	push   %esi
c00000a5:	53                   	push   %ebx
c00000a6:	83 ec 04             	sub    $0x4,%esp
c00000a9:	8b 4d 10             	mov    0x10(%ebp),%ecx
c00000ac:	8b 75 08             	mov    0x8(%ebp),%esi
c00000af:	8b 7d 14             	mov    0x14(%ebp),%edi
    if(base < 2 || base > 32)
c00000b2:	8d 41 fe             	lea    -0x2(%ecx),%eax
c00000b5:	83 f8 1e             	cmp    $0x1e,%eax
c00000b8:	0f 87 ca 00 00 00    	ja     c0000188 <format_uint+0xe8>
        return -1;

    //When 0 is printed with an explicit precision 0, the output is empty.
    if(value==0 && precision==0)
c00000be:	89 f8                	mov    %edi,%eax
c00000c0:	09 f0                	or     %esi,%eax
c00000c2:	0f 84 88 00 00 00    	je     c0000150 <format_uint+0xb0>
//returns number of digits of unsigned int represented in given base
//num_digits is always >= 1
unsigned int numdigits_uint(unsigned int value, unsigned int base)
{
    unsigned int num_digits = 1;
    while(value >= base)
c00000c8:	89 f0                	mov    %esi,%eax
    unsigned int num_digits = 1;
c00000ca:	bb 01 00 00 00       	mov    $0x1,%ebx
    while(value >= base)
c00000cf:	39 f1                	cmp    %esi,%ecx
c00000d1:	0f 87 99 00 00 00    	ja     c0000170 <format_uint+0xd0>
c00000d7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00000de:	66 90                	xchg   %ax,%ax
    {
        num_digits++;
        value /= base;
c00000e0:	31 d2                	xor    %edx,%edx
        num_digits++;
c00000e2:	83 c3 01             	add    $0x1,%ebx
        value /= base;
c00000e5:	f7 f1                	div    %ecx
    while(value >= base)
c00000e7:	39 c1                	cmp    %eax,%ecx
c00000e9:	76 f5                	jbe    c00000e0 <format_uint+0x40>
    num_digits = num_digits>precision ? num_digits : precision;
c00000eb:	39 df                	cmp    %ebx,%edi
    char* s = str + num_digits;
c00000ed:	8b 45 0c             	mov    0xc(%ebp),%eax
    num_digits = num_digits>precision ? num_digits : precision;
c00000f0:	0f 4c fb             	cmovl  %ebx,%edi
    char* s = str + num_digits;
c00000f3:	01 f8                	add    %edi,%eax
    *(s--) = '\0'; //null termination
c00000f5:	8d 58 ff             	lea    -0x1(%eax),%ebx
c00000f8:	c6 00 00             	movb   $0x0,(%eax)
c00000fb:	89 5d f0             	mov    %ebx,-0x10(%ebp)
    for(int nn=0;nn<num_digits; nn++)
c00000fe:	85 ff                	test   %edi,%edi
c0000100:	7e 42                	jle    c0000144 <format_uint+0xa4>
    unsigned int num_digits = 1;
c0000102:	8b 5d f0             	mov    -0x10(%ebp),%ebx
c0000105:	89 f0                	mov    %esi,%eax
c0000107:	eb 16                	jmp    c000011f <format_uint+0x7f>
c0000109:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
            *(s--) = d + '0';
c0000110:	83 c2 30             	add    $0x30,%edx
c0000113:	88 53 01             	mov    %dl,0x1(%ebx)
    for(int nn=0;nn<num_digits; nn++)
c0000116:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0000119:	29 da                	sub    %ebx,%edx
c000011b:	39 d7                	cmp    %edx,%edi
c000011d:	7e 25                	jle    c0000144 <format_uint+0xa4>
        value /= base;
c000011f:	31 d2                	xor    %edx,%edx
            *(s--) = d + '0';
c0000121:	83 eb 01             	sub    $0x1,%ebx
        value /= base;
c0000124:	f7 f1                	div    %ecx
        if(d < 10)
c0000126:	83 fa 09             	cmp    $0x9,%edx
c0000129:	76 e5                	jbe    c0000110 <format_uint+0x70>
            *(s--) = d - 10 + 'a';
c000012b:	8d 72 37             	lea    0x37(%edx),%esi
c000012e:	83 c2 57             	add    $0x57,%edx
c0000131:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
c0000135:	0f 45 d6             	cmovne %esi,%edx
c0000138:	88 53 01             	mov    %dl,0x1(%ebx)
    for(int nn=0;nn<num_digits; nn++)
c000013b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000013e:	29 da                	sub    %ebx,%edx
c0000140:	39 d7                	cmp    %edx,%edi
c0000142:	7f db                	jg     c000011f <format_uint+0x7f>
}
c0000144:	83 c4 04             	add    $0x4,%esp
c0000147:	89 f8                	mov    %edi,%eax
c0000149:	5b                   	pop    %ebx
c000014a:	5e                   	pop    %esi
c000014b:	5f                   	pop    %edi
c000014c:	5d                   	pop    %ebp
c000014d:	c3                   	ret    
c000014e:	66 90                	xchg   %ax,%ax
        str[0] = 0;
c0000150:	8b 45 0c             	mov    0xc(%ebp),%eax
        return 0;
c0000153:	31 ff                	xor    %edi,%edi
        str[0] = 0;
c0000155:	c6 00 00             	movb   $0x0,(%eax)
}
c0000158:	83 c4 04             	add    $0x4,%esp
c000015b:	89 f8                	mov    %edi,%eax
c000015d:	5b                   	pop    %ebx
c000015e:	5e                   	pop    %esi
c000015f:	5f                   	pop    %edi
c0000160:	5d                   	pop    %ebp
c0000161:	c3                   	ret    
c0000162:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0000169:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    num_digits = num_digits>precision ? num_digits : precision;
c0000170:	85 ff                	test   %edi,%edi
    char* s = str + num_digits;
c0000172:	8b 45 0c             	mov    0xc(%ebp),%eax
    num_digits = num_digits>precision ? num_digits : precision;
c0000175:	0f 4e fb             	cmovle %ebx,%edi
    char* s = str + num_digits;
c0000178:	01 f8                	add    %edi,%eax
    *(s--) = '\0'; //null termination
c000017a:	8d 58 ff             	lea    -0x1(%eax),%ebx
c000017d:	c6 00 00             	movb   $0x0,(%eax)
c0000180:	89 5d f0             	mov    %ebx,-0x10(%ebp)
    for(int nn=0;nn<num_digits; nn++)
c0000183:	e9 7a ff ff ff       	jmp    c0000102 <format_uint+0x62>
        return -1;
c0000188:	bf ff ff ff ff       	mov    $0xffffffff,%edi
c000018d:	eb b5                	jmp    c0000144 <format_uint+0xa4>
c000018f:	90                   	nop

c0000190 <kprintf>:
{
c0000190:	55                   	push   %ebp
c0000191:	89 e5                	mov    %esp,%ebp
c0000193:	57                   	push   %edi
    int nchar = 0;
c0000194:	31 ff                	xor    %edi,%edi
{
c0000196:	56                   	push   %esi
    va_start(valist, format);
c0000197:	8d 45 0c             	lea    0xc(%ebp),%eax
{
c000019a:	53                   	push   %ebx
c000019b:	81 ec 5c 02 00 00    	sub    $0x25c,%esp
c00001a1:	8b 5d 08             	mov    0x8(%ebp),%ebx
    va_start(valist, format);
c00001a4:	89 85 b4 fd ff ff    	mov    %eax,-0x24c(%ebp)
    while(f[0] != 0)
c00001aa:	0f b6 03             	movzbl (%ebx),%eax
c00001ad:	84 c0                	test   %al,%al
c00001af:	74 29                	je     c00001da <kprintf+0x4a>
        if(f[0] == '\\' && f[1] == '%')
c00001b1:	3c 5c                	cmp    $0x5c,%al
c00001b3:	74 3b                	je     c00001f0 <kprintf+0x60>
        if(f[0] == '%')
c00001b5:	0f be 03             	movsbl (%ebx),%eax
c00001b8:	3c 25                	cmp    $0x25,%al
c00001ba:	74 64                	je     c0000220 <kprintf+0x90>
    terminal_putchar(&stdout, c); 
c00001bc:	83 ec 08             	sub    $0x8,%esp
            kprint_char(*(f++));
c00001bf:	83 c3 01             	add    $0x1,%ebx
            nchar++;
c00001c2:	83 c7 01             	add    $0x1,%edi
    terminal_putchar(&stdout, c); 
c00001c5:	50                   	push   %eax
c00001c6:	68 00 b0 00 c0       	push   $0xc000b000
c00001cb:	e8 80 16 00 00       	call   c0001850 <terminal_putchar>
            nchar++;
c00001d0:	83 c4 10             	add    $0x10,%esp
    while(f[0] != 0)
c00001d3:	0f b6 03             	movzbl (%ebx),%eax
c00001d6:	84 c0                	test   %al,%al
c00001d8:	75 d7                	jne    c00001b1 <kprintf+0x21>
}
c00001da:	8d 65 f4             	lea    -0xc(%ebp),%esp
c00001dd:	89 f8                	mov    %edi,%eax
c00001df:	5b                   	pop    %ebx
c00001e0:	5e                   	pop    %esi
c00001e1:	5f                   	pop    %edi
c00001e2:	5d                   	pop    %ebp
c00001e3:	c3                   	ret    
c00001e4:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00001eb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c00001ef:	90                   	nop
        if(f[0] == '\\' && f[1] == '%')
c00001f0:	80 7b 01 25          	cmpb   $0x25,0x1(%ebx)
c00001f4:	75 bf                	jne    c00001b5 <kprintf+0x25>
    terminal_putchar(&stdout, c); 
c00001f6:	83 ec 08             	sub    $0x8,%esp
            f += 2;
c00001f9:	83 c3 02             	add    $0x2,%ebx
            nchar++;
c00001fc:	83 c7 01             	add    $0x1,%edi
    terminal_putchar(&stdout, c); 
c00001ff:	6a 25                	push   $0x25
c0000201:	68 00 b0 00 c0       	push   $0xc000b000
c0000206:	e8 45 16 00 00       	call   c0001850 <terminal_putchar>
        if(f[0] == '%')
c000020b:	0f be 03             	movsbl (%ebx),%eax
            f += 2;
c000020e:	83 c4 10             	add    $0x10,%esp
        if(f[0] == '%')
c0000211:	3c 25                	cmp    $0x25,%al
c0000213:	75 a7                	jne    c00001bc <kprintf+0x2c>
c0000215:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000021c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                switch(*(++f))
c0000220:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
            struct format_flags flags = {0};
c0000224:	c6 85 c0 fd ff ff 00 	movb   $0x0,-0x240(%ebp)
c000022b:	31 f6                	xor    %esi,%esi
                switch(*(++f))
c000022d:	8d 4b 01             	lea    0x1(%ebx),%ecx
            struct format_flags flags = {0};
c0000230:	c6 85 bf fd ff ff 00 	movb   $0x0,-0x241(%ebp)
c0000237:	c6 85 d0 fd ff ff 00 	movb   $0x0,-0x230(%ebp)
c000023e:	c6 85 c8 fd ff ff 00 	movb   $0x0,-0x238(%ebp)
                switch(*(++f))
c0000245:	84 d2                	test   %dl,%dl
c0000247:	0f 84 b3 00 00 00    	je     c0000300 <kprintf+0x170>
c000024d:	8d 42 e0             	lea    -0x20(%edx),%eax
c0000250:	3c 10                	cmp    $0x10,%al
c0000252:	77 0c                	ja     c0000260 <kprintf+0xd0>
c0000254:	0f b6 c0             	movzbl %al,%eax
c0000257:	ff 24 85 00 30 00 c0 	jmp    *-0x3fffd000(,%eax,4)
c000025e:	66 90                	xchg   %ax,%ax
            if(flags.left) flags.zero = 0; //If the 0 and - flags both appear, the 0 flag is ignored
c0000260:	b8 00 00 00 00       	mov    $0x0,%eax
c0000265:	80 bd d0 fd ff ff 00 	cmpb   $0x0,-0x230(%ebp)
c000026c:	0f 45 f0             	cmovne %eax,%esi
            while(f[nn] >= '0' && f[nn] <= '9')
c000026f:	8d 42 d0             	lea    -0x30(%edx),%eax
c0000272:	3c 09                	cmp    $0x9,%al
c0000274:	0f 87 36 05 00 00    	ja     c00007b0 <kprintf+0x620>
c000027a:	8d 53 02             	lea    0x2(%ebx),%edx
c000027d:	8d 76 00             	lea    0x0(%esi),%esi
c0000280:	89 d3                	mov    %edx,%ebx
c0000282:	8d 52 01             	lea    0x1(%edx),%edx
c0000285:	0f b6 03             	movzbl (%ebx),%eax
c0000288:	83 e8 30             	sub    $0x30,%eax
c000028b:	3c 09                	cmp    $0x9,%al
c000028d:	76 f1                	jbe    c0000280 <kprintf+0xf0>
                field_width = atoi(f);
c000028f:	83 ec 0c             	sub    $0xc,%esp
c0000292:	51                   	push   %ecx
c0000293:	e8 e8 0f 00 00       	call   c0001280 <atoi>
            if(f[0] == '.')
c0000298:	0f b6 13             	movzbl (%ebx),%edx
c000029b:	83 c4 10             	add    $0x10,%esp
                field_width = atoi(f);
c000029e:	89 85 b0 fd ff ff    	mov    %eax,-0x250(%ebp)
            int field_prec=-1; //default is -1
c00002a4:	c7 85 ac fd ff ff ff 	movl   $0xffffffff,-0x254(%ebp)
c00002ab:	ff ff ff 
                f++;
c00002ae:	8d 43 01             	lea    0x1(%ebx),%eax
c00002b1:	89 85 b8 fd ff ff    	mov    %eax,-0x248(%ebp)
            if(f[0] == '.')
c00002b7:	80 fa 2e             	cmp    $0x2e,%dl
c00002ba:	0f 84 80 04 00 00    	je     c0000740 <kprintf+0x5b0>
            switch(*(f++))
c00002c0:	83 ea 4c             	sub    $0x4c,%edx
c00002c3:	80 fa 2e             	cmp    $0x2e,%dl
c00002c6:	0f 87 c4 00 00 00    	ja     c0000390 <kprintf+0x200>
c00002cc:	0f b6 d2             	movzbl %dl,%edx
c00002cf:	ff 24 95 44 30 00 c0 	jmp    *-0x3fffcfbc(,%edx,4)
c00002d6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00002dd:	8d 76 00             	lea    0x0(%esi),%esi
                        if(flags.zero) return 0;
c00002e0:	89 f0                	mov    %esi,%eax
c00002e2:	84 c0                	test   %al,%al
c00002e4:	0f 85 e6 04 00 00    	jne    c00007d0 <kprintf+0x640>
                        flags.zero = 1;
c00002ea:	be 01 00 00 00       	mov    $0x1,%esi
                        flags.sign = 1;
c00002ef:	89 cb                	mov    %ecx,%ebx
                switch(*(++f))
c00002f1:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
c00002f5:	8d 4b 01             	lea    0x1(%ebx),%ecx
c00002f8:	84 d2                	test   %dl,%dl
c00002fa:	0f 85 4d ff ff ff    	jne    c000024d <kprintf+0xbd>
}
c0000300:	8d 65 f4             	lea    -0xc(%ebp),%esp
                return -1;
c0000303:	bf ff ff ff ff       	mov    $0xffffffff,%edi
}
c0000308:	5b                   	pop    %ebx
c0000309:	89 f8                	mov    %edi,%eax
c000030b:	5e                   	pop    %esi
c000030c:	5f                   	pop    %edi
c000030d:	5d                   	pop    %ebp
c000030e:	c3                   	ret    
c000030f:	90                   	nop
                        if(flags.left) return 0;
c0000310:	80 bd d0 fd ff ff 00 	cmpb   $0x0,-0x230(%ebp)
c0000317:	0f 85 b3 04 00 00    	jne    c00007d0 <kprintf+0x640>
                        flags.left = 1;
c000031d:	c6 85 d0 fd ff ff 01 	movb   $0x1,-0x230(%ebp)
                        flags.sign = 1;
c0000324:	89 cb                	mov    %ecx,%ebx
c0000326:	eb c9                	jmp    c00002f1 <kprintf+0x161>
c0000328:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000032f:	90                   	nop
                        if(flags.sign) return 0;
c0000330:	80 bd c0 fd ff ff 00 	cmpb   $0x0,-0x240(%ebp)
c0000337:	0f 85 93 04 00 00    	jne    c00007d0 <kprintf+0x640>
                        flags.sign = 1;
c000033d:	c6 85 c0 fd ff ff 01 	movb   $0x1,-0x240(%ebp)
c0000344:	89 cb                	mov    %ecx,%ebx
c0000346:	eb a9                	jmp    c00002f1 <kprintf+0x161>
c0000348:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000034f:	90                   	nop
                        if(flags.alt) return 0;
c0000350:	80 bd c8 fd ff ff 00 	cmpb   $0x0,-0x238(%ebp)
c0000357:	0f 85 73 04 00 00    	jne    c00007d0 <kprintf+0x640>
                        flags.alt = 1;
c000035d:	c6 85 c8 fd ff ff 01 	movb   $0x1,-0x238(%ebp)
                        flags.sign = 1;
c0000364:	89 cb                	mov    %ecx,%ebx
c0000366:	eb 89                	jmp    c00002f1 <kprintf+0x161>
c0000368:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000036f:	90                   	nop
                        if(flags.space) return 0;
c0000370:	80 bd bf fd ff ff 00 	cmpb   $0x0,-0x241(%ebp)
c0000377:	0f 85 53 04 00 00    	jne    c00007d0 <kprintf+0x640>
                        flags.space = 1;
c000037d:	c6 85 bf fd ff ff 01 	movb   $0x1,-0x241(%ebp)
                        flags.sign = 1;
c0000384:	89 cb                	mov    %ecx,%ebx
c0000386:	e9 66 ff ff ff       	jmp    c00002f1 <kprintf+0x161>
c000038b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c000038f:	90                   	nop
                default:
c0000390:	89 9d b8 fd ff ff    	mov    %ebx,-0x248(%ebp)
                    length_mod = DEFAULT;
c0000396:	31 c0                	xor    %eax,%eax
c0000398:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000039f:	90                   	nop
            if(field_width>511)
c00003a0:	81 bd b0 fd ff ff ff 	cmpl   $0x1ff,-0x250(%ebp)
c00003a7:	01 00 00 
c00003aa:	0f 8f 50 ff ff ff    	jg     c0000300 <kprintf+0x170>
            switch(*f)
c00003b0:	8b 8d b8 fd ff ff    	mov    -0x248(%ebp),%ecx
c00003b6:	0f b6 19             	movzbl (%ecx),%ebx
c00003b9:	8d 53 ba             	lea    -0x46(%ebx),%edx
c00003bc:	80 fa 32             	cmp    $0x32,%dl
c00003bf:	0f 87 3b ff ff ff    	ja     c0000300 <kprintf+0x170>
c00003c5:	0f b6 d2             	movzbl %dl,%edx
c00003c8:	ff 24 95 00 31 00 c0 	jmp    *-0x3fffcf00(,%edx,4)
c00003cf:	90                   	nop
                    switch(length_mod)
c00003d0:	83 f8 04             	cmp    $0x4,%eax
c00003d3:	0f 87 27 ff ff ff    	ja     c0000300 <kprintf+0x170>
                                    ui_value = (unsigned int) va_arg(valist, long long unsigned int); //TODO: implement actual longlong handling
c00003d9:	8b 85 b4 fd ff ff    	mov    -0x24c(%ebp),%eax
c00003df:	8b 10                	mov    (%eax),%edx
                                if(length_mod == LONGLONGINT)
c00003e1:	0f 84 a3 05 00 00    	je     c000098a <kprintf+0x7fa>
                                    ui_value = va_arg(valist, unsigned int);
c00003e7:	83 c0 04             	add    $0x4,%eax
c00003ea:	89 85 b4 fd ff ff    	mov    %eax,-0x24c(%ebp)
                                if(*f == 'o')
c00003f0:	80 fb 6f             	cmp    $0x6f,%bl
c00003f3:	0f 84 9f 05 00 00    	je     c0000998 <kprintf+0x808>
                                else if(*f == 'x' || *f == 'X')
c00003f9:	89 d8                	mov    %ebx,%eax
c00003fb:	83 e0 df             	and    $0xffffffdf,%eax
c00003fe:	3c 58                	cmp    $0x58,%al
c0000400:	0f 85 d1 03 00 00    	jne    c00007d7 <kprintf+0x647>
                                int len = format_uint(ui_value, val_buf, base, field_prec, cap);
c0000406:	83 ec 0c             	sub    $0xc,%esp
                                else if(*f == 'x' || *f == 'X')
c0000409:	31 c0                	xor    %eax,%eax
c000040b:	80 fb 58             	cmp    $0x58,%bl
c000040e:	0f 94 c0             	sete   %al
                                int len = format_uint(ui_value, val_buf, base, field_prec, cap);
c0000411:	50                   	push   %eax
c0000412:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
c0000418:	ff b5 ac fd ff ff    	pushl  -0x254(%ebp)
c000041e:	6a 10                	push   $0x10
c0000420:	50                   	push   %eax
c0000421:	52                   	push   %edx
c0000422:	89 85 c0 fd ff ff    	mov    %eax,-0x240(%ebp)
c0000428:	e8 73 fc ff ff       	call   c00000a0 <format_uint>
                                int lenpad = field_width - len; 
c000042d:	8b 95 b0 fd ff ff    	mov    -0x250(%ebp),%edx
                                if(flags.alt)
c0000433:	83 c4 20             	add    $0x20,%esp
                                char radix[3]="";
c0000436:	c6 85 e7 fd ff ff 00 	movb   $0x0,-0x219(%ebp)
                                int lenpad = field_width - len; 
c000043d:	29 c2                	sub    %eax,%edx
                                char radix[3]="";
c000043f:	31 c0                	xor    %eax,%eax
                                if(flags.alt)
c0000441:	80 bd c8 fd ff ff 00 	cmpb   $0x0,-0x238(%ebp)
                                char radix[3]="";
c0000448:	66 89 85 e5 fd ff ff 	mov    %ax,-0x21b(%ebp)
                                if(flags.alt)
c000044f:	0f 84 c6 03 00 00    	je     c000081b <kprintf+0x68b>
                                        radix[0] = '0';
c0000455:	c6 85 e5 fd ff ff 30 	movb   $0x30,-0x21b(%ebp)
                                        lenpad -= 2;
c000045c:	83 ea 02             	sub    $0x2,%edx
                                        radix[1] = cap ? 'X' : 'x';
c000045f:	80 fb 58             	cmp    $0x58,%bl
c0000462:	0f 85 6d 0b 00 00    	jne    c0000fd5 <kprintf+0xe45>
c0000468:	88 9d e6 fd ff ff    	mov    %bl,-0x21a(%ebp)
                                    if(flags.zero)
c000046e:	89 f0                	mov    %esi,%eax
c0000470:	84 c0                	test   %al,%al
c0000472:	0f 85 d0 08 00 00    	jne    c0000d48 <kprintf+0xbb8>
                                if(!flags.left && lenpad>0)
c0000478:	80 bd d0 fd ff ff 00 	cmpb   $0x0,-0x230(%ebp)
c000047f:	0f 85 0a 08 00 00    	jne    c0000c8f <kprintf+0xaff>
c0000485:	85 d2                	test   %edx,%edx
c0000487:	0f 8e 40 08 00 00    	jle    c0000ccd <kprintf+0xb3d>
                                        nchar += kprintn_char('0', lenpad);
c000048d:	01 d7                	add    %edx,%edi
    terminal_putcharn(&stdout, c, rpt); 
c000048f:	83 ec 04             	sub    $0x4,%esp
c0000492:	52                   	push   %edx
c0000493:	6a 20                	push   $0x20
c0000495:	68 00 b0 00 c0       	push   $0xc000b000
c000049a:	e8 d1 11 00 00       	call   c0001670 <terminal_putcharn>
                                if(!flags.zero && radix[0])
c000049f:	83 c4 10             	add    $0x10,%esp
c00004a2:	80 bd e5 fd ff ff 00 	cmpb   $0x0,-0x21b(%ebp)
c00004a9:	0f 85 2b 08 00 00    	jne    c0000cda <kprintf+0xb4a>
    terminal_writestring(&stdout, str);
c00004af:	83 ec 08             	sub    $0x8,%esp
c00004b2:	e9 99 03 00 00       	jmp    c0000850 <kprintf+0x6c0>
                    length_mod = SIZE;
c00004b7:	b8 07 00 00 00       	mov    $0x7,%eax
                    break;
c00004bc:	e9 df fe ff ff       	jmp    c00003a0 <kprintf+0x210>
                    switch(length_mod)
c00004c1:	83 f8 04             	cmp    $0x4,%eax
c00004c4:	0f 87 36 fe ff ff    	ja     c0000300 <kprintf+0x170>
                                    i_value = (int) va_arg(valist, long long int); //TODO: implement actual longlong handling
c00004ca:	8b 8d b4 fd ff ff    	mov    -0x24c(%ebp),%ecx
c00004d0:	8b 01                	mov    (%ecx),%eax
                                if(length_mod == LONGLONGINT)
c00004d2:	0f 84 a4 04 00 00    	je     c000097c <kprintf+0x7ec>
                                    i_value = va_arg(valist, int);
c00004d8:	83 c1 04             	add    $0x4,%ecx
c00004db:	89 8d b4 fd ff ff    	mov    %ecx,-0x24c(%ebp)
                                if(i_value<0)
c00004e1:	85 c0                	test   %eax,%eax
c00004e3:	0f 88 5a 04 00 00    	js     c0000943 <kprintf+0x7b3>
                                    if(flags.sign)
c00004e9:	80 bd c0 fd ff ff 00 	cmpb   $0x0,-0x240(%ebp)
                                    ui_value = i_value;
c00004f0:	89 c2                	mov    %eax,%edx
                                    if(flags.sign)
c00004f2:	0f 85 85 03 00 00    	jne    c000087d <kprintf+0x6ed>
                                    else if(flags.space)
c00004f8:	80 bd bf fd ff ff 00 	cmpb   $0x0,-0x241(%ebp)
c00004ff:	0f 84 b3 08 00 00    	je     c0000db8 <kprintf+0xc28>
                                        sign_char = ' ';
c0000505:	b9 20 00 00 00       	mov    $0x20,%ecx
c000050a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
                                int len = format_uint(ui_value, val_buf, 10, field_prec, 0);
c0000510:	83 ec 0c             	sub    $0xc,%esp
c0000513:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
c0000519:	88 8d c8 fd ff ff    	mov    %cl,-0x238(%ebp)
c000051f:	6a 00                	push   $0x0
c0000521:	ff b5 ac fd ff ff    	pushl  -0x254(%ebp)
c0000527:	6a 0a                	push   $0xa
c0000529:	50                   	push   %eax
c000052a:	52                   	push   %edx
c000052b:	89 85 c0 fd ff ff    	mov    %eax,-0x240(%ebp)
c0000531:	e8 6a fb ff ff       	call   c00000a0 <format_uint>
                                int lenpad = field_width - len; 
c0000536:	8b 9d b0 fd ff ff    	mov    -0x250(%ebp),%ebx
                                    if(flags.zero)
c000053c:	83 c4 20             	add    $0x20,%esp
c000053f:	0f b6 8d c8 fd ff ff 	movzbl -0x238(%ebp),%ecx
                                int lenpad = field_width - len; 
c0000546:	29 c3                	sub    %eax,%ebx
                                    if(flags.zero)
c0000548:	89 f0                	mov    %esi,%eax
                                    lenpad--; //remove one char of padding to account for sign
c000054a:	83 eb 01             	sub    $0x1,%ebx
                                    if(flags.zero)
c000054d:	84 c0                	test   %al,%al
c000054f:	0f 85 aa 07 00 00    	jne    c0000cff <kprintf+0xb6f>
                                if(!flags.left && lenpad>0)
c0000555:	80 bd d0 fd ff ff 00 	cmpb   $0x0,-0x230(%ebp)
c000055c:	0f 84 ef 03 00 00    	je     c0000951 <kprintf+0x7c1>
    terminal_putchar(&stdout, c); 
c0000562:	83 ec 08             	sub    $0x8,%esp
                                    nchar += kprint_char(sign_char); //if not zero padding, write sign here
c0000565:	0f be c1             	movsbl %cl,%eax
c0000568:	83 c7 01             	add    $0x1,%edi
    terminal_putchar(&stdout, c); 
c000056b:	50                   	push   %eax
c000056c:	68 00 b0 00 c0       	push   $0xc000b000
c0000571:	e8 da 12 00 00       	call   c0001850 <terminal_putchar>
    terminal_writestring(&stdout, str);
c0000576:	58                   	pop    %eax
c0000577:	5a                   	pop    %edx
c0000578:	8b b5 c0 fd ff ff    	mov    -0x240(%ebp),%esi
c000057e:	56                   	push   %esi
c000057f:	68 00 b0 00 c0       	push   $0xc000b000
c0000584:	e8 17 15 00 00       	call   c0001aa0 <terminal_writestring>
    return strlen(str);
c0000589:	89 34 24             	mov    %esi,(%esp)
c000058c:	e8 6f 0c 00 00       	call   c0001200 <strlen>
                                nchar += kprint(val_buf);
c0000591:	83 c4 10             	add    $0x10,%esp
c0000594:	01 c7                	add    %eax,%edi
                                if(flags.left && lenpad>0)
c0000596:	85 db                	test   %ebx,%ebx
c0000598:	7e 56                	jle    c00005f0 <kprintf+0x460>
    terminal_putcharn(&stdout, c, rpt); 
c000059a:	83 ec 04             	sub    $0x4,%esp
c000059d:	e9 86 01 00 00       	jmp    c0000728 <kprintf+0x598>
                        float f_value = (float) va_arg(valist, double);
c00005a2:	8b 8d b4 fd ff ff    	mov    -0x24c(%ebp),%ecx
                        if(f_value==0 && field_prec==0)
c00005a8:	ba 00 00 00 00       	mov    $0x0,%edx
                        float f_value = (float) va_arg(valist, double);
c00005ad:	89 c8                	mov    %ecx,%eax
c00005af:	83 c1 08             	add    $0x8,%ecx
c00005b2:	dd 00                	fldl   (%eax)
c00005b4:	89 8d b4 fd ff ff    	mov    %ecx,-0x24c(%ebp)
c00005ba:	d9 9d c8 fd ff ff    	fstps  -0x238(%ebp)
c00005c0:	d9 85 c8 fd ff ff    	flds   -0x238(%ebp)
                        if(f_value==0 && field_prec==0)
c00005c6:	d9 ee                	fldz   
c00005c8:	df e9                	fucomip %st(1),%st
c00005ca:	dd d8                	fstp   %st(0)
c00005cc:	0f 9b c0             	setnp  %al
c00005cf:	0f 45 c2             	cmovne %edx,%eax
c00005d2:	84 c0                	test   %al,%al
c00005d4:	0f 84 22 04 00 00    	je     c00009fc <kprintf+0x86c>
c00005da:	8b 85 ac fd ff ff    	mov    -0x254(%ebp),%eax
c00005e0:	85 c0                	test   %eax,%eax
c00005e2:	0f 85 14 04 00 00    	jne    c00009fc <kprintf+0x86c>
c00005e8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00005ef:	90                   	nop
            f++;
c00005f0:	8b 9d b8 fd ff ff    	mov    -0x248(%ebp),%ebx
c00005f6:	83 c3 01             	add    $0x1,%ebx
c00005f9:	e9 d5 fb ff ff       	jmp    c00001d3 <kprintf+0x43>
                    if(*f == 'h')
c00005fe:	80 7b 01 68          	cmpb   $0x68,0x1(%ebx)
                        length_mod = SHORTINT;
c0000602:	b8 02 00 00 00       	mov    $0x2,%eax
                    if(*f == 'h')
c0000607:	0f 85 93 fd ff ff    	jne    c00003a0 <kprintf+0x210>
                        f++;
c000060d:	8d 43 02             	lea    0x2(%ebx),%eax
c0000610:	89 85 b8 fd ff ff    	mov    %eax,-0x248(%ebp)
                        length_mod = CHARINT;
c0000616:	b8 01 00 00 00       	mov    $0x1,%eax
c000061b:	e9 80 fd ff ff       	jmp    c00003a0 <kprintf+0x210>
                    if(*f == 'l')
c0000620:	80 7b 01 6c          	cmpb   $0x6c,0x1(%ebx)
                        length_mod = LONGINT;
c0000624:	b8 03 00 00 00       	mov    $0x3,%eax
                    if(*f == 'l')
c0000629:	0f 85 71 fd ff ff    	jne    c00003a0 <kprintf+0x210>
                        f++;
c000062f:	8d 43 02             	lea    0x2(%ebx),%eax
c0000632:	89 85 b8 fd ff ff    	mov    %eax,-0x248(%ebp)
                        length_mod = LONGLONGINT;
c0000638:	b8 04 00 00 00       	mov    $0x4,%eax
c000063d:	e9 5e fd ff ff       	jmp    c00003a0 <kprintf+0x210>
                    length_mod = PTRDIFF;
c0000642:	b8 08 00 00 00       	mov    $0x8,%eax
                    break;
c0000647:	e9 54 fd ff ff       	jmp    c00003a0 <kprintf+0x210>
                        char* str = va_arg(valist, char*);
c000064c:	8b 85 b4 fd ff ff    	mov    -0x24c(%ebp),%eax
                        int len = strlen(str);
c0000652:	83 ec 0c             	sub    $0xc,%esp
                        char* str = va_arg(valist, char*);
c0000655:	8d 70 04             	lea    0x4(%eax),%esi
c0000658:	89 b5 c8 fd ff ff    	mov    %esi,-0x238(%ebp)
c000065e:	8b 30                	mov    (%eax),%esi
                        int len = strlen(str);
c0000660:	56                   	push   %esi
c0000661:	e8 9a 0b 00 00       	call   c0001200 <strlen>
                        if(field_prec > 0 && field_prec < len)
c0000666:	8b 8d ac fd ff ff    	mov    -0x254(%ebp),%ecx
c000066c:	83 c4 10             	add    $0x10,%esp
                        int len = strlen(str);
c000066f:	89 c3                	mov    %eax,%ebx
                        if(field_prec > 0 && field_prec < len)
c0000671:	85 c9                	test   %ecx,%ecx
c0000673:	7e 08                	jle    c000067d <kprintf+0x4ed>
c0000675:	39 c1                	cmp    %eax,%ecx
c0000677:	7d 04                	jge    c000067d <kprintf+0x4ed>
                        nchar += kprintn(str,len);
c0000679:	89 cb                	mov    %ecx,%ebx
c000067b:	89 c8                	mov    %ecx,%eax
                        int lenpad = field_width - len; 
c000067d:	8b 95 b0 fd ff ff    	mov    -0x250(%ebp),%edx
c0000683:	29 c2                	sub    %eax,%edx
                        if(lenpad>0 && !flags.left)    
c0000685:	85 d2                	test   %edx,%edx
c0000687:	0f 8e 7d 02 00 00    	jle    c000090a <kprintf+0x77a>
c000068d:	80 bd d0 fd ff ff 00 	cmpb   $0x0,-0x230(%ebp)
c0000694:	0f 84 17 02 00 00    	je     c00008b1 <kprintf+0x721>
    terminal_write(&stdout, str, len);
c000069a:	83 ec 04             	sub    $0x4,%esp
c000069d:	89 95 d0 fd ff ff    	mov    %edx,-0x230(%ebp)
c00006a3:	53                   	push   %ebx
c00006a4:	56                   	push   %esi
c00006a5:	68 00 b0 00 c0       	push   $0xc000b000
c00006aa:	e8 91 12 00 00       	call   c0001940 <terminal_write>
    terminal_putcharn(&stdout, c, rpt); 
c00006af:	8b 95 d0 fd ff ff    	mov    -0x230(%ebp),%edx
c00006b5:	83 c4 0c             	add    $0xc,%esp
c00006b8:	52                   	push   %edx
c00006b9:	6a 20                	push   $0x20
c00006bb:	68 00 b0 00 c0       	push   $0xc000b000
c00006c0:	e8 ab 0f 00 00       	call   c0001670 <terminal_putcharn>
                        char* str = va_arg(valist, char*);
c00006c5:	8b 85 c8 fd ff ff    	mov    -0x238(%ebp),%eax
                            nchar += kprintn_char(' ', lenpad);
c00006cb:	03 bd b0 fd ff ff    	add    -0x250(%ebp),%edi
c00006d1:	83 c4 10             	add    $0x10,%esp
                        char* str = va_arg(valist, char*);
c00006d4:	89 85 b4 fd ff ff    	mov    %eax,-0x24c(%ebp)
c00006da:	e9 11 ff ff ff       	jmp    c00005f0 <kprintf+0x460>
                        char c = (char) va_arg(valist, int);
c00006df:	8b b5 b4 fd ff ff    	mov    -0x24c(%ebp),%esi
c00006e5:	89 f0                	mov    %esi,%eax
c00006e7:	83 c6 04             	add    $0x4,%esi
c00006ea:	89 b5 b4 fd ff ff    	mov    %esi,-0x24c(%ebp)
                        nchar += kprint_char(c);
c00006f0:	0f be 30             	movsbl (%eax),%esi
                        if(field_width>1 && !flags.left)    
c00006f3:	8b 85 b0 fd ff ff    	mov    -0x250(%ebp),%eax
c00006f9:	83 f8 01             	cmp    $0x1,%eax
c00006fc:	0f 8e 39 02 00 00    	jle    c000093b <kprintf+0x7ab>
                            nchar += kprintn_char(' ', field_width-1);
c0000702:	89 c3                	mov    %eax,%ebx
c0000704:	83 eb 01             	sub    $0x1,%ebx
                        if(field_width>1 && !flags.left)    
c0000707:	80 bd d0 fd ff ff 00 	cmpb   $0x0,-0x230(%ebp)
c000070e:	0f 84 73 01 00 00    	je     c0000887 <kprintf+0x6f7>
    terminal_putchar(&stdout, c); 
c0000714:	83 ec 08             	sub    $0x8,%esp
                        nchar += kprint_char(c);
c0000717:	83 c7 01             	add    $0x1,%edi
    terminal_putchar(&stdout, c); 
c000071a:	56                   	push   %esi
c000071b:	68 00 b0 00 c0       	push   $0xc000b000
c0000720:	e8 2b 11 00 00       	call   c0001850 <terminal_putchar>
    terminal_putcharn(&stdout, c, rpt); 
c0000725:	83 c4 0c             	add    $0xc,%esp
c0000728:	53                   	push   %ebx
                            nchar += kprintn_char(' ', field_width-1);
c0000729:	01 df                	add    %ebx,%edi
    terminal_putcharn(&stdout, c, rpt); 
c000072b:	6a 20                	push   $0x20
c000072d:	68 00 b0 00 c0       	push   $0xc000b000
c0000732:	e8 39 0f 00 00       	call   c0001670 <terminal_putcharn>
                            nchar += kprintn_char(' ', field_width-1);
c0000737:	83 c4 10             	add    $0x10,%esp
c000073a:	e9 b1 fe ff ff       	jmp    c00005f0 <kprintf+0x460>
c000073f:	90                   	nop
                while(f[nn] >= '0' && f[nn] <= '9')
c0000740:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
c0000744:	8d 4b 02             	lea    0x2(%ebx),%ecx
c0000747:	8d 42 d0             	lea    -0x30(%edx),%eax
c000074a:	3c 09                	cmp    $0x9,%al
c000074c:	0f 87 41 07 00 00    	ja     c0000e93 <kprintf+0xd03>
c0000752:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0000759:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0000760:	89 cb                	mov    %ecx,%ebx
c0000762:	8d 49 01             	lea    0x1(%ecx),%ecx
c0000765:	0f b6 03             	movzbl (%ebx),%eax
c0000768:	83 e8 30             	sub    $0x30,%eax
c000076b:	3c 09                	cmp    $0x9,%al
c000076d:	76 f1                	jbe    c0000760 <kprintf+0x5d0>
                    field_prec = atoi(f);
c000076f:	83 ec 0c             	sub    $0xc,%esp
c0000772:	ff b5 b8 fd ff ff    	pushl  -0x248(%ebp)
c0000778:	89 8d a0 fd ff ff    	mov    %ecx,-0x260(%ebp)
c000077e:	e8 fd 0a 00 00       	call   c0001280 <atoi>
                    if(field_prec<0) field_prec = 0;
c0000783:	83 c4 10             	add    $0x10,%esp
c0000786:	ba 00 00 00 00       	mov    $0x0,%edx
            switch(*(f++))
c000078b:	8b 8d a0 fd ff ff    	mov    -0x260(%ebp),%ecx
c0000791:	85 c0                	test   %eax,%eax
c0000793:	0f 49 d0             	cmovns %eax,%edx
c0000796:	89 8d b8 fd ff ff    	mov    %ecx,-0x248(%ebp)
c000079c:	89 95 ac fd ff ff    	mov    %edx,-0x254(%ebp)
c00007a2:	0f b6 13             	movzbl (%ebx),%edx
c00007a5:	e9 16 fb ff ff       	jmp    c00002c0 <kprintf+0x130>
c00007aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
            int field_width=0;
c00007b0:	c7 85 b0 fd ff ff 00 	movl   $0x0,-0x250(%ebp)
c00007b7:	00 00 00 
            while(f[nn] >= '0' && f[nn] <= '9')
c00007ba:	89 cb                	mov    %ecx,%ebx
c00007bc:	e9 e3 fa ff ff       	jmp    c00002a4 <kprintf+0x114>
c00007c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00007c8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00007cf:	90                   	nop
                        if(flags.alt) return 0;
c00007d0:	31 ff                	xor    %edi,%edi
c00007d2:	e9 03 fa ff ff       	jmp    c00001da <kprintf+0x4a>
                                else if(*f == 'p')
c00007d7:	80 fb 70             	cmp    $0x70,%bl
c00007da:	0f 84 e9 06 00 00    	je     c0000ec9 <kprintf+0xd39>
                                int len = format_uint(ui_value, val_buf, base, field_prec, cap);
c00007e0:	83 ec 0c             	sub    $0xc,%esp
c00007e3:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
c00007e9:	6a 00                	push   $0x0
c00007eb:	ff b5 ac fd ff ff    	pushl  -0x254(%ebp)
c00007f1:	6a 0a                	push   $0xa
c00007f3:	50                   	push   %eax
c00007f4:	52                   	push   %edx
c00007f5:	89 85 c0 fd ff ff    	mov    %eax,-0x240(%ebp)
c00007fb:	e8 a0 f8 ff ff       	call   c00000a0 <format_uint>
                                int lenpad = field_width - len; 
c0000800:	8b 95 b0 fd ff ff    	mov    -0x250(%ebp),%edx
                                char radix[3]="";
c0000806:	c6 85 e7 fd ff ff 00 	movb   $0x0,-0x219(%ebp)
c000080d:	83 c4 20             	add    $0x20,%esp
                                int lenpad = field_width - len; 
c0000810:	29 c2                	sub    %eax,%edx
                                char radix[3]="";
c0000812:	31 c0                	xor    %eax,%eax
c0000814:	66 89 85 e5 fd ff ff 	mov    %ax,-0x21b(%ebp)
                                if(!flags.left && lenpad>0)
c000081b:	80 bd d0 fd ff ff 00 	cmpb   $0x0,-0x230(%ebp)
c0000822:	0f 85 06 04 00 00    	jne    c0000c2e <kprintf+0xa9e>
c0000828:	85 d2                	test   %edx,%edx
c000082a:	0f 8e 93 04 00 00    	jle    c0000cc3 <kprintf+0xb33>
                                    if(flags.zero)
c0000830:	89 f0                	mov    %esi,%eax
                                        nchar += kprintn_char('0', lenpad);
c0000832:	01 d7                	add    %edx,%edi
                                    if(flags.zero)
c0000834:	84 c0                	test   %al,%al
c0000836:	0f 84 53 fc ff ff    	je     c000048f <kprintf+0x2ff>
    terminal_putcharn(&stdout, c, rpt); 
c000083c:	83 ec 04             	sub    $0x4,%esp
c000083f:	52                   	push   %edx
c0000840:	6a 30                	push   $0x30
c0000842:	68 00 b0 00 c0       	push   $0xc000b000
c0000847:	e8 24 0e 00 00       	call   c0001670 <terminal_putcharn>
    terminal_writestring(&stdout, str);
c000084c:	58                   	pop    %eax
c000084d:	5a                   	pop    %edx
c000084e:	66 90                	xchg   %ax,%ax
c0000850:	8b b5 c0 fd ff ff    	mov    -0x240(%ebp),%esi
c0000856:	56                   	push   %esi
c0000857:	68 00 b0 00 c0       	push   $0xc000b000
c000085c:	e8 3f 12 00 00       	call   c0001aa0 <terminal_writestring>
    return strlen(str);
c0000861:	89 34 24             	mov    %esi,(%esp)
c0000864:	e8 97 09 00 00       	call   c0001200 <strlen>
                                nchar += kprint(val_buf);
c0000869:	83 c4 10             	add    $0x10,%esp
c000086c:	01 c7                	add    %eax,%edi
                                if(flags.left && lenpad>0)
c000086e:	e9 7d fd ff ff       	jmp    c00005f0 <kprintf+0x460>
                    length_mod = LONGDOUBLE;
c0000873:	b8 05 00 00 00       	mov    $0x5,%eax
c0000878:	e9 23 fb ff ff       	jmp    c00003a0 <kprintf+0x210>
                                        sign_char = '+';
c000087d:	b9 2b 00 00 00       	mov    $0x2b,%ecx
c0000882:	e9 89 fc ff ff       	jmp    c0000510 <kprintf+0x380>
    terminal_putcharn(&stdout, c, rpt); 
c0000887:	83 ec 04             	sub    $0x4,%esp
                            nchar += kprintn_char(' ', field_width-1);
c000088a:	01 df                	add    %ebx,%edi
    terminal_putcharn(&stdout, c, rpt); 
c000088c:	53                   	push   %ebx
c000088d:	6a 20                	push   $0x20
c000088f:	68 00 b0 00 c0       	push   $0xc000b000
c0000894:	e8 d7 0d 00 00       	call   c0001670 <terminal_putcharn>
    terminal_putchar(&stdout, c); 
c0000899:	58                   	pop    %eax
c000089a:	5a                   	pop    %edx
c000089b:	56                   	push   %esi
                        nchar += kprint_char(c);
c000089c:	83 c7 01             	add    $0x1,%edi
    terminal_putchar(&stdout, c); 
c000089f:	68 00 b0 00 c0       	push   $0xc000b000
c00008a4:	e8 a7 0f 00 00       	call   c0001850 <terminal_putchar>
                        if(field_width>1 && flags.left)    
c00008a9:	83 c4 10             	add    $0x10,%esp
c00008ac:	e9 3f fd ff ff       	jmp    c00005f0 <kprintf+0x460>
    terminal_putcharn(&stdout, c, rpt); 
c00008b1:	83 ec 04             	sub    $0x4,%esp
c00008b4:	89 85 c0 fd ff ff    	mov    %eax,-0x240(%ebp)
c00008ba:	52                   	push   %edx
c00008bb:	6a 20                	push   $0x20
c00008bd:	68 00 b0 00 c0       	push   $0xc000b000
c00008c2:	89 95 d0 fd ff ff    	mov    %edx,-0x230(%ebp)
c00008c8:	e8 a3 0d 00 00       	call   c0001670 <terminal_putcharn>
    terminal_write(&stdout, str, len);
c00008cd:	83 c4 0c             	add    $0xc,%esp
                            nchar += kprintn_char(' ', lenpad);
c00008d0:	8b 95 d0 fd ff ff    	mov    -0x230(%ebp),%edx
    terminal_write(&stdout, str, len);
c00008d6:	53                   	push   %ebx
c00008d7:	56                   	push   %esi
                            nchar += kprintn_char(' ', lenpad);
c00008d8:	01 d7                	add    %edx,%edi
    terminal_write(&stdout, str, len);
c00008da:	68 00 b0 00 c0       	push   $0xc000b000
c00008df:	e8 5c 10 00 00       	call   c0001940 <terminal_write>
                        nchar += kprintn(str,len);
c00008e4:	8b 85 c0 fd ff ff    	mov    -0x240(%ebp),%eax
c00008ea:	83 c4 10             	add    $0x10,%esp
c00008ed:	01 c7                	add    %eax,%edi
                        char* str = va_arg(valist, char*);
c00008ef:	8b 85 c8 fd ff ff    	mov    -0x238(%ebp),%eax
c00008f5:	89 85 b4 fd ff ff    	mov    %eax,-0x24c(%ebp)
c00008fb:	e9 f0 fc ff ff       	jmp    c00005f0 <kprintf+0x460>
            int field_prec=-1; //default is -1
c0000900:	b8 06 00 00 00       	mov    $0x6,%eax
c0000905:	e9 96 fa ff ff       	jmp    c00003a0 <kprintf+0x210>
    terminal_write(&stdout, str, len);
c000090a:	83 ec 04             	sub    $0x4,%esp
c000090d:	89 85 d0 fd ff ff    	mov    %eax,-0x230(%ebp)
c0000913:	53                   	push   %ebx
c0000914:	56                   	push   %esi
c0000915:	68 00 b0 00 c0       	push   $0xc000b000
c000091a:	e8 21 10 00 00       	call   c0001940 <terminal_write>
                        nchar += kprintn(str,len);
c000091f:	8b 85 d0 fd ff ff    	mov    -0x230(%ebp),%eax
c0000925:	83 c4 10             	add    $0x10,%esp
c0000928:	01 c7                	add    %eax,%edi
                        char* str = va_arg(valist, char*);
c000092a:	8b 85 c8 fd ff ff    	mov    -0x238(%ebp),%eax
c0000930:	89 85 b4 fd ff ff    	mov    %eax,-0x24c(%ebp)
c0000936:	e9 b5 fc ff ff       	jmp    c00005f0 <kprintf+0x460>
    terminal_putchar(&stdout, c); 
c000093b:	83 ec 08             	sub    $0x8,%esp
c000093e:	e9 58 ff ff ff       	jmp    c000089b <kprintf+0x70b>
                                    ui_value = -i_value;
c0000943:	f7 d8                	neg    %eax
                                    sign_char = '-';
c0000945:	b9 2d 00 00 00       	mov    $0x2d,%ecx
                                    ui_value = -i_value;
c000094a:	89 c2                	mov    %eax,%edx
                                    sign_char = '-';
c000094c:	e9 bf fb ff ff       	jmp    c0000510 <kprintf+0x380>
                                if(!flags.left && lenpad>0)
c0000951:	85 db                	test   %ebx,%ebx
c0000953:	0f 8f 38 04 00 00    	jg     c0000d91 <kprintf+0xc01>
                                if(!flags.zero && sign_char)
c0000959:	84 c9                	test   %cl,%cl
c000095b:	0f 84 4e fb ff ff    	je     c00004af <kprintf+0x31f>
    terminal_putchar(&stdout, c); 
c0000961:	83 ec 08             	sub    $0x8,%esp
                                    nchar += kprint_char(sign_char); //if not zero padding, write sign here
c0000964:	0f be c1             	movsbl %cl,%eax
c0000967:	83 c7 01             	add    $0x1,%edi
    terminal_putchar(&stdout, c); 
c000096a:	50                   	push   %eax
c000096b:	68 00 b0 00 c0       	push   $0xc000b000
c0000970:	e8 db 0e 00 00       	call   c0001850 <terminal_putchar>
    terminal_writestring(&stdout, str);
c0000975:	59                   	pop    %ecx
c0000976:	5b                   	pop    %ebx
c0000977:	e9 d4 fe ff ff       	jmp    c0000850 <kprintf+0x6c0>
                                    i_value = (int) va_arg(valist, long long int); //TODO: implement actual longlong handling
c000097c:	83 c1 08             	add    $0x8,%ecx
c000097f:	89 8d b4 fd ff ff    	mov    %ecx,-0x24c(%ebp)
c0000985:	e9 57 fb ff ff       	jmp    c00004e1 <kprintf+0x351>
                                    ui_value = (unsigned int) va_arg(valist, long long unsigned int); //TODO: implement actual longlong handling
c000098a:	83 c0 08             	add    $0x8,%eax
c000098d:	89 85 b4 fd ff ff    	mov    %eax,-0x24c(%ebp)
c0000993:	e9 58 fa ff ff       	jmp    c00003f0 <kprintf+0x260>
                                int len = format_uint(ui_value, val_buf, base, field_prec, cap);
c0000998:	83 ec 0c             	sub    $0xc,%esp
c000099b:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
c00009a1:	6a 00                	push   $0x0
c00009a3:	ff b5 ac fd ff ff    	pushl  -0x254(%ebp)
c00009a9:	6a 08                	push   $0x8
c00009ab:	50                   	push   %eax
c00009ac:	52                   	push   %edx
c00009ad:	89 85 c0 fd ff ff    	mov    %eax,-0x240(%ebp)
c00009b3:	e8 e8 f6 ff ff       	call   c00000a0 <format_uint>
                                int lenpad = field_width - len; 
c00009b8:	8b 95 b0 fd ff ff    	mov    -0x250(%ebp),%edx
                                if(flags.alt)
c00009be:	83 c4 20             	add    $0x20,%esp
                                char radix[3]="";
c00009c1:	c6 85 e7 fd ff ff 00 	movb   $0x0,-0x219(%ebp)
                                int lenpad = field_width - len; 
c00009c8:	29 c2                	sub    %eax,%edx
                                char radix[3]="";
c00009ca:	31 c0                	xor    %eax,%eax
                                if(flags.alt)
c00009cc:	80 bd c8 fd ff ff 00 	cmpb   $0x0,-0x238(%ebp)
                                char radix[3]="";
c00009d3:	66 89 85 e5 fd ff ff 	mov    %ax,-0x21b(%ebp)
                                if(flags.alt)
c00009da:	0f 84 3b fe ff ff    	je     c000081b <kprintf+0x68b>
                                    else if(base==8 && val_buf[0] != '0')
c00009e0:	80 bd e8 fd ff ff 30 	cmpb   $0x30,-0x218(%ebp)
c00009e7:	0f 84 81 fa ff ff    	je     c000046e <kprintf+0x2de>
                                        radix[0] = '0';
c00009ed:	c6 85 e5 fd ff ff 30 	movb   $0x30,-0x21b(%ebp)
                                        lenpad -= 1;
c00009f4:	83 ea 01             	sub    $0x1,%edx
                                        radix[1] = 0;
c00009f7:	e9 72 fa ff ff       	jmp    c000046e <kprintf+0x2de>
                        if(field_prec<0) field_prec = 6;  //default is prec = 6
c00009fc:	8b 8d ac fd ff ff    	mov    -0x254(%ebp),%ecx
                        if(f_value<0)
c0000a02:	d9 85 c8 fd ff ff    	flds   -0x238(%ebp)
c0000a08:	d9 ee                	fldz   
                        if(field_prec<0) field_prec = 6;  //default is prec = 6
c0000a0a:	b8 06 00 00 00       	mov    $0x6,%eax
                        if(!flags.left && lenpad>0)
c0000a0f:	0f b6 9d d0 fd ff ff 	movzbl -0x230(%ebp),%ebx
                        if(field_prec<0) field_prec = 6;  //default is prec = 6
c0000a16:	83 f9 ff             	cmp    $0xffffffff,%ecx
c0000a19:	0f 45 c1             	cmovne %ecx,%eax
                        if(!flags.left && lenpad>0)
c0000a1c:	83 f3 01             	xor    $0x1,%ebx
                        if(f_value<0)
c0000a1f:	df f1                	fcomip %st(1),%st
                        if(field_prec<0) field_prec = 6;  //default is prec = 6
c0000a21:	89 85 ac fd ff ff    	mov    %eax,-0x254(%ebp)
                        if(f_value<0)
c0000a27:	0f 87 e2 04 00 00    	ja     c0000f0f <kprintf+0xd7f>
c0000a2d:	dd d8                	fstp   %st(0)
                            ui_part = (unsigned int) f_value;
c0000a2f:	d9 bd d6 fd ff ff    	fnstcw -0x22a(%ebp)
c0000a35:	d9 85 c8 fd ff ff    	flds   -0x238(%ebp)
c0000a3b:	0f b7 85 d6 fd ff ff 	movzwl -0x22a(%ebp),%eax
c0000a42:	80 cc 0c             	or     $0xc,%ah
                            if(flags.sign)
c0000a45:	80 bd c0 fd ff ff 00 	cmpb   $0x0,-0x240(%ebp)
                            ui_part = (unsigned int) f_value;
c0000a4c:	66 89 85 d4 fd ff ff 	mov    %ax,-0x22c(%ebp)
c0000a53:	d9 ad d4 fd ff ff    	fldcw  -0x22c(%ebp)
c0000a59:	df bd a0 fd ff ff    	fistpll -0x260(%ebp)
c0000a5f:	d9 ad d6 fd ff ff    	fldcw  -0x22a(%ebp)
c0000a65:	8b 85 a0 fd ff ff    	mov    -0x260(%ebp),%eax
                            if(flags.sign)
c0000a6b:	0f 85 e1 04 00 00    	jne    c0000f52 <kprintf+0xdc2>
                            else if(flags.space)
c0000a71:	80 bd bf fd ff ff 00 	cmpb   $0x0,-0x241(%ebp)
c0000a78:	0f 84 92 03 00 00    	je     c0000e10 <kprintf+0xc80>
                                sign_char = ' ';
c0000a7e:	c6 85 ab fd ff ff 20 	movb   $0x20,-0x255(%ebp)
                        int int_len = format_uint(ui_part,val_buf,10,-1,0);
c0000a85:	83 ec 0c             	sub    $0xc,%esp
c0000a88:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
c0000a8e:	6a 00                	push   $0x0
c0000a90:	6a ff                	push   $0xffffffff
c0000a92:	6a 0a                	push   $0xa
c0000a94:	50                   	push   %eax
c0000a95:	ff b5 a0 fd ff ff    	pushl  -0x260(%ebp)
c0000a9b:	89 85 c0 fd ff ff    	mov    %eax,-0x240(%ebp)
c0000aa1:	e8 fa f5 ff ff       	call   c00000a0 <format_uint>
                        int f_len = int_len + 1 + field_prec;
c0000aa6:	8b 8d ac fd ff ff    	mov    -0x254(%ebp),%ecx
                        int lenpad = field_width - f_len; 
c0000aac:	8b 95 b0 fd ff ff    	mov    -0x250(%ebp),%edx
                        if(!flags.left && lenpad>0)
c0000ab2:	83 c4 20             	add    $0x20,%esp
                        int f_len = int_len + 1 + field_prec;
c0000ab5:	8d 44 01 01          	lea    0x1(%ecx,%eax,1),%eax
                        int lenpad = field_width - f_len; 
c0000ab9:	29 c2                	sub    %eax,%edx
                            lenpad--; //remove one char of padding to account for sign
c0000abb:	8d 42 ff             	lea    -0x1(%edx),%eax
                        if(!flags.left && lenpad>0)
c0000abe:	85 c0                	test   %eax,%eax
                            lenpad--; //remove one char of padding to account for sign
c0000ac0:	89 85 b0 fd ff ff    	mov    %eax,-0x250(%ebp)
                        if(!flags.left && lenpad>0)
c0000ac6:	0f 9f 85 bf fd ff ff 	setg   -0x241(%ebp)
c0000acd:	0f b6 85 bf fd ff ff 	movzbl -0x241(%ebp),%eax
c0000ad4:	21 c3                	and    %eax,%ebx
                            if(flags.zero)
c0000ad6:	89 f0                	mov    %esi,%eax
c0000ad8:	84 c0                	test   %al,%al
c0000ada:	0f 85 7e 04 00 00    	jne    c0000f5e <kprintf+0xdce>
                        if(!flags.left && lenpad>0)
c0000ae0:	84 db                	test   %bl,%bl
c0000ae2:	0f 85 a4 04 00 00    	jne    c0000f8c <kprintf+0xdfc>
                            nchar += kprint_char(sign_char); //if not zero padding, write sign here
c0000ae8:	0f be 85 ab fd ff ff 	movsbl -0x255(%ebp),%eax
    terminal_putchar(&stdout, c); 
c0000aef:	83 ec 08             	sub    $0x8,%esp
                            nchar += kprint_char(sign_char); //if not zero padding, write sign here
c0000af2:	83 c7 01             	add    $0x1,%edi
    terminal_putchar(&stdout, c); 
c0000af5:	50                   	push   %eax
c0000af6:	68 00 b0 00 c0       	push   $0xc000b000
c0000afb:	e8 50 0d 00 00       	call   c0001850 <terminal_putchar>
                            nchar += kprint_char(sign_char); //if not zero padding, write sign here
c0000b00:	83 c4 10             	add    $0x10,%esp
    terminal_writestring(&stdout, str);
c0000b03:	8b b5 c0 fd ff ff    	mov    -0x240(%ebp),%esi
c0000b09:	83 ec 08             	sub    $0x8,%esp
c0000b0c:	56                   	push   %esi
c0000b0d:	68 00 b0 00 c0       	push   $0xc000b000
c0000b12:	e8 89 0f 00 00       	call   c0001aa0 <terminal_writestring>
    return strlen(str);
c0000b17:	89 34 24             	mov    %esi,(%esp)
c0000b1a:	e8 e1 06 00 00       	call   c0001200 <strlen>
    terminal_putchar(&stdout, c); 
c0000b1f:	5b                   	pop    %ebx
c0000b20:	5e                   	pop    %esi
c0000b21:	6a 2e                	push   $0x2e
c0000b23:	68 00 b0 00 c0       	push   $0xc000b000
                        nchar += kprint(val_buf);
c0000b28:	01 c7                	add    %eax,%edi
                        nchar += kprint_char('.');
c0000b2a:	83 c7 01             	add    $0x1,%edi
    terminal_putchar(&stdout, c); 
c0000b2d:	e8 1e 0d 00 00       	call   c0001850 <terminal_putchar>
                        float frac = f_value<0 ? -f_value - ui_part : f_value - ui_part;
c0000b32:	83 c4 10             	add    $0x10,%esp
c0000b35:	d9 85 c8 fd ff ff    	flds   -0x238(%ebp)
c0000b3b:	d9 ee                	fldz   
c0000b3d:	df f1                	fcomip %st(1),%st
c0000b3f:	0f 87 5f 03 00 00    	ja     c0000ea4 <kprintf+0xd14>
c0000b45:	dd d8                	fstp   %st(0)
c0000b47:	c7 85 c4 fd ff ff 00 	movl   $0x0,-0x23c(%ebp)
c0000b4e:	00 00 00 
c0000b51:	8b 85 a0 fd ff ff    	mov    -0x260(%ebp),%eax
c0000b57:	89 85 c0 fd ff ff    	mov    %eax,-0x240(%ebp)
c0000b5d:	df ad c0 fd ff ff    	fildll -0x240(%ebp)
c0000b63:	d8 ad c8 fd ff ff    	fsubrs -0x238(%ebp)
                        for(int nn=0;nn<field_prec; nn++)
c0000b69:	8b 8d ac fd ff ff    	mov    -0x254(%ebp),%ecx
c0000b6f:	8b b5 ac fd ff ff    	mov    -0x254(%ebp),%esi
c0000b75:	31 db                	xor    %ebx,%ebx
c0000b77:	85 c9                	test   %ecx,%ecx
c0000b79:	74 77                	je     c0000bf2 <kprintf+0xa62>
c0000b7b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c0000b7f:	90                   	nop
                            d = (int) frac;
c0000b80:	d9 bd d6 fd ff ff    	fnstcw -0x22a(%ebp)
                            frac *= 10.;
c0000b86:	d8 0d 54 35 00 c0    	fmuls  0xc0003554
    terminal_putchar(&stdout, c); 
c0000b8c:	83 ec 08             	sub    $0x8,%esp
                        for(int nn=0;nn<field_prec; nn++)
c0000b8f:	83 c3 01             	add    $0x1,%ebx
                            d = (int) frac;
c0000b92:	0f b7 85 d6 fd ff ff 	movzwl -0x22a(%ebp),%eax
c0000b99:	80 cc 0c             	or     $0xc,%ah
c0000b9c:	66 89 85 d4 fd ff ff 	mov    %ax,-0x22c(%ebp)
c0000ba3:	d9 ad d4 fd ff ff    	fldcw  -0x22c(%ebp)
c0000ba9:	db 95 c8 fd ff ff    	fistl  -0x238(%ebp)
c0000baf:	d9 ad d6 fd ff ff    	fldcw  -0x22a(%ebp)
                            nchar += kprint_char('0' + d);
c0000bb5:	0f b6 85 c8 fd ff ff 	movzbl -0x238(%ebp),%eax
                            frac -= d;
c0000bbc:	db 85 c8 fd ff ff    	fildl  -0x238(%ebp)
                            nchar += kprint_char('0' + d);
c0000bc2:	83 c0 30             	add    $0x30,%eax
c0000bc5:	0f be c0             	movsbl %al,%eax
                            frac -= d;
c0000bc8:	de e9                	fsubrp %st,%st(1)
    terminal_putchar(&stdout, c); 
c0000bca:	50                   	push   %eax
c0000bcb:	68 00 b0 00 c0       	push   $0xc000b000
                            frac -= d;
c0000bd0:	d9 9d c0 fd ff ff    	fstps  -0x240(%ebp)
    terminal_putchar(&stdout, c); 
c0000bd6:	e8 75 0c 00 00       	call   c0001850 <terminal_putchar>
                        for(int nn=0;nn<field_prec; nn++)
c0000bdb:	83 c4 10             	add    $0x10,%esp
c0000bde:	39 de                	cmp    %ebx,%esi
c0000be0:	d9 85 c0 fd ff ff    	flds   -0x240(%ebp)
c0000be6:	75 98                	jne    c0000b80 <kprintf+0x9f0>
c0000be8:	dd d8                	fstp   %st(0)
                            nchar += kprint_char('0' + d);
c0000bea:	03 bd ac fd ff ff    	add    -0x254(%ebp),%edi
c0000bf0:	eb 02                	jmp    c0000bf4 <kprintf+0xa64>
c0000bf2:	dd d8                	fstp   %st(0)
                        if(flags.left && lenpad>0)
c0000bf4:	80 bd d0 fd ff ff 00 	cmpb   $0x0,-0x230(%ebp)
c0000bfb:	0f 84 ef f9 ff ff    	je     c00005f0 <kprintf+0x460>
c0000c01:	80 bd bf fd ff ff 00 	cmpb   $0x0,-0x241(%ebp)
c0000c08:	0f 84 e2 f9 ff ff    	je     c00005f0 <kprintf+0x460>
    terminal_putcharn(&stdout, c, rpt); 
c0000c0e:	8b b5 b0 fd ff ff    	mov    -0x250(%ebp),%esi
c0000c14:	83 ec 04             	sub    $0x4,%esp
c0000c17:	56                   	push   %esi
                            nchar += kprintn_char(' ', lenpad);
c0000c18:	01 f7                	add    %esi,%edi
    terminal_putcharn(&stdout, c, rpt); 
c0000c1a:	6a 20                	push   $0x20
c0000c1c:	68 00 b0 00 c0       	push   $0xc000b000
c0000c21:	e8 4a 0a 00 00       	call   c0001670 <terminal_putcharn>
                            nchar += kprintn_char(' ', lenpad);
c0000c26:	83 c4 10             	add    $0x10,%esp
c0000c29:	e9 c2 f9 ff ff       	jmp    c00005f0 <kprintf+0x460>
                                if(!flags.zero && radix[0])
c0000c2e:	89 f0                	mov    %esi,%eax
c0000c30:	84 c0                	test   %al,%al
c0000c32:	74 5b                	je     c0000c8f <kprintf+0xaff>
c0000c34:	89 95 d0 fd ff ff    	mov    %edx,-0x230(%ebp)
    terminal_writestring(&stdout, str);
c0000c3a:	83 ec 08             	sub    $0x8,%esp
c0000c3d:	8b b5 c0 fd ff ff    	mov    -0x240(%ebp),%esi
c0000c43:	56                   	push   %esi
c0000c44:	68 00 b0 00 c0       	push   $0xc000b000
c0000c49:	e8 52 0e 00 00       	call   c0001aa0 <terminal_writestring>
    return strlen(str);
c0000c4e:	89 34 24             	mov    %esi,(%esp)
c0000c51:	e8 aa 05 00 00       	call   c0001200 <strlen>
c0000c56:	8b 95 d0 fd ff ff    	mov    -0x230(%ebp),%edx
                                nchar += kprint(val_buf);
c0000c5c:	83 c4 10             	add    $0x10,%esp
c0000c5f:	01 c7                	add    %eax,%edi
                                if(flags.left && lenpad>0)
c0000c61:	85 d2                	test   %edx,%edx
c0000c63:	0f 8e 87 f9 ff ff    	jle    c00005f0 <kprintf+0x460>
    terminal_putcharn(&stdout, c, rpt); 
c0000c69:	83 ec 04             	sub    $0x4,%esp
c0000c6c:	89 95 d0 fd ff ff    	mov    %edx,-0x230(%ebp)
c0000c72:	52                   	push   %edx
c0000c73:	6a 20                	push   $0x20
c0000c75:	68 00 b0 00 c0       	push   $0xc000b000
c0000c7a:	e8 f1 09 00 00       	call   c0001670 <terminal_putcharn>
                                    nchar += kprintn_char(' ', lenpad);
c0000c7f:	8b 95 d0 fd ff ff    	mov    -0x230(%ebp),%edx
c0000c85:	83 c4 10             	add    $0x10,%esp
c0000c88:	01 d7                	add    %edx,%edi
                    break;
c0000c8a:	e9 61 f9 ff ff       	jmp    c00005f0 <kprintf+0x460>
                                if(!flags.zero && radix[0])
c0000c8f:	80 bd e5 fd ff ff 00 	cmpb   $0x0,-0x21b(%ebp)
c0000c96:	74 9c                	je     c0000c34 <kprintf+0xaa4>
    terminal_writestring(&stdout, str);
c0000c98:	83 ec 08             	sub    $0x8,%esp
c0000c9b:	8d 9d e5 fd ff ff    	lea    -0x21b(%ebp),%ebx
c0000ca1:	89 95 d0 fd ff ff    	mov    %edx,-0x230(%ebp)
c0000ca7:	53                   	push   %ebx
c0000ca8:	68 00 b0 00 c0       	push   $0xc000b000
c0000cad:	e8 ee 0d 00 00       	call   c0001aa0 <terminal_writestring>
    return strlen(str);
c0000cb2:	89 1c 24             	mov    %ebx,(%esp)
c0000cb5:	e8 46 05 00 00       	call   c0001200 <strlen>
    terminal_writestring(&stdout, str);
c0000cba:	5e                   	pop    %esi
                                    nchar += kprint(radix);
c0000cbb:	01 c7                	add    %eax,%edi
    terminal_writestring(&stdout, str);
c0000cbd:	58                   	pop    %eax
c0000cbe:	e9 7a ff ff ff       	jmp    c0000c3d <kprintf+0xaad>
                                if(!flags.zero && radix[0])
c0000cc3:	89 f0                	mov    %esi,%eax
c0000cc5:	84 c0                	test   %al,%al
c0000cc7:	0f 85 e2 f7 ff ff    	jne    c00004af <kprintf+0x31f>
c0000ccd:	80 bd e5 fd ff ff 00 	cmpb   $0x0,-0x21b(%ebp)
c0000cd4:	0f 84 d5 f7 ff ff    	je     c00004af <kprintf+0x31f>
    terminal_writestring(&stdout, str);
c0000cda:	83 ec 08             	sub    $0x8,%esp
c0000cdd:	8d 9d e5 fd ff ff    	lea    -0x21b(%ebp),%ebx
c0000ce3:	53                   	push   %ebx
c0000ce4:	68 00 b0 00 c0       	push   $0xc000b000
c0000ce9:	e8 b2 0d 00 00       	call   c0001aa0 <terminal_writestring>
    return strlen(str);
c0000cee:	89 1c 24             	mov    %ebx,(%esp)
c0000cf1:	e8 0a 05 00 00       	call   c0001200 <strlen>
    terminal_writestring(&stdout, str);
c0000cf6:	59                   	pop    %ecx
c0000cf7:	5b                   	pop    %ebx
                                    nchar += kprint(radix);
c0000cf8:	01 c7                	add    %eax,%edi
    terminal_writestring(&stdout, str);
c0000cfa:	e9 51 fb ff ff       	jmp    c0000850 <kprintf+0x6c0>
    terminal_putchar(&stdout, c); 
c0000cff:	83 ec 08             	sub    $0x8,%esp
                                        nchar += kprint_char(sign_char); //if zero padding, sign is at beginning
c0000d02:	0f be c1             	movsbl %cl,%eax
c0000d05:	83 c7 01             	add    $0x1,%edi
    terminal_putchar(&stdout, c); 
c0000d08:	50                   	push   %eax
c0000d09:	68 00 b0 00 c0       	push   $0xc000b000
c0000d0e:	e8 3d 0b 00 00       	call   c0001850 <terminal_putchar>
                                if(!flags.left && lenpad>0)
c0000d13:	83 c4 10             	add    $0x10,%esp
c0000d16:	80 bd d0 fd ff ff 00 	cmpb   $0x0,-0x230(%ebp)
c0000d1d:	75 21                	jne    c0000d40 <kprintf+0xbb0>
c0000d1f:	85 db                	test   %ebx,%ebx
c0000d21:	0f 8e 88 f7 ff ff    	jle    c00004af <kprintf+0x31f>
                                        nchar += kprintn_char('0', lenpad);
c0000d27:	01 df                	add    %ebx,%edi
    terminal_putcharn(&stdout, c, rpt); 
c0000d29:	83 ec 04             	sub    $0x4,%esp
c0000d2c:	53                   	push   %ebx
c0000d2d:	6a 30                	push   $0x30
c0000d2f:	68 00 b0 00 c0       	push   $0xc000b000
c0000d34:	e8 37 09 00 00       	call   c0001670 <terminal_putcharn>
    terminal_writestring(&stdout, str);
c0000d39:	5e                   	pop    %esi
c0000d3a:	58                   	pop    %eax
c0000d3b:	e9 10 fb ff ff       	jmp    c0000850 <kprintf+0x6c0>
c0000d40:	83 ec 08             	sub    $0x8,%esp
c0000d43:	e9 30 f8 ff ff       	jmp    c0000578 <kprintf+0x3e8>
c0000d48:	83 ec 08             	sub    $0x8,%esp
c0000d4b:	8d 9d e5 fd ff ff    	lea    -0x21b(%ebp),%ebx
c0000d51:	89 95 c8 fd ff ff    	mov    %edx,-0x238(%ebp)
c0000d57:	53                   	push   %ebx
c0000d58:	68 00 b0 00 c0       	push   $0xc000b000
c0000d5d:	e8 3e 0d 00 00       	call   c0001aa0 <terminal_writestring>
    return strlen(str);
c0000d62:	89 1c 24             	mov    %ebx,(%esp)
c0000d65:	e8 96 04 00 00       	call   c0001200 <strlen>
                                if(!flags.left && lenpad>0)
c0000d6a:	83 c4 10             	add    $0x10,%esp
c0000d6d:	8b 95 c8 fd ff ff    	mov    -0x238(%ebp),%edx
                                        nchar += kprint(radix);
c0000d73:	01 c7                	add    %eax,%edi
                                if(!flags.left && lenpad>0)
c0000d75:	80 bd d0 fd ff ff 00 	cmpb   $0x0,-0x230(%ebp)
c0000d7c:	0f 85 b2 fe ff ff    	jne    c0000c34 <kprintf+0xaa4>
c0000d82:	85 d2                	test   %edx,%edx
c0000d84:	0f 8e 25 f7 ff ff    	jle    c00004af <kprintf+0x31f>
                                        nchar += kprintn_char('0', lenpad);
c0000d8a:	01 d7                	add    %edx,%edi
c0000d8c:	e9 ab fa ff ff       	jmp    c000083c <kprintf+0x6ac>
                                        nchar += kprintn_char('0', lenpad);
c0000d91:	01 df                	add    %ebx,%edi
    terminal_putcharn(&stdout, c, rpt); 
c0000d93:	83 ec 04             	sub    $0x4,%esp
c0000d96:	88 8d d0 fd ff ff    	mov    %cl,-0x230(%ebp)
c0000d9c:	53                   	push   %ebx
c0000d9d:	6a 20                	push   $0x20
c0000d9f:	68 00 b0 00 c0       	push   $0xc000b000
c0000da4:	e8 c7 08 00 00       	call   c0001670 <terminal_putcharn>
                                if(!flags.zero && sign_char)
c0000da9:	0f b6 8d d0 fd ff ff 	movzbl -0x230(%ebp),%ecx
    terminal_putcharn(&stdout, c, rpt); 
c0000db0:	83 c4 10             	add    $0x10,%esp
c0000db3:	e9 a1 fb ff ff       	jmp    c0000959 <kprintf+0x7c9>
                                int len = format_uint(ui_value, val_buf, 10, field_prec, 0);
c0000db8:	83 ec 0c             	sub    $0xc,%esp
c0000dbb:	8d 8d e8 fd ff ff    	lea    -0x218(%ebp),%ecx
c0000dc1:	6a 00                	push   $0x0
c0000dc3:	ff b5 ac fd ff ff    	pushl  -0x254(%ebp)
c0000dc9:	6a 0a                	push   $0xa
c0000dcb:	51                   	push   %ecx
c0000dcc:	50                   	push   %eax
c0000dcd:	89 8d c0 fd ff ff    	mov    %ecx,-0x240(%ebp)
c0000dd3:	e8 c8 f2 ff ff       	call   c00000a0 <format_uint>
                                int lenpad = field_width - len; 
c0000dd8:	8b 9d b0 fd ff ff    	mov    -0x250(%ebp),%ebx
                                if(!flags.left && lenpad>0)
c0000dde:	83 c4 20             	add    $0x20,%esp
                                int lenpad = field_width - len; 
c0000de1:	29 c3                	sub    %eax,%ebx
                                if(!flags.left && lenpad>0)
c0000de3:	80 bd d0 fd ff ff 00 	cmpb   $0x0,-0x230(%ebp)
c0000dea:	0f 85 50 ff ff ff    	jne    c0000d40 <kprintf+0xbb0>
c0000df0:	85 db                	test   %ebx,%ebx
c0000df2:	0f 8e b7 f6 ff ff    	jle    c00004af <kprintf+0x31f>
                                    if(flags.zero)
c0000df8:	89 f0                	mov    %esi,%eax
                                        nchar += kprintn_char('0', lenpad);
c0000dfa:	01 df                	add    %ebx,%edi
                                    if(flags.zero)
c0000dfc:	84 c0                	test   %al,%al
c0000dfe:	0f 85 25 ff ff ff    	jne    c0000d29 <kprintf+0xb99>
                                char sign_char = 0; //sign character or 0 if none
c0000e04:	31 c9                	xor    %ecx,%ecx
c0000e06:	eb 8b                	jmp    c0000d93 <kprintf+0xc03>
c0000e08:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0000e0f:	90                   	nop
                        int int_len = format_uint(ui_part,val_buf,10,-1,0);
c0000e10:	83 ec 0c             	sub    $0xc,%esp
c0000e13:	8d 8d e8 fd ff ff    	lea    -0x218(%ebp),%ecx
c0000e19:	6a 00                	push   $0x0
c0000e1b:	6a ff                	push   $0xffffffff
c0000e1d:	6a 0a                	push   $0xa
c0000e1f:	51                   	push   %ecx
c0000e20:	50                   	push   %eax
c0000e21:	89 8d c0 fd ff ff    	mov    %ecx,-0x240(%ebp)
c0000e27:	e8 74 f2 ff ff       	call   c00000a0 <format_uint>
                        int f_len = int_len + 1 + field_prec;
c0000e2c:	8b 8d ac fd ff ff    	mov    -0x254(%ebp),%ecx
                        if(!flags.left && lenpad>0)
c0000e32:	83 c4 20             	add    $0x20,%esp
                        int f_len = int_len + 1 + field_prec;
c0000e35:	8d 44 01 01          	lea    0x1(%ecx,%eax,1),%eax
                        int lenpad = field_width - f_len; 
c0000e39:	8b 8d b0 fd ff ff    	mov    -0x250(%ebp),%ecx
c0000e3f:	29 c1                	sub    %eax,%ecx
                        if(!flags.left && lenpad>0)
c0000e41:	85 c9                	test   %ecx,%ecx
                        int lenpad = field_width - f_len; 
c0000e43:	89 8d b0 fd ff ff    	mov    %ecx,-0x250(%ebp)
                        if(!flags.left && lenpad>0)
c0000e49:	0f 9f 85 bf fd ff ff 	setg   -0x241(%ebp)
c0000e50:	0f b6 85 bf fd ff ff 	movzbl -0x241(%ebp),%eax
c0000e57:	20 c3                	and    %al,%bl
c0000e59:	0f 84 a4 fc ff ff    	je     c0000b03 <kprintf+0x973>
                            if(flags.zero)
c0000e5f:	89 f0                	mov    %esi,%eax
                                nchar += kprintn_char(' ', lenpad);
c0000e61:	03 bd b0 fd ff ff    	add    -0x250(%ebp),%edi
                            if(flags.zero)
c0000e67:	84 c0                	test   %al,%al
c0000e69:	0f 84 43 01 00 00    	je     c0000fb2 <kprintf+0xe22>
    terminal_putcharn(&stdout, c, rpt); 
c0000e6f:	83 ec 04             	sub    $0x4,%esp
c0000e72:	ff b5 b0 fd ff ff    	pushl  -0x250(%ebp)
c0000e78:	6a 30                	push   $0x30
c0000e7a:	68 00 b0 00 c0       	push   $0xc000b000
c0000e7f:	e8 ec 07 00 00       	call   c0001670 <terminal_putcharn>
c0000e84:	c6 85 bf fd ff ff 01 	movb   $0x1,-0x241(%ebp)
c0000e8b:	83 c4 10             	add    $0x10,%esp
c0000e8e:	e9 70 fc ff ff       	jmp    c0000b03 <kprintf+0x973>
                f++;
c0000e93:	8b 9d b8 fd ff ff    	mov    -0x248(%ebp),%ebx
            switch(*(f++))
c0000e99:	89 8d b8 fd ff ff    	mov    %ecx,-0x248(%ebp)
c0000e9f:	e9 1c f4 ff ff       	jmp    c00002c0 <kprintf+0x130>
                        float frac = f_value<0 ? -f_value - ui_part : f_value - ui_part;
c0000ea4:	8b 85 a0 fd ff ff    	mov    -0x260(%ebp),%eax
c0000eaa:	d9 e0                	fchs   
c0000eac:	c7 85 cc fd ff ff 00 	movl   $0x0,-0x234(%ebp)
c0000eb3:	00 00 00 
c0000eb6:	89 85 c8 fd ff ff    	mov    %eax,-0x238(%ebp)
c0000ebc:	df ad c8 fd ff ff    	fildll -0x238(%ebp)
c0000ec2:	de e9                	fsubrp %st,%st(1)
c0000ec4:	e9 a0 fc ff ff       	jmp    c0000b69 <kprintf+0x9d9>
                                int len = format_uint(ui_value, val_buf, base, field_prec, cap);
c0000ec9:	83 ec 0c             	sub    $0xc,%esp
c0000ecc:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
c0000ed2:	6a 00                	push   $0x0
c0000ed4:	ff b5 ac fd ff ff    	pushl  -0x254(%ebp)
c0000eda:	6a 10                	push   $0x10
c0000edc:	50                   	push   %eax
c0000edd:	52                   	push   %edx
c0000ede:	89 85 c0 fd ff ff    	mov    %eax,-0x240(%ebp)
c0000ee4:	e8 b7 f1 ff ff       	call   c00000a0 <format_uint>
                                int lenpad = field_width - len; 
c0000ee9:	8b 9d b0 fd ff ff    	mov    -0x250(%ebp),%ebx
                                char radix[3]="";
c0000eef:	c6 85 e7 fd ff ff 00 	movb   $0x0,-0x219(%ebp)
                                        radix[0] = '0';
c0000ef6:	83 c4 20             	add    $0x20,%esp
c0000ef9:	c6 85 e5 fd ff ff 30 	movb   $0x30,-0x21b(%ebp)
                                int lenpad = field_width - len; 
c0000f00:	29 c3                	sub    %eax,%ebx
                                        lenpad -= 2;
c0000f02:	8d 53 fe             	lea    -0x2(%ebx),%edx
                                        radix[1] = cap ? 'X' : 'x';
c0000f05:	bb 78 00 00 00       	mov    $0x78,%ebx
c0000f0a:	e9 59 f5 ff ff       	jmp    c0000468 <kprintf+0x2d8>
                            ui_part = (unsigned int) -f_value;
c0000f0f:	d9 bd d6 fd ff ff    	fnstcw -0x22a(%ebp)
c0000f15:	d9 e0                	fchs   
                            sign_char = '-';
c0000f17:	c6 85 ab fd ff ff 2d 	movb   $0x2d,-0x255(%ebp)
                            ui_part = (unsigned int) -f_value;
c0000f1e:	0f b7 85 d6 fd ff ff 	movzwl -0x22a(%ebp),%eax
c0000f25:	80 cc 0c             	or     $0xc,%ah
c0000f28:	66 89 85 d4 fd ff ff 	mov    %ax,-0x22c(%ebp)
c0000f2f:	d9 ad d4 fd ff ff    	fldcw  -0x22c(%ebp)
c0000f35:	df bd c0 fd ff ff    	fistpll -0x240(%ebp)
c0000f3b:	d9 ad d6 fd ff ff    	fldcw  -0x22a(%ebp)
c0000f41:	8b 85 c0 fd ff ff    	mov    -0x240(%ebp),%eax
c0000f47:	89 85 a0 fd ff ff    	mov    %eax,-0x260(%ebp)
                            sign_char = '-';
c0000f4d:	e9 33 fb ff ff       	jmp    c0000a85 <kprintf+0x8f5>
                                sign_char = '+';
c0000f52:	c6 85 ab fd ff ff 2b 	movb   $0x2b,-0x255(%ebp)
c0000f59:	e9 27 fb ff ff       	jmp    c0000a85 <kprintf+0x8f5>
                                nchar += kprint_char(sign_char); //if zero padding, sign is at beginning
c0000f5e:	0f be 85 ab fd ff ff 	movsbl -0x255(%ebp),%eax
    terminal_putchar(&stdout, c); 
c0000f65:	83 ec 08             	sub    $0x8,%esp
                                nchar += kprint_char(sign_char); //if zero padding, sign is at beginning
c0000f68:	83 c7 01             	add    $0x1,%edi
    terminal_putchar(&stdout, c); 
c0000f6b:	50                   	push   %eax
c0000f6c:	68 00 b0 00 c0       	push   $0xc000b000
c0000f71:	e8 da 08 00 00       	call   c0001850 <terminal_putchar>
                        if(!flags.left && lenpad>0)
c0000f76:	83 c4 10             	add    $0x10,%esp
c0000f79:	84 db                	test   %bl,%bl
c0000f7b:	0f 84 82 fb ff ff    	je     c0000b03 <kprintf+0x973>
                                nchar += kprintn_char('0', lenpad);
c0000f81:	03 bd b0 fd ff ff    	add    -0x250(%ebp),%edi
c0000f87:	e9 e3 fe ff ff       	jmp    c0000e6f <kprintf+0xcdf>
                                nchar += kprintn_char(' ', lenpad);
c0000f8c:	8b 85 b0 fd ff ff    	mov    -0x250(%ebp),%eax
    terminal_putcharn(&stdout, c, rpt); 
c0000f92:	83 ec 04             	sub    $0x4,%esp
c0000f95:	50                   	push   %eax
                                nchar += kprintn_char(' ', lenpad);
c0000f96:	01 c7                	add    %eax,%edi
    terminal_putcharn(&stdout, c, rpt); 
c0000f98:	6a 20                	push   $0x20
c0000f9a:	68 00 b0 00 c0       	push   $0xc000b000
c0000f9f:	e8 cc 06 00 00       	call   c0001670 <terminal_putcharn>
c0000fa4:	88 9d bf fd ff ff    	mov    %bl,-0x241(%ebp)
c0000faa:	83 c4 10             	add    $0x10,%esp
c0000fad:	e9 36 fb ff ff       	jmp    c0000ae8 <kprintf+0x958>
c0000fb2:	83 ec 04             	sub    $0x4,%esp
c0000fb5:	ff b5 b0 fd ff ff    	pushl  -0x250(%ebp)
c0000fbb:	6a 20                	push   $0x20
c0000fbd:	68 00 b0 00 c0       	push   $0xc000b000
c0000fc2:	e8 a9 06 00 00       	call   c0001670 <terminal_putcharn>
c0000fc7:	88 9d bf fd ff ff    	mov    %bl,-0x241(%ebp)
c0000fcd:	83 c4 10             	add    $0x10,%esp
c0000fd0:	e9 2e fb ff ff       	jmp    c0000b03 <kprintf+0x973>
                                        radix[1] = cap ? 'X' : 'x';
c0000fd5:	bb 78 00 00 00       	mov    $0x78,%ebx
c0000fda:	e9 89 f4 ff ff       	jmp    c0000468 <kprintf+0x2d8>
c0000fdf:	90                   	nop

c0000fe0 <numdigits_uint>:
{
c0000fe0:	55                   	push   %ebp
c0000fe1:	89 e5                	mov    %esp,%ebp
c0000fe3:	53                   	push   %ebx
    unsigned int num_digits = 1;
c0000fe4:	bb 01 00 00 00       	mov    $0x1,%ebx
{
c0000fe9:	8b 45 08             	mov    0x8(%ebp),%eax
c0000fec:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    while(value >= base)
c0000fef:	39 c8                	cmp    %ecx,%eax
c0000ff1:	72 18                	jb     c000100b <numdigits_uint+0x2b>
c0000ff3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0000ffa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        value /= base;
c0001000:	31 d2                	xor    %edx,%edx
        num_digits++;
c0001002:	83 c3 01             	add    $0x1,%ebx
        value /= base;
c0001005:	f7 f1                	div    %ecx
    while(value >= base)
c0001007:	39 c1                	cmp    %eax,%ecx
c0001009:	76 f5                	jbe    c0001000 <numdigits_uint+0x20>
    }
    return num_digits;
}
c000100b:	89 d8                	mov    %ebx,%eax
c000100d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0001010:	c9                   	leave  
c0001011:	c3                   	ret    
c0001012:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001019:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

c0001020 <kprintf_test>:



void kprintf_test()
{
c0001020:	55                   	push   %ebp
c0001021:	89 e5                	mov    %esp,%ebp
c0001023:	83 ec 10             	sub    $0x10,%esp
    int num = 12345678;    
    kprintf("\nkprintf() tests...\n", num);
c0001026:	68 4e 61 bc 00       	push   $0xbc614e
c000102b:	68 cc 31 00 c0       	push   $0xc00031cc
c0001030:	e8 5b f1 ff ff       	call   c0000190 <kprintf>
    kprintf("Fixed width, right justify:\n");
c0001035:	c7 04 24 e1 31 00 c0 	movl   $0xc00031e1,(%esp)
c000103c:	e8 4f f1 ff ff       	call   c0000190 <kprintf>
    kprintf("Decimal: [%15d]\n", num);
c0001041:	58                   	pop    %eax
c0001042:	5a                   	pop    %edx
c0001043:	68 4e 61 bc 00       	push   $0xbc614e
c0001048:	68 fe 31 00 c0       	push   $0xc00031fe
c000104d:	e8 3e f1 ff ff       	call   c0000190 <kprintf>
    kprintf("Hex:     [%#15x]\n", num);
c0001052:	59                   	pop    %ecx
c0001053:	58                   	pop    %eax
c0001054:	68 4e 61 bc 00       	push   $0xbc614e
c0001059:	68 0f 32 00 c0       	push   $0xc000320f
c000105e:	e8 2d f1 ff ff       	call   c0000190 <kprintf>
    kprintf("Oct:     [%#15o]\n", num);
c0001063:	58                   	pop    %eax
c0001064:	5a                   	pop    %edx
c0001065:	68 4e 61 bc 00       	push   $0xbc614e
c000106a:	68 21 32 00 c0       	push   $0xc0003221
c000106f:	e8 1c f1 ff ff       	call   c0000190 <kprintf>
    kprintf("String:  [%15s]\n", "Hello World!");
c0001074:	59                   	pop    %ecx
c0001075:	58                   	pop    %eax
c0001076:	68 33 32 00 c0       	push   $0xc0003233
c000107b:	68 40 32 00 c0       	push   $0xc0003240
c0001080:	e8 0b f1 ff ff       	call   c0000190 <kprintf>
    kprintf("Char:    [%15c]\n", '!');
c0001085:	58                   	pop    %eax
c0001086:	5a                   	pop    %edx
c0001087:	6a 21                	push   $0x21
c0001089:	68 51 32 00 c0       	push   $0xc0003251
c000108e:	e8 fd f0 ff ff       	call   c0000190 <kprintf>

    kprintf("\nFixed width, left justify:\n");
c0001093:	c7 04 24 62 32 00 c0 	movl   $0xc0003262,(%esp)
c000109a:	e8 f1 f0 ff ff       	call   c0000190 <kprintf>
    kprintf("Decimal: [%-15d]\n", num);
c000109f:	59                   	pop    %ecx
c00010a0:	58                   	pop    %eax
c00010a1:	68 4e 61 bc 00       	push   $0xbc614e
c00010a6:	68 7f 32 00 c0       	push   $0xc000327f
c00010ab:	e8 e0 f0 ff ff       	call   c0000190 <kprintf>
    kprintf("Hex:     [%-#15x]\n", num);
c00010b0:	58                   	pop    %eax
c00010b1:	5a                   	pop    %edx
c00010b2:	68 4e 61 bc 00       	push   $0xbc614e
c00010b7:	68 91 32 00 c0       	push   $0xc0003291
c00010bc:	e8 cf f0 ff ff       	call   c0000190 <kprintf>
    kprintf("String:  [%-15s]\n", "Hello World!");
c00010c1:	59                   	pop    %ecx
c00010c2:	58                   	pop    %eax
c00010c3:	68 33 32 00 c0       	push   $0xc0003233
c00010c8:	68 a4 32 00 c0       	push   $0xc00032a4
c00010cd:	e8 be f0 ff ff       	call   c0000190 <kprintf>

    kprintf("\nFixed Precision:\n");
c00010d2:	c7 04 24 b6 32 00 c0 	movl   $0xc00032b6,(%esp)
c00010d9:	e8 b2 f0 ff ff       	call   c0000190 <kprintf>
    kprintf("Decimal: [%15.10d]\nHex:     [%#15.10x]\nOct:     [%#15.10o]\nString:  [%15.10s]\n", 
c00010de:	c7 04 24 33 32 00 c0 	movl   $0xc0003233,(%esp)
c00010e5:	68 4e 61 bc 00       	push   $0xbc614e
c00010ea:	68 4e 61 bc 00       	push   $0xbc614e
c00010ef:	68 4e 61 bc 00       	push   $0xbc614e
c00010f4:	68 f0 33 00 c0       	push   $0xc00033f0
c00010f9:	e8 92 f0 ff ff       	call   c0000190 <kprintf>
        num, num, num, "Hello World!");

    kprintf("\nLeading Zeros:\n");
c00010fe:	83 c4 14             	add    $0x14,%esp
c0001101:	68 c9 32 00 c0       	push   $0xc00032c9
c0001106:	e8 85 f0 ff ff       	call   c0000190 <kprintf>
    kprintf("Decimal: [%015.10d]\nHex:     [%#015.10x]\nOct:     [%#015.10o]\n",num, num, num);
c000110b:	68 4e 61 bc 00       	push   $0xbc614e
c0001110:	68 4e 61 bc 00       	push   $0xbc614e
c0001115:	68 4e 61 bc 00       	push   $0xbc614e
c000111a:	68 40 34 00 c0       	push   $0xc0003440
c000111f:	e8 6c f0 ff ff       	call   c0000190 <kprintf>

    kprintf("Signed (none):  [%d], [%d]\n",num, -num);
c0001124:	83 c4 1c             	add    $0x1c,%esp
c0001127:	68 b2 9e 43 ff       	push   $0xff439eb2
c000112c:	68 4e 61 bc 00       	push   $0xbc614e
c0001131:	68 da 32 00 c0       	push   $0xc00032da
c0001136:	e8 55 f0 ff ff       	call   c0000190 <kprintf>
    kprintf("Signed (space): [% d], [% d]\n",num, -num);
c000113b:	83 c4 0c             	add    $0xc,%esp
c000113e:	68 b2 9e 43 ff       	push   $0xff439eb2
c0001143:	68 4e 61 bc 00       	push   $0xbc614e
c0001148:	68 f6 32 00 c0       	push   $0xc00032f6
c000114d:	e8 3e f0 ff ff       	call   c0000190 <kprintf>
    kprintf("Signed (+):     [%+d], [%+d]\n",num, -num);
c0001152:	83 c4 0c             	add    $0xc,%esp
c0001155:	68 b2 9e 43 ff       	push   $0xff439eb2
c000115a:	68 4e 61 bc 00       	push   $0xbc614e
c000115f:	68 14 33 00 c0       	push   $0xc0003314
c0001164:	e8 27 f0 ff ff       	call   c0000190 <kprintf>

    float f = 1.23456789;
    kprintf("\nfloat:     [%15.f]\n",f);
c0001169:	d9 05 58 35 00 c0    	flds   0xc0003558
c000116f:	c7 04 24 32 33 00 c0 	movl   $0xc0003332,(%esp)
c0001176:	dd 5c 24 04          	fstpl  0x4(%esp)
c000117a:	e8 11 f0 ff ff       	call   c0000190 <kprintf>
    kprintf("float:     [%15.3f]\n",f);
c000117f:	dd 05 60 35 00 c0    	fldl   0xc0003560
c0001185:	c7 04 24 47 33 00 c0 	movl   $0xc0003347,(%esp)
c000118c:	dd 5c 24 04          	fstpl  0x4(%esp)
c0001190:	e8 fb ef ff ff       	call   c0000190 <kprintf>
    kprintf("float:     [%15.10f]\n",f);
c0001195:	dd 05 60 35 00 c0    	fldl   0xc0003560
c000119b:	c7 04 24 5c 33 00 c0 	movl   $0xc000335c,(%esp)
c00011a2:	dd 5c 24 04          	fstpl  0x4(%esp)
c00011a6:	e8 e5 ef ff ff       	call   c0000190 <kprintf>

    f = -12345.6789;
    kprintf("float:     [%15f]\n",f);
c00011ab:	d9 05 5c 35 00 c0    	flds   0xc000355c
c00011b1:	c7 04 24 72 33 00 c0 	movl   $0xc0003372,(%esp)
c00011b8:	dd 5c 24 04          	fstpl  0x4(%esp)
c00011bc:	e8 cf ef ff ff       	call   c0000190 <kprintf>
    kprintf("float:     [%15.3f]\n",f);
c00011c1:	dd 05 68 35 00 c0    	fldl   0xc0003568
c00011c7:	c7 04 24 47 33 00 c0 	movl   $0xc0003347,(%esp)
c00011ce:	dd 5c 24 04          	fstpl  0x4(%esp)
c00011d2:	e8 b9 ef ff ff       	call   c0000190 <kprintf>
    kprintf("float:     [%15.10f]\n",f);
c00011d7:	dd 05 68 35 00 c0    	fldl   0xc0003568
c00011dd:	c7 04 24 5c 33 00 c0 	movl   $0xc000335c,(%esp)
c00011e4:	dd 5c 24 04          	fstpl  0x4(%esp)
c00011e8:	e8 a3 ef ff ff       	call   c0000190 <kprintf>
}
c00011ed:	83 c4 10             	add    $0x10,%esp
c00011f0:	c9                   	leave  
c00011f1:	c3                   	ret    
c00011f2:	66 90                	xchg   %ax,%ax
c00011f4:	66 90                	xchg   %ax,%ax
c00011f6:	66 90                	xchg   %ax,%ax
c00011f8:	66 90                	xchg   %ax,%ax
c00011fa:	66 90                	xchg   %ax,%ax
c00011fc:	66 90                	xchg   %ax,%ax
c00011fe:	66 90                	xchg   %ax,%ax

c0001200 <strlen>:
#include "common.h"

size_t strlen(const char* str) 
{
c0001200:	55                   	push   %ebp
	size_t len = 0;
c0001201:	31 c0                	xor    %eax,%eax
{
c0001203:	89 e5                	mov    %esp,%ebp
c0001205:	8b 55 08             	mov    0x8(%ebp),%edx
	while (str[len])
c0001208:	80 3a 00             	cmpb   $0x0,(%edx)
c000120b:	74 0c                	je     c0001219 <strlen+0x19>
c000120d:	8d 76 00             	lea    0x0(%esi),%esi
		len++;
c0001210:	83 c0 01             	add    $0x1,%eax
	while (str[len])
c0001213:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
c0001217:	75 f7                	jne    c0001210 <strlen+0x10>
	return len;
}
c0001219:	5d                   	pop    %ebp
c000121a:	c3                   	ret    
c000121b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c000121f:	90                   	nop

c0001220 <memcpy>:

// copy n bytes from src to dest
void *memcpy(void *dest, const void *src, size_t n)
{
c0001220:	55                   	push   %ebp
c0001221:	89 e5                	mov    %esp,%ebp
c0001223:	57                   	push   %edi
c0001224:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0001227:	8b 7d 08             	mov    0x8(%ebp),%edi
c000122a:	56                   	push   %esi
c000122b:	8b 75 10             	mov    0x10(%ebp),%esi
c000122e:	53                   	push   %ebx
    //system wordsize is equal to length of size_t
    size_t n_words = n/sizeof(size_t);
    size_t* dest_word = (size_t *) dest;
    size_t* src_word = (size_t *) src;
    for(size_t nn=0; nn<n_words; nn++)
c000122f:	89 f3                	mov    %esi,%ebx
c0001231:	c1 eb 02             	shr    $0x2,%ebx
c0001234:	74 1c                	je     c0001252 <memcpy+0x32>
c0001236:	89 c8                	mov    %ecx,%eax
c0001238:	89 fa                	mov    %edi,%edx
c000123a:	8d 1c 99             	lea    (%ecx,%ebx,4),%ebx
c000123d:	8d 76 00             	lea    0x0(%esi),%esi
        dest_word[nn]=src_word[nn];
c0001240:	8b 08                	mov    (%eax),%ecx
    for(size_t nn=0; nn<n_words; nn++)
c0001242:	83 c0 04             	add    $0x4,%eax
c0001245:	83 c2 04             	add    $0x4,%edx
        dest_word[nn]=src_word[nn];
c0001248:	89 4a fc             	mov    %ecx,-0x4(%edx)
    for(size_t nn=0; nn<n_words; nn++)
c000124b:	39 d8                	cmp    %ebx,%eax
c000124d:	75 f1                	jne    c0001240 <memcpy+0x20>
c000124f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    
    //copy remaining bytes
    size_t n_bytes = n - n_words*sizeof(size_t);
    if(n_bytes > 0)
c0001252:	83 e6 03             	and    $0x3,%esi
c0001255:	74 14                	je     c000126b <memcpy+0x4b>
c0001257:	89 fa                	mov    %edi,%edx
c0001259:	01 ce                	add    %ecx,%esi
    {
        char* dest_byte = (char *) dest;
        char* src_byte = (char *) src;
        for(size_t nn=0; nn<n_bytes; nn++)
            dest_byte[nn]=src_byte[nn];
c000125b:	0f b6 01             	movzbl (%ecx),%eax
        for(size_t nn=0; nn<n_bytes; nn++)
c000125e:	83 c1 01             	add    $0x1,%ecx
c0001261:	83 c2 01             	add    $0x1,%edx
            dest_byte[nn]=src_byte[nn];
c0001264:	88 42 ff             	mov    %al,-0x1(%edx)
        for(size_t nn=0; nn<n_bytes; nn++)
c0001267:	39 f1                	cmp    %esi,%ecx
c0001269:	75 f0                	jne    c000125b <memcpy+0x3b>
    }

    return dest;
}
c000126b:	5b                   	pop    %ebx
c000126c:	89 f8                	mov    %edi,%eax
c000126e:	5e                   	pop    %esi
c000126f:	5f                   	pop    %edi
c0001270:	5d                   	pop    %ebp
c0001271:	c3                   	ret    
c0001272:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001279:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

c0001280 <atoi>:

int atoi(const char* str)
{
c0001280:	55                   	push   %ebp
    int p = 0;
    int neg = 0;
    //find start of number string, ignore whitespace
    while(str[p] == '-' || str[p] == ' ' || (str[p] >= 9 && str[p] <= 13))
c0001281:	b8 01 00 00 00       	mov    $0x1,%eax
{
c0001286:	89 e5                	mov    %esp,%ebp
c0001288:	57                   	push   %edi
c0001289:	8b 4d 08             	mov    0x8(%ebp),%ecx
c000128c:	56                   	push   %esi
c000128d:	53                   	push   %ebx
    while(str[p] == '-' || str[p] == ' ' || (str[p] >= 9 && str[p] <= 13))
c000128e:	eb 1e                	jmp    c00012ae <atoi+0x2e>
c0001290:	89 d7                	mov    %edx,%edi
c0001292:	8d 77 f7             	lea    -0x9(%edi),%esi
c0001295:	89 f2                	mov    %esi,%edx
c0001297:	80 fa 04             	cmp    $0x4,%dl
c000129a:	0f 87 b0 00 00 00    	ja     c0001350 <atoi+0xd0>
        if(str[p++] == '-')
        {
            neg=1;
            break;
        }
        if(str[p++] == '\0')
c00012a0:	83 c0 02             	add    $0x2,%eax
c00012a3:	80 7c 01 fe 00       	cmpb   $0x0,-0x2(%ecx,%eax,1)
c00012a8:	0f 84 92 00 00 00    	je     c0001340 <atoi+0xc0>
    while(str[p] == '-' || str[p] == ' ' || (str[p] >= 9 && str[p] <= 13))
c00012ae:	0f b6 54 01 ff       	movzbl -0x1(%ecx,%eax,1),%edx
c00012b3:	8d 58 ff             	lea    -0x1(%eax),%ebx
c00012b6:	80 fa 2d             	cmp    $0x2d,%dl
c00012b9:	74 05                	je     c00012c0 <atoi+0x40>
c00012bb:	80 fa 20             	cmp    $0x20,%dl
c00012be:	75 d0                	jne    c0001290 <atoi+0x10>
        if(str[p++] == '-')
c00012c0:	89 c3                	mov    %eax,%ebx
c00012c2:	80 fa 2d             	cmp    $0x2d,%dl
c00012c5:	75 d9                	jne    c00012a0 <atoi+0x20>
    }

    int num_start = p;

    //find end of integer string (ints only, no decimal point)
    while(str[p] >= '0' && str[p] <= '9')
c00012c7:	0f b6 3c 01          	movzbl (%ecx,%eax,1),%edi
            neg=1;
c00012cb:	be 01 00 00 00       	mov    $0x1,%esi
    while(str[p] >= '0' && str[p] <= '9')
c00012d0:	8d 57 d0             	lea    -0x30(%edi),%edx
c00012d3:	80 fa 09             	cmp    $0x9,%dl
c00012d6:	77 68                	ja     c0001340 <atoi+0xc0>
c00012d8:	89 d8                	mov    %ebx,%eax
c00012da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    {
        if(str[p++] == '\0')
c00012e0:	89 c7                	mov    %eax,%edi
c00012e2:	83 c0 01             	add    $0x1,%eax
    while(str[p] >= '0' && str[p] <= '9')
c00012e5:	0f b6 14 01          	movzbl (%ecx,%eax,1),%edx
c00012e9:	83 ea 30             	sub    $0x30,%edx
c00012ec:	80 fa 09             	cmp    $0x9,%dl
c00012ef:	76 ef                	jbe    c00012e0 <atoi+0x60>
            return 0; //invalid string (only whitespace found)
    }

    if(num_start == p) return 0; //length 0 string
c00012f1:	39 c3                	cmp    %eax,%ebx
c00012f3:	74 4b                	je     c0001340 <atoi+0xc0>

    int number = 0;
    int place = 1;
    //iterate backwards through number to add each digit
    for(int digit = p-1; digit >= num_start; digit--)
c00012f5:	39 fb                	cmp    %edi,%ebx
c00012f7:	7f 5e                	jg     c0001357 <atoi+0xd7>
c00012f9:	01 cf                	add    %ecx,%edi
c00012fb:	8d 5c 19 ff          	lea    -0x1(%ecx,%ebx,1),%ebx
    int place = 1;
c00012ff:	b8 01 00 00 00       	mov    $0x1,%eax
    int number = 0;
c0001304:	31 c9                	xor    %ecx,%ecx
c0001306:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000130d:	8d 76 00             	lea    0x0(%esi),%esi
    {
        number += (int) (str[digit] - '0') * place;
c0001310:	0f be 17             	movsbl (%edi),%edx
    for(int digit = p-1; digit >= num_start; digit--)
c0001313:	83 ef 01             	sub    $0x1,%edi
        number += (int) (str[digit] - '0') * place;
c0001316:	83 ea 30             	sub    $0x30,%edx
c0001319:	0f af d0             	imul   %eax,%edx
        place *= 10;
c000131c:	8d 04 80             	lea    (%eax,%eax,4),%eax
c000131f:	01 c0                	add    %eax,%eax
        number += (int) (str[digit] - '0') * place;
c0001321:	01 d1                	add    %edx,%ecx
    for(int digit = p-1; digit >= num_start; digit--)
c0001323:	39 fb                	cmp    %edi,%ebx
c0001325:	75 e9                	jne    c0001310 <atoi+0x90>
    }

    if(neg)
        return -1*number;
c0001327:	89 c8                	mov    %ecx,%eax
    else
        return number;
}
c0001329:	5b                   	pop    %ebx
        return -1*number;
c000132a:	f7 d8                	neg    %eax
c000132c:	85 f6                	test   %esi,%esi
}
c000132e:	5e                   	pop    %esi
c000132f:	5f                   	pop    %edi
        return -1*number;
c0001330:	0f 45 c8             	cmovne %eax,%ecx
}
c0001333:	5d                   	pop    %ebp
c0001334:	89 c8                	mov    %ecx,%eax
c0001336:	c3                   	ret    
c0001337:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000133e:	66 90                	xchg   %ax,%ax
            return 0; //invalid string (only whitespace found)
c0001340:	31 c9                	xor    %ecx,%ecx
}
c0001342:	5b                   	pop    %ebx
c0001343:	5e                   	pop    %esi
c0001344:	89 c8                	mov    %ecx,%eax
c0001346:	5f                   	pop    %edi
c0001347:	5d                   	pop    %ebp
c0001348:	c3                   	ret    
c0001349:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    int neg = 0;
c0001350:	31 f6                	xor    %esi,%esi
c0001352:	e9 79 ff ff ff       	jmp    c00012d0 <atoi+0x50>
    int number = 0;
c0001357:	31 c9                	xor    %ecx,%ecx
c0001359:	eb cc                	jmp    c0001327 <atoi+0xa7>
c000135b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c000135f:	90                   	nop

c0001360 <itoa>:

char* itoa( int value, char* str, int base)
{
c0001360:	55                   	push   %ebp
c0001361:	89 e5                	mov    %esp,%ebp
c0001363:	57                   	push   %edi
c0001364:	56                   	push   %esi
c0001365:	53                   	push   %ebx
c0001366:	83 ec 08             	sub    $0x8,%esp
c0001369:	8b 4d 10             	mov    0x10(%ebp),%ecx
c000136c:	8b 45 08             	mov    0x8(%ebp),%eax
    if(base < 2 || base > 32)
c000136f:	8d 51 fe             	lea    -0x2(%ecx),%edx
c0001372:	83 fa 1e             	cmp    $0x1e,%edx
c0001375:	0f 87 b5 00 00 00    	ja     c0001430 <itoa+0xd0>
        return NULL;

    //handle zero as special case 
    if(value == 0)
c000137b:	85 c0                	test   %eax,%eax
c000137d:	0f 84 8d 00 00 00    	je     c0001410 <itoa+0xb0>
        return str;
    }

    char* s = str;
    unsigned int residual; //holds the unsigned value still to be parsed
    if(base == 10 && value < 0)
c0001383:	83 f9 0a             	cmp    $0xa,%ecx
c0001386:	75 78                	jne    c0001400 <itoa+0xa0>
c0001388:	85 c0                	test   %eax,%eax
c000138a:	79 74                	jns    c0001400 <itoa+0xa0>
    {
        residual = -value;
c000138c:	f7 d8                	neg    %eax
c000138e:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *(s++) = '-';
c0001391:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001394:	83 c0 01             	add    $0x1,%eax
c0001397:	89 45 ec             	mov    %eax,-0x14(%ebp)
c000139a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000139d:	c6 00 2d             	movb   $0x2d,(%eax)
    }
    
    // find number of digits so that we can parse number
    // directly into string from lowest to highest digit    
    unsigned int num_digits = 0;
    unsigned int temp = residual;
c00013a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    unsigned int num_digits = 0;
c00013a3:	31 f6                	xor    %esi,%esi
c00013a5:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00013ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    while(temp>0)
    {
        num_digits++;
c00013b0:	89 c3                	mov    %eax,%ebx
        temp /= base;
c00013b2:	31 d2                	xor    %edx,%edx
c00013b4:	89 f7                	mov    %esi,%edi
        num_digits++;
c00013b6:	83 c6 01             	add    $0x1,%esi
        temp /= base;
c00013b9:	f7 f1                	div    %ecx
    while(temp>0)
c00013bb:	39 d9                	cmp    %ebx,%ecx
c00013bd:	76 f1                	jbe    c00013b0 <itoa+0x50>
    }

    //point at end of string
    s += num_digits;
    *(s--) = '\0'; //null termination
c00013bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00013c2:	89 4d 10             	mov    %ecx,0x10(%ebp)
c00013c5:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
c00013c9:	8d 1c 38             	lea    (%eax,%edi,1),%ebx
c00013cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00013cf:	90                   	nop
    //compute each digit from lowest to highest.
    unsigned int digit;
    while(residual>0)
    {
        digit = residual % base;
        residual /= base;
c00013d0:	31 d2                	xor    %edx,%edx
c00013d2:	89 c1                	mov    %eax,%ecx

        //write digit into string and decrement pointer
        if(digit < 10)
            *(s--) = digit + '0';
c00013d4:	83 eb 01             	sub    $0x1,%ebx
        residual /= base;
c00013d7:	f7 75 10             	divl   0x10(%ebp)
            *(s--) = digit + '0';
c00013da:	8d 7a 30             	lea    0x30(%edx),%edi
c00013dd:	8d 72 37             	lea    0x37(%edx),%esi
c00013e0:	83 fa 09             	cmp    $0x9,%edx
c00013e3:	0f 47 fe             	cmova  %esi,%edi
c00013e6:	89 fa                	mov    %edi,%edx
c00013e8:	88 53 01             	mov    %dl,0x1(%ebx)
    while(residual>0)
c00013eb:	39 4d 10             	cmp    %ecx,0x10(%ebp)
c00013ee:	76 e0                	jbe    c00013d0 <itoa+0x70>
        else
            *(s--) = digit - 10 + 'A';        
    }

    return str;
}
c00013f0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00013f3:	83 c4 08             	add    $0x8,%esp
c00013f6:	5b                   	pop    %ebx
c00013f7:	5e                   	pop    %esi
c00013f8:	5f                   	pop    %edi
c00013f9:	5d                   	pop    %ebp
c00013fa:	c3                   	ret    
c00013fb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c00013ff:	90                   	nop
        residual = (unsigned int) value;
c0001400:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0001403:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001406:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0001409:	eb 95                	jmp    c00013a0 <itoa+0x40>
c000140b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c000140f:	90                   	nop
        str[0] = '0';
c0001410:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001413:	ba 30 00 00 00       	mov    $0x30,%edx
c0001418:	66 89 10             	mov    %dx,(%eax)
}
c000141b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000141e:	83 c4 08             	add    $0x8,%esp
c0001421:	5b                   	pop    %ebx
c0001422:	5e                   	pop    %esi
c0001423:	5f                   	pop    %edi
c0001424:	5d                   	pop    %ebp
c0001425:	c3                   	ret    
c0001426:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000142d:	8d 76 00             	lea    0x0(%esi),%esi
        return NULL;
c0001430:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
}
c0001437:	8b 45 0c             	mov    0xc(%ebp),%eax
c000143a:	83 c4 08             	add    $0x8,%esp
c000143d:	5b                   	pop    %ebx
c000143e:	5e                   	pop    %esi
c000143f:	5f                   	pop    %edi
c0001440:	5d                   	pop    %ebp
c0001441:	c3                   	ret    
c0001442:	66 90                	xchg   %ax,%ax
c0001444:	66 90                	xchg   %ax,%ax
c0001446:	66 90                	xchg   %ax,%ax
c0001448:	66 90                	xchg   %ax,%ax
c000144a:	66 90                	xchg   %ax,%ax
c000144c:	66 90                	xchg   %ax,%ax
c000144e:	66 90                	xchg   %ax,%ax

c0001450 <memory_table>:
#include "multiboot.h"
#include "kprintf.h"

size_t memory_table(multiboot_info_t* mbd)
{
c0001450:	55                   	push   %ebp
c0001451:	89 e5                	mov    %esp,%ebp
c0001453:	56                   	push   %esi
c0001454:	8b 55 08             	mov    0x8(%ebp),%edx
c0001457:	53                   	push   %ebx
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
    size_t available_mem = 0;
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001458:	8b 5a 2c             	mov    0x2c(%edx),%ebx
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c000145b:	8b 42 30             	mov    0x30(%edx),%eax
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c000145e:	85 db                	test   %ebx,%ebx
c0001460:	74 35                	je     c0001497 <memory_table+0x47>
c0001462:	8d 14 5b             	lea    (%ebx,%ebx,2),%edx
    size_t available_mem = 0;
c0001465:	31 db                	xor    %ebx,%ebx
c0001467:	8d 0c d0             	lea    (%eax,%edx,8),%ecx
c000146a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	{
		if(mmap_table[nn].len>0 && mmap_table[nn].size>0)
c0001470:	8b 50 0c             	mov    0xc(%eax),%edx
c0001473:	89 d6                	mov    %edx,%esi
c0001475:	0b 70 10             	or     0x10(%eax),%esi
c0001478:	74 16                	je     c0001490 <memory_table+0x40>
c000147a:	8b 30                	mov    (%eax),%esi
c000147c:	85 f6                	test   %esi,%esi
c000147e:	74 10                	je     c0001490 <memory_table+0x40>
        {
            if(mmap_table[nn].type == 1)
c0001480:	83 78 14 01          	cmpl   $0x1,0x14(%eax)
c0001484:	75 0a                	jne    c0001490 <memory_table+0x40>
            available_mem += mmap_table[nn].len;
c0001486:	01 d3                	add    %edx,%ebx
c0001488:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000148f:	90                   	nop
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001490:	83 c0 18             	add    $0x18,%eax
c0001493:	39 c8                	cmp    %ecx,%eax
c0001495:	75 d9                	jne    c0001470 <memory_table+0x20>
        }
		
	}

    return available_mem;
}
c0001497:	89 d8                	mov    %ebx,%eax
c0001499:	5b                   	pop    %ebx
c000149a:	5e                   	pop    %esi
c000149b:	5d                   	pop    %ebp
c000149c:	c3                   	ret    
c000149d:	8d 76 00             	lea    0x0(%esi),%esi

c00014a0 <print_memory_table>:

int print_memory_table(multiboot_info_t* mbd)
{
c00014a0:	55                   	push   %ebp
c00014a1:	89 e5                	mov    %esp,%ebp
c00014a3:	57                   	push   %edi
c00014a4:	56                   	push   %esi
c00014a5:	53                   	push   %ebx
c00014a6:	83 ec 28             	sub    $0x28,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c00014a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00014ac:	8b 78 30             	mov    0x30(%eax),%edi
	kprintf("Memory Table:\n");
c00014af:	68 85 33 00 c0       	push   $0xc0003385
c00014b4:	e8 d7 ec ff ff       	call   c0000190 <kprintf>
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c00014b9:	8b 45 08             	mov    0x8(%ebp),%eax
c00014bc:	83 c4 10             	add    $0x10,%esp
c00014bf:	8b 50 2c             	mov    0x2c(%eax),%edx
c00014c2:	85 d2                	test   %edx,%edx
c00014c4:	0f 84 8f 00 00 00    	je     c0001559 <print_memory_table+0xb9>
c00014ca:	31 f6                	xor    %esi,%esi
c00014cc:	eb 2a                	jmp    c00014f8 <print_memory_table+0x58>
c00014ce:	66 90                	xchg   %ax,%ax
		if(mmap_table[nn].len>0)
		{
			if(mmap_table[nn].type == MULTIBOOT_MEMORY_AVAILABLE)
				kprintf("%.8llp - %.8llp [AVAILABLE] (%6llu kiB)\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
			else
				kprintf("%.8llp - %.8llp [RESERVED]\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c00014d0:	83 ec 04             	sub    $0x4,%esp
c00014d3:	ff 75 e4             	pushl  -0x1c(%ebp)
c00014d6:	ff 75 e0             	pushl  -0x20(%ebp)
c00014d9:	52                   	push   %edx
c00014da:	50                   	push   %eax
c00014db:	53                   	push   %ebx
c00014dc:	51                   	push   %ecx
c00014dd:	68 94 33 00 c0       	push   $0xc0003394
c00014e2:	e8 a9 ec ff ff       	call   c0000190 <kprintf>
c00014e7:	83 c4 20             	add    $0x20,%esp
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c00014ea:	8b 45 08             	mov    0x8(%ebp),%eax
c00014ed:	83 c6 01             	add    $0x1,%esi
c00014f0:	83 c7 18             	add    $0x18,%edi
c00014f3:	39 70 2c             	cmp    %esi,0x2c(%eax)
c00014f6:	76 61                	jbe    c0001559 <print_memory_table+0xb9>
        if(mmap_table[nn].size == 0)
c00014f8:	8b 07                	mov    (%edi),%eax
c00014fa:	85 c0                	test   %eax,%eax
c00014fc:	74 5b                	je     c0001559 <print_memory_table+0xb9>
		if(mmap_table[nn].len>0)
c00014fe:	8b 57 10             	mov    0x10(%edi),%edx
c0001501:	8b 47 0c             	mov    0xc(%edi),%eax
c0001504:	89 d3                	mov    %edx,%ebx
c0001506:	89 c1                	mov    %eax,%ecx
c0001508:	09 c3                	or     %eax,%ebx
c000150a:	74 de                	je     c00014ea <print_memory_table+0x4a>
				kprintf("%.8llp - %.8llp [AVAILABLE] (%6llu kiB)\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c000150c:	89 d3                	mov    %edx,%ebx
c000150e:	0f ac d9 0a          	shrd   $0xa,%ebx,%ecx
c0001512:	c1 eb 0a             	shr    $0xa,%ebx
c0001515:	89 4d e0             	mov    %ecx,-0x20(%ebp)
c0001518:	8b 4f 04             	mov    0x4(%edi),%ecx
c000151b:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
c000151e:	8b 5f 08             	mov    0x8(%edi),%ebx
c0001521:	01 c8                	add    %ecx,%eax
c0001523:	11 da                	adc    %ebx,%edx
c0001525:	83 c0 ff             	add    $0xffffffff,%eax
c0001528:	83 d2 ff             	adc    $0xffffffff,%edx
			if(mmap_table[nn].type == MULTIBOOT_MEMORY_AVAILABLE)
c000152b:	83 7f 14 01          	cmpl   $0x1,0x14(%edi)
c000152f:	75 9f                	jne    c00014d0 <print_memory_table+0x30>
				kprintf("%.8llp - %.8llp [AVAILABLE] (%6llu kiB)\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c0001531:	83 ec 04             	sub    $0x4,%esp
c0001534:	ff 75 e4             	pushl  -0x1c(%ebp)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001537:	83 c6 01             	add    $0x1,%esi
c000153a:	83 c7 18             	add    $0x18,%edi
				kprintf("%.8llp - %.8llp [AVAILABLE] (%6llu kiB)\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c000153d:	ff 75 e0             	pushl  -0x20(%ebp)
c0001540:	52                   	push   %edx
c0001541:	50                   	push   %eax
c0001542:	53                   	push   %ebx
c0001543:	51                   	push   %ecx
c0001544:	68 80 34 00 c0       	push   $0xc0003480
c0001549:	e8 42 ec ff ff       	call   c0000190 <kprintf>
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c000154e:	8b 45 08             	mov    0x8(%ebp),%eax
c0001551:	83 c4 20             	add    $0x20,%esp
c0001554:	39 70 2c             	cmp    %esi,0x2c(%eax)
c0001557:	77 9f                	ja     c00014f8 <print_memory_table+0x58>
	// }

    // print_crs();

    return 0;
}
c0001559:	8d 65 f4             	lea    -0xc(%ebp),%esp
c000155c:	31 c0                	xor    %eax,%eax
c000155e:	5b                   	pop    %ebx
c000155f:	5e                   	pop    %esi
c0001560:	5f                   	pop    %edi
c0001561:	5d                   	pop    %ebp
c0001562:	c3                   	ret    
c0001563:	66 90                	xchg   %ax,%ax
c0001565:	66 90                	xchg   %ax,%ax
c0001567:	66 90                	xchg   %ax,%ax
c0001569:	66 90                	xchg   %ax,%ax
c000156b:	66 90                	xchg   %ax,%ax
c000156d:	66 90                	xchg   %ax,%ax
c000156f:	90                   	nop

c0001570 <terminal_init>:
#include "io.h"

struct terminal stdout;

void terminal_init(struct terminal* term) 
{
c0001570:	55                   	push   %ebp
	term->row = 0;
	term->column = 0;
	term->color = vga_entry_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
	term->buffer = (uint16_t*) VGA_BUFFER;
c0001571:	ba a0 80 0b 00       	mov    $0xb80a0,%edx
{
c0001576:	89 e5                	mov    %esp,%ebp
c0001578:	8b 45 08             	mov    0x8(%ebp),%eax
	term->row = 0;
c000157b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	term->column = 0;
c0001581:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	term->color = vga_entry_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
c0001588:	c6 40 08 07          	movb   $0x7,0x8(%eax)
	term->buffer = (uint16_t*) VGA_BUFFER;
c000158c:	c7 40 0c 00 80 0b 00 	movl   $0xb8000,0xc(%eax)
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
c0001593:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000159a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		for (size_t x = 0; x < VGA_WIDTH; x++) {
c00015a0:	8d 82 60 ff ff ff    	lea    -0xa0(%edx),%eax
c00015a6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00015ad:	8d 76 00             	lea    0x0(%esi),%esi
			const size_t index = y * VGA_WIDTH + x;
			term->buffer[index] = vga_entry(' ', term->color);
c00015b0:	b9 20 07 00 00       	mov    $0x720,%ecx
		for (size_t x = 0; x < VGA_WIDTH; x++) {
c00015b5:	83 c0 02             	add    $0x2,%eax
			term->buffer[index] = vga_entry(' ', term->color);
c00015b8:	66 89 48 fe          	mov    %cx,-0x2(%eax)
		for (size_t x = 0; x < VGA_WIDTH; x++) {
c00015bc:	39 d0                	cmp    %edx,%eax
c00015be:	75 f0                	jne    c00015b0 <terminal_init+0x40>
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
c00015c0:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c00015c6:	3d a0 8f 0b 00       	cmp    $0xb8fa0,%eax
c00015cb:	75 d3                	jne    c00015a0 <terminal_init+0x30>
}

static __inline void
outb (unsigned char __value, unsigned short int __port)
{
  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
c00015cd:	b8 0a 00 00 00       	mov    $0xa,%eax
c00015d2:	ba d4 03 00 00       	mov    $0x3d4,%edx
c00015d7:	ee                   	out    %al,(%dx)
c00015d8:	b8 20 00 00 00       	mov    $0x20,%eax
c00015dd:	ba d5 03 00 00       	mov    $0x3d5,%edx
c00015e2:	ee                   	out    %al,(%dx)
	// outb(0x0A, 0x3D4);
	// outb((inb(0x3D5) & 0xC0) | cursor_start, 0x3D5);
 
	// outb(0x0B, 0x3D4);
	// outb((inb(0x3D5) & 0xE0) | cursor_end, 0x3D5);
}
c00015e3:	5d                   	pop    %ebp
c00015e4:	c3                   	ret    
c00015e5:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00015ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

c00015f0 <terminal_setcolor>:
 
void terminal_setcolor(struct terminal* term, uint8_t color) 
{
c00015f0:	55                   	push   %ebp
c00015f1:	89 e5                	mov    %esp,%ebp
	term->color = color;
c00015f3:	8b 45 08             	mov    0x8(%ebp),%eax
c00015f6:	8b 55 0c             	mov    0xc(%ebp),%edx
c00015f9:	88 50 08             	mov    %dl,0x8(%eax)
}
c00015fc:	5d                   	pop    %ebp
c00015fd:	c3                   	ret    
c00015fe:	66 90                	xchg   %ax,%ax

c0001600 <terminal_putentryat>:
 
void terminal_putentryat(struct terminal* term, char c, uint8_t color, size_t x, size_t y) 
{
c0001600:	55                   	push   %ebp
c0001601:	89 e5                	mov    %esp,%ebp
c0001603:	53                   	push   %ebx
	const size_t index = y * VGA_WIDTH + x;
	term->buffer[index] = vga_entry(c, color);
c0001604:	8b 55 08             	mov    0x8(%ebp),%edx
{
c0001607:	8b 45 18             	mov    0x18(%ebp),%eax
	term->buffer[index] = vga_entry(c, color);
c000160a:	8b 5a 0c             	mov    0xc(%edx),%ebx
c000160d:	0f b6 55 10          	movzbl 0x10(%ebp),%edx
c0001611:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0001614:	c1 e0 04             	shl    $0x4,%eax
c0001617:	03 45 14             	add    0x14(%ebp),%eax
	return fg | bg << 4;
}
 
static inline uint16_t vga_entry(unsigned char uc, uint8_t color) 
{
	return (uint16_t) uc | (uint16_t) color << 8;
c000161a:	89 d1                	mov    %edx,%ecx
c000161c:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
c0001620:	c1 e1 08             	shl    $0x8,%ecx
c0001623:	09 ca                	or     %ecx,%edx
c0001625:	66 89 14 43          	mov    %dx,(%ebx,%eax,2)
	// terminal_movecursor(term, x, y);
}
c0001629:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000162c:	c9                   	leave  
c000162d:	c3                   	ret    
c000162e:	66 90                	xchg   %ax,%ax

c0001630 <terminal_movecursor>:

void terminal_movecursor(struct terminal* term, size_t x, size_t y)
{
c0001630:	55                   	push   %ebp
c0001631:	b8 0f 00 00 00       	mov    $0xf,%eax
c0001636:	89 e5                	mov    %esp,%ebp
c0001638:	56                   	push   %esi
c0001639:	be d4 03 00 00       	mov    $0x3d4,%esi
c000163e:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0001641:	53                   	push   %ebx
c0001642:	89 f2                	mov    %esi,%edx
	(void) term; //we are directly manipulating curser, so were arean't using the term struct

	uint16_t pos = y * VGA_WIDTH + x;
c0001644:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c0001647:	c1 e1 04             	shl    $0x4,%ecx
c000164a:	66 03 4d 0c          	add    0xc(%ebp),%cx
c000164e:	ee                   	out    %al,(%dx)
c000164f:	bb d5 03 00 00       	mov    $0x3d5,%ebx
c0001654:	89 c8                	mov    %ecx,%eax
c0001656:	89 da                	mov    %ebx,%edx
c0001658:	ee                   	out    %al,(%dx)
c0001659:	b8 0e 00 00 00       	mov    $0xe,%eax
c000165e:	89 f2                	mov    %esi,%edx
c0001660:	ee                   	out    %al,(%dx)

	outb(0x0F, 0x3D4);
	outb((uint8_t) (pos & 0xFF), 0x3D5);
	outb(0x0E, 0x3D4);
	outb((uint8_t) ((pos >> 8) & 0xFF), 0x3D5);
c0001661:	89 c8                	mov    %ecx,%eax
c0001663:	89 da                	mov    %ebx,%edx
c0001665:	66 c1 e8 08          	shr    $0x8,%ax
c0001669:	ee                   	out    %al,(%dx)
}
c000166a:	5b                   	pop    %ebx
c000166b:	5e                   	pop    %esi
c000166c:	5d                   	pop    %ebp
c000166d:	c3                   	ret    
c000166e:	66 90                	xchg   %ax,%ax

c0001670 <terminal_putcharn>:
	if (++term->column == VGA_WIDTH)
		terminal_newline(term);
}

void terminal_putcharn(struct terminal* term, char c, size_t repeat) 
{
c0001670:	55                   	push   %ebp
c0001671:	89 e5                	mov    %esp,%ebp
c0001673:	57                   	push   %edi
c0001674:	56                   	push   %esi
c0001675:	53                   	push   %ebx
c0001676:	83 ec 1c             	sub    $0x1c,%esp
c0001679:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
c000167d:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0001680:	88 45 e3             	mov    %al,-0x1d(%ebp)
c0001683:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
	for (size_t i = 0; i < repeat; i++)
c0001687:	8b 45 10             	mov    0x10(%ebp),%eax
c000168a:	85 c0                	test   %eax,%eax
c000168c:	0f 84 c4 00 00 00    	je     c0001756 <terminal_putcharn+0xe6>
c0001692:	31 ff                	xor    %edi,%edi
c0001694:	eb 19                	jmp    c00016af <terminal_putcharn+0x3f>
c0001696:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000169d:	8d 76 00             	lea    0x0(%esi),%esi
	if (++term->column == VGA_WIDTH)
c00016a0:	89 43 04             	mov    %eax,0x4(%ebx)
	for (size_t i = 0; i < repeat; i++)
c00016a3:	83 c7 01             	add    $0x1,%edi
c00016a6:	39 7d 10             	cmp    %edi,0x10(%ebp)
c00016a9:	0f 84 a7 00 00 00    	je     c0001756 <terminal_putcharn+0xe6>
}

void terminal_newline(struct terminal* term)
{
    term->column = 0;
    if (++term->row == VGA_HEIGHT)
c00016af:	8b 03                	mov    (%ebx),%eax
	if(c == '\n')
c00016b1:	80 7d e3 0a          	cmpb   $0xa,-0x1d(%ebp)
    if (++term->row == VGA_HEIGHT)
c00016b5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if(c == '\n')
c00016b8:	0f 84 a2 00 00 00    	je     c0001760 <terminal_putcharn+0xf0>
	term->buffer[index] = vga_entry(c, color);
c00016be:	8b 43 0c             	mov    0xc(%ebx),%eax
	terminal_putentryat(term, c, term->color, term->column, term->row);
c00016c1:	8b 73 04             	mov    0x4(%ebx),%esi
c00016c4:	0f b6 53 08          	movzbl 0x8(%ebx),%edx
	term->buffer[index] = vga_entry(c, color);
c00016c8:	89 c1                	mov    %eax,%ecx
c00016ca:	89 45 dc             	mov    %eax,-0x24(%ebp)
c00016cd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00016d0:	c1 e2 08             	shl    $0x8,%edx
c00016d3:	66 0b 55 e0          	or     -0x20(%ebp),%dx
c00016d7:	8d 04 80             	lea    (%eax,%eax,4),%eax
c00016da:	c1 e0 04             	shl    $0x4,%eax
c00016dd:	01 f0                	add    %esi,%eax
c00016df:	66 89 14 41          	mov    %dx,(%ecx,%eax,2)
	if (++term->column == VGA_WIDTH)
c00016e3:	8d 46 01             	lea    0x1(%esi),%eax
c00016e6:	83 fe 4f             	cmp    $0x4f,%esi
c00016e9:	75 b5                	jne    c00016a0 <terminal_putcharn+0x30>
    if (++term->row == VGA_HEIGHT)
c00016eb:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    term->column = 0;
c00016ee:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    if (++term->row == VGA_HEIGHT)
c00016f5:	83 c1 01             	add    $0x1,%ecx
c00016f8:	89 0b                	mov    %ecx,(%ebx)
c00016fa:	83 f9 19             	cmp    $0x19,%ecx
c00016fd:	75 a4                	jne    c00016a3 <terminal_putcharn+0x33>
}

void terminal_scrollline(struct terminal* term)
{
	// copy rows 2 though N to rows 1 through N-1
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c00016ff:	8b 75 dc             	mov    -0x24(%ebp),%esi
c0001702:	83 ec 04             	sub    $0x4,%esp
c0001705:	68 00 0f 00 00       	push   $0xf00
c000170a:	8d 86 a0 00 00 00    	lea    0xa0(%esi),%eax
c0001710:	50                   	push   %eax
c0001711:	56                   	push   %esi
c0001712:	e8 09 fb ff ff       	call   c0001220 <memcpy>

void terminal_clearline(struct terminal* term)
{
	size_t row_start = term->row * VGA_WIDTH;
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001717:	0f b6 53 08          	movzbl 0x8(%ebx),%edx
c000171b:	8b 4b 0c             	mov    0xc(%ebx),%ecx
c000171e:	83 c4 10             	add    $0x10,%esp
	term->row = VGA_HEIGHT-1;
c0001721:	c7 03 18 00 00 00    	movl   $0x18,(%ebx)
c0001727:	c1 e2 08             	shl    $0x8,%edx
c000172a:	8d 81 00 0f 00 00    	lea    0xf00(%ecx),%eax
c0001730:	81 c1 a0 0f 00 00    	add    $0xfa0,%ecx
c0001736:	83 ca 20             	or     $0x20,%edx
c0001739:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001740:	66 89 10             	mov    %dx,(%eax)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c0001743:	83 c0 02             	add    $0x2,%eax
c0001746:	39 c8                	cmp    %ecx,%eax
c0001748:	75 f6                	jne    c0001740 <terminal_putcharn+0xd0>
	for (size_t i = 0; i < repeat; i++)
c000174a:	83 c7 01             	add    $0x1,%edi
c000174d:	39 7d 10             	cmp    %edi,0x10(%ebp)
c0001750:	0f 85 59 ff ff ff    	jne    c00016af <terminal_putcharn+0x3f>
}
c0001756:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0001759:	5b                   	pop    %ebx
c000175a:	5e                   	pop    %esi
c000175b:	5f                   	pop    %edi
c000175c:	5d                   	pop    %ebp
c000175d:	c3                   	ret    
c000175e:	66 90                	xchg   %ax,%ax
    if (++term->row == VGA_HEIGHT)
c0001760:	89 c1                	mov    %eax,%ecx
    term->column = 0;
c0001762:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    if (++term->row == VGA_HEIGHT)
c0001769:	83 c1 01             	add    $0x1,%ecx
c000176c:	89 0b                	mov    %ecx,(%ebx)
c000176e:	83 f9 19             	cmp    $0x19,%ecx
c0001771:	0f 85 2c ff ff ff    	jne    c00016a3 <terminal_putcharn+0x33>
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c0001777:	8b 43 0c             	mov    0xc(%ebx),%eax
c000177a:	83 ec 04             	sub    $0x4,%esp
c000177d:	68 00 0f 00 00       	push   $0xf00
c0001782:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c0001788:	52                   	push   %edx
c0001789:	50                   	push   %eax
c000178a:	e8 91 fa ff ff       	call   c0001220 <memcpy>
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c000178f:	0f b6 53 08          	movzbl 0x8(%ebx),%edx
c0001793:	8b 4b 0c             	mov    0xc(%ebx),%ecx
c0001796:	83 c4 10             	add    $0x10,%esp
	term->row = VGA_HEIGHT-1;
c0001799:	c7 03 18 00 00 00    	movl   $0x18,(%ebx)
c000179f:	c1 e2 08             	shl    $0x8,%edx
c00017a2:	8d 81 00 0f 00 00    	lea    0xf00(%ecx),%eax
c00017a8:	81 c1 a0 0f 00 00    	add    $0xfa0,%ecx
c00017ae:	83 ca 20             	or     $0x20,%edx
c00017b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00017b8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00017bf:	90                   	nop
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c00017c0:	66 89 10             	mov    %dx,(%eax)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c00017c3:	83 c0 02             	add    $0x2,%eax
c00017c6:	39 c8                	cmp    %ecx,%eax
c00017c8:	75 f6                	jne    c00017c0 <terminal_putcharn+0x150>
c00017ca:	e9 d4 fe ff ff       	jmp    c00016a3 <terminal_putcharn+0x33>
c00017cf:	90                   	nop

c00017d0 <terminal_newline>:
{
c00017d0:	55                   	push   %ebp
c00017d1:	89 e5                	mov    %esp,%ebp
c00017d3:	53                   	push   %ebx
c00017d4:	83 ec 04             	sub    $0x4,%esp
c00017d7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    if (++term->row == VGA_HEIGHT)
c00017da:	8b 03                	mov    (%ebx),%eax
    term->column = 0;
c00017dc:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    if (++term->row == VGA_HEIGHT)
c00017e3:	83 c0 01             	add    $0x1,%eax
c00017e6:	89 03                	mov    %eax,(%ebx)
c00017e8:	83 f8 19             	cmp    $0x19,%eax
c00017eb:	74 13                	je     c0001800 <terminal_newline+0x30>
}
c00017ed:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00017f0:	c9                   	leave  
c00017f1:	c3                   	ret    
c00017f2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00017f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c0001800:	8b 43 0c             	mov    0xc(%ebx),%eax
c0001803:	83 ec 04             	sub    $0x4,%esp
c0001806:	68 00 0f 00 00       	push   $0xf00
c000180b:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c0001811:	52                   	push   %edx
c0001812:	50                   	push   %eax
c0001813:	e8 08 fa ff ff       	call   c0001220 <memcpy>
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001818:	0f b6 53 08          	movzbl 0x8(%ebx),%edx
c000181c:	8b 4b 0c             	mov    0xc(%ebx),%ecx
c000181f:	83 c4 10             	add    $0x10,%esp
	term->row = VGA_HEIGHT-1;
c0001822:	c7 03 18 00 00 00    	movl   $0x18,(%ebx)
c0001828:	c1 e2 08             	shl    $0x8,%edx
c000182b:	8d 81 00 0f 00 00    	lea    0xf00(%ecx),%eax
c0001831:	81 c1 a0 0f 00 00    	add    $0xfa0,%ecx
c0001837:	83 ca 20             	or     $0x20,%edx
c000183a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001840:	66 89 10             	mov    %dx,(%eax)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c0001843:	83 c0 02             	add    $0x2,%eax
c0001846:	39 c8                	cmp    %ecx,%eax
c0001848:	75 f6                	jne    c0001840 <terminal_newline+0x70>
}
c000184a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000184d:	c9                   	leave  
c000184e:	c3                   	ret    
c000184f:	90                   	nop

c0001850 <terminal_putchar>:
{
c0001850:	55                   	push   %ebp
c0001851:	89 e5                	mov    %esp,%ebp
c0001853:	56                   	push   %esi
c0001854:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001857:	8b 55 08             	mov    0x8(%ebp),%edx
c000185a:	53                   	push   %ebx
	if(c == '\n')
c000185b:	3c 0a                	cmp    $0xa,%al
c000185d:	74 31                	je     c0001890 <terminal_putchar+0x40>
	const size_t index = y * VGA_WIDTH + x;
c000185f:	8b 1a                	mov    (%edx),%ebx
	terminal_putentryat(term, c, term->color, term->column, term->row);
c0001861:	0f b6 72 08          	movzbl 0x8(%edx),%esi
c0001865:	0f b6 c0             	movzbl %al,%eax
c0001868:	8b 4a 04             	mov    0x4(%edx),%ecx
c000186b:	c1 e6 08             	shl    $0x8,%esi
	term->buffer[index] = vga_entry(c, color);
c000186e:	8d 1c 9b             	lea    (%ebx,%ebx,4),%ebx
c0001871:	09 f0                	or     %esi,%eax
c0001873:	c1 e3 04             	shl    $0x4,%ebx
c0001876:	8b 72 0c             	mov    0xc(%edx),%esi
c0001879:	01 cb                	add    %ecx,%ebx
	if (++term->column == VGA_WIDTH)
c000187b:	83 c1 01             	add    $0x1,%ecx
c000187e:	66 89 04 5e          	mov    %ax,(%esi,%ebx,2)
c0001882:	89 4a 04             	mov    %ecx,0x4(%edx)
c0001885:	83 f9 50             	cmp    $0x50,%ecx
c0001888:	74 06                	je     c0001890 <terminal_putchar+0x40>
}
c000188a:	5b                   	pop    %ebx
c000188b:	5e                   	pop    %esi
c000188c:	5d                   	pop    %ebp
c000188d:	c3                   	ret    
c000188e:	66 90                	xchg   %ax,%ax
c0001890:	5b                   	pop    %ebx
c0001891:	5e                   	pop    %esi
		terminal_newline(term);
c0001892:	89 55 08             	mov    %edx,0x8(%ebp)
}
c0001895:	5d                   	pop    %ebp
		terminal_newline(term);
c0001896:	e9 35 ff ff ff       	jmp    c00017d0 <terminal_newline>
c000189b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c000189f:	90                   	nop

c00018a0 <terminal_scrollline>:
{
c00018a0:	55                   	push   %ebp
c00018a1:	89 e5                	mov    %esp,%ebp
c00018a3:	53                   	push   %ebx
c00018a4:	83 ec 08             	sub    $0x8,%esp
c00018a7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c00018aa:	8b 43 0c             	mov    0xc(%ebx),%eax
c00018ad:	68 00 0f 00 00       	push   $0xf00
c00018b2:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c00018b8:	52                   	push   %edx
c00018b9:	50                   	push   %eax
c00018ba:	e8 61 f9 ff ff       	call   c0001220 <memcpy>
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c00018bf:	0f b6 53 08          	movzbl 0x8(%ebx),%edx
c00018c3:	8b 4b 0c             	mov    0xc(%ebx),%ecx
c00018c6:	83 c4 10             	add    $0x10,%esp
	term->row = VGA_HEIGHT-1;
c00018c9:	c7 03 18 00 00 00    	movl   $0x18,(%ebx)
c00018cf:	c1 e2 08             	shl    $0x8,%edx
c00018d2:	8d 81 00 0f 00 00    	lea    0xf00(%ecx),%eax
c00018d8:	81 c1 a0 0f 00 00    	add    $0xfa0,%ecx
c00018de:	83 ca 20             	or     $0x20,%edx
c00018e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00018e8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00018ef:	90                   	nop
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c00018f0:	66 89 10             	mov    %dx,(%eax)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c00018f3:	83 c0 02             	add    $0x2,%eax
c00018f6:	39 c8                	cmp    %ecx,%eax
c00018f8:	75 f6                	jne    c00018f0 <terminal_scrollline+0x50>
}
c00018fa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00018fd:	c9                   	leave  
c00018fe:	c3                   	ret    
c00018ff:	90                   	nop

c0001900 <terminal_clearline>:
{
c0001900:	55                   	push   %ebp
c0001901:	89 e5                	mov    %esp,%ebp
c0001903:	53                   	push   %ebx
c0001904:	8b 45 08             	mov    0x8(%ebp),%eax
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001907:	8b 58 0c             	mov    0xc(%eax),%ebx
c000190a:	0f b6 50 08          	movzbl 0x8(%eax),%edx
c000190e:	8b 00                	mov    (%eax),%eax
c0001910:	c1 e2 08             	shl    $0x8,%edx
c0001913:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
c0001916:	83 ca 20             	or     $0x20,%edx
c0001919:	c1 e1 05             	shl    $0x5,%ecx
c000191c:	8d 04 0b             	lea    (%ebx,%ecx,1),%eax
c000191f:	8d 8c 0b a0 00 00 00 	lea    0xa0(%ebx,%ecx,1),%ecx
c0001926:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000192d:	8d 76 00             	lea    0x0(%esi),%esi
c0001930:	66 89 10             	mov    %dx,(%eax)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c0001933:	83 c0 02             	add    $0x2,%eax
c0001936:	39 c8                	cmp    %ecx,%eax
c0001938:	75 f6                	jne    c0001930 <terminal_clearline+0x30>

}
c000193a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000193d:	c9                   	leave  
c000193e:	c3                   	ret    
c000193f:	90                   	nop

c0001940 <terminal_write>:


void terminal_write(struct terminal* term, const char* data, size_t size) 
{
c0001940:	55                   	push   %ebp
c0001941:	89 e5                	mov    %esp,%ebp
c0001943:	57                   	push   %edi
c0001944:	56                   	push   %esi
c0001945:	53                   	push   %ebx
c0001946:	83 ec 1c             	sub    $0x1c,%esp
c0001949:	8b 45 10             	mov    0x10(%ebp),%eax
c000194c:	8b 7d 0c             	mov    0xc(%ebp),%edi
c000194f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	for (size_t i = 0; i < size; i++)
c0001952:	8d 14 07             	lea    (%edi,%eax,1),%edx
c0001955:	89 55 dc             	mov    %edx,-0x24(%ebp)
c0001958:	85 c0                	test   %eax,%eax
c000195a:	75 23                	jne    c000197f <terminal_write+0x3f>
c000195c:	e9 c5 00 00 00       	jmp    c0001a26 <terminal_write+0xe6>
c0001961:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001968:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000196f:	90                   	nop
	if (++term->column == VGA_WIDTH)
c0001970:	89 43 04             	mov    %eax,0x4(%ebx)
	for (size_t i = 0; i < size; i++)
c0001973:	83 c7 01             	add    $0x1,%edi
c0001976:	3b 7d dc             	cmp    -0x24(%ebp),%edi
c0001979:	0f 84 a7 00 00 00    	je     c0001a26 <terminal_write+0xe6>
    if (++term->row == VGA_HEIGHT)
c000197f:	8b 0b                	mov    (%ebx),%ecx
		terminal_putchar(term, data[i]);
c0001981:	0f b6 07             	movzbl (%edi),%eax
    if (++term->row == VGA_HEIGHT)
c0001984:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	if(c == '\n')
c0001987:	3c 0a                	cmp    $0xa,%al
c0001989:	0f 84 a1 00 00 00    	je     c0001a30 <terminal_write+0xf0>
	term->buffer[index] = vga_entry(c, color);
c000198f:	8b 73 0c             	mov    0xc(%ebx),%esi
	terminal_putentryat(term, c, term->color, term->column, term->row);
c0001992:	8b 4b 04             	mov    0x4(%ebx),%ecx
	term->buffer[index] = vga_entry(c, color);
c0001995:	89 f2                	mov    %esi,%edx
c0001997:	89 75 d8             	mov    %esi,-0x28(%ebp)
c000199a:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c000199d:	8d 34 b6             	lea    (%esi,%esi,4),%esi
c00019a0:	c1 e6 04             	shl    $0x4,%esi
c00019a3:	01 ce                	add    %ecx,%esi
c00019a5:	89 75 e0             	mov    %esi,-0x20(%ebp)
	terminal_putentryat(term, c, term->color, term->column, term->row);
c00019a8:	0f b6 73 08          	movzbl 0x8(%ebx),%esi
c00019ac:	c1 e6 08             	shl    $0x8,%esi
c00019af:	09 f0                	or     %esi,%eax
c00019b1:	89 d6                	mov    %edx,%esi
c00019b3:	8b 55 e0             	mov    -0x20(%ebp),%edx
c00019b6:	66 89 04 56          	mov    %ax,(%esi,%edx,2)
	if (++term->column == VGA_WIDTH)
c00019ba:	8d 41 01             	lea    0x1(%ecx),%eax
c00019bd:	83 f9 4f             	cmp    $0x4f,%ecx
c00019c0:	75 ae                	jne    c0001970 <terminal_write+0x30>
    if (++term->row == VGA_HEIGHT)
c00019c2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    term->column = 0;
c00019c5:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    if (++term->row == VGA_HEIGHT)
c00019cc:	83 c2 01             	add    $0x1,%edx
c00019cf:	89 13                	mov    %edx,(%ebx)
c00019d1:	83 fa 19             	cmp    $0x19,%edx
c00019d4:	75 9d                	jne    c0001973 <terminal_write+0x33>
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c00019d6:	8b 55 d8             	mov    -0x28(%ebp),%edx
c00019d9:	83 ec 04             	sub    $0x4,%esp
c00019dc:	68 00 0f 00 00       	push   $0xf00
c00019e1:	8d 82 a0 00 00 00    	lea    0xa0(%edx),%eax
c00019e7:	50                   	push   %eax
c00019e8:	52                   	push   %edx
c00019e9:	e8 32 f8 ff ff       	call   c0001220 <memcpy>
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c00019ee:	0f b6 53 08          	movzbl 0x8(%ebx),%edx
c00019f2:	8b 4b 0c             	mov    0xc(%ebx),%ecx
c00019f5:	83 c4 10             	add    $0x10,%esp
	term->row = VGA_HEIGHT-1;
c00019f8:	c7 03 18 00 00 00    	movl   $0x18,(%ebx)
c00019fe:	c1 e2 08             	shl    $0x8,%edx
c0001a01:	8d 81 00 0f 00 00    	lea    0xf00(%ecx),%eax
c0001a07:	81 c1 a0 0f 00 00    	add    $0xfa0,%ecx
c0001a0d:	83 ca 20             	or     $0x20,%edx
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001a10:	66 89 10             	mov    %dx,(%eax)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c0001a13:	83 c0 02             	add    $0x2,%eax
c0001a16:	39 c8                	cmp    %ecx,%eax
c0001a18:	75 f6                	jne    c0001a10 <terminal_write+0xd0>
	for (size_t i = 0; i < size; i++)
c0001a1a:	83 c7 01             	add    $0x1,%edi
c0001a1d:	3b 7d dc             	cmp    -0x24(%ebp),%edi
c0001a20:	0f 85 59 ff ff ff    	jne    c000197f <terminal_write+0x3f>
}
c0001a26:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0001a29:	5b                   	pop    %ebx
c0001a2a:	5e                   	pop    %esi
c0001a2b:	5f                   	pop    %edi
c0001a2c:	5d                   	pop    %ebp
c0001a2d:	c3                   	ret    
c0001a2e:	66 90                	xchg   %ax,%ax
    if (++term->row == VGA_HEIGHT)
c0001a30:	89 ca                	mov    %ecx,%edx
    term->column = 0;
c0001a32:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    if (++term->row == VGA_HEIGHT)
c0001a39:	83 c2 01             	add    $0x1,%edx
c0001a3c:	89 13                	mov    %edx,(%ebx)
c0001a3e:	83 fa 19             	cmp    $0x19,%edx
c0001a41:	0f 85 2c ff ff ff    	jne    c0001973 <terminal_write+0x33>
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c0001a47:	8b 43 0c             	mov    0xc(%ebx),%eax
c0001a4a:	83 ec 04             	sub    $0x4,%esp
c0001a4d:	68 00 0f 00 00       	push   $0xf00
c0001a52:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c0001a58:	52                   	push   %edx
c0001a59:	50                   	push   %eax
c0001a5a:	e8 c1 f7 ff ff       	call   c0001220 <memcpy>
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001a5f:	0f b6 53 08          	movzbl 0x8(%ebx),%edx
c0001a63:	8b 4b 0c             	mov    0xc(%ebx),%ecx
c0001a66:	83 c4 10             	add    $0x10,%esp
	term->row = VGA_HEIGHT-1;
c0001a69:	c7 03 18 00 00 00    	movl   $0x18,(%ebx)
c0001a6f:	c1 e2 08             	shl    $0x8,%edx
c0001a72:	8d 81 00 0f 00 00    	lea    0xf00(%ecx),%eax
c0001a78:	81 c1 a0 0f 00 00    	add    $0xfa0,%ecx
c0001a7e:	83 ca 20             	or     $0x20,%edx
c0001a81:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001a88:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001a8f:	90                   	nop
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001a90:	66 89 10             	mov    %dx,(%eax)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c0001a93:	83 c0 02             	add    $0x2,%eax
c0001a96:	39 c8                	cmp    %ecx,%eax
c0001a98:	75 f6                	jne    c0001a90 <terminal_write+0x150>
c0001a9a:	e9 d4 fe ff ff       	jmp    c0001973 <terminal_write+0x33>
c0001a9f:	90                   	nop

c0001aa0 <terminal_writestring>:
 
void terminal_writestring(struct terminal* term, const char* data) 
{
c0001aa0:	55                   	push   %ebp
c0001aa1:	89 e5                	mov    %esp,%ebp
c0001aa3:	57                   	push   %edi
c0001aa4:	56                   	push   %esi
c0001aa5:	53                   	push   %ebx
c0001aa6:	83 ec 28             	sub    $0x28,%esp
c0001aa9:	8b 7d 0c             	mov    0xc(%ebp),%edi
c0001aac:	8b 5d 08             	mov    0x8(%ebp),%ebx
	terminal_write(term, data, strlen(data));
c0001aaf:	57                   	push   %edi
c0001ab0:	e8 4b f7 ff ff       	call   c0001200 <strlen>
	for (size_t i = 0; i < size; i++)
c0001ab5:	83 c4 10             	add    $0x10,%esp
c0001ab8:	8d 14 07             	lea    (%edi,%eax,1),%edx
c0001abb:	89 55 dc             	mov    %edx,-0x24(%ebp)
c0001abe:	85 c0                	test   %eax,%eax
c0001ac0:	75 1d                	jne    c0001adf <terminal_writestring+0x3f>
c0001ac2:	e9 bf 00 00 00       	jmp    c0001b86 <terminal_writestring+0xe6>
c0001ac7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001ace:	66 90                	xchg   %ax,%ax
	if (++term->column == VGA_WIDTH)
c0001ad0:	89 43 04             	mov    %eax,0x4(%ebx)
	for (size_t i = 0; i < size; i++)
c0001ad3:	83 c7 01             	add    $0x1,%edi
c0001ad6:	3b 7d dc             	cmp    -0x24(%ebp),%edi
c0001ad9:	0f 84 a7 00 00 00    	je     c0001b86 <terminal_writestring+0xe6>
    if (++term->row == VGA_HEIGHT)
c0001adf:	8b 0b                	mov    (%ebx),%ecx
		terminal_putchar(term, data[i]);
c0001ae1:	0f b6 07             	movzbl (%edi),%eax
    if (++term->row == VGA_HEIGHT)
c0001ae4:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	if(c == '\n')
c0001ae7:	3c 0a                	cmp    $0xa,%al
c0001ae9:	0f 84 a1 00 00 00    	je     c0001b90 <terminal_writestring+0xf0>
	term->buffer[index] = vga_entry(c, color);
c0001aef:	8b 73 0c             	mov    0xc(%ebx),%esi
	terminal_putentryat(term, c, term->color, term->column, term->row);
c0001af2:	8b 4b 04             	mov    0x4(%ebx),%ecx
	term->buffer[index] = vga_entry(c, color);
c0001af5:	89 f2                	mov    %esi,%edx
c0001af7:	89 75 d8             	mov    %esi,-0x28(%ebp)
c0001afa:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c0001afd:	8d 34 b6             	lea    (%esi,%esi,4),%esi
c0001b00:	c1 e6 04             	shl    $0x4,%esi
c0001b03:	01 ce                	add    %ecx,%esi
c0001b05:	89 75 e0             	mov    %esi,-0x20(%ebp)
	terminal_putentryat(term, c, term->color, term->column, term->row);
c0001b08:	0f b6 73 08          	movzbl 0x8(%ebx),%esi
c0001b0c:	c1 e6 08             	shl    $0x8,%esi
c0001b0f:	09 f0                	or     %esi,%eax
c0001b11:	89 d6                	mov    %edx,%esi
c0001b13:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0001b16:	66 89 04 56          	mov    %ax,(%esi,%edx,2)
	if (++term->column == VGA_WIDTH)
c0001b1a:	8d 41 01             	lea    0x1(%ecx),%eax
c0001b1d:	83 f9 4f             	cmp    $0x4f,%ecx
c0001b20:	75 ae                	jne    c0001ad0 <terminal_writestring+0x30>
    if (++term->row == VGA_HEIGHT)
c0001b22:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    term->column = 0;
c0001b25:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    if (++term->row == VGA_HEIGHT)
c0001b2c:	83 c2 01             	add    $0x1,%edx
c0001b2f:	89 13                	mov    %edx,(%ebx)
c0001b31:	83 fa 19             	cmp    $0x19,%edx
c0001b34:	75 9d                	jne    c0001ad3 <terminal_writestring+0x33>
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c0001b36:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0001b39:	83 ec 04             	sub    $0x4,%esp
c0001b3c:	68 00 0f 00 00       	push   $0xf00
c0001b41:	8d 82 a0 00 00 00    	lea    0xa0(%edx),%eax
c0001b47:	50                   	push   %eax
c0001b48:	52                   	push   %edx
c0001b49:	e8 d2 f6 ff ff       	call   c0001220 <memcpy>
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001b4e:	0f b6 53 08          	movzbl 0x8(%ebx),%edx
c0001b52:	8b 4b 0c             	mov    0xc(%ebx),%ecx
c0001b55:	83 c4 10             	add    $0x10,%esp
	term->row = VGA_HEIGHT-1;
c0001b58:	c7 03 18 00 00 00    	movl   $0x18,(%ebx)
c0001b5e:	c1 e2 08             	shl    $0x8,%edx
c0001b61:	8d 81 00 0f 00 00    	lea    0xf00(%ecx),%eax
c0001b67:	81 c1 a0 0f 00 00    	add    $0xfa0,%ecx
c0001b6d:	83 ca 20             	or     $0x20,%edx
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001b70:	66 89 10             	mov    %dx,(%eax)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c0001b73:	83 c0 02             	add    $0x2,%eax
c0001b76:	39 c8                	cmp    %ecx,%eax
c0001b78:	75 f6                	jne    c0001b70 <terminal_writestring+0xd0>
	for (size_t i = 0; i < size; i++)
c0001b7a:	83 c7 01             	add    $0x1,%edi
c0001b7d:	3b 7d dc             	cmp    -0x24(%ebp),%edi
c0001b80:	0f 85 59 ff ff ff    	jne    c0001adf <terminal_writestring+0x3f>
}
c0001b86:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0001b89:	5b                   	pop    %ebx
c0001b8a:	5e                   	pop    %esi
c0001b8b:	5f                   	pop    %edi
c0001b8c:	5d                   	pop    %ebp
c0001b8d:	c3                   	ret    
c0001b8e:	66 90                	xchg   %ax,%ax
    if (++term->row == VGA_HEIGHT)
c0001b90:	89 ca                	mov    %ecx,%edx
    term->column = 0;
c0001b92:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    if (++term->row == VGA_HEIGHT)
c0001b99:	83 c2 01             	add    $0x1,%edx
c0001b9c:	89 13                	mov    %edx,(%ebx)
c0001b9e:	83 fa 19             	cmp    $0x19,%edx
c0001ba1:	0f 85 2c ff ff ff    	jne    c0001ad3 <terminal_writestring+0x33>
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c0001ba7:	8b 43 0c             	mov    0xc(%ebx),%eax
c0001baa:	83 ec 04             	sub    $0x4,%esp
c0001bad:	68 00 0f 00 00       	push   $0xf00
c0001bb2:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c0001bb8:	52                   	push   %edx
c0001bb9:	50                   	push   %eax
c0001bba:	e8 61 f6 ff ff       	call   c0001220 <memcpy>
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001bbf:	0f b6 53 08          	movzbl 0x8(%ebx),%edx
c0001bc3:	8b 4b 0c             	mov    0xc(%ebx),%ecx
c0001bc6:	83 c4 10             	add    $0x10,%esp
	term->row = VGA_HEIGHT-1;
c0001bc9:	c7 03 18 00 00 00    	movl   $0x18,(%ebx)
c0001bcf:	c1 e2 08             	shl    $0x8,%edx
c0001bd2:	8d 81 00 0f 00 00    	lea    0xf00(%ecx),%eax
c0001bd8:	81 c1 a0 0f 00 00    	add    $0xfa0,%ecx
c0001bde:	83 ca 20             	or     $0x20,%edx
c0001be1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001be8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001bef:	90                   	nop
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0001bf0:	66 89 10             	mov    %dx,(%eax)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c0001bf3:	83 c0 02             	add    $0x2,%eax
c0001bf6:	39 c8                	cmp    %ecx,%eax
c0001bf8:	75 f6                	jne    c0001bf0 <terminal_writestring+0x150>
c0001bfa:	e9 d4 fe ff ff       	jmp    c0001ad3 <terminal_writestring+0x33>
c0001bff:	90                   	nop

c0001c00 <get_table>:

page_directory_virt_t* pd = (page_directory_virt_t*) PD_ADDR;

// return page directory index for virtual address
page_table_t* get_table(void* addr)
{
c0001c00:	55                   	push   %ebp
    uint32_t idx = get_pdindex(addr);
    if(pd->dir.pde[idx] & PAGE_FLAG_PRESENT)
c0001c01:	8b 0d 00 40 00 c0    	mov    0xc0004000,%ecx
{
c0001c07:	89 e5                	mov    %esp,%ebp
}

// return page directory index for virtual address
inline uint32_t get_pdindex(void* addr)
{
    return ((uint32_t) addr) >> 22;
c0001c09:	8b 55 08             	mov    0x8(%ebp),%edx
        return pd->tables + get_pdindex(addr);
    else 
        return NULL;
}
c0001c0c:	5d                   	pop    %ebp
c0001c0d:	c1 ea 16             	shr    $0x16,%edx
        return pd->tables + get_pdindex(addr);
c0001c10:	89 d0                	mov    %edx,%eax
c0001c12:	c1 e0 0c             	shl    $0xc,%eax
c0001c15:	01 c8                	add    %ecx,%eax
c0001c17:	f6 84 91 00 f0 3f 00 	testb  $0x1,0x3ff000(%ecx,%edx,4)
c0001c1e:	01 
c0001c1f:	ba 00 00 00 00       	mov    $0x0,%edx
c0001c24:	0f 44 c2             	cmove  %edx,%eax
}
c0001c27:	c3                   	ret    
c0001c28:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001c2f:	90                   	nop

c0001c30 <get_physaddr>:

// return physical addr from virt addr
char* get_physaddr(char* addr)
{
c0001c30:	55                   	push   %ebp
c0001c31:	89 e5                	mov    %esp,%ebp
c0001c33:	53                   	push   %ebx
    //check pd entry is present
    uint32_t pdi = get_pdindex(addr);
    if(! pd->dir.pde[pdi] & PAGE_FLAG_PRESENT)
c0001c34:	8b 1d 00 40 00 c0    	mov    0xc0004000,%ebx
{
c0001c3a:	8b 55 08             	mov    0x8(%ebp),%edx
c0001c3d:	89 d0                	mov    %edx,%eax
c0001c3f:	c1 e8 16             	shr    $0x16,%eax
    if(! pd->dir.pde[pdi] & PAGE_FLAG_PRESENT)
c0001c42:	8b 8c 83 00 f0 3f 00 	mov    0x3ff000(%ebx,%eax,4),%ecx
c0001c49:	85 c9                	test   %ecx,%ecx
c0001c4b:	74 33                	je     c0001c80 <get_physaddr+0x50>
    return (((uint32_t) addr) & PAGE_PTE_MASK ) >> 12;
c0001c4d:	89 d1                	mov    %edx,%ecx
        return NULL;

    //check pt entry is present
    uint32_t pte = pd->tables[pdi].pte[get_ptindex(addr)];
c0001c4f:	c1 e0 0a             	shl    $0xa,%eax
c0001c52:	c1 e9 0c             	shr    $0xc,%ecx
c0001c55:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
c0001c5b:	01 c8                	add    %ecx,%eax
c0001c5d:	8b 04 83             	mov    (%ebx,%eax,4),%eax
    if(! pte & PAGE_FLAG_PRESENT)
c0001c60:	85 c0                	test   %eax,%eax
c0001c62:	74 1c                	je     c0001c80 <get_physaddr+0x50>
        return NULL;

    return (char*) ((pte & PAGE_ADDRMASK) +  get_page_offset(addr) );
c0001c64:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}

// return offset into page
inline uint32_t get_page_offset(void* addr)
{
    return ((uint32_t) addr) & ~PAGE_ADDRMASK;
c0001c69:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
}
c0001c6f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0001c72:	c9                   	leave  
    return (char*) ((pte & PAGE_ADDRMASK) +  get_page_offset(addr) );
c0001c73:	09 d0                	or     %edx,%eax
}
c0001c75:	c3                   	ret    
c0001c76:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001c7d:	8d 76 00             	lea    0x0(%esi),%esi
c0001c80:	8b 5d fc             	mov    -0x4(%ebp),%ebx
        return NULL;
c0001c83:	31 c0                	xor    %eax,%eax
}
c0001c85:	c9                   	leave  
c0001c86:	c3                   	ret    
c0001c87:	66 90                	xchg   %ax,%ax
c0001c89:	66 90                	xchg   %ax,%ax
c0001c8b:	66 90                	xchg   %ax,%ax
c0001c8d:	66 90                	xchg   %ax,%ax
c0001c8f:	90                   	nop

c0001c90 <unmap_lowmem>:

    return 0;
}

int unmap_lowmem()
{
c0001c90:	55                   	push   %ebp
c0001c91:	89 e5                	mov    %esp,%ebp
c0001c93:	83 ec 08             	sub    $0x8,%esp
    pd->dir.pde[0] = PAGE_FLAG_EMPTY;
c0001c96:	a1 00 40 00 c0       	mov    0xc0004000,%eax
c0001c9b:	c7 80 00 f0 3f 00 00 	movl   $0x0,0x3ff000(%eax)
c0001ca2:	00 00 00 
    refresh_tlb();
c0001ca5:	e8 fe 07 00 00       	call   c00024a8 <refresh_tlb>
    return 0;
}
c0001caa:	31 c0                	xor    %eax,%eax
c0001cac:	c9                   	leave  
c0001cad:	c3                   	ret    
c0001cae:	66 90                	xchg   %ax,%ax

c0001cb0 <get_big_block>:
    return heap;
}


size_t get_big_block(multiboot_info_t* mbd, void** block)
{
c0001cb0:	55                   	push   %ebp
c0001cb1:	89 e5                	mov    %esp,%ebp
c0001cb3:	57                   	push   %edi
c0001cb4:	56                   	push   %esi
c0001cb5:	53                   	push   %ebx
c0001cb6:	83 ec 0c             	sub    $0xc,%esp
c0001cb9:	8b 55 08             	mov    0x8(%ebp),%edx
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
    size_t block_size = 0;
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001cbc:	8b 4a 2c             	mov    0x2c(%edx),%ecx
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c0001cbf:	8b 42 30             	mov    0x30(%edx),%eax
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001cc2:	89 4d ec             	mov    %ecx,-0x14(%ebp)
c0001cc5:	85 c9                	test   %ecx,%ecx
c0001cc7:	74 53                	je     c0001d1c <get_big_block+0x6c>
c0001cc9:	31 d2                	xor    %edx,%edx
    size_t block_size = 0;
c0001ccb:	31 f6                	xor    %esi,%esi
c0001ccd:	eb 0c                	jmp    c0001cdb <get_big_block+0x2b>
c0001ccf:	90                   	nop
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001cd0:	83 c2 01             	add    $0x1,%edx
c0001cd3:	83 c0 18             	add    $0x18,%eax
c0001cd6:	3b 55 ec             	cmp    -0x14(%ebp),%edx
c0001cd9:	74 37                	je     c0001d12 <get_big_block+0x62>
	{
        if(mmap_table[nn].size == 0)
c0001cdb:	8b 38                	mov    (%eax),%edi
c0001cdd:	85 ff                	test   %edi,%edi
c0001cdf:	74 31                	je     c0001d12 <get_big_block+0x62>
            break;

		if(mmap_table[nn].len>block_size && mmap_table[nn].type == MULTIBOOT_MEMORY_AVAILABLE)
c0001ce1:	8b 78 0c             	mov    0xc(%eax),%edi
c0001ce4:	bb 00 00 00 00       	mov    $0x0,%ebx
c0001ce9:	39 fe                	cmp    %edi,%esi
c0001ceb:	1b 58 10             	sbb    0x10(%eax),%ebx
c0001cee:	73 e0                	jae    c0001cd0 <get_big_block+0x20>
c0001cf0:	83 78 14 01          	cmpl   $0x1,0x14(%eax)
c0001cf4:	75 da                	jne    c0001cd0 <get_big_block+0x20>
        {
            block_size = mmap_table[nn].len;
            if(mmap_table[nn].addr >> 32)
c0001cf6:	8b 58 08             	mov    0x8(%eax),%ebx
c0001cf9:	8b 48 04             	mov    0x4(%eax),%ecx
            block_size = mmap_table[nn].len;
c0001cfc:	89 fe                	mov    %edi,%esi
            if(mmap_table[nn].addr >> 32)
c0001cfe:	85 db                	test   %ebx,%ebx
c0001d00:	75 10                	jne    c0001d12 <get_big_block+0x62>
            {
                // ignore anything above 32bits
                break;
            }
            *block = (void*) (uint32_t) mmap_table[nn].addr;
c0001d02:	8b 7d 0c             	mov    0xc(%ebp),%edi
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001d05:	83 c2 01             	add    $0x1,%edx
c0001d08:	83 c0 18             	add    $0x18,%eax
            *block = (void*) (uint32_t) mmap_table[nn].addr;
c0001d0b:	89 0f                	mov    %ecx,(%edi)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001d0d:	3b 55 ec             	cmp    -0x14(%ebp),%edx
c0001d10:	75 c9                	jne    c0001cdb <get_big_block+0x2b>
        }
	}
    return block_size;
}
c0001d12:	83 c4 0c             	add    $0xc,%esp
c0001d15:	89 f0                	mov    %esi,%eax
c0001d17:	5b                   	pop    %ebx
c0001d18:	5e                   	pop    %esi
c0001d19:	5f                   	pop    %edi
c0001d1a:	5d                   	pop    %ebp
c0001d1b:	c3                   	ret    
    size_t block_size = 0;
c0001d1c:	31 f6                	xor    %esi,%esi
    return block_size;
c0001d1e:	eb f2                	jmp    c0001d12 <get_big_block+0x62>

c0001d20 <new_page_table>:
    refresh_page(page_virt);
    return page_virt;
}

page_table_t* new_page_table(void* addr, uint32_t flags)
{
c0001d20:	55                   	push   %ebp
c0001d21:	89 e5                	mov    %esp,%ebp
c0001d23:	53                   	push   %ebx
c0001d24:	83 ec 04             	sub    $0x4,%esp
    return ((uint32_t) addr) >> 22;
c0001d27:	8b 5d 08             	mov    0x8(%ebp),%ebx
    uint32_t pdindex = get_pdindex(addr);      // index into page dir (which table does this address point to)

    // is this table already mapped?
    if(pd->dir.pde[pdindex] & PAGE_FLAG_PRESENT)
c0001d2a:	8b 15 00 40 00 c0    	mov    0xc0004000,%edx
c0001d30:	c1 eb 16             	shr    $0x16,%ebx
c0001d33:	f6 84 9a 00 f0 3f 00 	testb  $0x1,0x3ff000(%edx,%ebx,4)
c0001d3a:	01 
c0001d3b:	75 73                	jne    c0001db0 <new_page_table+0x90>

// return next available physical page from the heap and updates the heap_page_phys pointer
// returns NULL on OOM
page_t* get_next_heap_page_phys()
{
    if( (uint32_t) (heap_page_phys+1) > (uint32_t) heap_end_phys)
c0001d3d:	a1 1c b0 00 c0       	mov    0xc000b01c,%eax
c0001d42:	05 00 10 00 00       	add    $0x1000,%eax
c0001d47:	39 05 10 b0 00 c0    	cmp    %eax,0xc000b010
c0001d4d:	72 61                	jb     c0001db0 <new_page_table+0x90>
c0001d4f:	8d 8b 00 fc 0f 00    	lea    0xffc00(%ebx),%ecx
    {
        //out of memory
        return NULL;
    }
    return ++heap_page_phys;
c0001d55:	a3 1c b0 00 c0       	mov    %eax,0xc000b01c
    page_table_t* pv = pd->tables + pdindex;        // pointer to table (virtual)
c0001d5a:	c1 e3 0c             	shl    $0xc,%ebx
    refresh_page(pv);
c0001d5d:	83 ec 0c             	sub    $0xc,%esp
    pd->dir.pde[pdindex] = (((uint32_t) pp) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0001d60:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0001d65:	0b 45 0c             	or     0xc(%ebp),%eax
    page_table_t* pv = pd->tables + pdindex;        // pointer to table (virtual)
c0001d68:	01 d3                	add    %edx,%ebx
    pd->dir.pde[pdindex] = (((uint32_t) pp) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0001d6a:	83 c8 01             	or     $0x1,%eax
c0001d6d:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
    refresh_page(pv);
c0001d70:	53                   	push   %ebx
c0001d71:	e8 3a 07 00 00       	call   c00024b0 <refresh_page>
    for(size_t nn=0;nn<cnt; nn++)
c0001d76:	89 d8                	mov    %ebx,%eax
c0001d78:	8d 93 00 10 00 00    	lea    0x1000(%ebx),%edx
c0001d7e:	83 c4 10             	add    $0x10,%esp
c0001d81:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001d88:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001d8f:	90                   	nop
        m[nn] = val;
c0001d90:	c6 00 00             	movb   $0x0,(%eax)
    for(size_t nn=0;nn<cnt; nn++)
c0001d93:	83 c0 01             	add    $0x1,%eax
c0001d96:	39 d0                	cmp    %edx,%eax
c0001d98:	75 f6                	jne    c0001d90 <new_page_table+0x70>
}
c0001d9a:	89 d8                	mov    %ebx,%eax
c0001d9c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0001d9f:	c9                   	leave  
c0001da0:	c3                   	ret    
c0001da1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001da8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001daf:	90                   	nop
        return NULL;
c0001db0:	31 db                	xor    %ebx,%ebx
}
c0001db2:	89 d8                	mov    %ebx,%eax
c0001db4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0001db7:	c9                   	leave  
c0001db8:	c3                   	ret    
c0001db9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

c0001dc0 <map_page_at>:
{
c0001dc0:	55                   	push   %ebp
c0001dc1:	89 e5                	mov    %esp,%ebp
c0001dc3:	53                   	push   %ebx
c0001dc4:	83 ec 10             	sub    $0x10,%esp
c0001dc7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    page_table_t* pt = get_table(page_virt);
c0001dca:	53                   	push   %ebx
c0001dcb:	e8 30 fe ff ff       	call   c0001c00 <get_table>
    if(!pt)
c0001dd0:	83 c4 10             	add    $0x10,%esp
c0001dd3:	85 c0                	test   %eax,%eax
c0001dd5:	74 49                	je     c0001e20 <map_page_at+0x60>
    return (((uint32_t) addr) & PAGE_PTE_MASK ) >> 12;
c0001dd7:	89 d9                	mov    %ebx,%ecx
        return NULL; //page already mapped
c0001dd9:	31 d2                	xor    %edx,%edx
c0001ddb:	c1 e9 0c             	shr    $0xc,%ecx
c0001dde:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
    if(pt->pte[get_ptindex(page_virt)] & PAGE_FLAG_PRESENT)
c0001de4:	f6 04 88 01          	testb  $0x1,(%eax,%ecx,4)
c0001de8:	75 20                	jne    c0001e0a <map_page_at+0x4a>
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0001dea:	8b 55 0c             	mov    0xc(%ebp),%edx
    refresh_page(page_virt);
c0001ded:	83 ec 0c             	sub    $0xc,%esp
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0001df0:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c0001df6:	0b 55 10             	or     0x10(%ebp),%edx
c0001df9:	83 ca 01             	or     $0x1,%edx
c0001dfc:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    refresh_page(page_virt);
c0001dff:	53                   	push   %ebx
c0001e00:	e8 ab 06 00 00       	call   c00024b0 <refresh_page>
    return page_virt;
c0001e05:	83 c4 10             	add    $0x10,%esp
c0001e08:	89 da                	mov    %ebx,%edx
}
c0001e0a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0001e0d:	89 d0                	mov    %edx,%eax
c0001e0f:	c9                   	leave  
c0001e10:	c3                   	ret    
c0001e11:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001e18:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001e1f:	90                   	nop
        pt = new_page_table(page_virt, flags); // page table is not present, allocate a new one
c0001e20:	83 ec 08             	sub    $0x8,%esp
c0001e23:	ff 75 10             	pushl  0x10(%ebp)
c0001e26:	53                   	push   %ebx
c0001e27:	e8 f4 fe ff ff       	call   c0001d20 <new_page_table>
c0001e2c:	83 c4 10             	add    $0x10,%esp
c0001e2f:	eb a6                	jmp    c0001dd7 <map_page_at+0x17>
c0001e31:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001e38:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0001e3f:	90                   	nop

c0001e40 <heap_init>:
{
c0001e40:	55                   	push   %ebp
c0001e41:	89 e5                	mov    %esp,%ebp
c0001e43:	83 ec 18             	sub    $0x18,%esp
	size_t free_mem_size = get_big_block(mbd, (void**) &heap_phys);
c0001e46:	8d 45 f4             	lea    -0xc(%ebp),%eax
c0001e49:	50                   	push   %eax
c0001e4a:	ff 75 08             	pushl  0x8(%ebp)
c0001e4d:	e8 5e fe ff ff       	call   c0001cb0 <get_big_block>
	if(&_kernel_end_phys >= heap_phys && &_kernel_end_phys < heap_end_phys)
c0001e52:	83 c4 08             	add    $0x8,%esp
	size_t free_mem_size = get_big_block(mbd, (void**) &heap_phys);
c0001e55:	89 c2                	mov    %eax,%edx
	heap_end_phys = heap_phys+free_mem_size;
c0001e57:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001e5a:	01 c2                	add    %eax,%edx
c0001e5c:	89 15 10 b0 00 c0    	mov    %edx,0xc000b010
	if(&_kernel_end_phys >= heap_phys && &_kernel_end_phys < heap_end_phys)
c0001e62:	81 fa 24 c0 10 00    	cmp    $0x10c024,%edx
c0001e68:	76 0d                	jbe    c0001e77 <heap_init+0x37>
c0001e6a:	3d 24 c0 10 00       	cmp    $0x10c024,%eax
c0001e6f:	b9 24 c0 10 00       	mov    $0x10c024,%ecx
c0001e74:	0f 46 c1             	cmovbe %ecx,%eax
void* memset(void* addr, int val, size_t cnt);

inline void* align_addr(void* addr, uint32_t alignment)
{
    uint32_t am = alignment - 1;
    return (char*) (((uint32_t)addr + am) & ~am);
c0001e77:	05 ff 0f 00 00       	add    $0xfff,%eax
	kprintf("\nPhysical heap: 0x%.8x - 0x%.8x (%u MiB)\n", heap_phys, heap_end_phys,  (uint32_t) (heap_end_phys-heap_phys) >> 20);
c0001e7c:	89 d1                	mov    %edx,%ecx
    heap_page = (page_t*) align_addr((void*) KERNEL_HEAP, PAGE_SIZE);
c0001e7e:	c7 05 20 b0 00 c0 00 	movl   $0x400000,0xc000b020
c0001e85:	00 40 00 
    heap = (char*) heap_page;
c0001e88:	c7 05 18 b0 00 c0 00 	movl   $0x400000,0xc000b018
c0001e8f:	00 40 00 
c0001e92:	25 00 f0 ff ff       	and    $0xfffff000,%eax
	kprintf("\nPhysical heap: 0x%.8x - 0x%.8x (%u MiB)\n", heap_phys, heap_end_phys,  (uint32_t) (heap_end_phys-heap_phys) >> 20);
c0001e97:	29 c1                	sub    %eax,%ecx
    heap_phys = (char*) heap_page_phys;
c0001e99:	89 45 f4             	mov    %eax,-0xc(%ebp)
	kprintf("\nPhysical heap: 0x%.8x - 0x%.8x (%u MiB)\n", heap_phys, heap_end_phys,  (uint32_t) (heap_end_phys-heap_phys) >> 20);
c0001e9c:	c1 e9 14             	shr    $0x14,%ecx
    heap_page_phys = (page_t*) align_addr((void*) heap_phys, PAGE_SIZE);
c0001e9f:	a3 1c b0 00 c0       	mov    %eax,0xc000b01c
	kprintf("\nPhysical heap: 0x%.8x - 0x%.8x (%u MiB)\n", heap_phys, heap_end_phys,  (uint32_t) (heap_end_phys-heap_phys) >> 20);
c0001ea4:	51                   	push   %ecx
c0001ea5:	52                   	push   %edx
c0001ea6:	50                   	push   %eax
c0001ea7:	68 ac 34 00 c0       	push   $0xc00034ac
    heap_end = (char*) KERNEL_BASE;
c0001eac:	c7 05 14 b0 00 c0 00 	movl   $0xc0000000,0xc000b014
c0001eb3:	00 00 c0 
	kprintf("\nPhysical heap: 0x%.8x - 0x%.8x (%u MiB)\n", heap_phys, heap_end_phys,  (uint32_t) (heap_end_phys-heap_phys) >> 20);
c0001eb6:	e8 d5 e2 ff ff       	call   c0000190 <kprintf>
	kprintf("Virtual heap: 0x%.8x - 0x%.8x (%u MiB)\n\n", heap, heap_end,  (uint32_t) (heap_end-heap) >> 20);
c0001ebb:	8b 0d 14 b0 00 c0    	mov    0xc000b014,%ecx
c0001ec1:	8b 15 18 b0 00 c0    	mov    0xc000b018,%edx
c0001ec7:	89 c8                	mov    %ecx,%eax
c0001ec9:	29 d0                	sub    %edx,%eax
c0001ecb:	c1 e8 14             	shr    $0x14,%eax
c0001ece:	50                   	push   %eax
c0001ecf:	51                   	push   %ecx
c0001ed0:	52                   	push   %edx
c0001ed1:	68 d8 34 00 c0       	push   $0xc00034d8
c0001ed6:	e8 b5 e2 ff ff       	call   c0000190 <kprintf>
    if(!map_page_at(heap_page, heap_page_phys, PAGE_FLAG_WRITE))
c0001edb:	83 c4 1c             	add    $0x1c,%esp
c0001ede:	6a 02                	push   $0x2
c0001ee0:	ff 35 1c b0 00 c0    	pushl  0xc000b01c
c0001ee6:	ff 35 20 b0 00 c0    	pushl  0xc000b020
c0001eec:	e8 cf fe ff ff       	call   c0001dc0 <map_page_at>
c0001ef1:	83 c4 10             	add    $0x10,%esp
    return heap;
c0001ef4:	85 c0                	test   %eax,%eax
c0001ef6:	0f 45 05 18 b0 00 c0 	cmovne 0xc000b018,%eax
}
c0001efd:	c9                   	leave  
c0001efe:	c3                   	ret    
c0001eff:	90                   	nop

c0001f00 <map_vga>:
{
c0001f00:	55                   	push   %ebp
c0001f01:	89 e5                	mov    %esp,%ebp
c0001f03:	83 ec 14             	sub    $0x14,%esp
    page_table_t* pt = get_table(page_virt);
c0001f06:	68 00 80 0b 00       	push   $0xb8000
c0001f0b:	e8 f0 fc ff ff       	call   c0001c00 <get_table>
    if(!pt)
c0001f10:	83 c4 10             	add    $0x10,%esp
c0001f13:	85 c0                	test   %eax,%eax
c0001f15:	0f 84 95 01 00 00    	je     c00020b0 <map_vga+0x1b0>
    if(pt->pte[get_ptindex(page_virt)] & PAGE_FLAG_PRESENT)
c0001f1b:	f6 80 e0 02 00 00 01 	testb  $0x1,0x2e0(%eax)
c0001f22:	75 1a                	jne    c0001f3e <map_vga+0x3e>
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0001f24:	c7 80 e0 02 00 00 07 	movl   $0xb8007,0x2e0(%eax)
c0001f2b:	80 0b 00 
    refresh_page(page_virt);
c0001f2e:	83 ec 0c             	sub    $0xc,%esp
c0001f31:	68 00 80 0b 00       	push   $0xb8000
c0001f36:	e8 75 05 00 00       	call   c00024b0 <refresh_page>
    return page_virt;
c0001f3b:	83 c4 10             	add    $0x10,%esp
    page_table_t* pt = get_table(page_virt);
c0001f3e:	83 ec 0c             	sub    $0xc,%esp
c0001f41:	68 00 90 0b 00       	push   $0xb9000
c0001f46:	e8 b5 fc ff ff       	call   c0001c00 <get_table>
    if(!pt)
c0001f4b:	83 c4 10             	add    $0x10,%esp
c0001f4e:	85 c0                	test   %eax,%eax
c0001f50:	0f 84 7a 01 00 00    	je     c00020d0 <map_vga+0x1d0>
    if(pt->pte[get_ptindex(page_virt)] & PAGE_FLAG_PRESENT)
c0001f56:	f6 80 e4 02 00 00 01 	testb  $0x1,0x2e4(%eax)
c0001f5d:	75 1a                	jne    c0001f79 <map_vga+0x79>
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0001f5f:	c7 80 e4 02 00 00 07 	movl   $0xb9007,0x2e4(%eax)
c0001f66:	90 0b 00 
    refresh_page(page_virt);
c0001f69:	83 ec 0c             	sub    $0xc,%esp
c0001f6c:	68 00 90 0b 00       	push   $0xb9000
c0001f71:	e8 3a 05 00 00       	call   c00024b0 <refresh_page>
    return page_virt;
c0001f76:	83 c4 10             	add    $0x10,%esp
    page_table_t* pt = get_table(page_virt);
c0001f79:	83 ec 0c             	sub    $0xc,%esp
c0001f7c:	68 00 a0 0b 00       	push   $0xba000
c0001f81:	e8 7a fc ff ff       	call   c0001c00 <get_table>
    if(!pt)
c0001f86:	83 c4 10             	add    $0x10,%esp
c0001f89:	85 c0                	test   %eax,%eax
c0001f8b:	0f 84 5f 01 00 00    	je     c00020f0 <map_vga+0x1f0>
    if(pt->pte[get_ptindex(page_virt)] & PAGE_FLAG_PRESENT)
c0001f91:	f6 80 e8 02 00 00 01 	testb  $0x1,0x2e8(%eax)
c0001f98:	75 1a                	jne    c0001fb4 <map_vga+0xb4>
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0001f9a:	c7 80 e8 02 00 00 07 	movl   $0xba007,0x2e8(%eax)
c0001fa1:	a0 0b 00 
    refresh_page(page_virt);
c0001fa4:	83 ec 0c             	sub    $0xc,%esp
c0001fa7:	68 00 a0 0b 00       	push   $0xba000
c0001fac:	e8 ff 04 00 00       	call   c00024b0 <refresh_page>
    return page_virt;
c0001fb1:	83 c4 10             	add    $0x10,%esp
    page_table_t* pt = get_table(page_virt);
c0001fb4:	83 ec 0c             	sub    $0xc,%esp
c0001fb7:	68 00 b0 0b 00       	push   $0xbb000
c0001fbc:	e8 3f fc ff ff       	call   c0001c00 <get_table>
    if(!pt)
c0001fc1:	83 c4 10             	add    $0x10,%esp
c0001fc4:	85 c0                	test   %eax,%eax
c0001fc6:	0f 84 44 01 00 00    	je     c0002110 <map_vga+0x210>
    if(pt->pte[get_ptindex(page_virt)] & PAGE_FLAG_PRESENT)
c0001fcc:	f6 80 ec 02 00 00 01 	testb  $0x1,0x2ec(%eax)
c0001fd3:	75 1a                	jne    c0001fef <map_vga+0xef>
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0001fd5:	c7 80 ec 02 00 00 07 	movl   $0xbb007,0x2ec(%eax)
c0001fdc:	b0 0b 00 
    refresh_page(page_virt);
c0001fdf:	83 ec 0c             	sub    $0xc,%esp
c0001fe2:	68 00 b0 0b 00       	push   $0xbb000
c0001fe7:	e8 c4 04 00 00       	call   c00024b0 <refresh_page>
    return page_virt;
c0001fec:	83 c4 10             	add    $0x10,%esp
    page_table_t* pt = get_table(page_virt);
c0001fef:	83 ec 0c             	sub    $0xc,%esp
c0001ff2:	68 00 c0 0b 00       	push   $0xbc000
c0001ff7:	e8 04 fc ff ff       	call   c0001c00 <get_table>
    if(!pt)
c0001ffc:	83 c4 10             	add    $0x10,%esp
c0001fff:	85 c0                	test   %eax,%eax
c0002001:	0f 84 29 01 00 00    	je     c0002130 <map_vga+0x230>
    if(pt->pte[get_ptindex(page_virt)] & PAGE_FLAG_PRESENT)
c0002007:	f6 80 f0 02 00 00 01 	testb  $0x1,0x2f0(%eax)
c000200e:	75 1a                	jne    c000202a <map_vga+0x12a>
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0002010:	c7 80 f0 02 00 00 07 	movl   $0xbc007,0x2f0(%eax)
c0002017:	c0 0b 00 
    refresh_page(page_virt);
c000201a:	83 ec 0c             	sub    $0xc,%esp
c000201d:	68 00 c0 0b 00       	push   $0xbc000
c0002022:	e8 89 04 00 00       	call   c00024b0 <refresh_page>
    return page_virt;
c0002027:	83 c4 10             	add    $0x10,%esp
    page_table_t* pt = get_table(page_virt);
c000202a:	83 ec 0c             	sub    $0xc,%esp
c000202d:	68 00 d0 0b 00       	push   $0xbd000
c0002032:	e8 c9 fb ff ff       	call   c0001c00 <get_table>
    if(!pt)
c0002037:	83 c4 10             	add    $0x10,%esp
c000203a:	85 c0                	test   %eax,%eax
c000203c:	0f 84 0e 01 00 00    	je     c0002150 <map_vga+0x250>
    if(pt->pte[get_ptindex(page_virt)] & PAGE_FLAG_PRESENT)
c0002042:	f6 80 f4 02 00 00 01 	testb  $0x1,0x2f4(%eax)
c0002049:	75 1a                	jne    c0002065 <map_vga+0x165>
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c000204b:	c7 80 f4 02 00 00 07 	movl   $0xbd007,0x2f4(%eax)
c0002052:	d0 0b 00 
    refresh_page(page_virt);
c0002055:	83 ec 0c             	sub    $0xc,%esp
c0002058:	68 00 d0 0b 00       	push   $0xbd000
c000205d:	e8 4e 04 00 00       	call   c00024b0 <refresh_page>
    return page_virt;
c0002062:	83 c4 10             	add    $0x10,%esp
    page_table_t* pt = get_table(page_virt);
c0002065:	83 ec 0c             	sub    $0xc,%esp
c0002068:	68 00 e0 0b 00       	push   $0xbe000
c000206d:	e8 8e fb ff ff       	call   c0001c00 <get_table>
    if(!pt)
c0002072:	83 c4 10             	add    $0x10,%esp
c0002075:	85 c0                	test   %eax,%eax
c0002077:	0f 84 f3 00 00 00    	je     c0002170 <map_vga+0x270>
    if(pt->pte[get_ptindex(page_virt)] & PAGE_FLAG_PRESENT)
c000207d:	f6 80 f8 02 00 00 01 	testb  $0x1,0x2f8(%eax)
c0002084:	75 1a                	jne    c00020a0 <map_vga+0x1a0>
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0002086:	c7 80 f8 02 00 00 07 	movl   $0xbe007,0x2f8(%eax)
c000208d:	e0 0b 00 
    refresh_page(page_virt);
c0002090:	83 ec 0c             	sub    $0xc,%esp
c0002093:	68 00 e0 0b 00       	push   $0xbe000
c0002098:	e8 13 04 00 00       	call   c00024b0 <refresh_page>
    return page_virt;
c000209d:	83 c4 10             	add    $0x10,%esp
}
c00020a0:	c9                   	leave  
c00020a1:	b8 00 80 0b 00       	mov    $0xb8000,%eax
c00020a6:	c3                   	ret    
c00020a7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00020ae:	66 90                	xchg   %ax,%ax
        pt = new_page_table(page_virt, flags); // page table is not present, allocate a new one
c00020b0:	83 ec 08             	sub    $0x8,%esp
c00020b3:	6a 06                	push   $0x6
c00020b5:	68 00 80 0b 00       	push   $0xb8000
c00020ba:	e8 61 fc ff ff       	call   c0001d20 <new_page_table>
c00020bf:	83 c4 10             	add    $0x10,%esp
c00020c2:	e9 54 fe ff ff       	jmp    c0001f1b <map_vga+0x1b>
c00020c7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00020ce:	66 90                	xchg   %ax,%ax
c00020d0:	83 ec 08             	sub    $0x8,%esp
c00020d3:	6a 06                	push   $0x6
c00020d5:	68 00 90 0b 00       	push   $0xb9000
c00020da:	e8 41 fc ff ff       	call   c0001d20 <new_page_table>
c00020df:	83 c4 10             	add    $0x10,%esp
c00020e2:	e9 6f fe ff ff       	jmp    c0001f56 <map_vga+0x56>
c00020e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00020ee:	66 90                	xchg   %ax,%ax
c00020f0:	83 ec 08             	sub    $0x8,%esp
c00020f3:	6a 06                	push   $0x6
c00020f5:	68 00 a0 0b 00       	push   $0xba000
c00020fa:	e8 21 fc ff ff       	call   c0001d20 <new_page_table>
c00020ff:	83 c4 10             	add    $0x10,%esp
c0002102:	e9 8a fe ff ff       	jmp    c0001f91 <map_vga+0x91>
c0002107:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000210e:	66 90                	xchg   %ax,%ax
c0002110:	83 ec 08             	sub    $0x8,%esp
c0002113:	6a 06                	push   $0x6
c0002115:	68 00 b0 0b 00       	push   $0xbb000
c000211a:	e8 01 fc ff ff       	call   c0001d20 <new_page_table>
c000211f:	83 c4 10             	add    $0x10,%esp
c0002122:	e9 a5 fe ff ff       	jmp    c0001fcc <map_vga+0xcc>
c0002127:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000212e:	66 90                	xchg   %ax,%ax
c0002130:	83 ec 08             	sub    $0x8,%esp
c0002133:	6a 06                	push   $0x6
c0002135:	68 00 c0 0b 00       	push   $0xbc000
c000213a:	e8 e1 fb ff ff       	call   c0001d20 <new_page_table>
c000213f:	83 c4 10             	add    $0x10,%esp
c0002142:	e9 c0 fe ff ff       	jmp    c0002007 <map_vga+0x107>
c0002147:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000214e:	66 90                	xchg   %ax,%ax
c0002150:	83 ec 08             	sub    $0x8,%esp
c0002153:	6a 06                	push   $0x6
c0002155:	68 00 d0 0b 00       	push   $0xbd000
c000215a:	e8 c1 fb ff ff       	call   c0001d20 <new_page_table>
c000215f:	83 c4 10             	add    $0x10,%esp
c0002162:	e9 db fe ff ff       	jmp    c0002042 <map_vga+0x142>
c0002167:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000216e:	66 90                	xchg   %ax,%ax
c0002170:	83 ec 08             	sub    $0x8,%esp
c0002173:	6a 06                	push   $0x6
c0002175:	68 00 e0 0b 00       	push   $0xbe000
c000217a:	e8 a1 fb ff ff       	call   c0001d20 <new_page_table>
c000217f:	83 c4 10             	add    $0x10,%esp
c0002182:	e9 f6 fe ff ff       	jmp    c000207d <map_vga+0x17d>
c0002187:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000218e:	66 90                	xchg   %ax,%ax

c0002190 <memory_init>:
{
c0002190:	55                   	push   %ebp
c0002191:	89 e5                	mov    %esp,%ebp
c0002193:	83 ec 14             	sub    $0x14,%esp
	if(! heap_init(mbd) )
c0002196:	ff 75 08             	pushl  0x8(%ebp)
c0002199:	e8 a2 fc ff ff       	call   c0001e40 <heap_init>
c000219e:	83 c4 10             	add    $0x10,%esp
c00021a1:	85 c0                	test   %eax,%eax
c00021a3:	74 25                	je     c00021ca <memory_init+0x3a>
    pd->dir.pde[0] = PAGE_FLAG_EMPTY;
c00021a5:	a1 00 40 00 c0       	mov    0xc0004000,%eax
c00021aa:	c7 80 00 f0 3f 00 00 	movl   $0x0,0x3ff000(%eax)
c00021b1:	00 00 00 
    refresh_tlb();
c00021b4:	e8 ef 02 00 00       	call   c00024a8 <refresh_tlb>
	if(! map_vga() )
c00021b9:	e8 42 fd ff ff       	call   c0001f00 <map_vga>
}
c00021be:	c9                   	leave  
	if(! map_vga() )
c00021bf:	85 c0                	test   %eax,%eax
c00021c1:	0f 94 c0             	sete   %al
c00021c4:	0f b6 c0             	movzbl %al,%eax
c00021c7:	f7 d8                	neg    %eax
}
c00021c9:	c3                   	ret    
c00021ca:	c9                   	leave  
        return -1;
c00021cb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c00021d0:	c3                   	ret    
c00021d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00021d8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00021df:	90                   	nop

c00021e0 <kmalloc_aligned>:
{
c00021e0:	55                   	push   %ebp
c00021e1:	89 e5                	mov    %esp,%ebp
c00021e3:	57                   	push   %edi
c00021e4:	56                   	push   %esi
c00021e5:	53                   	push   %ebx
c00021e6:	83 ec 0c             	sub    $0xc,%esp
c00021e9:	8b 45 08             	mov    0x8(%ebp),%eax
c00021ec:	8b 5d 0c             	mov    0xc(%ebp),%ebx
}

inline int is_pow_of_two(uint32_t x)
{
    return (x != 0) && ((x & (x - 1)) == 0);
c00021ef:	85 c0                	test   %eax,%eax
c00021f1:	0f 84 8c 00 00 00    	je     c0002283 <kmalloc_aligned+0xa3>
c00021f7:	85 db                	test   %ebx,%ebx
c00021f9:	0f 84 84 00 00 00    	je     c0002283 <kmalloc_aligned+0xa3>
c00021ff:	8d 4b ff             	lea    -0x1(%ebx),%ecx
c0002202:	85 cb                	test   %ecx,%ebx
c0002204:	75 7d                	jne    c0002283 <kmalloc_aligned+0xa3>
    return (char*) (((uint32_t)addr + am) & ~am);
c0002206:	8b 3d 18 b0 00 c0    	mov    0xc000b018,%edi
c000220c:	f7 db                	neg    %ebx
c000220e:	89 da                	mov    %ebx,%edx
c0002210:	01 cf                	add    %ecx,%edi
c0002212:	21 df                	and    %ebx,%edi
    char* mem_end = align_addr(mem+sz, alignment); //first byte past end of allocated region
c0002214:	01 f8                	add    %edi,%eax
c0002216:	8d 1c 08             	lea    (%eax,%ecx,1),%ebx
c0002219:	21 d3                	and    %edx,%ebx
    if(mem_end > heap_end)
c000221b:	39 1d 14 b0 00 c0    	cmp    %ebx,0xc000b014
c0002221:	72 60                	jb     c0002283 <kmalloc_aligned+0xa3>
    page_t* page_end = (page_t*) (((uint32_t) mem_end - 1) & PAGE_ADDRMASK);
c0002223:	8d 73 ff             	lea    -0x1(%ebx),%esi
c0002226:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
    while(page_end > heap_page)
c000222c:	eb 24                	jmp    c0002252 <kmalloc_aligned+0x72>
c000222e:	66 90                	xchg   %ax,%ax
    return ++heap_page_phys;
c0002230:	89 15 1c b0 00 c0    	mov    %edx,0xc000b01c
// returns next available virtual page from the heap and updates the heap_page_phys pointer
// this does *not* update the heap pointer
// returns NULL on OOM
page_t* get_next_heap_page_virt()
{
    if( (uint32_t) (heap_page+1) > (uint32_t) heap_end)
c0002236:	39 c1                	cmp    %eax,%ecx
c0002238:	72 49                	jb     c0002283 <kmalloc_aligned+0xa3>
        if(!map_page_at(pv, pp, PAGE_FLAG_WRITE))
c000223a:	83 ec 04             	sub    $0x4,%esp
    {
        //out of memory
        return NULL;
    }
    return ++heap_page;
c000223d:	a3 20 b0 00 c0       	mov    %eax,0xc000b020
        if(!map_page_at(pv, pp, PAGE_FLAG_WRITE))
c0002242:	6a 02                	push   $0x2
c0002244:	52                   	push   %edx
c0002245:	50                   	push   %eax
c0002246:	e8 75 fb ff ff       	call   c0001dc0 <map_page_at>
c000224b:	83 c4 10             	add    $0x10,%esp
c000224e:	85 c0                	test   %eax,%eax
c0002250:	74 31                	je     c0002283 <kmalloc_aligned+0xa3>
    while(page_end > heap_page)
c0002252:	a1 20 b0 00 c0       	mov    0xc000b020,%eax
c0002257:	39 f0                	cmp    %esi,%eax
c0002259:	73 35                	jae    c0002290 <kmalloc_aligned+0xb0>
    if( (uint32_t) (heap_page_phys+1) > (uint32_t) heap_end_phys)
c000225b:	8b 0d 1c b0 00 c0    	mov    0xc000b01c,%ecx
    if( (uint32_t) (heap_page+1) > (uint32_t) heap_end)
c0002261:	05 00 10 00 00       	add    $0x1000,%eax
    if( (uint32_t) (heap_page_phys+1) > (uint32_t) heap_end_phys)
c0002266:	8d 91 00 10 00 00    	lea    0x1000(%ecx),%edx
    if( (uint32_t) (heap_page+1) > (uint32_t) heap_end)
c000226c:	8b 0d 14 b0 00 c0    	mov    0xc000b014,%ecx
    if( (uint32_t) (heap_page_phys+1) > (uint32_t) heap_end_phys)
c0002272:	3b 15 10 b0 00 c0    	cmp    0xc000b010,%edx
c0002278:	76 b6                	jbe    c0002230 <kmalloc_aligned+0x50>
    if( (uint32_t) (heap_page+1) > (uint32_t) heap_end)
c000227a:	39 c1                	cmp    %eax,%ecx
c000227c:	72 05                	jb     c0002283 <kmalloc_aligned+0xa3>
    return ++heap_page;
c000227e:	a3 20 b0 00 c0       	mov    %eax,0xc000b020
            return NULL; //OOM
c0002283:	31 ff                	xor    %edi,%edi
}
c0002285:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0002288:	89 f8                	mov    %edi,%eax
c000228a:	5b                   	pop    %ebx
c000228b:	5e                   	pop    %esi
c000228c:	5f                   	pop    %edi
c000228d:	5d                   	pop    %ebp
c000228e:	c3                   	ret    
c000228f:	90                   	nop
    heap = mem_end;     //update pointer to end of used heap
c0002290:	89 1d 18 b0 00 c0    	mov    %ebx,0xc000b018
    return (void*) mem;
c0002296:	eb ed                	jmp    c0002285 <kmalloc_aligned+0xa5>
c0002298:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000229f:	90                   	nop

c00022a0 <kmalloc>:
{
c00022a0:	55                   	push   %ebp
c00022a1:	89 e5                	mov    %esp,%ebp
c00022a3:	83 ec 10             	sub    $0x10,%esp
    return kmalloc_aligned(sz, 4);
c00022a6:	6a 04                	push   $0x4
c00022a8:	ff 75 08             	pushl  0x8(%ebp)
c00022ab:	e8 30 ff ff ff       	call   c00021e0 <kmalloc_aligned>
}
c00022b0:	c9                   	leave  
c00022b1:	c3                   	ret    
c00022b2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00022b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

c00022c0 <memset>:
{
c00022c0:	55                   	push   %ebp
c00022c1:	89 e5                	mov    %esp,%ebp
c00022c3:	56                   	push   %esi
c00022c4:	8b 75 10             	mov    0x10(%ebp),%esi
        m[nn] = val;
c00022c7:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
{
c00022cb:	53                   	push   %ebx
c00022cc:	8b 5d 08             	mov    0x8(%ebp),%ebx
    for(size_t nn=0;nn<cnt; nn++)
c00022cf:	8d 14 33             	lea    (%ebx,%esi,1),%edx
c00022d2:	85 f6                	test   %esi,%esi
c00022d4:	74 13                	je     c00022e9 <memset+0x29>
c00022d6:	89 d8                	mov    %ebx,%eax
c00022d8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c00022df:	90                   	nop
        m[nn] = val;
c00022e0:	88 08                	mov    %cl,(%eax)
    for(size_t nn=0;nn<cnt; nn++)
c00022e2:	83 c0 01             	add    $0x1,%eax
c00022e5:	39 d0                	cmp    %edx,%eax
c00022e7:	75 f7                	jne    c00022e0 <memset+0x20>
}
c00022e9:	89 d8                	mov    %ebx,%eax
c00022eb:	5b                   	pop    %ebx
c00022ec:	5e                   	pop    %esi
c00022ed:	5d                   	pop    %ebp
c00022ee:	c3                   	ret    
c00022ef:	90                   	nop

c00022f0 <get_next_heap_page_phys>:
    if( (uint32_t) (heap_page_phys+1) > (uint32_t) heap_end_phys)
c00022f0:	a1 1c b0 00 c0       	mov    0xc000b01c,%eax
c00022f5:	05 00 10 00 00       	add    $0x1000,%eax
c00022fa:	3b 05 10 b0 00 c0    	cmp    0xc000b010,%eax
c0002300:	77 0e                	ja     c0002310 <get_next_heap_page_phys+0x20>
    return ++heap_page_phys;
c0002302:	a3 1c b0 00 c0       	mov    %eax,0xc000b01c
c0002307:	c3                   	ret    
c0002308:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000230f:	90                   	nop
        return NULL;
c0002310:	31 c0                	xor    %eax,%eax
}
c0002312:	c3                   	ret    
c0002313:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000231a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

c0002320 <get_next_heap_page_virt>:
    if( (uint32_t) (heap_page+1) > (uint32_t) heap_end)
c0002320:	a1 20 b0 00 c0       	mov    0xc000b020,%eax
c0002325:	05 00 10 00 00       	add    $0x1000,%eax
c000232a:	3b 05 14 b0 00 c0    	cmp    0xc000b014,%eax
c0002330:	77 0e                	ja     c0002340 <get_next_heap_page_virt+0x20>
    return ++heap_page;
c0002332:	a3 20 b0 00 c0       	mov    %eax,0xc000b020
c0002337:	c3                   	ret    
c0002338:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c000233f:	90                   	nop
        return NULL;
c0002340:	31 c0                	xor    %eax,%eax
}
c0002342:	c3                   	ret    
c0002343:	66 90                	xchg   %ax,%ax
c0002345:	66 90                	xchg   %ax,%ax
c0002347:	66 90                	xchg   %ax,%ax
c0002349:	66 90                	xchg   %ax,%ax
c000234b:	66 90                	xchg   %ax,%ax
c000234d:	66 90                	xchg   %ax,%ax
c000234f:	90                   	nop

c0002350 <kernel_main>:
#if defined(__linux__)  || !defined(__i386__)
#error "This kernel requires ix86-elf cross compiler"
#endif

void kernel_main(multiboot_info_t* mbd)
{
c0002350:	55                   	push   %ebp
c0002351:	89 e5                	mov    %esp,%ebp
c0002353:	57                   	push   %edi
c0002354:	56                   	push   %esi
c0002355:	53                   	push   %ebx
c0002356:	83 ec 28             	sub    $0x28,%esp
c0002359:	8b 5d 08             	mov    0x8(%ebp),%ebx
	terminal_init(&stdout);
c000235c:	68 00 b0 00 c0       	push   $0xc000b000
c0002361:	e8 0a f2 ff ff       	call   c0001570 <terminal_init>

    // terminal_setcolor(&stdout, VGA_COLOR_WHITE);
	kprintf("Let's learn about Operating Systems!\n");
c0002366:	c7 04 24 04 35 00 c0 	movl   $0xc0003504,(%esp)
c000236d:	e8 1e de ff ff       	call   c0000190 <kprintf>
	kprintf("Jon Doane, 2020\n\n");
c0002372:	c7 04 24 b0 33 00 c0 	movl   $0xc00033b0,(%esp)
c0002379:	e8 12 de ff ff       	call   c0000190 <kprintf>

	print_memory_table(mbd);
c000237e:	89 1c 24             	mov    %ebx,(%esp)
c0002381:	e8 1a f1 ff ff       	call   c00014a0 <print_memory_table>
	memory_init(mbd);	//after this the multiboot structure is unmapped
c0002386:	89 1c 24             	mov    %ebx,(%esp)
c0002389:	e8 02 fe ff ff       	call   c0002190 <memory_init>

	kprintf("Allocate some memory on the heap...\n");
c000238e:	c7 04 24 2c 35 00 c0 	movl   $0xc000352c,(%esp)
c0002395:	e8 f6 dd ff ff       	call   c0000190 <kprintf>
	uint32_t* some_memory = kmalloc(sizeof(uint32_t)*4000);
c000239a:	c7 04 24 80 3e 00 00 	movl   $0x3e80,(%esp)
c00023a1:	e8 fa fe ff ff       	call   c00022a0 <kmalloc>
	kprintf("setting [0x%x] = 0x%x\n", some_memory + 0, 0x12345678);
c00023a6:	83 c4 0c             	add    $0xc,%esp
c00023a9:	68 78 56 34 12       	push   $0x12345678
	uint32_t* some_memory = kmalloc(sizeof(uint32_t)*4000);
c00023ae:	89 c3                	mov    %eax,%ebx
	kprintf("setting [0x%x] = 0x%x\n", some_memory + 0, 0x12345678);
c00023b0:	50                   	push   %eax
	kprintf("setting [0x%x] = 0x%x\n", some_memory + 100, 0xdeadbeef);
	kprintf("setting [0x%x] = 0x%x\n", some_memory + 3000, 0xbeefcafe);
c00023b1:	8d bb e0 2e 00 00    	lea    0x2ee0(%ebx),%edi
	kprintf("setting [0x%x] = 0x%x\n", some_memory + 3999, 0x1234abcd);
c00023b7:	8d b3 7c 3e 00 00    	lea    0x3e7c(%ebx),%esi
	kprintf("setting [0x%x] = 0x%x\n", some_memory + 0, 0x12345678);
c00023bd:	68 c2 33 00 c0       	push   $0xc00033c2
c00023c2:	e8 c9 dd ff ff       	call   c0000190 <kprintf>
	kprintf("setting [0x%x] = 0x%x\n", some_memory + 100, 0xdeadbeef);
c00023c7:	8d 93 90 01 00 00    	lea    0x190(%ebx),%edx
c00023cd:	83 c4 0c             	add    $0xc,%esp
c00023d0:	68 ef be ad de       	push   $0xdeadbeef
c00023d5:	52                   	push   %edx
c00023d6:	68 c2 33 00 c0       	push   $0xc00033c2
c00023db:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c00023de:	e8 ad dd ff ff       	call   c0000190 <kprintf>
	kprintf("setting [0x%x] = 0x%x\n", some_memory + 3000, 0xbeefcafe);
c00023e3:	83 c4 0c             	add    $0xc,%esp
c00023e6:	68 fe ca ef be       	push   $0xbeefcafe
c00023eb:	57                   	push   %edi
c00023ec:	68 c2 33 00 c0       	push   $0xc00033c2
c00023f1:	e8 9a dd ff ff       	call   c0000190 <kprintf>
	kprintf("setting [0x%x] = 0x%x\n", some_memory + 3999, 0x1234abcd);
c00023f6:	83 c4 0c             	add    $0xc,%esp
c00023f9:	68 cd ab 34 12       	push   $0x1234abcd
c00023fe:	56                   	push   %esi
c00023ff:	68 c2 33 00 c0       	push   $0xc00033c2
c0002404:	e8 87 dd ff ff       	call   c0000190 <kprintf>
	some_memory[0] = 0x12345678;
	some_memory[100] = 0xdeadbeef;
	some_memory[3000] = 0xbeefcafe;
	some_memory[3999] = 0x1234abcd;

	kprintf("check [0x%x] = 0x%x\n", some_memory + 0, some_memory[0]);
c0002409:	83 c4 0c             	add    $0xc,%esp
	some_memory[0] = 0x12345678;
c000240c:	c7 03 78 56 34 12    	movl   $0x12345678,(%ebx)
	some_memory[100] = 0xdeadbeef;
c0002412:	c7 83 90 01 00 00 ef 	movl   $0xdeadbeef,0x190(%ebx)
c0002419:	be ad de 
	some_memory[3000] = 0xbeefcafe;
c000241c:	c7 83 e0 2e 00 00 fe 	movl   $0xbeefcafe,0x2ee0(%ebx)
c0002423:	ca ef be 
	some_memory[3999] = 0x1234abcd;
c0002426:	c7 83 7c 3e 00 00 cd 	movl   $0x1234abcd,0x3e7c(%ebx)
c000242d:	ab 34 12 
	kprintf("check [0x%x] = 0x%x\n", some_memory + 0, some_memory[0]);
c0002430:	68 78 56 34 12       	push   $0x12345678
c0002435:	53                   	push   %ebx
c0002436:	68 d9 33 00 c0       	push   $0xc00033d9
c000243b:	e8 50 dd ff ff       	call   c0000190 <kprintf>
	kprintf("check [0x%x] = 0x%x\n", some_memory + 100, some_memory[100]);
c0002440:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0002443:	83 c4 0c             	add    $0xc,%esp
c0002446:	ff b3 90 01 00 00    	pushl  0x190(%ebx)
c000244c:	52                   	push   %edx
c000244d:	68 d9 33 00 c0       	push   $0xc00033d9
c0002452:	e8 39 dd ff ff       	call   c0000190 <kprintf>
	kprintf("check [0x%x] = 0x%x\n", some_memory + 3000, some_memory[3000]);
c0002457:	83 c4 0c             	add    $0xc,%esp
c000245a:	ff b3 e0 2e 00 00    	pushl  0x2ee0(%ebx)
c0002460:	57                   	push   %edi
c0002461:	68 d9 33 00 c0       	push   $0xc00033d9
c0002466:	e8 25 dd ff ff       	call   c0000190 <kprintf>
	kprintf("check [0x%x] = 0x%x\n", some_memory + 3999, some_memory[3999]);
c000246b:	83 c4 0c             	add    $0xc,%esp
c000246e:	ff b3 7c 3e 00 00    	pushl  0x3e7c(%ebx)
c0002474:	56                   	push   %esi
c0002475:	68 d9 33 00 c0       	push   $0xc00033d9
c000247a:	e8 11 dd ff ff       	call   c0000190 <kprintf>
c000247f:	83 c4 10             	add    $0x10,%esp


	while(1);
c0002482:	eb fe                	jmp    c0002482 <kernel_main+0x132>

c0002484 <enable_paging>:
c0002484:	55                   	push   %ebp
c0002485:	89 e5                	mov    %esp,%ebp
c0002487:	8b 45 08             	mov    0x8(%ebp),%eax
c000248a:	0f 22 d8             	mov    %eax,%cr3
c000248d:	0f 20 c0             	mov    %cr0,%eax
c0002490:	0d 01 00 00 80       	or     $0x80000001,%eax
c0002495:	0f 22 c0             	mov    %eax,%cr0
c0002498:	89 ec                	mov    %ebp,%esp
c000249a:	5d                   	pop    %ebp
c000249b:	c3                   	ret    

c000249c <set_page_dir>:
c000249c:	8b 44 24 08          	mov    0x8(%esp),%eax
c00024a0:	0f 22 d8             	mov    %eax,%cr3
c00024a3:	c3                   	ret    

c00024a4 <get_page_dir>:
c00024a4:	0f 20 d8             	mov    %cr3,%eax
c00024a7:	c3                   	ret    

c00024a8 <refresh_tlb>:
c00024a8:	0f 20 d8             	mov    %cr3,%eax
c00024ab:	0f 22 d8             	mov    %eax,%cr3
c00024ae:	c3                   	ret    
c00024af:	90                   	nop

c00024b0 <refresh_page>:
c00024b0:	8b 44 24 08          	mov    0x8(%esp),%eax
c00024b4:	0f 01 38             	invlpg (%eax)
c00024b7:	c3                   	ret    
