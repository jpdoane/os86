
build/kernel:     file format elf32-i386


Disassembly of section .text.boot:

00100000 <_start-0xc>:
  100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fb                   	sti    
  100009:	4f                   	dec    %edi
  10000a:	52                   	push   %edx
  10000b:	e4                   	.byte 0xe4

0010000c <_start>:
  10000c:	fa                   	cli    
  10000d:	3d 02 b0 ad 2b       	cmp    $0x2badb002,%eax
  100012:	0f 85 c1 00 00 00    	jne    1000d9 <kpanic>
  100018:	8d 25 00 e0 10 00    	lea    0x10e000,%esp
  10001e:	53                   	push   %ebx
  10001f:	8d 3d 00 e0 10 00    	lea    0x10e000,%edi
  100025:	b8 83 00 00 00       	mov    $0x83,%eax
  10002a:	89 07                	mov    %eax,(%edi)
  10002c:	0f 20 e0             	mov    %cr4,%eax
  10002f:	83 c8 10             	or     $0x10,%eax
  100032:	0f 22 e0             	mov    %eax,%cr4
  100035:	8d 35 00 f0 10 00    	lea    0x10f000,%esi
  10003b:	83 ce 03             	or     $0x3,%esi
  10003e:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  100044:	c1 e8 16             	shr    $0x16,%eax
  100047:	bb 04 00 00 00       	mov    $0x4,%ebx
  10004c:	f7 e3                	mul    %ebx
  10004e:	8d 3d 00 e0 10 00    	lea    0x10e000,%edi
  100054:	01 c7                	add    %eax,%edi
  100056:	89 37                	mov    %esi,(%edi)
  100058:	8d 1d 00 00 00 c0    	lea    0xc0000000,%ebx
  10005e:	c1 eb 0c             	shr    $0xc,%ebx
  100061:	8d 0d 48 f9 00 c0    	lea    0xc000f948,%ecx
  100067:	81 c1 ff 0f 00 00    	add    $0xfff,%ecx
  10006d:	c1 e9 0c             	shr    $0xc,%ecx
  100070:	29 d9                	sub    %ebx,%ecx
  100072:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  100078:	25 00 f0 3f 00       	and    $0x3ff000,%eax
  10007d:	c1 e8 0c             	shr    $0xc,%eax
  100080:	bb 04 00 00 00       	mov    $0x4,%ebx
  100085:	f7 e3                	mul    %ebx
  100087:	8d 3d 00 f0 10 00    	lea    0x10f000,%edi
  10008d:	01 c7                	add    %eax,%edi
  10008f:	8d 05 00 10 10 00    	lea    0x101000,%eax
  100095:	83 c8 03             	or     $0x3,%eax
  100098:	fc                   	cld    

00100099 <.nextpte>:
  100099:	ab                   	stos   %eax,%es:(%edi)
  10009a:	05 00 10 00 00       	add    $0x1000,%eax
  10009f:	e2 f8                	loop   100099 <.nextpte>
  1000a1:	8d 35 00 e0 10 00    	lea    0x10e000,%esi
  1000a7:	89 f7                	mov    %esi,%edi
  1000a9:	81 c7 fc 0f 00 00    	add    $0xffc,%edi
  1000af:	83 ce 03             	or     $0x3,%esi
  1000b2:	89 37                	mov    %esi,(%edi)
  1000b4:	5b                   	pop    %ebx

001000b5 <_enable_paging>:
  1000b5:	8d 05 00 e0 10 00    	lea    0x10e000,%eax
  1000bb:	0f 22 d8             	mov    %eax,%cr3
  1000be:	0f 20 c0             	mov    %cr0,%eax
  1000c1:	0d 00 00 01 80       	or     $0x80010000,%eax
  1000c6:	0f 22 c0             	mov    %eax,%cr0
  1000c9:	8d 25 00 d0 00 c0    	lea    0xc000d000,%esp
  1000cf:	50                   	push   %eax
  1000d0:	50                   	push   %eax
  1000d1:	50                   	push   %eax
  1000d2:	53                   	push   %ebx
  1000d3:	e8 99 25 f0 bf       	call   c0002671 <kernel_main>
  1000d8:	fa                   	cli    

001000d9 <kpanic>:
  1000d9:	f4                   	hlt    
  1000da:	eb fd                	jmp    1000d9 <kpanic>

Disassembly of section .text:

c0000000 <syscall>:
#include "terminal.h"
#include "kprintf.h"

void syscall()
{
c0000000:	55                   	push   %ebp
c0000001:	89 e5                	mov    %esp,%ebp
}
c0000003:	90                   	nop
c0000004:	5d                   	pop    %ebp
c0000005:	c3                   	ret    

c0000006 <vga_entry_color>:
	VGA_COLOR_LIGHT_BROWN = 14,
	VGA_COLOR_WHITE = 15,
};
 
static inline uint8_t vga_entry_color(enum vga_color fg, enum vga_color bg) 
{
c0000006:	55                   	push   %ebp
c0000007:	89 e5                	mov    %esp,%ebp
	return fg | bg << 4;
c0000009:	8b 45 0c             	mov    0xc(%ebp),%eax
c000000c:	c1 e0 04             	shl    $0x4,%eax
c000000f:	89 c2                	mov    %eax,%edx
c0000011:	8b 45 08             	mov    0x8(%ebp),%eax
c0000014:	09 d0                	or     %edx,%eax
}
c0000016:	5d                   	pop    %ebp
c0000017:	c3                   	ret    

c0000018 <vga_entry>:
 
static inline uint16_t vga_entry(unsigned char uc, uint8_t color) 
{
c0000018:	55                   	push   %ebp
c0000019:	89 e5                	mov    %esp,%ebp
c000001b:	83 ec 08             	sub    $0x8,%esp
c000001e:	8b 55 08             	mov    0x8(%ebp),%edx
c0000021:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000024:	88 55 fc             	mov    %dl,-0x4(%ebp)
c0000027:	88 45 f8             	mov    %al,-0x8(%ebp)
	return (uint16_t) uc | (uint16_t) color << 8;
c000002a:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c000002e:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0000032:	c1 e0 08             	shl    $0x8,%eax
c0000035:	09 d0                	or     %edx,%eax
}
c0000037:	c9                   	leave  
c0000038:	c3                   	ret    

c0000039 <outb>:
  return _v;
}

static inline void
outb (unsigned char __value, unsigned short int __port)
{
c0000039:	55                   	push   %ebp
c000003a:	89 e5                	mov    %esp,%ebp
c000003c:	83 ec 08             	sub    $0x8,%esp
c000003f:	8b 55 08             	mov    0x8(%ebp),%edx
c0000042:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000045:	88 55 fc             	mov    %dl,-0x4(%ebp)
c0000048:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
c000004c:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0000050:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
c0000054:	ee                   	out    %al,(%dx)
}
c0000055:	90                   	nop
c0000056:	c9                   	leave  
c0000057:	c3                   	ret    

c0000058 <terminal_init>:
#include "io.h"

struct terminal stdout;

void terminal_init(struct terminal* term) 
{
c0000058:	55                   	push   %ebp
c0000059:	89 e5                	mov    %esp,%ebp
c000005b:	53                   	push   %ebx
c000005c:	83 ec 10             	sub    $0x10,%esp
	term->row = 0;
c000005f:	8b 45 08             	mov    0x8(%ebp),%eax
c0000062:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	term->column = 0;
c0000068:	8b 45 08             	mov    0x8(%ebp),%eax
c000006b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	term->color = vga_entry_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
c0000072:	6a 00                	push   $0x0
c0000074:	6a 07                	push   $0x7
c0000076:	e8 8b ff ff ff       	call   c0000006 <vga_entry_color>
c000007b:	83 c4 08             	add    $0x8,%esp
c000007e:	8b 55 08             	mov    0x8(%ebp),%edx
c0000081:	88 42 08             	mov    %al,0x8(%edx)
	term->buffer = (uint16_t*) VGA_BUFFER;
c0000084:	8b 45 08             	mov    0x8(%ebp),%eax
c0000087:	c7 40 0c 00 80 0b 00 	movl   $0xb8000,0xc(%eax)
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
c000008e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0000095:	eb 54                	jmp    c00000eb <terminal_init+0x93>
		for (size_t x = 0; x < VGA_WIDTH; x++) {
c0000097:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000009e:	eb 41                	jmp    c00000e1 <terminal_init+0x89>
			const size_t index = y * VGA_WIDTH + x;
c00000a0:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00000a3:	89 d0                	mov    %edx,%eax
c00000a5:	c1 e0 02             	shl    $0x2,%eax
c00000a8:	01 d0                	add    %edx,%eax
c00000aa:	c1 e0 04             	shl    $0x4,%eax
c00000ad:	89 c2                	mov    %eax,%edx
c00000af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00000b2:	01 d0                	add    %edx,%eax
c00000b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
			term->buffer[index] = vga_entry(' ', term->color);
c00000b7:	8b 45 08             	mov    0x8(%ebp),%eax
c00000ba:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c00000be:	0f b6 c0             	movzbl %al,%eax
c00000c1:	8b 55 08             	mov    0x8(%ebp),%edx
c00000c4:	8b 4a 0c             	mov    0xc(%edx),%ecx
c00000c7:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00000ca:	01 d2                	add    %edx,%edx
c00000cc:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
c00000cf:	50                   	push   %eax
c00000d0:	6a 20                	push   $0x20
c00000d2:	e8 41 ff ff ff       	call   c0000018 <vga_entry>
c00000d7:	83 c4 08             	add    $0x8,%esp
c00000da:	66 89 03             	mov    %ax,(%ebx)
		for (size_t x = 0; x < VGA_WIDTH; x++) {
c00000dd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00000e1:	83 7d f4 4f          	cmpl   $0x4f,-0xc(%ebp)
c00000e5:	76 b9                	jbe    c00000a0 <terminal_init+0x48>
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
c00000e7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c00000eb:	83 7d f8 18          	cmpl   $0x18,-0x8(%ebp)
c00000ef:	76 a6                	jbe    c0000097 <terminal_init+0x3f>
		}
	}

	//disable cursor
	outb(0x0A, 0x3D4);
c00000f1:	68 d4 03 00 00       	push   $0x3d4
c00000f6:	6a 0a                	push   $0xa
c00000f8:	e8 3c ff ff ff       	call   c0000039 <outb>
c00000fd:	83 c4 08             	add    $0x8,%esp
	outb(0x20, 0x3D5);
c0000100:	68 d5 03 00 00       	push   $0x3d5
c0000105:	6a 20                	push   $0x20
c0000107:	e8 2d ff ff ff       	call   c0000039 <outb>
c000010c:	83 c4 08             	add    $0x8,%esp
	// outb(0x0A, 0x3D4);
	// outb((inb(0x3D5) & 0xC0) | cursor_start, 0x3D5);
 
	// outb(0x0B, 0x3D4);
	// outb((inb(0x3D5) & 0xE0) | cursor_end, 0x3D5);
}
c000010f:	90                   	nop
c0000110:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0000113:	c9                   	leave  
c0000114:	c3                   	ret    

c0000115 <terminal_setcolor>:
 
void terminal_setcolor(struct terminal* term, uint8_t color) 
{
c0000115:	55                   	push   %ebp
c0000116:	89 e5                	mov    %esp,%ebp
c0000118:	83 ec 04             	sub    $0x4,%esp
c000011b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000011e:	88 45 fc             	mov    %al,-0x4(%ebp)
	term->color = color;
c0000121:	8b 45 08             	mov    0x8(%ebp),%eax
c0000124:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c0000128:	88 50 08             	mov    %dl,0x8(%eax)
}
c000012b:	90                   	nop
c000012c:	c9                   	leave  
c000012d:	c3                   	ret    

c000012e <terminal_putentryat>:
 
void terminal_putentryat(struct terminal* term, char c, uint8_t color, size_t x, size_t y) 
{
c000012e:	55                   	push   %ebp
c000012f:	89 e5                	mov    %esp,%ebp
c0000131:	53                   	push   %ebx
c0000132:	83 ec 18             	sub    $0x18,%esp
c0000135:	8b 55 0c             	mov    0xc(%ebp),%edx
c0000138:	8b 45 10             	mov    0x10(%ebp),%eax
c000013b:	88 55 e8             	mov    %dl,-0x18(%ebp)
c000013e:	88 45 e4             	mov    %al,-0x1c(%ebp)
	const size_t index = y * VGA_WIDTH + x;
c0000141:	8b 55 18             	mov    0x18(%ebp),%edx
c0000144:	89 d0                	mov    %edx,%eax
c0000146:	c1 e0 02             	shl    $0x2,%eax
c0000149:	01 d0                	add    %edx,%eax
c000014b:	c1 e0 04             	shl    $0x4,%eax
c000014e:	89 c2                	mov    %eax,%edx
c0000150:	8b 45 14             	mov    0x14(%ebp),%eax
c0000153:	01 d0                	add    %edx,%eax
c0000155:	89 45 f8             	mov    %eax,-0x8(%ebp)
	term->buffer[index] = vga_entry(c, color);
c0000158:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c000015c:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0000160:	0f b6 c0             	movzbl %al,%eax
c0000163:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0000166:	8b 59 0c             	mov    0xc(%ecx),%ebx
c0000169:	8b 4d f8             	mov    -0x8(%ebp),%ecx
c000016c:	01 c9                	add    %ecx,%ecx
c000016e:	01 cb                	add    %ecx,%ebx
c0000170:	52                   	push   %edx
c0000171:	50                   	push   %eax
c0000172:	e8 a1 fe ff ff       	call   c0000018 <vga_entry>
c0000177:	83 c4 08             	add    $0x8,%esp
c000017a:	66 89 03             	mov    %ax,(%ebx)
	// terminal_movecursor(term, x, y);
}
c000017d:	90                   	nop
c000017e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0000181:	c9                   	leave  
c0000182:	c3                   	ret    

c0000183 <terminal_movecursor>:

void terminal_movecursor(struct terminal* term, size_t x, size_t y)
{
c0000183:	55                   	push   %ebp
c0000184:	89 e5                	mov    %esp,%ebp
c0000186:	83 ec 10             	sub    $0x10,%esp
	(void) term; //we are directly manipulating curser, so were arean't using the term struct

	uint16_t pos = y * VGA_WIDTH + x;
c0000189:	8b 45 10             	mov    0x10(%ebp),%eax
c000018c:	89 c2                	mov    %eax,%edx
c000018e:	89 d0                	mov    %edx,%eax
c0000190:	c1 e0 02             	shl    $0x2,%eax
c0000193:	01 d0                	add    %edx,%eax
c0000195:	c1 e0 04             	shl    $0x4,%eax
c0000198:	89 c2                	mov    %eax,%edx
c000019a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000019d:	01 d0                	add    %edx,%eax
c000019f:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

	outb(0x0F, 0x3D4);
c00001a3:	68 d4 03 00 00       	push   $0x3d4
c00001a8:	6a 0f                	push   $0xf
c00001aa:	e8 8a fe ff ff       	call   c0000039 <outb>
c00001af:	83 c4 08             	add    $0x8,%esp
	outb((uint8_t) (pos & 0xFF), 0x3D5);
c00001b2:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c00001b6:	0f b6 c0             	movzbl %al,%eax
c00001b9:	68 d5 03 00 00       	push   $0x3d5
c00001be:	50                   	push   %eax
c00001bf:	e8 75 fe ff ff       	call   c0000039 <outb>
c00001c4:	83 c4 08             	add    $0x8,%esp
	outb(0x0E, 0x3D4);
c00001c7:	68 d4 03 00 00       	push   $0x3d4
c00001cc:	6a 0e                	push   $0xe
c00001ce:	e8 66 fe ff ff       	call   c0000039 <outb>
c00001d3:	83 c4 08             	add    $0x8,%esp
	outb((uint8_t) ((pos >> 8) & 0xFF), 0x3D5);
c00001d6:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c00001da:	66 c1 e8 08          	shr    $0x8,%ax
c00001de:	0f b6 c0             	movzbl %al,%eax
c00001e1:	68 d5 03 00 00       	push   $0x3d5
c00001e6:	50                   	push   %eax
c00001e7:	e8 4d fe ff ff       	call   c0000039 <outb>
c00001ec:	83 c4 08             	add    $0x8,%esp
}
c00001ef:	90                   	nop
c00001f0:	c9                   	leave  
c00001f1:	c3                   	ret    

c00001f2 <terminal_putchar>:

 
void terminal_putchar(struct terminal* term, char c) 
{
c00001f2:	55                   	push   %ebp
c00001f3:	89 e5                	mov    %esp,%ebp
c00001f5:	53                   	push   %ebx
c00001f6:	83 ec 14             	sub    $0x14,%esp
c00001f9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00001fc:	88 45 f4             	mov    %al,-0xc(%ebp)
	if(c == '\n')
c00001ff:	80 7d f4 0a          	cmpb   $0xa,-0xc(%ebp)
c0000203:	75 10                	jne    c0000215 <terminal_putchar+0x23>
	{
		terminal_newline(term);
c0000205:	83 ec 0c             	sub    $0xc,%esp
c0000208:	ff 75 08             	pushl  0x8(%ebp)
c000020b:	e8 95 00 00 00       	call   c00002a5 <terminal_newline>
c0000210:	83 c4 10             	add    $0x10,%esp
		return;
c0000213:	eb 53                	jmp    c0000268 <terminal_putchar+0x76>
	}

	terminal_putentryat(term, c, term->color, term->column, term->row);
c0000215:	8b 45 08             	mov    0x8(%ebp),%eax
c0000218:	8b 18                	mov    (%eax),%ebx
c000021a:	8b 45 08             	mov    0x8(%ebp),%eax
c000021d:	8b 48 04             	mov    0x4(%eax),%ecx
c0000220:	8b 45 08             	mov    0x8(%ebp),%eax
c0000223:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c0000227:	0f b6 d0             	movzbl %al,%edx
c000022a:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c000022e:	83 ec 0c             	sub    $0xc,%esp
c0000231:	53                   	push   %ebx
c0000232:	51                   	push   %ecx
c0000233:	52                   	push   %edx
c0000234:	50                   	push   %eax
c0000235:	ff 75 08             	pushl  0x8(%ebp)
c0000238:	e8 f1 fe ff ff       	call   c000012e <terminal_putentryat>
c000023d:	83 c4 20             	add    $0x20,%esp
	if (++term->column == VGA_WIDTH)
c0000240:	8b 45 08             	mov    0x8(%ebp),%eax
c0000243:	8b 40 04             	mov    0x4(%eax),%eax
c0000246:	8d 50 01             	lea    0x1(%eax),%edx
c0000249:	8b 45 08             	mov    0x8(%ebp),%eax
c000024c:	89 50 04             	mov    %edx,0x4(%eax)
c000024f:	8b 45 08             	mov    0x8(%ebp),%eax
c0000252:	8b 40 04             	mov    0x4(%eax),%eax
c0000255:	83 f8 50             	cmp    $0x50,%eax
c0000258:	75 0e                	jne    c0000268 <terminal_putchar+0x76>
		terminal_newline(term);
c000025a:	83 ec 0c             	sub    $0xc,%esp
c000025d:	ff 75 08             	pushl  0x8(%ebp)
c0000260:	e8 40 00 00 00       	call   c00002a5 <terminal_newline>
c0000265:	83 c4 10             	add    $0x10,%esp
}
c0000268:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000026b:	c9                   	leave  
c000026c:	c3                   	ret    

c000026d <terminal_putcharn>:

void terminal_putcharn(struct terminal* term, char c, size_t repeat) 
{
c000026d:	55                   	push   %ebp
c000026e:	89 e5                	mov    %esp,%ebp
c0000270:	83 ec 28             	sub    $0x28,%esp
c0000273:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000276:	88 45 e4             	mov    %al,-0x1c(%ebp)
	for (size_t i = 0; i < repeat; i++)
c0000279:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0000280:	eb 17                	jmp    c0000299 <terminal_putcharn+0x2c>
		terminal_putchar(term, c);
c0000282:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
c0000286:	83 ec 08             	sub    $0x8,%esp
c0000289:	50                   	push   %eax
c000028a:	ff 75 08             	pushl  0x8(%ebp)
c000028d:	e8 60 ff ff ff       	call   c00001f2 <terminal_putchar>
c0000292:	83 c4 10             	add    $0x10,%esp
	for (size_t i = 0; i < repeat; i++)
c0000295:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0000299:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000029c:	3b 45 10             	cmp    0x10(%ebp),%eax
c000029f:	72 e1                	jb     c0000282 <terminal_putcharn+0x15>
}
c00002a1:	90                   	nop
c00002a2:	90                   	nop
c00002a3:	c9                   	leave  
c00002a4:	c3                   	ret    

c00002a5 <terminal_newline>:

void terminal_newline(struct terminal* term)
{
c00002a5:	55                   	push   %ebp
c00002a6:	89 e5                	mov    %esp,%ebp
c00002a8:	83 ec 08             	sub    $0x8,%esp
    term->column = 0;
c00002ab:	8b 45 08             	mov    0x8(%ebp),%eax
c00002ae:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if (++term->row == VGA_HEIGHT)
c00002b5:	8b 45 08             	mov    0x8(%ebp),%eax
c00002b8:	8b 00                	mov    (%eax),%eax
c00002ba:	8d 50 01             	lea    0x1(%eax),%edx
c00002bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00002c0:	89 10                	mov    %edx,(%eax)
c00002c2:	8b 45 08             	mov    0x8(%ebp),%eax
c00002c5:	8b 00                	mov    (%eax),%eax
c00002c7:	83 f8 19             	cmp    $0x19,%eax
c00002ca:	75 0e                	jne    c00002da <terminal_newline+0x35>
        terminal_scrollline(term);
c00002cc:	83 ec 0c             	sub    $0xc,%esp
c00002cf:	ff 75 08             	pushl  0x8(%ebp)
c00002d2:	e8 06 00 00 00       	call   c00002dd <terminal_scrollline>
c00002d7:	83 c4 10             	add    $0x10,%esp
}
c00002da:	90                   	nop
c00002db:	c9                   	leave  
c00002dc:	c3                   	ret    

c00002dd <terminal_scrollline>:

void terminal_scrollline(struct terminal* term)
{
c00002dd:	55                   	push   %ebp
c00002de:	89 e5                	mov    %esp,%ebp
c00002e0:	83 ec 08             	sub    $0x8,%esp
	// copy rows 2 though N to rows 1 through N-1
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c00002e3:	8b 45 08             	mov    0x8(%ebp),%eax
c00002e6:	8b 40 0c             	mov    0xc(%eax),%eax
c00002e9:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c00002ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00002f2:	8b 40 0c             	mov    0xc(%eax),%eax
c00002f5:	83 ec 04             	sub    $0x4,%esp
c00002f8:	68 00 0f 00 00       	push   $0xf00
c00002fd:	52                   	push   %edx
c00002fe:	50                   	push   %eax
c00002ff:	e8 bf 0f 00 00       	call   c00012c3 <memcpy>
c0000304:	83 c4 10             	add    $0x10,%esp
	// clear last row
	term->row = VGA_HEIGHT-1;
c0000307:	8b 45 08             	mov    0x8(%ebp),%eax
c000030a:	c7 00 18 00 00 00    	movl   $0x18,(%eax)
	terminal_clearline(term);
c0000310:	83 ec 0c             	sub    $0xc,%esp
c0000313:	ff 75 08             	pushl  0x8(%ebp)
c0000316:	e8 06 00 00 00       	call   c0000321 <terminal_clearline>
c000031b:	83 c4 10             	add    $0x10,%esp
}
c000031e:	90                   	nop
c000031f:	c9                   	leave  
c0000320:	c3                   	ret    

c0000321 <terminal_clearline>:

void terminal_clearline(struct terminal* term)
{
c0000321:	55                   	push   %ebp
c0000322:	89 e5                	mov    %esp,%ebp
c0000324:	53                   	push   %ebx
c0000325:	83 ec 10             	sub    $0x10,%esp
	size_t row_start = term->row * VGA_WIDTH;
c0000328:	8b 45 08             	mov    0x8(%ebp),%eax
c000032b:	8b 10                	mov    (%eax),%edx
c000032d:	89 d0                	mov    %edx,%eax
c000032f:	c1 e0 02             	shl    $0x2,%eax
c0000332:	01 d0                	add    %edx,%eax
c0000334:	c1 e0 04             	shl    $0x4,%eax
c0000337:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c000033a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0000341:	eb 2f                	jmp    c0000372 <terminal_clearline+0x51>
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0000343:	8b 45 08             	mov    0x8(%ebp),%eax
c0000346:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c000034a:	0f b6 c0             	movzbl %al,%eax
c000034d:	8b 55 08             	mov    0x8(%ebp),%edx
c0000350:	8b 4a 0c             	mov    0xc(%edx),%ecx
c0000353:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c0000356:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0000359:	01 da                	add    %ebx,%edx
c000035b:	01 d2                	add    %edx,%edx
c000035d:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
c0000360:	50                   	push   %eax
c0000361:	6a 20                	push   $0x20
c0000363:	e8 b0 fc ff ff       	call   c0000018 <vga_entry>
c0000368:	83 c4 08             	add    $0x8,%esp
c000036b:	66 89 03             	mov    %ax,(%ebx)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c000036e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0000372:	83 7d f8 4f          	cmpl   $0x4f,-0x8(%ebp)
c0000376:	76 cb                	jbe    c0000343 <terminal_clearline+0x22>

}
c0000378:	90                   	nop
c0000379:	90                   	nop
c000037a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000037d:	c9                   	leave  
c000037e:	c3                   	ret    

c000037f <terminal_write>:


void terminal_write(struct terminal* term, const char* data, size_t size) 
{
c000037f:	55                   	push   %ebp
c0000380:	89 e5                	mov    %esp,%ebp
c0000382:	83 ec 18             	sub    $0x18,%esp
	for (size_t i = 0; i < size; i++)
c0000385:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000038c:	eb 21                	jmp    c00003af <terminal_write+0x30>
		terminal_putchar(term, data[i]);
c000038e:	8b 55 0c             	mov    0xc(%ebp),%edx
c0000391:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000394:	01 d0                	add    %edx,%eax
c0000396:	0f b6 00             	movzbl (%eax),%eax
c0000399:	0f be c0             	movsbl %al,%eax
c000039c:	83 ec 08             	sub    $0x8,%esp
c000039f:	50                   	push   %eax
c00003a0:	ff 75 08             	pushl  0x8(%ebp)
c00003a3:	e8 4a fe ff ff       	call   c00001f2 <terminal_putchar>
c00003a8:	83 c4 10             	add    $0x10,%esp
	for (size_t i = 0; i < size; i++)
c00003ab:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00003af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00003b2:	3b 45 10             	cmp    0x10(%ebp),%eax
c00003b5:	72 d7                	jb     c000038e <terminal_write+0xf>
}
c00003b7:	90                   	nop
c00003b8:	90                   	nop
c00003b9:	c9                   	leave  
c00003ba:	c3                   	ret    

c00003bb <terminal_writestring>:
 
void terminal_writestring(struct terminal* term, const char* data) 
{
c00003bb:	55                   	push   %ebp
c00003bc:	89 e5                	mov    %esp,%ebp
c00003be:	83 ec 08             	sub    $0x8,%esp
	terminal_write(term, data, strlen(data));
c00003c1:	83 ec 0c             	sub    $0xc,%esp
c00003c4:	ff 75 0c             	pushl  0xc(%ebp)
c00003c7:	e8 d0 0e 00 00       	call   c000129c <strlen>
c00003cc:	83 c4 10             	add    $0x10,%esp
c00003cf:	83 ec 04             	sub    $0x4,%esp
c00003d2:	50                   	push   %eax
c00003d3:	ff 75 0c             	pushl  0xc(%ebp)
c00003d6:	ff 75 08             	pushl  0x8(%ebp)
c00003d9:	e8 a1 ff ff ff       	call   c000037f <terminal_write>
c00003de:	83 c4 10             	add    $0x10,%esp
}
c00003e1:	90                   	nop
c00003e2:	c9                   	leave  
c00003e3:	c3                   	ret    

c00003e4 <kprint>:
unsigned int numdigits_uint(unsigned int value, unsigned int base);

int format_uint(unsigned int value, char* str, unsigned int base, int precision, int cap);

int kprint(const char* str)
{
c00003e4:	55                   	push   %ebp
c00003e5:	89 e5                	mov    %esp,%ebp
c00003e7:	83 ec 08             	sub    $0x8,%esp
    terminal_writestring(&stdout, str);
c00003ea:	83 ec 08             	sub    $0x8,%esp
c00003ed:	ff 75 08             	pushl  0x8(%ebp)
c00003f0:	68 00 f0 00 c0       	push   $0xc000f000
c00003f5:	e8 c1 ff ff ff       	call   c00003bb <terminal_writestring>
c00003fa:	83 c4 10             	add    $0x10,%esp
    return strlen(str);
c00003fd:	83 ec 0c             	sub    $0xc,%esp
c0000400:	ff 75 08             	pushl  0x8(%ebp)
c0000403:	e8 94 0e 00 00       	call   c000129c <strlen>
c0000408:	83 c4 10             	add    $0x10,%esp
}
c000040b:	c9                   	leave  
c000040c:	c3                   	ret    

c000040d <kprintn>:

int kprintn(const char* str, size_t len)
{
c000040d:	55                   	push   %ebp
c000040e:	89 e5                	mov    %esp,%ebp
c0000410:	83 ec 08             	sub    $0x8,%esp
    terminal_write(&stdout, str, len);
c0000413:	83 ec 04             	sub    $0x4,%esp
c0000416:	ff 75 0c             	pushl  0xc(%ebp)
c0000419:	ff 75 08             	pushl  0x8(%ebp)
c000041c:	68 00 f0 00 c0       	push   $0xc000f000
c0000421:	e8 59 ff ff ff       	call   c000037f <terminal_write>
c0000426:	83 c4 10             	add    $0x10,%esp
    return len;
c0000429:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c000042c:	c9                   	leave  
c000042d:	c3                   	ret    

c000042e <kprint_char>:

int kprint_char(char c)
{
c000042e:	55                   	push   %ebp
c000042f:	89 e5                	mov    %esp,%ebp
c0000431:	83 ec 18             	sub    $0x18,%esp
c0000434:	8b 45 08             	mov    0x8(%ebp),%eax
c0000437:	88 45 f4             	mov    %al,-0xc(%ebp)
    terminal_putchar(&stdout, c); 
c000043a:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c000043e:	83 ec 08             	sub    $0x8,%esp
c0000441:	50                   	push   %eax
c0000442:	68 00 f0 00 c0       	push   $0xc000f000
c0000447:	e8 a6 fd ff ff       	call   c00001f2 <terminal_putchar>
c000044c:	83 c4 10             	add    $0x10,%esp
    return 1;
c000044f:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0000454:	c9                   	leave  
c0000455:	c3                   	ret    

c0000456 <kprintn_char>:

int kprintn_char(char c, size_t rpt)
{
c0000456:	55                   	push   %ebp
c0000457:	89 e5                	mov    %esp,%ebp
c0000459:	83 ec 18             	sub    $0x18,%esp
c000045c:	8b 45 08             	mov    0x8(%ebp),%eax
c000045f:	88 45 f4             	mov    %al,-0xc(%ebp)
    terminal_putcharn(&stdout, c, rpt); 
c0000462:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c0000466:	83 ec 04             	sub    $0x4,%esp
c0000469:	ff 75 0c             	pushl  0xc(%ebp)
c000046c:	50                   	push   %eax
c000046d:	68 00 f0 00 c0       	push   $0xc000f000
c0000472:	e8 f6 fd ff ff       	call   c000026d <terminal_putcharn>
c0000477:	83 c4 10             	add    $0x10,%esp
    return rpt;
c000047a:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c000047d:	c9                   	leave  
c000047e:	c3                   	ret    

c000047f <kprintf>:


int kprintf(const char* format, ...)
{
c000047f:	55                   	push   %ebp
c0000480:	89 e5                	mov    %esp,%ebp
c0000482:	81 ec a8 02 00 00    	sub    $0x2a8,%esp
    /* initialize valist for num number of arguments */
    va_list valist;
    va_start(valist, format);
c0000488:	8d 45 0c             	lea    0xc(%ebp),%eax
c000048b:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)

    // parse format into str
    const char* f = format;
c0000491:	8b 45 08             	mov    0x8(%ebp),%eax
c0000494:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int nchar = 0;
c0000497:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    while(f[0] != 0)
c000049e:	e9 9e 0a 00 00       	jmp    c0000f41 <kprintf+0xac2>
    {
        if(f[0] == '\\' && f[1] == '%')
c00004a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00004a6:	0f b6 00             	movzbl (%eax),%eax
c00004a9:	3c 5c                	cmp    $0x5c,%al
c00004ab:	75 22                	jne    c00004cf <kprintf+0x50>
c00004ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00004b0:	83 c0 01             	add    $0x1,%eax
c00004b3:	0f b6 00             	movzbl (%eax),%eax
c00004b6:	3c 25                	cmp    $0x25,%al
c00004b8:	75 15                	jne    c00004cf <kprintf+0x50>
        {
            //write escaped "%%" as '%'
            kprint_char('%');
c00004ba:	83 ec 0c             	sub    $0xc,%esp
c00004bd:	6a 25                	push   $0x25
c00004bf:	e8 6a ff ff ff       	call   c000042e <kprint_char>
c00004c4:	83 c4 10             	add    $0x10,%esp
            nchar++;
c00004c7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
            f += 2;
c00004cb:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
        }

        if(f[0] == '%')
c00004cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00004d2:	0f b6 00             	movzbl (%eax),%eax
c00004d5:	3c 25                	cmp    $0x25,%al
c00004d7:	0f 85 45 0a 00 00    	jne    c0000f22 <kprintf+0xaa3>
        {
            // found new field

            // parse flags
            struct format_flags flags = {0};
c00004dd:	c7 85 77 ff ff ff 00 	movl   $0x0,-0x89(%ebp)
c00004e4:	00 00 00 
c00004e7:	c6 85 7b ff ff ff 00 	movb   $0x0,-0x85(%ebp)
            int check_flags = 1;
c00004ee:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
            while(check_flags)
c00004f5:	e9 ee 00 00 00       	jmp    c00005e8 <kprintf+0x169>
            {
                switch(*(++f))
c00004fa:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00004fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000501:	0f b6 00             	movzbl (%eax),%eax
c0000504:	0f be c0             	movsbl %al,%eax
c0000507:	85 c0                	test   %eax,%eax
c0000509:	0f 84 c8 00 00 00    	je     c00005d7 <kprintf+0x158>
c000050f:	85 c0                	test   %eax,%eax
c0000511:	0f 88 ca 00 00 00    	js     c00005e1 <kprintf+0x162>
c0000517:	83 f8 30             	cmp    $0x30,%eax
c000051a:	0f 8f c1 00 00 00    	jg     c00005e1 <kprintf+0x162>
c0000520:	83 f8 20             	cmp    $0x20,%eax
c0000523:	0f 8c b8 00 00 00    	jl     c00005e1 <kprintf+0x162>
c0000529:	83 e8 20             	sub    $0x20,%eax
c000052c:	83 f8 10             	cmp    $0x10,%eax
c000052f:	0f 87 ac 00 00 00    	ja     c00005e1 <kprintf+0x162>
c0000535:	8b 04 85 00 30 00 c0 	mov    -0x3fffd000(,%eax,4),%eax
c000053c:	ff e0                	jmp    *%eax
                {
                    case '#':
                        if(flags.alt) return 0;
c000053e:	0f b6 85 77 ff ff ff 	movzbl -0x89(%ebp),%eax
c0000545:	84 c0                	test   %al,%al
c0000547:	74 0a                	je     c0000553 <kprintf+0xd4>
c0000549:	b8 00 00 00 00       	mov    $0x0,%eax
c000054e:	e9 ff 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        flags.alt = 1;
c0000553:	c6 85 77 ff ff ff 01 	movb   $0x1,-0x89(%ebp)
                        break;
c000055a:	e9 89 00 00 00       	jmp    c00005e8 <kprintf+0x169>
                    case '0':
                        if(flags.zero) return 0;
c000055f:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000566:	84 c0                	test   %al,%al
c0000568:	74 0a                	je     c0000574 <kprintf+0xf5>
c000056a:	b8 00 00 00 00       	mov    $0x0,%eax
c000056f:	e9 de 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        flags.zero = 1;
c0000574:	c6 85 78 ff ff ff 01 	movb   $0x1,-0x88(%ebp)
                        break;
c000057b:	eb 6b                	jmp    c00005e8 <kprintf+0x169>
                    case '-':
                        if(flags.left) return 0;
c000057d:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000584:	84 c0                	test   %al,%al
c0000586:	74 0a                	je     c0000592 <kprintf+0x113>
c0000588:	b8 00 00 00 00       	mov    $0x0,%eax
c000058d:	e9 c0 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        flags.left = 1;
c0000592:	c6 85 79 ff ff ff 01 	movb   $0x1,-0x87(%ebp)
                        break;
c0000599:	eb 4d                	jmp    c00005e8 <kprintf+0x169>
                    case ' ':
                        if(flags.space) return 0;
c000059b:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c00005a2:	84 c0                	test   %al,%al
c00005a4:	74 0a                	je     c00005b0 <kprintf+0x131>
c00005a6:	b8 00 00 00 00       	mov    $0x0,%eax
c00005ab:	e9 a2 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        flags.space = 1;
c00005b0:	c6 85 7a ff ff ff 01 	movb   $0x1,-0x86(%ebp)
                        break;
c00005b7:	eb 2f                	jmp    c00005e8 <kprintf+0x169>
                    case '+':
                        if(flags.sign) return 0;
c00005b9:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c00005c0:	84 c0                	test   %al,%al
c00005c2:	74 0a                	je     c00005ce <kprintf+0x14f>
c00005c4:	b8 00 00 00 00       	mov    $0x0,%eax
c00005c9:	e9 84 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        flags.sign = 1;
c00005ce:	c6 85 7b ff ff ff 01 	movb   $0x1,-0x85(%ebp)
                        break;
c00005d5:	eb 11                	jmp    c00005e8 <kprintf+0x169>
                    case '\0':
                        //unexpected string termination
                        return -1;
c00005d7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00005dc:	e9 71 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        break;
                    default:
                        //no more flags
                        check_flags = 0;
c00005e1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
            while(check_flags)
c00005e8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c00005ec:	0f 85 08 ff ff ff    	jne    c00004fa <kprintf+0x7b>
                }
            }

            if(flags.left) flags.zero = 0; //If the 0 and - flags both appear, the 0 flag is ignored
c00005f2:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c00005f9:	84 c0                	test   %al,%al
c00005fb:	74 07                	je     c0000604 <kprintf+0x185>
c00005fd:	c6 85 78 ff ff ff 00 	movb   $0x0,-0x88(%ebp)

            // parse field width
            int field_width=0;
c0000604:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
            int nn=0;
c000060b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
            while(f[nn] >= '0' && f[nn] <= '9')
c0000612:	eb 04                	jmp    c0000618 <kprintf+0x199>
                nn++;            
c0000614:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
            while(f[nn] >= '0' && f[nn] <= '9')
c0000618:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c000061b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000061e:	01 d0                	add    %edx,%eax
c0000620:	0f b6 00             	movzbl (%eax),%eax
c0000623:	3c 2f                	cmp    $0x2f,%al
c0000625:	7e 0f                	jle    c0000636 <kprintf+0x1b7>
c0000627:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c000062a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000062d:	01 d0                	add    %edx,%eax
c000062f:	0f b6 00             	movzbl (%eax),%eax
c0000632:	3c 39                	cmp    $0x39,%al
c0000634:	7e de                	jle    c0000614 <kprintf+0x195>
            if(nn>0)
c0000636:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c000063a:	7e 17                	jle    c0000653 <kprintf+0x1d4>
            {
                field_width = atoi(f);
c000063c:	83 ec 0c             	sub    $0xc,%esp
c000063f:	ff 75 f4             	pushl  -0xc(%ebp)
c0000642:	e8 21 0d 00 00       	call   c0001368 <atoi>
c0000647:	83 c4 10             	add    $0x10,%esp
c000064a:	89 45 e8             	mov    %eax,-0x18(%ebp)
                f += nn;
c000064d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0000650:	01 45 f4             	add    %eax,-0xc(%ebp)
            }

            // parse field precision
            int field_prec=-1; //default is -1
c0000653:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
            if(f[0] == '.')
c000065a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000065d:	0f b6 00             	movzbl (%eax),%eax
c0000660:	3c 2e                	cmp    $0x2e,%al
c0000662:	75 59                	jne    c00006bd <kprintf+0x23e>
            {
                f++;
c0000664:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                nn=0;
c0000668:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
                while(f[nn] >= '0' && f[nn] <= '9')
c000066f:	eb 04                	jmp    c0000675 <kprintf+0x1f6>
                    nn++;            
c0000671:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                while(f[nn] >= '0' && f[nn] <= '9')
c0000675:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000678:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000067b:	01 d0                	add    %edx,%eax
c000067d:	0f b6 00             	movzbl (%eax),%eax
c0000680:	3c 2f                	cmp    $0x2f,%al
c0000682:	7e 0f                	jle    c0000693 <kprintf+0x214>
c0000684:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000687:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000068a:	01 d0                	add    %edx,%eax
c000068c:	0f b6 00             	movzbl (%eax),%eax
c000068f:	3c 39                	cmp    $0x39,%al
c0000691:	7e de                	jle    c0000671 <kprintf+0x1f2>
                if(nn>0)
c0000693:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0000697:	7e 24                	jle    c00006bd <kprintf+0x23e>
                {
                    field_prec = atoi(f);
c0000699:	83 ec 0c             	sub    $0xc,%esp
c000069c:	ff 75 f4             	pushl  -0xc(%ebp)
c000069f:	e8 c4 0c 00 00       	call   c0001368 <atoi>
c00006a4:	83 c4 10             	add    $0x10,%esp
c00006a7:	89 45 e0             	mov    %eax,-0x20(%ebp)
                    if(field_prec<0) field_prec = 0;
c00006aa:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c00006ae:	79 07                	jns    c00006b7 <kprintf+0x238>
c00006b0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
                    f += nn;
c00006b7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00006ba:	01 45 f4             	add    %eax,-0xc(%ebp)

            //parse type
            enum length_mod_t {DEFAULT, CHARINT, SHORTINT, LONGINT, LONGLONGINT,
                            LONGDOUBLE, INTMAX, SIZE, PTRDIFF} length_mod;

            switch(*(f++))
c00006bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00006c0:	8d 50 01             	lea    0x1(%eax),%edx
c00006c3:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00006c6:	0f b6 00             	movzbl (%eax),%eax
c00006c9:	0f be c0             	movsbl %al,%eax
c00006cc:	83 e8 4c             	sub    $0x4c,%eax
c00006cf:	83 f8 2e             	cmp    $0x2e,%eax
c00006d2:	77 6d                	ja     c0000741 <kprintf+0x2c2>
c00006d4:	8b 04 85 44 30 00 c0 	mov    -0x3fffcfbc(,%eax,4),%eax
c00006db:	ff e0                	jmp    *%eax
            {
                case 'h':
                    if(*f == 'h')
c00006dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00006e0:	0f b6 00             	movzbl (%eax),%eax
c00006e3:	3c 68                	cmp    $0x68,%al
c00006e5:	75 0d                	jne    c00006f4 <kprintf+0x275>
                    {
                        f++;
c00006e7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                        length_mod = CHARINT;
c00006eb:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
                    }
                    else
                        length_mod = SHORTINT;
                    break;
c00006f2:	eb 58                	jmp    c000074c <kprintf+0x2cd>
                        length_mod = SHORTINT;
c00006f4:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
                    break;
c00006fb:	eb 4f                	jmp    c000074c <kprintf+0x2cd>
                case 'l':
                    if(*f == 'l')
c00006fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000700:	0f b6 00             	movzbl (%eax),%eax
c0000703:	3c 6c                	cmp    $0x6c,%al
c0000705:	75 0d                	jne    c0000714 <kprintf+0x295>
                    {
                        f++;
c0000707:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                        length_mod = LONGLONGINT;
c000070b:	c7 45 dc 04 00 00 00 	movl   $0x4,-0x24(%ebp)
                    }
                    else
                        length_mod = LONGINT;
                    break;
c0000712:	eb 38                	jmp    c000074c <kprintf+0x2cd>
                        length_mod = LONGINT;
c0000714:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
                    break;
c000071b:	eb 2f                	jmp    c000074c <kprintf+0x2cd>
                case 'q':
                case 'L':
                    length_mod = LONGDOUBLE;
c000071d:	c7 45 dc 05 00 00 00 	movl   $0x5,-0x24(%ebp)
                    break;
c0000724:	eb 26                	jmp    c000074c <kprintf+0x2cd>
                case 'j':
                    length_mod = INTMAX;
c0000726:	c7 45 dc 06 00 00 00 	movl   $0x6,-0x24(%ebp)
                    break;
c000072d:	eb 1d                	jmp    c000074c <kprintf+0x2cd>
                case 'Z':
                case 'z':
                    length_mod = SIZE;
c000072f:	c7 45 dc 07 00 00 00 	movl   $0x7,-0x24(%ebp)
                    break;
c0000736:	eb 14                	jmp    c000074c <kprintf+0x2cd>
                case 't':
                    length_mod = PTRDIFF;
c0000738:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
                    break;
c000073f:	eb 0b                	jmp    c000074c <kprintf+0x2cd>
                default:
                    f--; //no length mod, back up a char...
c0000741:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
                    length_mod = DEFAULT;
c0000745:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
            }

            //parse field
            char val_buf[512]; //assuming here that numberical values cannot exceed 512 chars 
            if(field_width>511)
c000074c:	81 7d e8 ff 01 00 00 	cmpl   $0x1ff,-0x18(%ebp)
c0000753:	7e 0a                	jle    c000075f <kprintf+0x2e0>
                return -1;
c0000755:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000075a:	e9 f3 07 00 00       	jmp    c0000f52 <kprintf+0xad3>

            switch(*f)
c000075f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000762:	0f b6 00             	movzbl (%eax),%eax
c0000765:	0f be c0             	movsbl %al,%eax
c0000768:	83 e8 45             	sub    $0x45,%eax
c000076b:	83 f8 33             	cmp    $0x33,%eax
c000076e:	0f 87 97 07 00 00    	ja     c0000f0b <kprintf+0xa8c>
c0000774:	8b 04 85 00 31 00 c0 	mov    -0x3fffcf00(,%eax,4),%eax
c000077b:	ff e0                	jmp    *%eax
c000077d:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000781:	0f 87 67 01 00 00    	ja     c00008ee <kprintf+0x46f>
                        case(LONGINT):
                        case(LONGLONGINT):
                        case(DEFAULT):
                            {
                                int i_value;
                                if(length_mod == LONGLONGINT)
c0000787:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c000078b:	75 19                	jne    c00007a6 <kprintf+0x327>
                                    i_value = (int) va_arg(valist, long long int); //TODO: implement actual longlong handling
c000078d:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000793:	8d 50 08             	lea    0x8(%eax),%edx
c0000796:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c000079c:	8b 50 04             	mov    0x4(%eax),%edx
c000079f:	8b 00                	mov    (%eax),%eax
c00007a1:	89 45 d8             	mov    %eax,-0x28(%ebp)
c00007a4:	eb 14                	jmp    c00007ba <kprintf+0x33b>
                                else
                                    i_value = va_arg(valist, int);
c00007a6:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c00007ac:	8d 50 04             	lea    0x4(%eax),%edx
c00007af:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c00007b5:	8b 00                	mov    (%eax),%eax
c00007b7:	89 45 d8             	mov    %eax,-0x28(%ebp)

                                char sign_char = 0; //sign character or 0 if none
c00007ba:	c6 45 d7 00          	movb   $0x0,-0x29(%ebp)
                                unsigned int ui_value; //unsigned value (abs value)
                                if(i_value<0)
c00007be:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c00007c2:	79 0e                	jns    c00007d2 <kprintf+0x353>
                                {
                                    ui_value = -i_value;
c00007c4:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00007c7:	f7 d8                	neg    %eax
c00007c9:	89 45 d0             	mov    %eax,-0x30(%ebp)
                                    sign_char = '-';
c00007cc:	c6 45 d7 2d          	movb   $0x2d,-0x29(%ebp)
c00007d0:	eb 26                	jmp    c00007f8 <kprintf+0x379>
                                }
                                else
                                {
                                    ui_value = i_value;
c00007d2:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00007d5:	89 45 d0             	mov    %eax,-0x30(%ebp)
                                    if(flags.sign)
c00007d8:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c00007df:	84 c0                	test   %al,%al
c00007e1:	74 06                	je     c00007e9 <kprintf+0x36a>
                                        sign_char = '+';
c00007e3:	c6 45 d7 2b          	movb   $0x2b,-0x29(%ebp)
c00007e7:	eb 0f                	jmp    c00007f8 <kprintf+0x379>
                                    else if(flags.space)
c00007e9:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c00007f0:	84 c0                	test   %al,%al
c00007f2:	74 04                	je     c00007f8 <kprintf+0x379>
                                        sign_char = ' ';
c00007f4:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
                                    
                                    //else positive number has no sign character
                                }

                                //convert value into string
                                int len = format_uint(ui_value, val_buf, 10, field_prec, 0);
c00007f8:	83 ec 0c             	sub    $0xc,%esp
c00007fb:	6a 00                	push   $0x0
c00007fd:	ff 75 e0             	pushl  -0x20(%ebp)
c0000800:	6a 0a                	push   $0xa
c0000802:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000808:	50                   	push   %eax
c0000809:	ff 75 d0             	pushl  -0x30(%ebp)
c000080c:	e8 43 07 00 00       	call   c0000f54 <format_uint>
c0000811:	83 c4 20             	add    $0x20,%esp
c0000814:	89 45 9c             	mov    %eax,-0x64(%ebp)
                                //amount of padding required to meet requested width
                                int lenpad = field_width - len; 
c0000817:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000081a:	2b 45 9c             	sub    -0x64(%ebp),%eax
c000081d:	89 45 cc             	mov    %eax,-0x34(%ebp)

                                if(sign_char)
c0000820:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
c0000824:	74 22                	je     c0000848 <kprintf+0x3c9>
                                {
                                    lenpad--; //remove one char of padding to account for sign
c0000826:	83 6d cc 01          	subl   $0x1,-0x34(%ebp)
                                    if(flags.zero)
c000082a:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000831:	84 c0                	test   %al,%al
c0000833:	74 13                	je     c0000848 <kprintf+0x3c9>
                                        nchar += kprint_char(sign_char); //if zero padding, sign is at beginning
c0000835:	0f be 45 d7          	movsbl -0x29(%ebp),%eax
c0000839:	83 ec 0c             	sub    $0xc,%esp
c000083c:	50                   	push   %eax
c000083d:	e8 ec fb ff ff       	call   c000042e <kprint_char>
c0000842:	83 c4 10             	add    $0x10,%esp
c0000845:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                if(!flags.left && lenpad>0)
c0000848:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c000084f:	84 c0                	test   %al,%al
c0000851:	75 3b                	jne    c000088e <kprintf+0x40f>
c0000853:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
c0000857:	7e 35                	jle    c000088e <kprintf+0x40f>
                                {
                                    if(flags.zero)
c0000859:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000860:	84 c0                	test   %al,%al
c0000862:	74 16                	je     c000087a <kprintf+0x3fb>
                                        nchar += kprintn_char('0', lenpad);
c0000864:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0000867:	83 ec 08             	sub    $0x8,%esp
c000086a:	50                   	push   %eax
c000086b:	6a 30                	push   $0x30
c000086d:	e8 e4 fb ff ff       	call   c0000456 <kprintn_char>
c0000872:	83 c4 10             	add    $0x10,%esp
c0000875:	01 45 f0             	add    %eax,-0x10(%ebp)
c0000878:	eb 14                	jmp    c000088e <kprintf+0x40f>
                                    else
                                        nchar += kprintn_char(' ', lenpad);
c000087a:	8b 45 cc             	mov    -0x34(%ebp),%eax
c000087d:	83 ec 08             	sub    $0x8,%esp
c0000880:	50                   	push   %eax
c0000881:	6a 20                	push   $0x20
c0000883:	e8 ce fb ff ff       	call   c0000456 <kprintn_char>
c0000888:	83 c4 10             	add    $0x10,%esp
c000088b:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                if(!flags.zero && sign_char)
c000088e:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000895:	84 c0                	test   %al,%al
c0000897:	75 19                	jne    c00008b2 <kprintf+0x433>
c0000899:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
c000089d:	74 13                	je     c00008b2 <kprintf+0x433>
                                    nchar += kprint_char(sign_char); //if not zero padding, write sign here
c000089f:	0f be 45 d7          	movsbl -0x29(%ebp),%eax
c00008a3:	83 ec 0c             	sub    $0xc,%esp
c00008a6:	50                   	push   %eax
c00008a7:	e8 82 fb ff ff       	call   c000042e <kprint_char>
c00008ac:	83 c4 10             	add    $0x10,%esp
c00008af:	01 45 f0             	add    %eax,-0x10(%ebp)

                                nchar += kprint(val_buf);
c00008b2:	83 ec 0c             	sub    $0xc,%esp
c00008b5:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c00008bb:	50                   	push   %eax
c00008bc:	e8 23 fb ff ff       	call   c00003e4 <kprint>
c00008c1:	83 c4 10             	add    $0x10,%esp
c00008c4:	01 45 f0             	add    %eax,-0x10(%ebp)

                                if(flags.left && lenpad>0)
c00008c7:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c00008ce:	84 c0                	test   %al,%al
c00008d0:	74 26                	je     c00008f8 <kprintf+0x479>
c00008d2:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
c00008d6:	7e 20                	jle    c00008f8 <kprintf+0x479>
                                    nchar += kprintn_char(' ', lenpad);
c00008d8:	8b 45 cc             	mov    -0x34(%ebp),%eax
c00008db:	83 ec 08             	sub    $0x8,%esp
c00008de:	50                   	push   %eax
c00008df:	6a 20                	push   $0x20
c00008e1:	e8 70 fb ff ff       	call   c0000456 <kprintn_char>
c00008e6:	83 c4 10             	add    $0x10,%esp
c00008e9:	01 45 f0             	add    %eax,-0x10(%ebp)


                            }
                            break;
c00008ec:	eb 0a                	jmp    c00008f8 <kprintf+0x479>
                        default:
                            return -1; //invalid length mod
c00008ee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00008f3:	e9 5a 06 00 00       	jmp    c0000f52 <kprintf+0xad3>
                            break;
c00008f8:	90                   	nop
                    }
                    break;
c00008f9:	e9 1e 06 00 00       	jmp    c0000f1c <kprintf+0xa9d>
c00008fe:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000902:	0f 87 03 02 00 00    	ja     c0000b0b <kprintf+0x68c>
                        case(SHORTINT):
                        case(LONGINT):
                        case(LONGLONGINT):
                        case(DEFAULT):
                            {
                                unsigned int base = 10;
c0000908:	c7 45 c8 0a 00 00 00 	movl   $0xa,-0x38(%ebp)
                                unsigned int ui_value;
                                if(length_mod == LONGLONGINT)
c000090f:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000913:	75 19                	jne    c000092e <kprintf+0x4af>
                                    ui_value = (unsigned int) va_arg(valist, long long unsigned int); //TODO: implement actual longlong handling
c0000915:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c000091b:	8d 50 08             	lea    0x8(%eax),%edx
c000091e:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000924:	8b 50 04             	mov    0x4(%eax),%edx
c0000927:	8b 00                	mov    (%eax),%eax
c0000929:	89 45 c4             	mov    %eax,-0x3c(%ebp)
c000092c:	eb 14                	jmp    c0000942 <kprintf+0x4c3>
                                else
                                    ui_value = va_arg(valist, unsigned int);
c000092e:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000934:	8d 50 04             	lea    0x4(%eax),%edx
c0000937:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c000093d:	8b 00                	mov    (%eax),%eax
c000093f:	89 45 c4             	mov    %eax,-0x3c(%ebp)

                                if(*f == 'o')
c0000942:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000945:	0f b6 00             	movzbl (%eax),%eax
c0000948:	3c 6f                	cmp    $0x6f,%al
c000094a:	75 09                	jne    c0000955 <kprintf+0x4d6>
                                    base = 8;
c000094c:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
c0000953:	eb 3e                	jmp    c0000993 <kprintf+0x514>
                                else if(*f == 'x' || *f == 'X')
c0000955:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000958:	0f b6 00             	movzbl (%eax),%eax
c000095b:	3c 78                	cmp    $0x78,%al
c000095d:	74 0a                	je     c0000969 <kprintf+0x4ea>
c000095f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000962:	0f b6 00             	movzbl (%eax),%eax
c0000965:	3c 58                	cmp    $0x58,%al
c0000967:	75 09                	jne    c0000972 <kprintf+0x4f3>
                                    base = 16;
c0000969:	c7 45 c8 10 00 00 00 	movl   $0x10,-0x38(%ebp)
c0000970:	eb 21                	jmp    c0000993 <kprintf+0x514>
                                else if(*f == 'p')
c0000972:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000975:	0f b6 00             	movzbl (%eax),%eax
c0000978:	3c 70                	cmp    $0x70,%al
c000097a:	75 10                	jne    c000098c <kprintf+0x50d>
                                {
                                    //print as hex with 0x prefix
                                    base = 16;
c000097c:	c7 45 c8 10 00 00 00 	movl   $0x10,-0x38(%ebp)
                                    flags.alt = 1; 
c0000983:	c6 85 77 ff ff ff 01 	movb   $0x1,-0x89(%ebp)
c000098a:	eb 07                	jmp    c0000993 <kprintf+0x514>
                                }
                                else
                                    flags.alt = 0;
c000098c:	c6 85 77 ff ff ff 00 	movb   $0x0,-0x89(%ebp)
                                
                                int cap = (*f == 'X') ? 1 : 0;
c0000993:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000996:	0f b6 00             	movzbl (%eax),%eax
c0000999:	3c 58                	cmp    $0x58,%al
c000099b:	0f 94 c0             	sete   %al
c000099e:	0f b6 c0             	movzbl %al,%eax
c00009a1:	89 45 94             	mov    %eax,-0x6c(%ebp)

                                //convert value into string
                                int len = format_uint(ui_value, val_buf, base, field_prec, cap);
c00009a4:	83 ec 0c             	sub    $0xc,%esp
c00009a7:	ff 75 94             	pushl  -0x6c(%ebp)
c00009aa:	ff 75 e0             	pushl  -0x20(%ebp)
c00009ad:	ff 75 c8             	pushl  -0x38(%ebp)
c00009b0:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c00009b6:	50                   	push   %eax
c00009b7:	ff 75 c4             	pushl  -0x3c(%ebp)
c00009ba:	e8 95 05 00 00       	call   c0000f54 <format_uint>
c00009bf:	83 c4 20             	add    $0x20,%esp
c00009c2:	89 45 90             	mov    %eax,-0x70(%ebp)
                                //amount of padding required to meet requested width
                                int lenpad = field_width - len; 
c00009c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00009c8:	2b 45 90             	sub    -0x70(%ebp),%eax
c00009cb:	89 45 c0             	mov    %eax,-0x40(%ebp)


                                //format radix prefix for oct and hex with alt flag
                                char radix[3]="";
c00009ce:	66 c7 85 74 ff ff ff 	movw   $0x0,-0x8c(%ebp)
c00009d5:	00 00 
c00009d7:	c6 85 76 ff ff ff 00 	movb   $0x0,-0x8a(%ebp)
                                if(flags.alt)
c00009de:	0f b6 85 77 ff ff ff 	movzbl -0x89(%ebp),%eax
c00009e5:	84 c0                	test   %al,%al
c00009e7:	74 75                	je     c0000a5e <kprintf+0x5df>
                                {
                                    if(base==16)
c00009e9:	83 7d c8 10          	cmpl   $0x10,-0x38(%ebp)
c00009ed:	75 2c                	jne    c0000a1b <kprintf+0x59c>
                                    {
                                        lenpad -= 2;
c00009ef:	83 6d c0 02          	subl   $0x2,-0x40(%ebp)
                                        radix[0] = '0';
c00009f3:	c6 85 74 ff ff ff 30 	movb   $0x30,-0x8c(%ebp)
                                        radix[1] = cap ? 'X' : 'x';
c00009fa:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
c00009fe:	74 07                	je     c0000a07 <kprintf+0x588>
c0000a00:	b8 58 00 00 00       	mov    $0x58,%eax
c0000a05:	eb 05                	jmp    c0000a0c <kprintf+0x58d>
c0000a07:	b8 78 00 00 00       	mov    $0x78,%eax
c0000a0c:	88 85 75 ff ff ff    	mov    %al,-0x8b(%ebp)
                                        radix[2] = 0;
c0000a12:	c6 85 76 ff ff ff 00 	movb   $0x0,-0x8a(%ebp)
c0000a19:	eb 23                	jmp    c0000a3e <kprintf+0x5bf>
                                    }
                                    else if(base==8 && val_buf[0] != '0')
c0000a1b:	83 7d c8 08          	cmpl   $0x8,-0x38(%ebp)
c0000a1f:	75 1d                	jne    c0000a3e <kprintf+0x5bf>
c0000a21:	0f b6 85 74 fd ff ff 	movzbl -0x28c(%ebp),%eax
c0000a28:	3c 30                	cmp    $0x30,%al
c0000a2a:	74 12                	je     c0000a3e <kprintf+0x5bf>
                                    {
                                        lenpad -= 1;
c0000a2c:	83 6d c0 01          	subl   $0x1,-0x40(%ebp)
                                        radix[0] = '0';
c0000a30:	c6 85 74 ff ff ff 30 	movb   $0x30,-0x8c(%ebp)
                                        radix[1] = 0;
c0000a37:	c6 85 75 ff ff ff 00 	movb   $0x0,-0x8b(%ebp)
                                    }

                                    //if zero padding, radix is printed first
                                    if(flags.zero)
c0000a3e:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000a45:	84 c0                	test   %al,%al
c0000a47:	74 15                	je     c0000a5e <kprintf+0x5df>
                                        nchar += kprint(radix);
c0000a49:	83 ec 0c             	sub    $0xc,%esp
c0000a4c:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
c0000a52:	50                   	push   %eax
c0000a53:	e8 8c f9 ff ff       	call   c00003e4 <kprint>
c0000a58:	83 c4 10             	add    $0x10,%esp
c0000a5b:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }


                                //print leading padding, if any
                                if(!flags.left && lenpad>0)
c0000a5e:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000a65:	84 c0                	test   %al,%al
c0000a67:	75 3b                	jne    c0000aa4 <kprintf+0x625>
c0000a69:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
c0000a6d:	7e 35                	jle    c0000aa4 <kprintf+0x625>
                                {
                                    if(flags.zero)
c0000a6f:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000a76:	84 c0                	test   %al,%al
c0000a78:	74 16                	je     c0000a90 <kprintf+0x611>
                                        nchar += kprintn_char('0', lenpad);
c0000a7a:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000a7d:	83 ec 08             	sub    $0x8,%esp
c0000a80:	50                   	push   %eax
c0000a81:	6a 30                	push   $0x30
c0000a83:	e8 ce f9 ff ff       	call   c0000456 <kprintn_char>
c0000a88:	83 c4 10             	add    $0x10,%esp
c0000a8b:	01 45 f0             	add    %eax,-0x10(%ebp)
c0000a8e:	eb 14                	jmp    c0000aa4 <kprintf+0x625>
                                    else
                                        nchar += kprintn_char(' ', lenpad);
c0000a90:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000a93:	83 ec 08             	sub    $0x8,%esp
c0000a96:	50                   	push   %eax
c0000a97:	6a 20                	push   $0x20
c0000a99:	e8 b8 f9 ff ff       	call   c0000456 <kprintn_char>
c0000a9e:	83 c4 10             	add    $0x10,%esp
c0000aa1:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                //print radix prefix if valid and not leading zeros
                                if(!flags.zero && radix[0])
c0000aa4:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000aab:	84 c0                	test   %al,%al
c0000aad:	75 20                	jne    c0000acf <kprintf+0x650>
c0000aaf:	0f b6 85 74 ff ff ff 	movzbl -0x8c(%ebp),%eax
c0000ab6:	84 c0                	test   %al,%al
c0000ab8:	74 15                	je     c0000acf <kprintf+0x650>
                                    nchar += kprint(radix);
c0000aba:	83 ec 0c             	sub    $0xc,%esp
c0000abd:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
c0000ac3:	50                   	push   %eax
c0000ac4:	e8 1b f9 ff ff       	call   c00003e4 <kprint>
c0000ac9:	83 c4 10             	add    $0x10,%esp
c0000acc:	01 45 f0             	add    %eax,-0x10(%ebp)

                                //print number itself
                                nchar += kprint(val_buf);
c0000acf:	83 ec 0c             	sub    $0xc,%esp
c0000ad2:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000ad8:	50                   	push   %eax
c0000ad9:	e8 06 f9 ff ff       	call   c00003e4 <kprint>
c0000ade:	83 c4 10             	add    $0x10,%esp
c0000ae1:	01 45 f0             	add    %eax,-0x10(%ebp)

                                //print trailing padding if left justified
                                if(flags.left && lenpad>0)
c0000ae4:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000aeb:	84 c0                	test   %al,%al
c0000aed:	74 26                	je     c0000b15 <kprintf+0x696>
c0000aef:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
c0000af3:	7e 20                	jle    c0000b15 <kprintf+0x696>
                                    nchar += kprintn_char(' ', lenpad);
c0000af5:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000af8:	83 ec 08             	sub    $0x8,%esp
c0000afb:	50                   	push   %eax
c0000afc:	6a 20                	push   $0x20
c0000afe:	e8 53 f9 ff ff       	call   c0000456 <kprintn_char>
c0000b03:	83 c4 10             	add    $0x10,%esp
c0000b06:	01 45 f0             	add    %eax,-0x10(%ebp)

                            }
                            break;
c0000b09:	eb 0a                	jmp    c0000b15 <kprintf+0x696>
                        default:
                            return -1; //invalid length mod
c0000b0b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000b10:	e9 3d 04 00 00       	jmp    c0000f52 <kprintf+0xad3>
                            break;
c0000b15:	90                   	nop
                    }

                    break;
c0000b16:	e9 01 04 00 00       	jmp    c0000f1c <kprintf+0xa9d>

                case 'f':
                case 'F':
                    {
                        float f_value = (float) va_arg(valist, double);
c0000b1b:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000b21:	8d 50 08             	lea    0x8(%eax),%edx
c0000b24:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000b2a:	dd 00                	fldl   (%eax)
c0000b2c:	d9 5d 8c             	fstps  -0x74(%ebp)

                        //When 0 is printed with an explicit precision 0, the output is empty.
                        if(f_value==0 && field_prec==0)
c0000b2f:	d9 45 8c             	flds   -0x74(%ebp)
c0000b32:	d9 ee                	fldz   
c0000b34:	df e9                	fucomip %st(1),%st
c0000b36:	dd d8                	fstp   %st(0)
c0000b38:	7a 15                	jp     c0000b4f <kprintf+0x6d0>
c0000b3a:	d9 45 8c             	flds   -0x74(%ebp)
c0000b3d:	d9 ee                	fldz   
c0000b3f:	df e9                	fucomip %st(1),%st
c0000b41:	dd d8                	fstp   %st(0)
c0000b43:	75 0a                	jne    c0000b4f <kprintf+0x6d0>
c0000b45:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000b49:	0f 84 c3 03 00 00    	je     c0000f12 <kprintf+0xa93>
                            break;
                        if(field_prec<0) field_prec = 6;  //default is prec = 6
c0000b4f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000b53:	79 07                	jns    c0000b5c <kprintf+0x6dd>
c0000b55:	c7 45 e0 06 00 00 00 	movl   $0x6,-0x20(%ebp)

                        unsigned int ui_part;
                        char sign_char = 0;
c0000b5c:	c6 45 bb 00          	movb   $0x0,-0x45(%ebp)
                        if(f_value<0)
c0000b60:	d9 45 8c             	flds   -0x74(%ebp)
c0000b63:	d9 ee                	fldz   
c0000b65:	df f1                	fcomip %st(1),%st
c0000b67:	dd d8                	fstp   %st(0)
c0000b69:	76 3d                	jbe    c0000ba8 <kprintf+0x729>
                        {
                            ui_part = (unsigned int) -f_value;
c0000b6b:	d9 45 8c             	flds   -0x74(%ebp)
c0000b6e:	d9 e0                	fchs   
c0000b70:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c0000b76:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c0000b7d:	80 cc 0c             	or     $0xc,%ah
c0000b80:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c0000b87:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c0000b8d:	df bd 58 fd ff ff    	fistpll -0x2a8(%ebp)
c0000b93:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
c0000b99:	8b 85 58 fd ff ff    	mov    -0x2a8(%ebp),%eax
c0000b9f:	89 45 bc             	mov    %eax,-0x44(%ebp)
                            sign_char = '-';
c0000ba2:	c6 45 bb 2d          	movb   $0x2d,-0x45(%ebp)
c0000ba6:	eb 55                	jmp    c0000bfd <kprintf+0x77e>
                        }
                        else
                        {
                            ui_part = (unsigned int) f_value;
c0000ba8:	d9 45 8c             	flds   -0x74(%ebp)
c0000bab:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c0000bb1:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c0000bb8:	80 cc 0c             	or     $0xc,%ah
c0000bbb:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c0000bc2:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c0000bc8:	df bd 58 fd ff ff    	fistpll -0x2a8(%ebp)
c0000bce:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
c0000bd4:	8b 85 58 fd ff ff    	mov    -0x2a8(%ebp),%eax
c0000bda:	89 45 bc             	mov    %eax,-0x44(%ebp)
                            if(flags.sign)
c0000bdd:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c0000be4:	84 c0                	test   %al,%al
c0000be6:	74 06                	je     c0000bee <kprintf+0x76f>
                                sign_char = '+';
c0000be8:	c6 45 bb 2b          	movb   $0x2b,-0x45(%ebp)
c0000bec:	eb 0f                	jmp    c0000bfd <kprintf+0x77e>
                            else if(flags.space)
c0000bee:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c0000bf5:	84 c0                	test   %al,%al
c0000bf7:	74 04                	je     c0000bfd <kprintf+0x77e>
                                sign_char = ' ';
c0000bf9:	c6 45 bb 20          	movb   $0x20,-0x45(%ebp)
                            
                            //else positive number has no sign character
                        }

                        int int_len = format_uint(ui_part,val_buf,10,-1,0);
c0000bfd:	83 ec 0c             	sub    $0xc,%esp
c0000c00:	6a 00                	push   $0x0
c0000c02:	6a ff                	push   $0xffffffff
c0000c04:	6a 0a                	push   $0xa
c0000c06:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000c0c:	50                   	push   %eax
c0000c0d:	ff 75 bc             	pushl  -0x44(%ebp)
c0000c10:	e8 3f 03 00 00       	call   c0000f54 <format_uint>
c0000c15:	83 c4 20             	add    $0x20,%esp
c0000c18:	89 45 88             	mov    %eax,-0x78(%ebp)

                        int f_len = int_len + 1 + field_prec;
c0000c1b:	8b 45 88             	mov    -0x78(%ebp),%eax
c0000c1e:	8d 50 01             	lea    0x1(%eax),%edx
c0000c21:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0000c24:	01 d0                	add    %edx,%eax
c0000c26:	89 45 84             	mov    %eax,-0x7c(%ebp)

                        //amount of padding required to meet requested width
                        int lenpad = field_width - f_len; 
c0000c29:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000c2c:	2b 45 84             	sub    -0x7c(%ebp),%eax
c0000c2f:	89 45 b4             	mov    %eax,-0x4c(%ebp)

                        if(sign_char)
c0000c32:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
c0000c36:	74 22                	je     c0000c5a <kprintf+0x7db>
                        {
                            lenpad--; //remove one char of padding to account for sign
c0000c38:	83 6d b4 01          	subl   $0x1,-0x4c(%ebp)
                            if(flags.zero)
c0000c3c:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000c43:	84 c0                	test   %al,%al
c0000c45:	74 13                	je     c0000c5a <kprintf+0x7db>
                                nchar += kprint_char(sign_char); //if zero padding, sign is at beginning
c0000c47:	0f be 45 bb          	movsbl -0x45(%ebp),%eax
c0000c4b:	83 ec 0c             	sub    $0xc,%esp
c0000c4e:	50                   	push   %eax
c0000c4f:	e8 da f7 ff ff       	call   c000042e <kprint_char>
c0000c54:	83 c4 10             	add    $0x10,%esp
c0000c57:	01 45 f0             	add    %eax,-0x10(%ebp)
                        }

                        if(!flags.left && lenpad>0)
c0000c5a:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000c61:	84 c0                	test   %al,%al
c0000c63:	75 3b                	jne    c0000ca0 <kprintf+0x821>
c0000c65:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
c0000c69:	7e 35                	jle    c0000ca0 <kprintf+0x821>
                        {
                            if(flags.zero)
c0000c6b:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000c72:	84 c0                	test   %al,%al
c0000c74:	74 16                	je     c0000c8c <kprintf+0x80d>
                                nchar += kprintn_char('0', lenpad);
c0000c76:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c0000c79:	83 ec 08             	sub    $0x8,%esp
c0000c7c:	50                   	push   %eax
c0000c7d:	6a 30                	push   $0x30
c0000c7f:	e8 d2 f7 ff ff       	call   c0000456 <kprintn_char>
c0000c84:	83 c4 10             	add    $0x10,%esp
c0000c87:	01 45 f0             	add    %eax,-0x10(%ebp)
c0000c8a:	eb 14                	jmp    c0000ca0 <kprintf+0x821>
                            else
                                nchar += kprintn_char(' ', lenpad);
c0000c8c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c0000c8f:	83 ec 08             	sub    $0x8,%esp
c0000c92:	50                   	push   %eax
c0000c93:	6a 20                	push   $0x20
c0000c95:	e8 bc f7 ff ff       	call   c0000456 <kprintn_char>
c0000c9a:	83 c4 10             	add    $0x10,%esp
c0000c9d:	01 45 f0             	add    %eax,-0x10(%ebp)
                        }

                        if(!flags.zero && sign_char)
c0000ca0:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000ca7:	84 c0                	test   %al,%al
c0000ca9:	75 19                	jne    c0000cc4 <kprintf+0x845>
c0000cab:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
c0000caf:	74 13                	je     c0000cc4 <kprintf+0x845>
                            nchar += kprint_char(sign_char); //if not zero padding, write sign here
c0000cb1:	0f be 45 bb          	movsbl -0x45(%ebp),%eax
c0000cb5:	83 ec 0c             	sub    $0xc,%esp
c0000cb8:	50                   	push   %eax
c0000cb9:	e8 70 f7 ff ff       	call   c000042e <kprint_char>
c0000cbe:	83 c4 10             	add    $0x10,%esp
c0000cc1:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprint(val_buf);
c0000cc4:	83 ec 0c             	sub    $0xc,%esp
c0000cc7:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000ccd:	50                   	push   %eax
c0000cce:	e8 11 f7 ff ff       	call   c00003e4 <kprint>
c0000cd3:	83 c4 10             	add    $0x10,%esp
c0000cd6:	01 45 f0             	add    %eax,-0x10(%ebp)
                        nchar += kprint_char('.');
c0000cd9:	83 ec 0c             	sub    $0xc,%esp
c0000cdc:	6a 2e                	push   $0x2e
c0000cde:	e8 4b f7 ff ff       	call   c000042e <kprint_char>
c0000ce3:	83 c4 10             	add    $0x10,%esp
c0000ce6:	01 45 f0             	add    %eax,-0x10(%ebp)

                        //compute fractional digits.
                        float frac = f_value<0 ? -f_value - ui_part : f_value - ui_part;
c0000ce9:	d9 45 8c             	flds   -0x74(%ebp)
c0000cec:	d9 ee                	fldz   
c0000cee:	df f1                	fcomip %st(1),%st
c0000cf0:	dd d8                	fstp   %st(0)
c0000cf2:	76 23                	jbe    c0000d17 <kprintf+0x898>
c0000cf4:	d9 45 8c             	flds   -0x74(%ebp)
c0000cf7:	d9 e0                	fchs   
c0000cf9:	8b 45 bc             	mov    -0x44(%ebp),%eax
c0000cfc:	ba 00 00 00 00       	mov    $0x0,%edx
c0000d01:	89 85 58 fd ff ff    	mov    %eax,-0x2a8(%ebp)
c0000d07:	89 95 5c fd ff ff    	mov    %edx,-0x2a4(%ebp)
c0000d0d:	df ad 58 fd ff ff    	fildll -0x2a8(%ebp)
c0000d13:	de e9                	fsubrp %st,%st(1)
c0000d15:	eb 1f                	jmp    c0000d36 <kprintf+0x8b7>
c0000d17:	8b 45 bc             	mov    -0x44(%ebp),%eax
c0000d1a:	ba 00 00 00 00       	mov    $0x0,%edx
c0000d1f:	89 85 58 fd ff ff    	mov    %eax,-0x2a8(%ebp)
c0000d25:	89 95 5c fd ff ff    	mov    %edx,-0x2a4(%ebp)
c0000d2b:	df ad 58 fd ff ff    	fildll -0x2a8(%ebp)
c0000d31:	d9 45 8c             	flds   -0x74(%ebp)
c0000d34:	de e1                	fsubp  %st,%st(1)
c0000d36:	d9 5d b0             	fstps  -0x50(%ebp)
                        int d;
                        for(int nn=0;nn<field_prec; nn++)
c0000d39:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
c0000d40:	eb 5e                	jmp    c0000da0 <kprintf+0x921>
                        {
                            frac *= 10.;
c0000d42:	d9 45 b0             	flds   -0x50(%ebp)
c0000d45:	d9 05 1c 34 00 c0    	flds   0xc000341c
c0000d4b:	de c9                	fmulp  %st,%st(1)
c0000d4d:	d9 5d b0             	fstps  -0x50(%ebp)
                            d = (int) frac;
c0000d50:	d9 45 b0             	flds   -0x50(%ebp)
c0000d53:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c0000d59:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c0000d60:	80 cc 0c             	or     $0xc,%ah
c0000d63:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c0000d6a:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c0000d70:	db 5d 80             	fistpl -0x80(%ebp)
c0000d73:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
                            frac -= d;
c0000d79:	db 45 80             	fildl  -0x80(%ebp)
c0000d7c:	d9 45 b0             	flds   -0x50(%ebp)
c0000d7f:	de e1                	fsubp  %st,%st(1)
c0000d81:	d9 5d b0             	fstps  -0x50(%ebp)
                            nchar += kprint_char('0' + d);
c0000d84:	8b 45 80             	mov    -0x80(%ebp),%eax
c0000d87:	83 c0 30             	add    $0x30,%eax
c0000d8a:	0f be c0             	movsbl %al,%eax
c0000d8d:	83 ec 0c             	sub    $0xc,%esp
c0000d90:	50                   	push   %eax
c0000d91:	e8 98 f6 ff ff       	call   c000042e <kprint_char>
c0000d96:	83 c4 10             	add    $0x10,%esp
c0000d99:	01 45 f0             	add    %eax,-0x10(%ebp)
                        for(int nn=0;nn<field_prec; nn++)
c0000d9c:	83 45 ac 01          	addl   $0x1,-0x54(%ebp)
c0000da0:	8b 45 ac             	mov    -0x54(%ebp),%eax
c0000da3:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c0000da6:	7c 9a                	jl     c0000d42 <kprintf+0x8c3>
                        }

                        if(flags.left && lenpad>0)
c0000da8:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000daf:	84 c0                	test   %al,%al
c0000db1:	0f 84 5e 01 00 00    	je     c0000f15 <kprintf+0xa96>
c0000db7:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
c0000dbb:	0f 8e 54 01 00 00    	jle    c0000f15 <kprintf+0xa96>
                            nchar += kprintn_char(' ', lenpad);
c0000dc1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c0000dc4:	83 ec 08             	sub    $0x8,%esp
c0000dc7:	50                   	push   %eax
c0000dc8:	6a 20                	push   $0x20
c0000dca:	e8 87 f6 ff ff       	call   c0000456 <kprintn_char>
c0000dcf:	83 c4 10             	add    $0x10,%esp
c0000dd2:	01 45 f0             	add    %eax,-0x10(%ebp)

                    }
                    break;
c0000dd5:	e9 3b 01 00 00       	jmp    c0000f15 <kprintf+0xa96>
                case 'e':
                case 'E':
                case 'g':
                case 'G':
                    return -1; // not yet implemented
c0000dda:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000ddf:	e9 6e 01 00 00       	jmp    c0000f52 <kprintf+0xad3>
                case 'c':
                    {
                        char c = (char) va_arg(valist, int);
c0000de4:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000dea:	8d 50 04             	lea    0x4(%eax),%edx
c0000ded:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000df3:	8b 00                	mov    (%eax),%eax
c0000df5:	88 45 9b             	mov    %al,-0x65(%ebp)

                        if(field_width>1 && !flags.left)    
c0000df8:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
c0000dfc:	7e 22                	jle    c0000e20 <kprintf+0x9a1>
c0000dfe:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000e05:	84 c0                	test   %al,%al
c0000e07:	75 17                	jne    c0000e20 <kprintf+0x9a1>
                            nchar += kprintn_char(' ', field_width-1);
c0000e09:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000e0c:	83 e8 01             	sub    $0x1,%eax
c0000e0f:	83 ec 08             	sub    $0x8,%esp
c0000e12:	50                   	push   %eax
c0000e13:	6a 20                	push   $0x20
c0000e15:	e8 3c f6 ff ff       	call   c0000456 <kprintn_char>
c0000e1a:	83 c4 10             	add    $0x10,%esp
c0000e1d:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprint_char(c);
c0000e20:	0f be 45 9b          	movsbl -0x65(%ebp),%eax
c0000e24:	83 ec 0c             	sub    $0xc,%esp
c0000e27:	50                   	push   %eax
c0000e28:	e8 01 f6 ff ff       	call   c000042e <kprint_char>
c0000e2d:	83 c4 10             	add    $0x10,%esp
c0000e30:	01 45 f0             	add    %eax,-0x10(%ebp)

                        if(field_width>1 && flags.left)    
c0000e33:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
c0000e37:	0f 8e db 00 00 00    	jle    c0000f18 <kprintf+0xa99>
c0000e3d:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000e44:	84 c0                	test   %al,%al
c0000e46:	0f 84 cc 00 00 00    	je     c0000f18 <kprintf+0xa99>
                            nchar += kprintn_char(' ', field_width-1);
c0000e4c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000e4f:	83 e8 01             	sub    $0x1,%eax
c0000e52:	83 ec 08             	sub    $0x8,%esp
c0000e55:	50                   	push   %eax
c0000e56:	6a 20                	push   $0x20
c0000e58:	e8 f9 f5 ff ff       	call   c0000456 <kprintn_char>
c0000e5d:	83 c4 10             	add    $0x10,%esp
c0000e60:	01 45 f0             	add    %eax,-0x10(%ebp)
                    }                    
                    break;
c0000e63:	e9 b0 00 00 00       	jmp    c0000f18 <kprintf+0xa99>

                case 's':
                    {
                        char* str = va_arg(valist, char*);
c0000e68:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000e6e:	8d 50 04             	lea    0x4(%eax),%edx
c0000e71:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000e77:	8b 00                	mov    (%eax),%eax
c0000e79:	89 45 a4             	mov    %eax,-0x5c(%ebp)
                        int len = strlen(str);
c0000e7c:	83 ec 0c             	sub    $0xc,%esp
c0000e7f:	ff 75 a4             	pushl  -0x5c(%ebp)
c0000e82:	e8 15 04 00 00       	call   c000129c <strlen>
c0000e87:	83 c4 10             	add    $0x10,%esp
c0000e8a:	89 45 a8             	mov    %eax,-0x58(%ebp)
                        if(field_prec > 0 && field_prec < len)
c0000e8d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000e91:	7e 0e                	jle    c0000ea1 <kprintf+0xa22>
c0000e93:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0000e96:	3b 45 a8             	cmp    -0x58(%ebp),%eax
c0000e99:	7d 06                	jge    c0000ea1 <kprintf+0xa22>
                            len = field_prec;
c0000e9b:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0000e9e:	89 45 a8             	mov    %eax,-0x58(%ebp)

                        int lenpad = field_width - len; 
c0000ea1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000ea4:	2b 45 a8             	sub    -0x58(%ebp),%eax
c0000ea7:	89 45 a0             	mov    %eax,-0x60(%ebp)

                        if(lenpad>0 && !flags.left)    
c0000eaa:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
c0000eae:	7e 1f                	jle    c0000ecf <kprintf+0xa50>
c0000eb0:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000eb7:	84 c0                	test   %al,%al
c0000eb9:	75 14                	jne    c0000ecf <kprintf+0xa50>
                            nchar += kprintn_char(' ', lenpad);
c0000ebb:	8b 45 a0             	mov    -0x60(%ebp),%eax
c0000ebe:	83 ec 08             	sub    $0x8,%esp
c0000ec1:	50                   	push   %eax
c0000ec2:	6a 20                	push   $0x20
c0000ec4:	e8 8d f5 ff ff       	call   c0000456 <kprintn_char>
c0000ec9:	83 c4 10             	add    $0x10,%esp
c0000ecc:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprintn(str,len);
c0000ecf:	8b 45 a8             	mov    -0x58(%ebp),%eax
c0000ed2:	83 ec 08             	sub    $0x8,%esp
c0000ed5:	50                   	push   %eax
c0000ed6:	ff 75 a4             	pushl  -0x5c(%ebp)
c0000ed9:	e8 2f f5 ff ff       	call   c000040d <kprintn>
c0000ede:	83 c4 10             	add    $0x10,%esp
c0000ee1:	01 45 f0             	add    %eax,-0x10(%ebp)

                        if(lenpad>0 && flags.left)
c0000ee4:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
c0000ee8:	7e 31                	jle    c0000f1b <kprintf+0xa9c>
c0000eea:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000ef1:	84 c0                	test   %al,%al
c0000ef3:	74 26                	je     c0000f1b <kprintf+0xa9c>
                            nchar += kprintn_char(' ', lenpad);
c0000ef5:	8b 45 a0             	mov    -0x60(%ebp),%eax
c0000ef8:	83 ec 08             	sub    $0x8,%esp
c0000efb:	50                   	push   %eax
c0000efc:	6a 20                	push   $0x20
c0000efe:	e8 53 f5 ff ff       	call   c0000456 <kprintn_char>
c0000f03:	83 c4 10             	add    $0x10,%esp
c0000f06:	01 45 f0             	add    %eax,-0x10(%ebp)
                        
                    }
                    break;
c0000f09:	eb 10                	jmp    c0000f1b <kprintf+0xa9c>
                default:
                    //unsupported type
                    return -1;
c0000f0b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000f10:	eb 40                	jmp    c0000f52 <kprintf+0xad3>
                            break;
c0000f12:	90                   	nop
c0000f13:	eb 07                	jmp    c0000f1c <kprintf+0xa9d>
                    break;
c0000f15:	90                   	nop
c0000f16:	eb 04                	jmp    c0000f1c <kprintf+0xa9d>
                    break;
c0000f18:	90                   	nop
c0000f19:	eb 01                	jmp    c0000f1c <kprintf+0xa9d>
                    break;
c0000f1b:	90                   	nop
                
            }
            f++;
c0000f1c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0000f20:	eb 1f                	jmp    c0000f41 <kprintf+0xac2>
        }
        else
        {
            //this isnt part of a format code, just copy char to string and increment pointers
            kprint_char(*(f++));
c0000f22:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000f25:	8d 50 01             	lea    0x1(%eax),%edx
c0000f28:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0000f2b:	0f b6 00             	movzbl (%eax),%eax
c0000f2e:	0f be c0             	movsbl %al,%eax
c0000f31:	83 ec 0c             	sub    $0xc,%esp
c0000f34:	50                   	push   %eax
c0000f35:	e8 f4 f4 ff ff       	call   c000042e <kprint_char>
c0000f3a:	83 c4 10             	add    $0x10,%esp
            nchar++;
c0000f3d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    while(f[0] != 0)
c0000f41:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000f44:	0f b6 00             	movzbl (%eax),%eax
c0000f47:	84 c0                	test   %al,%al
c0000f49:	0f 85 54 f5 ff ff    	jne    c00004a3 <kprintf+0x24>
    }

   /* clean memory reserved for valist */
   va_end(valist);

   return nchar; //number of characters copied to str
c0000f4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0000f52:	c9                   	leave  
c0000f53:	c3                   	ret    

c0000f54 <format_uint>:
// base may be 2-32
// precision is per printf format, precision<0 represents default (unspecified) 
// cap = 0, alpha-numbers are capitalized [base>10 only]
// returns length of string (not counting null termination)
int format_uint(unsigned int value, char* str, unsigned int base, int precision, int cap)
{
c0000f54:	55                   	push   %ebp
c0000f55:	89 e5                	mov    %esp,%ebp
c0000f57:	83 ec 18             	sub    $0x18,%esp
    if(base < 2 || base > 32)
c0000f5a:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c0000f5e:	76 06                	jbe    c0000f66 <format_uint+0x12>
c0000f60:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
c0000f64:	76 0a                	jbe    c0000f70 <format_uint+0x1c>
        return -1;
c0000f66:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000f6b:	e9 d1 00 00 00       	jmp    c0001041 <format_uint+0xed>

    //When 0 is printed with an explicit precision 0, the output is empty.
    if(value==0 && precision==0)
c0000f70:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0000f74:	75 16                	jne    c0000f8c <format_uint+0x38>
c0000f76:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c0000f7a:	75 10                	jne    c0000f8c <format_uint+0x38>
    {
        str[0] = 0;
c0000f7c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000f7f:	c6 00 00             	movb   $0x0,(%eax)
        return 0;
c0000f82:	b8 00 00 00 00       	mov    $0x0,%eax
c0000f87:	e9 b5 00 00 00       	jmp    c0001041 <format_uint+0xed>
    }

    // find number of digits
    int num_digits = numdigits_uint(value, base);
c0000f8c:	83 ec 08             	sub    $0x8,%esp
c0000f8f:	ff 75 10             	pushl  0x10(%ebp)
c0000f92:	ff 75 08             	pushl  0x8(%ebp)
c0000f95:	e8 a9 00 00 00       	call   c0001043 <numdigits_uint>
c0000f9a:	83 c4 10             	add    $0x10,%esp
c0000f9d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    num_digits = num_digits>precision ? num_digits : precision;
c0000fa0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0000fa3:	39 45 14             	cmp    %eax,0x14(%ebp)
c0000fa6:	0f 4d 45 14          	cmovge 0x14(%ebp),%eax
c0000faa:	89 45 ec             	mov    %eax,-0x14(%ebp)

    //write formatted number out in reverse order
    char* s = str + num_digits;
c0000fad:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0000fb0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000fb3:	01 d0                	add    %edx,%eax
c0000fb5:	89 45 f4             	mov    %eax,-0xc(%ebp)

    *(s--) = '\0'; //null termination
c0000fb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000fbb:	8d 50 ff             	lea    -0x1(%eax),%edx
c0000fbe:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0000fc1:	c6 00 00             	movb   $0x0,(%eax)

    //compute each digit from lowest to highest.
    unsigned int d;
    for(int nn=0;nn<num_digits; nn++)
c0000fc4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0000fcb:	eb 69                	jmp    c0001036 <format_uint+0xe2>
    {
        d = value % base;
c0000fcd:	8b 45 08             	mov    0x8(%ebp),%eax
c0000fd0:	ba 00 00 00 00       	mov    $0x0,%edx
c0000fd5:	f7 75 10             	divl   0x10(%ebp)
c0000fd8:	89 55 e8             	mov    %edx,-0x18(%ebp)
        value /= base;
c0000fdb:	8b 45 08             	mov    0x8(%ebp),%eax
c0000fde:	ba 00 00 00 00       	mov    $0x0,%edx
c0000fe3:	f7 75 10             	divl   0x10(%ebp)
c0000fe6:	89 45 08             	mov    %eax,0x8(%ebp)

        //write digit into string and decrement pointer
        if(d < 10)
c0000fe9:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
c0000fed:	77 15                	ja     c0001004 <format_uint+0xb0>
            *(s--) = d + '0';
c0000fef:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000ff2:	8d 48 30             	lea    0x30(%eax),%ecx
c0000ff5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000ff8:	8d 50 ff             	lea    -0x1(%eax),%edx
c0000ffb:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0000ffe:	89 ca                	mov    %ecx,%edx
c0001000:	88 10                	mov    %dl,(%eax)
c0001002:	eb 2e                	jmp    c0001032 <format_uint+0xde>
        else if(cap == 0)
c0001004:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
c0001008:	75 15                	jne    c000101f <format_uint+0xcb>
            *(s--) = d - 10 + 'a';
c000100a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000100d:	8d 48 57             	lea    0x57(%eax),%ecx
c0001010:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001013:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001016:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0001019:	89 ca                	mov    %ecx,%edx
c000101b:	88 10                	mov    %dl,(%eax)
c000101d:	eb 13                	jmp    c0001032 <format_uint+0xde>
        else
            *(s--) = d - 10 + 'A';
c000101f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001022:	8d 48 37             	lea    0x37(%eax),%ecx
c0001025:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001028:	8d 50 ff             	lea    -0x1(%eax),%edx
c000102b:	89 55 f4             	mov    %edx,-0xc(%ebp)
c000102e:	89 ca                	mov    %ecx,%edx
c0001030:	88 10                	mov    %dl,(%eax)
    for(int nn=0;nn<num_digits; nn++)
c0001032:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0001036:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001039:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c000103c:	7c 8f                	jl     c0000fcd <format_uint+0x79>
    }

    return num_digits;
c000103e:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c0001041:	c9                   	leave  
c0001042:	c3                   	ret    

c0001043 <numdigits_uint>:


//returns number of digits of unsigned int represented in given base
//num_digits is always >= 1
unsigned int numdigits_uint(unsigned int value, unsigned int base)
{
c0001043:	55                   	push   %ebp
c0001044:	89 e5                	mov    %esp,%ebp
c0001046:	83 ec 10             	sub    $0x10,%esp
    unsigned int num_digits = 1;
c0001049:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
    while(value >= base)
c0001050:	eb 12                	jmp    c0001064 <numdigits_uint+0x21>
    {
        num_digits++;
c0001052:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        value /= base;
c0001056:	8b 45 08             	mov    0x8(%ebp),%eax
c0001059:	ba 00 00 00 00       	mov    $0x0,%edx
c000105e:	f7 75 0c             	divl   0xc(%ebp)
c0001061:	89 45 08             	mov    %eax,0x8(%ebp)
    while(value >= base)
c0001064:	8b 45 08             	mov    0x8(%ebp),%eax
c0001067:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000106a:	73 e6                	jae    c0001052 <numdigits_uint+0xf>
    }
    return num_digits;
c000106c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c000106f:	c9                   	leave  
c0001070:	c3                   	ret    

c0001071 <kprintf_test>:



void kprintf_test()
{
c0001071:	55                   	push   %ebp
c0001072:	89 e5                	mov    %esp,%ebp
c0001074:	83 ec 18             	sub    $0x18,%esp
    int num = 12345678;    
c0001077:	c7 45 f4 4e 61 bc 00 	movl   $0xbc614e,-0xc(%ebp)
    kprintf("\nkprintf() tests...\n", num);
c000107e:	83 ec 08             	sub    $0x8,%esp
c0001081:	ff 75 f4             	pushl  -0xc(%ebp)
c0001084:	68 d0 31 00 c0       	push   $0xc00031d0
c0001089:	e8 f1 f3 ff ff       	call   c000047f <kprintf>
c000108e:	83 c4 10             	add    $0x10,%esp
    kprintf("Fixed width, right justify:\n");
c0001091:	83 ec 0c             	sub    $0xc,%esp
c0001094:	68 e5 31 00 c0       	push   $0xc00031e5
c0001099:	e8 e1 f3 ff ff       	call   c000047f <kprintf>
c000109e:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%15d]\n", num);
c00010a1:	83 ec 08             	sub    $0x8,%esp
c00010a4:	ff 75 f4             	pushl  -0xc(%ebp)
c00010a7:	68 02 32 00 c0       	push   $0xc0003202
c00010ac:	e8 ce f3 ff ff       	call   c000047f <kprintf>
c00010b1:	83 c4 10             	add    $0x10,%esp
    kprintf("Hex:     [%#15x]\n", num);
c00010b4:	83 ec 08             	sub    $0x8,%esp
c00010b7:	ff 75 f4             	pushl  -0xc(%ebp)
c00010ba:	68 13 32 00 c0       	push   $0xc0003213
c00010bf:	e8 bb f3 ff ff       	call   c000047f <kprintf>
c00010c4:	83 c4 10             	add    $0x10,%esp
    kprintf("Oct:     [%#15o]\n", num);
c00010c7:	83 ec 08             	sub    $0x8,%esp
c00010ca:	ff 75 f4             	pushl  -0xc(%ebp)
c00010cd:	68 25 32 00 c0       	push   $0xc0003225
c00010d2:	e8 a8 f3 ff ff       	call   c000047f <kprintf>
c00010d7:	83 c4 10             	add    $0x10,%esp
    kprintf("String:  [%15s]\n", "Hello World!");
c00010da:	83 ec 08             	sub    $0x8,%esp
c00010dd:	68 37 32 00 c0       	push   $0xc0003237
c00010e2:	68 44 32 00 c0       	push   $0xc0003244
c00010e7:	e8 93 f3 ff ff       	call   c000047f <kprintf>
c00010ec:	83 c4 10             	add    $0x10,%esp
    kprintf("Char:    [%15c]\n", '!');
c00010ef:	83 ec 08             	sub    $0x8,%esp
c00010f2:	6a 21                	push   $0x21
c00010f4:	68 55 32 00 c0       	push   $0xc0003255
c00010f9:	e8 81 f3 ff ff       	call   c000047f <kprintf>
c00010fe:	83 c4 10             	add    $0x10,%esp

    kprintf("\nFixed width, left justify:\n");
c0001101:	83 ec 0c             	sub    $0xc,%esp
c0001104:	68 66 32 00 c0       	push   $0xc0003266
c0001109:	e8 71 f3 ff ff       	call   c000047f <kprintf>
c000110e:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%-15d]\n", num);
c0001111:	83 ec 08             	sub    $0x8,%esp
c0001114:	ff 75 f4             	pushl  -0xc(%ebp)
c0001117:	68 83 32 00 c0       	push   $0xc0003283
c000111c:	e8 5e f3 ff ff       	call   c000047f <kprintf>
c0001121:	83 c4 10             	add    $0x10,%esp
    kprintf("Hex:     [%-#15x]\n", num);
c0001124:	83 ec 08             	sub    $0x8,%esp
c0001127:	ff 75 f4             	pushl  -0xc(%ebp)
c000112a:	68 95 32 00 c0       	push   $0xc0003295
c000112f:	e8 4b f3 ff ff       	call   c000047f <kprintf>
c0001134:	83 c4 10             	add    $0x10,%esp
    kprintf("String:  [%-15s]\n", "Hello World!");
c0001137:	83 ec 08             	sub    $0x8,%esp
c000113a:	68 37 32 00 c0       	push   $0xc0003237
c000113f:	68 a8 32 00 c0       	push   $0xc00032a8
c0001144:	e8 36 f3 ff ff       	call   c000047f <kprintf>
c0001149:	83 c4 10             	add    $0x10,%esp

    kprintf("\nFixed Precision:\n");
c000114c:	83 ec 0c             	sub    $0xc,%esp
c000114f:	68 ba 32 00 c0       	push   $0xc00032ba
c0001154:	e8 26 f3 ff ff       	call   c000047f <kprintf>
c0001159:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%15.10d]\nHex:     [%#15.10x]\nOct:     [%#15.10o]\nString:  [%15.10s]\n", 
c000115c:	83 ec 0c             	sub    $0xc,%esp
c000115f:	68 37 32 00 c0       	push   $0xc0003237
c0001164:	ff 75 f4             	pushl  -0xc(%ebp)
c0001167:	ff 75 f4             	pushl  -0xc(%ebp)
c000116a:	ff 75 f4             	pushl  -0xc(%ebp)
c000116d:	68 d0 32 00 c0       	push   $0xc00032d0
c0001172:	e8 08 f3 ff ff       	call   c000047f <kprintf>
c0001177:	83 c4 20             	add    $0x20,%esp
        num, num, num, "Hello World!");

    kprintf("\nLeading Zeros:\n");
c000117a:	83 ec 0c             	sub    $0xc,%esp
c000117d:	68 1f 33 00 c0       	push   $0xc000331f
c0001182:	e8 f8 f2 ff ff       	call   c000047f <kprintf>
c0001187:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%015.10d]\nHex:     [%#015.10x]\nOct:     [%#015.10o]\n",num, num, num);
c000118a:	ff 75 f4             	pushl  -0xc(%ebp)
c000118d:	ff 75 f4             	pushl  -0xc(%ebp)
c0001190:	ff 75 f4             	pushl  -0xc(%ebp)
c0001193:	68 30 33 00 c0       	push   $0xc0003330
c0001198:	e8 e2 f2 ff ff       	call   c000047f <kprintf>
c000119d:	83 c4 10             	add    $0x10,%esp

    kprintf("Signed (none):  [%d], [%d]\n",num, -num);
c00011a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00011a3:	f7 d8                	neg    %eax
c00011a5:	83 ec 04             	sub    $0x4,%esp
c00011a8:	50                   	push   %eax
c00011a9:	ff 75 f4             	pushl  -0xc(%ebp)
c00011ac:	68 6f 33 00 c0       	push   $0xc000336f
c00011b1:	e8 c9 f2 ff ff       	call   c000047f <kprintf>
c00011b6:	83 c4 10             	add    $0x10,%esp
    kprintf("Signed (space): [% d], [% d]\n",num, -num);
c00011b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00011bc:	f7 d8                	neg    %eax
c00011be:	83 ec 04             	sub    $0x4,%esp
c00011c1:	50                   	push   %eax
c00011c2:	ff 75 f4             	pushl  -0xc(%ebp)
c00011c5:	68 8b 33 00 c0       	push   $0xc000338b
c00011ca:	e8 b0 f2 ff ff       	call   c000047f <kprintf>
c00011cf:	83 c4 10             	add    $0x10,%esp
    kprintf("Signed (+):     [%+d], [%+d]\n",num, -num);
c00011d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00011d5:	f7 d8                	neg    %eax
c00011d7:	83 ec 04             	sub    $0x4,%esp
c00011da:	50                   	push   %eax
c00011db:	ff 75 f4             	pushl  -0xc(%ebp)
c00011de:	68 a9 33 00 c0       	push   $0xc00033a9
c00011e3:	e8 97 f2 ff ff       	call   c000047f <kprintf>
c00011e8:	83 c4 10             	add    $0x10,%esp

    float f = 1.23456789;
c00011eb:	d9 05 20 34 00 c0    	flds   0xc0003420
c00011f1:	d9 5d f0             	fstps  -0x10(%ebp)
    kprintf("\nfloat:     [%15.f]\n",f);
c00011f4:	d9 45 f0             	flds   -0x10(%ebp)
c00011f7:	83 ec 04             	sub    $0x4,%esp
c00011fa:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c00011fe:	dd 1c 24             	fstpl  (%esp)
c0001201:	68 c7 33 00 c0       	push   $0xc00033c7
c0001206:	e8 74 f2 ff ff       	call   c000047f <kprintf>
c000120b:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.3f]\n",f);
c000120e:	d9 45 f0             	flds   -0x10(%ebp)
c0001211:	83 ec 04             	sub    $0x4,%esp
c0001214:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001218:	dd 1c 24             	fstpl  (%esp)
c000121b:	68 dc 33 00 c0       	push   $0xc00033dc
c0001220:	e8 5a f2 ff ff       	call   c000047f <kprintf>
c0001225:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.10f]\n",f);
c0001228:	d9 45 f0             	flds   -0x10(%ebp)
c000122b:	83 ec 04             	sub    $0x4,%esp
c000122e:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001232:	dd 1c 24             	fstpl  (%esp)
c0001235:	68 f1 33 00 c0       	push   $0xc00033f1
c000123a:	e8 40 f2 ff ff       	call   c000047f <kprintf>
c000123f:	83 c4 10             	add    $0x10,%esp

    f = -12345.6789;
c0001242:	d9 05 24 34 00 c0    	flds   0xc0003424
c0001248:	d9 5d f0             	fstps  -0x10(%ebp)
    kprintf("float:     [%15f]\n",f);
c000124b:	d9 45 f0             	flds   -0x10(%ebp)
c000124e:	83 ec 04             	sub    $0x4,%esp
c0001251:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001255:	dd 1c 24             	fstpl  (%esp)
c0001258:	68 07 34 00 c0       	push   $0xc0003407
c000125d:	e8 1d f2 ff ff       	call   c000047f <kprintf>
c0001262:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.3f]\n",f);
c0001265:	d9 45 f0             	flds   -0x10(%ebp)
c0001268:	83 ec 04             	sub    $0x4,%esp
c000126b:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c000126f:	dd 1c 24             	fstpl  (%esp)
c0001272:	68 dc 33 00 c0       	push   $0xc00033dc
c0001277:	e8 03 f2 ff ff       	call   c000047f <kprintf>
c000127c:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.10f]\n",f);
c000127f:	d9 45 f0             	flds   -0x10(%ebp)
c0001282:	83 ec 04             	sub    $0x4,%esp
c0001285:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001289:	dd 1c 24             	fstpl  (%esp)
c000128c:	68 f1 33 00 c0       	push   $0xc00033f1
c0001291:	e8 e9 f1 ff ff       	call   c000047f <kprintf>
c0001296:	83 c4 10             	add    $0x10,%esp
}
c0001299:	90                   	nop
c000129a:	c9                   	leave  
c000129b:	c3                   	ret    

c000129c <strlen>:
#include "common.h"

size_t strlen(const char* str) 
{
c000129c:	55                   	push   %ebp
c000129d:	89 e5                	mov    %esp,%ebp
c000129f:	83 ec 10             	sub    $0x10,%esp
	size_t len = 0;
c00012a2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while (str[len])
c00012a9:	eb 04                	jmp    c00012af <strlen+0x13>
		len++;
c00012ab:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
	while (str[len])
c00012af:	8b 55 08             	mov    0x8(%ebp),%edx
c00012b2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00012b5:	01 d0                	add    %edx,%eax
c00012b7:	0f b6 00             	movzbl (%eax),%eax
c00012ba:	84 c0                	test   %al,%al
c00012bc:	75 ed                	jne    c00012ab <strlen+0xf>
	return len;
c00012be:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00012c1:	c9                   	leave  
c00012c2:	c3                   	ret    

c00012c3 <memcpy>:

// copy n bytes from src to dest
void *memcpy(void *dest, const void *src, size_t n)
{
c00012c3:	55                   	push   %ebp
c00012c4:	89 e5                	mov    %esp,%ebp
c00012c6:	83 ec 20             	sub    $0x20,%esp
    //system wordsize is equal to length of size_t
    size_t n_words = n/sizeof(size_t);
c00012c9:	8b 45 10             	mov    0x10(%ebp),%eax
c00012cc:	c1 e8 02             	shr    $0x2,%eax
c00012cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t* dest_word = (size_t *) dest;
c00012d2:	8b 45 08             	mov    0x8(%ebp),%eax
c00012d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    size_t* src_word = (size_t *) src;
c00012d8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00012db:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for(size_t nn=0; nn<n_words; nn++)
c00012de:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00012e5:	eb 26                	jmp    c000130d <memcpy+0x4a>
        dest_word[nn]=src_word[nn];
c00012e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00012ea:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c00012f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00012f4:	01 d0                	add    %edx,%eax
c00012f6:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00012f9:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
c0001300:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001303:	01 ca                	add    %ecx,%edx
c0001305:	8b 00                	mov    (%eax),%eax
c0001307:	89 02                	mov    %eax,(%edx)
    for(size_t nn=0; nn<n_words; nn++)
c0001309:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c000130d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001310:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0001313:	72 d2                	jb     c00012e7 <memcpy+0x24>
    
    //copy remaining bytes
    size_t n_bytes = n - n_words*sizeof(size_t);
c0001315:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001318:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000131f:	8b 45 10             	mov    0x10(%ebp),%eax
c0001322:	29 d0                	sub    %edx,%eax
c0001324:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(n_bytes > 0)
c0001327:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c000132b:	74 36                	je     c0001363 <memcpy+0xa0>
    {
        char* dest_byte = (char *) dest;
c000132d:	8b 45 08             	mov    0x8(%ebp),%eax
c0001330:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        char* src_byte = (char *) src;
c0001333:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001336:	89 45 e0             	mov    %eax,-0x20(%ebp)
        for(size_t nn=0; nn<n_bytes; nn++)
c0001339:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0001340:	eb 19                	jmp    c000135b <memcpy+0x98>
            dest_byte[nn]=src_byte[nn];
c0001342:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0001345:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0001348:	01 d0                	add    %edx,%eax
c000134a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c000134d:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0001350:	01 ca                	add    %ecx,%edx
c0001352:	0f b6 00             	movzbl (%eax),%eax
c0001355:	88 02                	mov    %al,(%edx)
        for(size_t nn=0; nn<n_bytes; nn++)
c0001357:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c000135b:	8b 45 f8             	mov    -0x8(%ebp),%eax
c000135e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0001361:	72 df                	jb     c0001342 <memcpy+0x7f>
    }

    return dest;
c0001363:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0001366:	c9                   	leave  
c0001367:	c3                   	ret    

c0001368 <atoi>:

int atoi(const char* str)
{
c0001368:	55                   	push   %ebp
c0001369:	89 e5                	mov    %esp,%ebp
c000136b:	83 ec 20             	sub    $0x20,%esp
    int p = 0;
c000136e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    int neg = 0;
c0001375:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    //find start of number string, ignore whitespace
    while(str[p] == '-' || str[p] == ' ' || (str[p] >= 9 && str[p] <= 13))
c000137c:	eb 41                	jmp    c00013bf <atoi+0x57>
    {
        if(str[p++] == '-')
c000137e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001381:	8d 50 01             	lea    0x1(%eax),%edx
c0001384:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001387:	89 c2                	mov    %eax,%edx
c0001389:	8b 45 08             	mov    0x8(%ebp),%eax
c000138c:	01 d0                	add    %edx,%eax
c000138e:	0f b6 00             	movzbl (%eax),%eax
c0001391:	3c 2d                	cmp    $0x2d,%al
c0001393:	75 09                	jne    c000139e <atoi+0x36>
        {
            neg=1;
c0001395:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
            break;
c000139c:	eb 5d                	jmp    c00013fb <atoi+0x93>
        }
        if(str[p++] == '\0')
c000139e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00013a1:	8d 50 01             	lea    0x1(%eax),%edx
c00013a4:	89 55 fc             	mov    %edx,-0x4(%ebp)
c00013a7:	89 c2                	mov    %eax,%edx
c00013a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00013ac:	01 d0                	add    %edx,%eax
c00013ae:	0f b6 00             	movzbl (%eax),%eax
c00013b1:	84 c0                	test   %al,%al
c00013b3:	75 0a                	jne    c00013bf <atoi+0x57>
            return 0; //invalid string (only whitespace found)
c00013b5:	b8 00 00 00 00       	mov    $0x0,%eax
c00013ba:	e9 ee 00 00 00       	jmp    c00014ad <atoi+0x145>
    while(str[p] == '-' || str[p] == ' ' || (str[p] >= 9 && str[p] <= 13))
c00013bf:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00013c2:	8b 45 08             	mov    0x8(%ebp),%eax
c00013c5:	01 d0                	add    %edx,%eax
c00013c7:	0f b6 00             	movzbl (%eax),%eax
c00013ca:	3c 2d                	cmp    $0x2d,%al
c00013cc:	74 b0                	je     c000137e <atoi+0x16>
c00013ce:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00013d1:	8b 45 08             	mov    0x8(%ebp),%eax
c00013d4:	01 d0                	add    %edx,%eax
c00013d6:	0f b6 00             	movzbl (%eax),%eax
c00013d9:	3c 20                	cmp    $0x20,%al
c00013db:	74 a1                	je     c000137e <atoi+0x16>
c00013dd:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00013e0:	8b 45 08             	mov    0x8(%ebp),%eax
c00013e3:	01 d0                	add    %edx,%eax
c00013e5:	0f b6 00             	movzbl (%eax),%eax
c00013e8:	3c 08                	cmp    $0x8,%al
c00013ea:	7e 0f                	jle    c00013fb <atoi+0x93>
c00013ec:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00013ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00013f2:	01 d0                	add    %edx,%eax
c00013f4:	0f b6 00             	movzbl (%eax),%eax
c00013f7:	3c 0d                	cmp    $0xd,%al
c00013f9:	7e 83                	jle    c000137e <atoi+0x16>
    }

    int num_start = p;
c00013fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00013fe:	89 45 e8             	mov    %eax,-0x18(%ebp)

    //find end of integer string (ints only, no decimal point)
    while(str[p] >= '0' && str[p] <= '9')
c0001401:	eb 21                	jmp    c0001424 <atoi+0xbc>
    {
        if(str[p++] == '\0')
c0001403:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001406:	8d 50 01             	lea    0x1(%eax),%edx
c0001409:	89 55 fc             	mov    %edx,-0x4(%ebp)
c000140c:	89 c2                	mov    %eax,%edx
c000140e:	8b 45 08             	mov    0x8(%ebp),%eax
c0001411:	01 d0                	add    %edx,%eax
c0001413:	0f b6 00             	movzbl (%eax),%eax
c0001416:	84 c0                	test   %al,%al
c0001418:	75 0a                	jne    c0001424 <atoi+0xbc>
            return 0; //invalid string (only whitespace found)
c000141a:	b8 00 00 00 00       	mov    $0x0,%eax
c000141f:	e9 89 00 00 00       	jmp    c00014ad <atoi+0x145>
    while(str[p] >= '0' && str[p] <= '9')
c0001424:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0001427:	8b 45 08             	mov    0x8(%ebp),%eax
c000142a:	01 d0                	add    %edx,%eax
c000142c:	0f b6 00             	movzbl (%eax),%eax
c000142f:	3c 2f                	cmp    $0x2f,%al
c0001431:	7e 0f                	jle    c0001442 <atoi+0xda>
c0001433:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0001436:	8b 45 08             	mov    0x8(%ebp),%eax
c0001439:	01 d0                	add    %edx,%eax
c000143b:	0f b6 00             	movzbl (%eax),%eax
c000143e:	3c 39                	cmp    $0x39,%al
c0001440:	7e c1                	jle    c0001403 <atoi+0x9b>
    }

    if(num_start == p) return 0; //length 0 string
c0001442:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001445:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c0001448:	75 07                	jne    c0001451 <atoi+0xe9>
c000144a:	b8 00 00 00 00       	mov    $0x0,%eax
c000144f:	eb 5c                	jmp    c00014ad <atoi+0x145>

    int number = 0;
c0001451:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    int place = 1;
c0001458:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    //iterate backwards through number to add each digit
    for(int digit = p-1; digit >= num_start; digit--)
c000145f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001462:	83 e8 01             	sub    $0x1,%eax
c0001465:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0001468:	eb 2b                	jmp    c0001495 <atoi+0x12d>
    {
        number += (int) (str[digit] - '0') * place;
c000146a:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000146d:	8b 45 08             	mov    0x8(%ebp),%eax
c0001470:	01 d0                	add    %edx,%eax
c0001472:	0f b6 00             	movzbl (%eax),%eax
c0001475:	0f be c0             	movsbl %al,%eax
c0001478:	83 e8 30             	sub    $0x30,%eax
c000147b:	0f af 45 f0          	imul   -0x10(%ebp),%eax
c000147f:	01 45 f4             	add    %eax,-0xc(%ebp)
        place *= 10;
c0001482:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001485:	89 d0                	mov    %edx,%eax
c0001487:	c1 e0 02             	shl    $0x2,%eax
c000148a:	01 d0                	add    %edx,%eax
c000148c:	01 c0                	add    %eax,%eax
c000148e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for(int digit = p-1; digit >= num_start; digit--)
c0001491:	83 6d ec 01          	subl   $0x1,-0x14(%ebp)
c0001495:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001498:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c000149b:	7d cd                	jge    c000146a <atoi+0x102>
    }

    if(neg)
c000149d:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c00014a1:	74 07                	je     c00014aa <atoi+0x142>
        return -1*number;
c00014a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00014a6:	f7 d8                	neg    %eax
c00014a8:	eb 03                	jmp    c00014ad <atoi+0x145>
    else
        return number;
c00014aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00014ad:	c9                   	leave  
c00014ae:	c3                   	ret    

c00014af <itoa>:

char* itoa( int value, char* str, int base)
{
c00014af:	55                   	push   %ebp
c00014b0:	89 e5                	mov    %esp,%ebp
c00014b2:	83 ec 20             	sub    $0x20,%esp
    if(base < 2 || base > 32)
c00014b5:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c00014b9:	7e 06                	jle    c00014c1 <itoa+0x12>
c00014bb:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
c00014bf:	7e 0a                	jle    c00014cb <itoa+0x1c>
        return NULL;
c00014c1:	b8 00 00 00 00       	mov    $0x0,%eax
c00014c6:	e9 df 00 00 00       	jmp    c00015aa <itoa+0xfb>

    //handle zero as special case 
    if(value == 0)
c00014cb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00014cf:	75 17                	jne    c00014e8 <itoa+0x39>
    {
        str[0] = '0';
c00014d1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00014d4:	c6 00 30             	movb   $0x30,(%eax)
        str[1] = '\0';
c00014d7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00014da:	83 c0 01             	add    $0x1,%eax
c00014dd:	c6 00 00             	movb   $0x0,(%eax)
        return str;
c00014e0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00014e3:	e9 c2 00 00 00       	jmp    c00015aa <itoa+0xfb>
    }

    char* s = str;
c00014e8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00014eb:	89 45 fc             	mov    %eax,-0x4(%ebp)
    unsigned int residual; //holds the unsigned value still to be parsed
    if(base == 10 && value < 0)
c00014ee:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
c00014f2:	75 1c                	jne    c0001510 <itoa+0x61>
c00014f4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00014f8:	79 16                	jns    c0001510 <itoa+0x61>
    {
        residual = -value;
c00014fa:	8b 45 08             	mov    0x8(%ebp),%eax
c00014fd:	f7 d8                	neg    %eax
c00014ff:	89 45 f8             	mov    %eax,-0x8(%ebp)
        *(s++) = '-';
c0001502:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001505:	8d 50 01             	lea    0x1(%eax),%edx
c0001508:	89 55 fc             	mov    %edx,-0x4(%ebp)
c000150b:	c6 00 2d             	movb   $0x2d,(%eax)
c000150e:	eb 06                	jmp    c0001516 <itoa+0x67>
    }
    else
    {
        //all non-decimal numbers are treated as unsigned
        residual = (unsigned int) value;
c0001510:	8b 45 08             	mov    0x8(%ebp),%eax
c0001513:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    
    // find number of digits so that we can parse number
    // directly into string from lowest to highest digit    
    unsigned int num_digits = 0;
c0001516:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    unsigned int temp = residual;
c000151d:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0001520:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(temp>0)
c0001523:	eb 14                	jmp    c0001539 <itoa+0x8a>
    {
        num_digits++;
c0001525:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
        temp /= base;
c0001529:	8b 4d 10             	mov    0x10(%ebp),%ecx
c000152c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000152f:	ba 00 00 00 00       	mov    $0x0,%edx
c0001534:	f7 f1                	div    %ecx
c0001536:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(temp>0)
c0001539:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000153d:	75 e6                	jne    c0001525 <itoa+0x76>
    }

    //point at end of string
    s += num_digits;
c000153f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001542:	01 45 fc             	add    %eax,-0x4(%ebp)
    *(s--) = '\0'; //null termination
c0001545:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001548:	8d 50 ff             	lea    -0x1(%eax),%edx
c000154b:	89 55 fc             	mov    %edx,-0x4(%ebp)
c000154e:	c6 00 00             	movb   $0x0,(%eax)

    //compute each digit from lowest to highest.
    unsigned int digit;
    while(residual>0)
c0001551:	eb 4e                	jmp    c00015a1 <itoa+0xf2>
    {
        digit = residual % base;
c0001553:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0001556:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0001559:	ba 00 00 00 00       	mov    $0x0,%edx
c000155e:	f7 f1                	div    %ecx
c0001560:	89 55 ec             	mov    %edx,-0x14(%ebp)
        residual /= base;
c0001563:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0001566:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0001569:	ba 00 00 00 00       	mov    $0x0,%edx
c000156e:	f7 f1                	div    %ecx
c0001570:	89 45 f8             	mov    %eax,-0x8(%ebp)

        //write digit into string and decrement pointer
        if(digit < 10)
c0001573:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
c0001577:	77 15                	ja     c000158e <itoa+0xdf>
            *(s--) = digit + '0';
c0001579:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000157c:	8d 48 30             	lea    0x30(%eax),%ecx
c000157f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001582:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001585:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001588:	89 ca                	mov    %ecx,%edx
c000158a:	88 10                	mov    %dl,(%eax)
c000158c:	eb 13                	jmp    c00015a1 <itoa+0xf2>
        else
            *(s--) = digit - 10 + 'A';        
c000158e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001591:	8d 48 37             	lea    0x37(%eax),%ecx
c0001594:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001597:	8d 50 ff             	lea    -0x1(%eax),%edx
c000159a:	89 55 fc             	mov    %edx,-0x4(%ebp)
c000159d:	89 ca                	mov    %ecx,%edx
c000159f:	88 10                	mov    %dl,(%eax)
    while(residual>0)
c00015a1:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c00015a5:	75 ac                	jne    c0001553 <itoa+0xa4>
    }

    return str;
c00015a7:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c00015aa:	c9                   	leave  
c00015ab:	c3                   	ret    

c00015ac <memory_table>:
#include "multiboot.h"
#include "kprintf.h"

size_t memory_table(multiboot_info_t* mbd)
{
c00015ac:	55                   	push   %ebp
c00015ad:	89 e5                	mov    %esp,%ebp
c00015af:	56                   	push   %esi
c00015b0:	53                   	push   %ebx
c00015b1:	83 ec 10             	sub    $0x10,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c00015b4:	8b 45 08             	mov    0x8(%ebp),%eax
c00015b7:	8b 40 30             	mov    0x30(%eax),%eax
c00015ba:	89 45 ec             	mov    %eax,-0x14(%ebp)
    size_t available_mem = 0;
c00015bd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c00015c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00015cb:	e9 83 00 00 00       	jmp    c0001653 <memory_table+0xa7>
	{
		if(mmap_table[nn].len>0 && mmap_table[nn].size>0)
c00015d0:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00015d3:	89 d0                	mov    %edx,%eax
c00015d5:	01 c0                	add    %eax,%eax
c00015d7:	01 d0                	add    %edx,%eax
c00015d9:	c1 e0 03             	shl    $0x3,%eax
c00015dc:	89 c2                	mov    %eax,%edx
c00015de:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00015e1:	01 d0                	add    %edx,%eax
c00015e3:	8b 50 10             	mov    0x10(%eax),%edx
c00015e6:	8b 40 0c             	mov    0xc(%eax),%eax
c00015e9:	89 c6                	mov    %eax,%esi
c00015eb:	83 f6 00             	xor    $0x0,%esi
c00015ee:	89 f1                	mov    %esi,%ecx
c00015f0:	89 d0                	mov    %edx,%eax
c00015f2:	80 f4 00             	xor    $0x0,%ah
c00015f5:	89 c3                	mov    %eax,%ebx
c00015f7:	89 d8                	mov    %ebx,%eax
c00015f9:	09 c8                	or     %ecx,%eax
c00015fb:	85 c0                	test   %eax,%eax
c00015fd:	74 50                	je     c000164f <memory_table+0xa3>
c00015ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001602:	89 d0                	mov    %edx,%eax
c0001604:	01 c0                	add    %eax,%eax
c0001606:	01 d0                	add    %edx,%eax
c0001608:	c1 e0 03             	shl    $0x3,%eax
c000160b:	89 c2                	mov    %eax,%edx
c000160d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001610:	01 d0                	add    %edx,%eax
c0001612:	8b 00                	mov    (%eax),%eax
c0001614:	85 c0                	test   %eax,%eax
c0001616:	74 37                	je     c000164f <memory_table+0xa3>
        {
            if(mmap_table[nn].type == 1)
c0001618:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000161b:	89 d0                	mov    %edx,%eax
c000161d:	01 c0                	add    %eax,%eax
c000161f:	01 d0                	add    %edx,%eax
c0001621:	c1 e0 03             	shl    $0x3,%eax
c0001624:	89 c2                	mov    %eax,%edx
c0001626:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001629:	01 d0                	add    %edx,%eax
c000162b:	8b 40 14             	mov    0x14(%eax),%eax
c000162e:	83 f8 01             	cmp    $0x1,%eax
c0001631:	75 1c                	jne    c000164f <memory_table+0xa3>
            available_mem += mmap_table[nn].len;
c0001633:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001636:	89 d0                	mov    %edx,%eax
c0001638:	01 c0                	add    %eax,%eax
c000163a:	01 d0                	add    %edx,%eax
c000163c:	c1 e0 03             	shl    $0x3,%eax
c000163f:	89 c2                	mov    %eax,%edx
c0001641:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001644:	01 d0                	add    %edx,%eax
c0001646:	8b 50 10             	mov    0x10(%eax),%edx
c0001649:	8b 40 0c             	mov    0xc(%eax),%eax
c000164c:	01 45 f4             	add    %eax,-0xc(%ebp)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c000164f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0001653:	8b 45 08             	mov    0x8(%ebp),%eax
c0001656:	8b 40 2c             	mov    0x2c(%eax),%eax
c0001659:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c000165c:	0f 82 6e ff ff ff    	jb     c00015d0 <memory_table+0x24>
        }
		
	}

    return available_mem;
c0001662:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0001665:	83 c4 10             	add    $0x10,%esp
c0001668:	5b                   	pop    %ebx
c0001669:	5e                   	pop    %esi
c000166a:	5d                   	pop    %ebp
c000166b:	c3                   	ret    

c000166c <print_memory_table>:

int print_memory_table(multiboot_info_t* mbd)
{
c000166c:	55                   	push   %ebp
c000166d:	89 e5                	mov    %esp,%ebp
c000166f:	57                   	push   %edi
c0001670:	56                   	push   %esi
c0001671:	53                   	push   %ebx
c0001672:	83 ec 2c             	sub    $0x2c,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c0001675:	8b 45 08             	mov    0x8(%ebp),%eax
c0001678:	8b 40 30             	mov    0x30(%eax),%eax
c000167b:	89 45 e0             	mov    %eax,-0x20(%ebp)
	kprintf("Memory Table:\n");
c000167e:	83 ec 0c             	sub    $0xc,%esp
c0001681:	68 28 34 00 c0       	push   $0xc0003428
c0001686:	e8 f4 ed ff ff       	call   c000047f <kprintf>
c000168b:	83 c4 10             	add    $0x10,%esp
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c000168e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c0001695:	e9 a6 01 00 00       	jmp    c0001840 <print_memory_table+0x1d4>
	{
        if(mmap_table[nn].size == 0)
c000169a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c000169d:	89 d0                	mov    %edx,%eax
c000169f:	01 c0                	add    %eax,%eax
c00016a1:	01 d0                	add    %edx,%eax
c00016a3:	c1 e0 03             	shl    $0x3,%eax
c00016a6:	89 c2                	mov    %eax,%edx
c00016a8:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00016ab:	01 d0                	add    %edx,%eax
c00016ad:	8b 00                	mov    (%eax),%eax
c00016af:	85 c0                	test   %eax,%eax
c00016b1:	0f 84 9a 01 00 00    	je     c0001851 <print_memory_table+0x1e5>
            break;

		if(mmap_table[nn].len>0)
c00016b7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00016ba:	89 d0                	mov    %edx,%eax
c00016bc:	01 c0                	add    %eax,%eax
c00016be:	01 d0                	add    %edx,%eax
c00016c0:	c1 e0 03             	shl    $0x3,%eax
c00016c3:	89 c2                	mov    %eax,%edx
c00016c5:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00016c8:	01 d0                	add    %edx,%eax
c00016ca:	8b 50 10             	mov    0x10(%eax),%edx
c00016cd:	8b 40 0c             	mov    0xc(%eax),%eax
c00016d0:	89 c7                	mov    %eax,%edi
c00016d2:	83 f7 00             	xor    $0x0,%edi
c00016d5:	89 7d d0             	mov    %edi,-0x30(%ebp)
c00016d8:	89 d0                	mov    %edx,%eax
c00016da:	80 f4 00             	xor    $0x0,%ah
c00016dd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
c00016e0:	8b 5d d0             	mov    -0x30(%ebp),%ebx
c00016e3:	8b 75 d4             	mov    -0x2c(%ebp),%esi
c00016e6:	89 f0                	mov    %esi,%eax
c00016e8:	09 d8                	or     %ebx,%eax
c00016ea:	85 c0                	test   %eax,%eax
c00016ec:	0f 84 4a 01 00 00    	je     c000183c <print_memory_table+0x1d0>
		{
			if(mmap_table[nn].type == MULTIBOOT_MEMORY_AVAILABLE)
c00016f2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00016f5:	89 d0                	mov    %edx,%eax
c00016f7:	01 c0                	add    %eax,%eax
c00016f9:	01 d0                	add    %edx,%eax
c00016fb:	c1 e0 03             	shl    $0x3,%eax
c00016fe:	89 c2                	mov    %eax,%edx
c0001700:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001703:	01 d0                	add    %edx,%eax
c0001705:	8b 40 14             	mov    0x14(%eax),%eax
c0001708:	83 f8 01             	cmp    $0x1,%eax
c000170b:	0f 85 98 00 00 00    	jne    c00017a9 <print_memory_table+0x13d>
				kprintf("%.8llp - %.8llp [AVAILABLE] (%6llu kiB)\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c0001711:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001714:	89 d0                	mov    %edx,%eax
c0001716:	01 c0                	add    %eax,%eax
c0001718:	01 d0                	add    %edx,%eax
c000171a:	c1 e0 03             	shl    $0x3,%eax
c000171d:	89 c2                	mov    %eax,%edx
c000171f:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001722:	01 d0                	add    %edx,%eax
c0001724:	8b 50 10             	mov    0x10(%eax),%edx
c0001727:	8b 40 0c             	mov    0xc(%eax),%eax
c000172a:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c000172e:	c1 ea 0a             	shr    $0xa,%edx
c0001731:	89 c6                	mov    %eax,%esi
c0001733:	89 d7                	mov    %edx,%edi
c0001735:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001738:	89 d0                	mov    %edx,%eax
c000173a:	01 c0                	add    %eax,%eax
c000173c:	01 d0                	add    %edx,%eax
c000173e:	c1 e0 03             	shl    $0x3,%eax
c0001741:	89 c2                	mov    %eax,%edx
c0001743:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001746:	01 d0                	add    %edx,%eax
c0001748:	8b 48 04             	mov    0x4(%eax),%ecx
c000174b:	8b 58 08             	mov    0x8(%eax),%ebx
c000174e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001751:	89 d0                	mov    %edx,%eax
c0001753:	01 c0                	add    %eax,%eax
c0001755:	01 d0                	add    %edx,%eax
c0001757:	c1 e0 03             	shl    $0x3,%eax
c000175a:	89 c2                	mov    %eax,%edx
c000175c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000175f:	01 d0                	add    %edx,%eax
c0001761:	8b 50 10             	mov    0x10(%eax),%edx
c0001764:	8b 40 0c             	mov    0xc(%eax),%eax
c0001767:	01 c8                	add    %ecx,%eax
c0001769:	11 da                	adc    %ebx,%edx
c000176b:	83 c0 ff             	add    $0xffffffff,%eax
c000176e:	83 d2 ff             	adc    $0xffffffff,%edx
c0001771:	89 c1                	mov    %eax,%ecx
c0001773:	89 d3                	mov    %edx,%ebx
c0001775:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001778:	89 d0                	mov    %edx,%eax
c000177a:	01 c0                	add    %eax,%eax
c000177c:	01 d0                	add    %edx,%eax
c000177e:	c1 e0 03             	shl    $0x3,%eax
c0001781:	89 c2                	mov    %eax,%edx
c0001783:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001786:	01 d0                	add    %edx,%eax
c0001788:	8b 50 08             	mov    0x8(%eax),%edx
c000178b:	8b 40 04             	mov    0x4(%eax),%eax
c000178e:	83 ec 04             	sub    $0x4,%esp
c0001791:	57                   	push   %edi
c0001792:	56                   	push   %esi
c0001793:	53                   	push   %ebx
c0001794:	51                   	push   %ecx
c0001795:	52                   	push   %edx
c0001796:	50                   	push   %eax
c0001797:	68 38 34 00 c0       	push   $0xc0003438
c000179c:	e8 de ec ff ff       	call   c000047f <kprintf>
c00017a1:	83 c4 20             	add    $0x20,%esp
c00017a4:	e9 93 00 00 00       	jmp    c000183c <print_memory_table+0x1d0>
			else
				kprintf("%.8llp - %.8llp [RESERVED]\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c00017a9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00017ac:	89 d0                	mov    %edx,%eax
c00017ae:	01 c0                	add    %eax,%eax
c00017b0:	01 d0                	add    %edx,%eax
c00017b2:	c1 e0 03             	shl    $0x3,%eax
c00017b5:	89 c2                	mov    %eax,%edx
c00017b7:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00017ba:	01 d0                	add    %edx,%eax
c00017bc:	8b 50 10             	mov    0x10(%eax),%edx
c00017bf:	8b 40 0c             	mov    0xc(%eax),%eax
c00017c2:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c00017c6:	c1 ea 0a             	shr    $0xa,%edx
c00017c9:	89 c6                	mov    %eax,%esi
c00017cb:	89 d7                	mov    %edx,%edi
c00017cd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00017d0:	89 d0                	mov    %edx,%eax
c00017d2:	01 c0                	add    %eax,%eax
c00017d4:	01 d0                	add    %edx,%eax
c00017d6:	c1 e0 03             	shl    $0x3,%eax
c00017d9:	89 c2                	mov    %eax,%edx
c00017db:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00017de:	01 d0                	add    %edx,%eax
c00017e0:	8b 48 04             	mov    0x4(%eax),%ecx
c00017e3:	8b 58 08             	mov    0x8(%eax),%ebx
c00017e6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00017e9:	89 d0                	mov    %edx,%eax
c00017eb:	01 c0                	add    %eax,%eax
c00017ed:	01 d0                	add    %edx,%eax
c00017ef:	c1 e0 03             	shl    $0x3,%eax
c00017f2:	89 c2                	mov    %eax,%edx
c00017f4:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00017f7:	01 d0                	add    %edx,%eax
c00017f9:	8b 50 10             	mov    0x10(%eax),%edx
c00017fc:	8b 40 0c             	mov    0xc(%eax),%eax
c00017ff:	01 c8                	add    %ecx,%eax
c0001801:	11 da                	adc    %ebx,%edx
c0001803:	83 c0 ff             	add    $0xffffffff,%eax
c0001806:	83 d2 ff             	adc    $0xffffffff,%edx
c0001809:	89 c1                	mov    %eax,%ecx
c000180b:	89 d3                	mov    %edx,%ebx
c000180d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001810:	89 d0                	mov    %edx,%eax
c0001812:	01 c0                	add    %eax,%eax
c0001814:	01 d0                	add    %edx,%eax
c0001816:	c1 e0 03             	shl    $0x3,%eax
c0001819:	89 c2                	mov    %eax,%edx
c000181b:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000181e:	01 d0                	add    %edx,%eax
c0001820:	8b 50 08             	mov    0x8(%eax),%edx
c0001823:	8b 40 04             	mov    0x4(%eax),%eax
c0001826:	83 ec 04             	sub    $0x4,%esp
c0001829:	57                   	push   %edi
c000182a:	56                   	push   %esi
c000182b:	53                   	push   %ebx
c000182c:	51                   	push   %ecx
c000182d:	52                   	push   %edx
c000182e:	50                   	push   %eax
c000182f:	68 61 34 00 c0       	push   $0xc0003461
c0001834:	e8 46 ec ff ff       	call   c000047f <kprintf>
c0001839:	83 c4 20             	add    $0x20,%esp
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c000183c:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c0001840:	8b 45 08             	mov    0x8(%ebp),%eax
c0001843:	8b 40 2c             	mov    0x2c(%eax),%eax
c0001846:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c0001849:	0f 82 4b fe ff ff    	jb     c000169a <print_memory_table+0x2e>
c000184f:	eb 01                	jmp    c0001852 <print_memory_table+0x1e6>
            break;
c0001851:	90                   	nop
    //         kprintf("[%3u] %p (%#x)\n", nn, addr, flags);		
	// }

    // print_crs();

    return 0;
c0001852:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0001857:	8d 65 f4             	lea    -0xc(%ebp),%esp
c000185a:	5b                   	pop    %ebx
c000185b:	5e                   	pop    %esi
c000185c:	5f                   	pop    %edi
c000185d:	5d                   	pop    %ebp
c000185e:	c3                   	ret    

c000185f <inb>:
{
c000185f:	55                   	push   %ebp
c0001860:	89 e5                	mov    %esp,%ebp
c0001862:	83 ec 14             	sub    $0x14,%esp
c0001865:	8b 45 08             	mov    0x8(%ebp),%eax
c0001868:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  __asm__ __volatile__ ("inb %w1,%0":"=a" (_v):"Nd" (__port));
c000186c:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0001870:	89 c2                	mov    %eax,%edx
c0001872:	ec                   	in     (%dx),%al
c0001873:	88 45 ff             	mov    %al,-0x1(%ebp)
  return _v;
c0001876:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c000187a:	c9                   	leave  
c000187b:	c3                   	ret    

c000187c <outb>:
{
c000187c:	55                   	push   %ebp
c000187d:	89 e5                	mov    %esp,%ebp
c000187f:	83 ec 08             	sub    $0x8,%esp
c0001882:	8b 55 08             	mov    0x8(%ebp),%edx
c0001885:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001888:	88 55 fc             	mov    %dl,-0x4(%ebp)
c000188b:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
c000188f:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0001893:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
c0001897:	ee                   	out    %al,(%dx)
}
c0001898:	90                   	nop
c0001899:	c9                   	leave  
c000189a:	c3                   	ret    

c000189b <init_interrupts>:

idt_entry_t __aligned idt[NUM_INTERRUPT_HANDLERS] = {0};
idt_descriptor_t __aligned idtd;

void init_interrupts()
{
c000189b:	55                   	push   %ebp
c000189c:	89 e5                	mov    %esp,%ebp
c000189e:	83 ec 08             	sub    $0x8,%esp
    /* init the PIC */
	outb(PIC_INIT, PIC1_CMD);  // init PIC 1
c00018a1:	6a 20                	push   $0x20
c00018a3:	6a 11                	push   $0x11
c00018a5:	e8 d2 ff ff ff       	call   c000187c <outb>
c00018aa:	83 c4 08             	add    $0x8,%esp
    outb(PIC_INIT, PIC2_CMD);  // init PIC 2
c00018ad:	68 a0 00 00 00       	push   $0xa0
c00018b2:	6a 11                	push   $0x11
c00018b4:	e8 c3 ff ff ff       	call   c000187c <outb>
c00018b9:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_OFFSET, PIC1_DATA); // map irq 0x0-0x7 to int 0x20-0x27
c00018bc:	6a 21                	push   $0x21
c00018be:	6a 20                	push   $0x20
c00018c0:	e8 b7 ff ff ff       	call   c000187c <outb>
c00018c5:	83 c4 08             	add    $0x8,%esp
    outb(PIC2_OFFSET, PIC2_DATA); // map irq 0x8-0xf to int 0x28-0x2f
c00018c8:	68 a1 00 00 00       	push   $0xa1
c00018cd:	6a 28                	push   $0x28
c00018cf:	e8 a8 ff ff ff       	call   c000187c <outb>
c00018d4:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_MS, PIC1_DATA);     // pic1 is master, with slave at irq 2
c00018d7:	6a 21                	push   $0x21
c00018d9:	6a 04                	push   $0x4
c00018db:	e8 9c ff ff ff       	call   c000187c <outb>
c00018e0:	83 c4 08             	add    $0x8,%esp
    outb(PIC2_MS, PIC2_DATA);     // pic2 is slave with id 2
c00018e3:	68 a1 00 00 00       	push   $0xa1
c00018e8:	6a 02                	push   $0x2
c00018ea:	e8 8d ff ff ff       	call   c000187c <outb>
c00018ef:	83 c4 08             	add    $0x8,%esp
    outb(PIC_8086MODE, PIC1_DATA); //enable 8086 mode
c00018f2:	6a 21                	push   $0x21
c00018f4:	6a 01                	push   $0x1
c00018f6:	e8 81 ff ff ff       	call   c000187c <outb>
c00018fb:	83 c4 08             	add    $0x8,%esp
    outb(PIC_8086MODE, PIC2_DATA); //enable 8086 mode
c00018fe:	68 a1 00 00 00       	push   $0xa1
c0001903:	6a 01                	push   $0x1
c0001905:	e8 72 ff ff ff       	call   c000187c <outb>
c000190a:	83 c4 08             	add    $0x8,%esp
    // interrupt mask
    outb( ~(1<<1) , PIC1_DATA); //enable irq1 (keyboard)
c000190d:	6a 21                	push   $0x21
c000190f:	68 fd 00 00 00       	push   $0xfd
c0001914:	e8 63 ff ff ff       	call   c000187c <outb>
c0001919:	83 c4 08             	add    $0x8,%esp
    outb(0xff, PIC2_DATA); //disable interrupts from slave
c000191c:	68 a1 00 00 00       	push   $0xa1
c0001921:	68 ff 00 00 00       	push   $0xff
c0001926:	e8 51 ff ff ff       	call   c000187c <outb>
c000192b:	83 c4 08             	add    $0x8,%esp


    // individual handler routines defined in interrupt.S
    // these call back to exception_handler() and irq_handler()
    set_interrupt_handler(0,except_0);
c000192e:	83 ec 08             	sub    $0x8,%esp
c0001931:	68 c4 28 00 c0       	push   $0xc00028c4
c0001936:	6a 00                	push   $0x0
c0001938:	e8 94 02 00 00       	call   c0001bd1 <set_interrupt_handler>
c000193d:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(1,except_1);
c0001940:	83 ec 08             	sub    $0x8,%esp
c0001943:	68 dc 28 00 c0       	push   $0xc00028dc
c0001948:	6a 01                	push   $0x1
c000194a:	e8 82 02 00 00       	call   c0001bd1 <set_interrupt_handler>
c000194f:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(2,except_2);
c0001952:	83 ec 08             	sub    $0x8,%esp
c0001955:	68 f4 28 00 c0       	push   $0xc00028f4
c000195a:	6a 02                	push   $0x2
c000195c:	e8 70 02 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001961:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(3,except_3);
c0001964:	83 ec 08             	sub    $0x8,%esp
c0001967:	68 0c 29 00 c0       	push   $0xc000290c
c000196c:	6a 03                	push   $0x3
c000196e:	e8 5e 02 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001973:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(4,except_4);
c0001976:	83 ec 08             	sub    $0x8,%esp
c0001979:	68 24 29 00 c0       	push   $0xc0002924
c000197e:	6a 04                	push   $0x4
c0001980:	e8 4c 02 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001985:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(5,except_5);
c0001988:	83 ec 08             	sub    $0x8,%esp
c000198b:	68 3c 29 00 c0       	push   $0xc000293c
c0001990:	6a 05                	push   $0x5
c0001992:	e8 3a 02 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001997:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(6,except_6);
c000199a:	83 ec 08             	sub    $0x8,%esp
c000199d:	68 54 29 00 c0       	push   $0xc0002954
c00019a2:	6a 06                	push   $0x6
c00019a4:	e8 28 02 00 00       	call   c0001bd1 <set_interrupt_handler>
c00019a9:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(7,except_7);
c00019ac:	83 ec 08             	sub    $0x8,%esp
c00019af:	68 6c 29 00 c0       	push   $0xc000296c
c00019b4:	6a 07                	push   $0x7
c00019b6:	e8 16 02 00 00       	call   c0001bd1 <set_interrupt_handler>
c00019bb:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(8,except_8);
c00019be:	83 ec 08             	sub    $0x8,%esp
c00019c1:	68 84 29 00 c0       	push   $0xc0002984
c00019c6:	6a 08                	push   $0x8
c00019c8:	e8 04 02 00 00       	call   c0001bd1 <set_interrupt_handler>
c00019cd:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(10,except_10);
c00019d0:	83 ec 08             	sub    $0x8,%esp
c00019d3:	68 a0 29 00 c0       	push   $0xc00029a0
c00019d8:	6a 0a                	push   $0xa
c00019da:	e8 f2 01 00 00       	call   c0001bd1 <set_interrupt_handler>
c00019df:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(11,except_11);
c00019e2:	83 ec 08             	sub    $0x8,%esp
c00019e5:	68 bc 29 00 c0       	push   $0xc00029bc
c00019ea:	6a 0b                	push   $0xb
c00019ec:	e8 e0 01 00 00       	call   c0001bd1 <set_interrupt_handler>
c00019f1:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(12,except_12);
c00019f4:	83 ec 08             	sub    $0x8,%esp
c00019f7:	68 d8 29 00 c0       	push   $0xc00029d8
c00019fc:	6a 0c                	push   $0xc
c00019fe:	e8 ce 01 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001a03:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(13,except_13);
c0001a06:	83 ec 08             	sub    $0x8,%esp
c0001a09:	68 f4 29 00 c0       	push   $0xc00029f4
c0001a0e:	6a 0d                	push   $0xd
c0001a10:	e8 bc 01 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001a15:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(14,except_pf);
c0001a18:	83 ec 08             	sub    $0x8,%esp
c0001a1b:	68 b8 2a 00 c0       	push   $0xc0002ab8
c0001a20:	6a 0e                	push   $0xe
c0001a22:	e8 aa 01 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001a27:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(16,except_16);
c0001a2a:	83 ec 08             	sub    $0x8,%esp
c0001a2d:	68 10 2a 00 c0       	push   $0xc0002a10
c0001a32:	6a 10                	push   $0x10
c0001a34:	e8 98 01 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001a39:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(17,except_17);
c0001a3c:	83 ec 08             	sub    $0x8,%esp
c0001a3f:	68 2c 2a 00 c0       	push   $0xc0002a2c
c0001a44:	6a 11                	push   $0x11
c0001a46:	e8 86 01 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001a4b:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(18,except_18);
c0001a4e:	83 ec 08             	sub    $0x8,%esp
c0001a51:	68 48 2a 00 c0       	push   $0xc0002a48
c0001a56:	6a 12                	push   $0x12
c0001a58:	e8 74 01 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001a5d:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(19,except_19);
c0001a60:	83 ec 08             	sub    $0x8,%esp
c0001a63:	68 64 2a 00 c0       	push   $0xc0002a64
c0001a68:	6a 13                	push   $0x13
c0001a6a:	e8 62 01 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001a6f:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(20,except_20);
c0001a72:	83 ec 08             	sub    $0x8,%esp
c0001a75:	68 80 2a 00 c0       	push   $0xc0002a80
c0001a7a:	6a 14                	push   $0x14
c0001a7c:	e8 50 01 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001a81:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(30,except_30);
c0001a84:	83 ec 08             	sub    $0x8,%esp
c0001a87:	68 9c 2a 00 c0       	push   $0xc0002a9c
c0001a8c:	6a 1e                	push   $0x1e
c0001a8e:	e8 3e 01 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001a93:	83 c4 10             	add    $0x10,%esp

    set_interrupt_handler(32,irq_0);
c0001a96:	83 ec 08             	sub    $0x8,%esp
c0001a99:	68 d0 2a 00 c0       	push   $0xc0002ad0
c0001a9e:	6a 20                	push   $0x20
c0001aa0:	e8 2c 01 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001aa5:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(33,irq_1);
c0001aa8:	83 ec 08             	sub    $0x8,%esp
c0001aab:	68 e4 2a 00 c0       	push   $0xc0002ae4
c0001ab0:	6a 21                	push   $0x21
c0001ab2:	e8 1a 01 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001ab7:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(34,irq_2);
c0001aba:	83 ec 08             	sub    $0x8,%esp
c0001abd:	68 f8 2a 00 c0       	push   $0xc0002af8
c0001ac2:	6a 22                	push   $0x22
c0001ac4:	e8 08 01 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001ac9:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(35,irq_3);
c0001acc:	83 ec 08             	sub    $0x8,%esp
c0001acf:	68 0c 2b 00 c0       	push   $0xc0002b0c
c0001ad4:	6a 23                	push   $0x23
c0001ad6:	e8 f6 00 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001adb:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(36,irq_4);
c0001ade:	83 ec 08             	sub    $0x8,%esp
c0001ae1:	68 20 2b 00 c0       	push   $0xc0002b20
c0001ae6:	6a 24                	push   $0x24
c0001ae8:	e8 e4 00 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001aed:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(37,irq_5);
c0001af0:	83 ec 08             	sub    $0x8,%esp
c0001af3:	68 34 2b 00 c0       	push   $0xc0002b34
c0001af8:	6a 25                	push   $0x25
c0001afa:	e8 d2 00 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001aff:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(38,irq_6);
c0001b02:	83 ec 08             	sub    $0x8,%esp
c0001b05:	68 48 2b 00 c0       	push   $0xc0002b48
c0001b0a:	6a 26                	push   $0x26
c0001b0c:	e8 c0 00 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001b11:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(39,irq_7);
c0001b14:	83 ec 08             	sub    $0x8,%esp
c0001b17:	68 5c 2b 00 c0       	push   $0xc0002b5c
c0001b1c:	6a 27                	push   $0x27
c0001b1e:	e8 ae 00 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001b23:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(40,irq_8);
c0001b26:	83 ec 08             	sub    $0x8,%esp
c0001b29:	68 70 2b 00 c0       	push   $0xc0002b70
c0001b2e:	6a 28                	push   $0x28
c0001b30:	e8 9c 00 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001b35:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(41,irq_9);
c0001b38:	83 ec 08             	sub    $0x8,%esp
c0001b3b:	68 84 2b 00 c0       	push   $0xc0002b84
c0001b40:	6a 29                	push   $0x29
c0001b42:	e8 8a 00 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001b47:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(42,irq_10);
c0001b4a:	83 ec 08             	sub    $0x8,%esp
c0001b4d:	68 98 2b 00 c0       	push   $0xc0002b98
c0001b52:	6a 2a                	push   $0x2a
c0001b54:	e8 78 00 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001b59:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(43,irq_11);
c0001b5c:	83 ec 08             	sub    $0x8,%esp
c0001b5f:	68 ac 2b 00 c0       	push   $0xc0002bac
c0001b64:	6a 2b                	push   $0x2b
c0001b66:	e8 66 00 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001b6b:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(44,irq_12);
c0001b6e:	83 ec 08             	sub    $0x8,%esp
c0001b71:	68 c0 2b 00 c0       	push   $0xc0002bc0
c0001b76:	6a 2c                	push   $0x2c
c0001b78:	e8 54 00 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001b7d:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(45,irq_13);
c0001b80:	83 ec 08             	sub    $0x8,%esp
c0001b83:	68 d4 2b 00 c0       	push   $0xc0002bd4
c0001b88:	6a 2d                	push   $0x2d
c0001b8a:	e8 42 00 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001b8f:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(46,irq_14);
c0001b92:	83 ec 08             	sub    $0x8,%esp
c0001b95:	68 e8 2b 00 c0       	push   $0xc0002be8
c0001b9a:	6a 2e                	push   $0x2e
c0001b9c:	e8 30 00 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001ba1:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(47,irq_15);
c0001ba4:	83 ec 08             	sub    $0x8,%esp
c0001ba7:	68 fc 2b 00 c0       	push   $0xc0002bfc
c0001bac:	6a 2f                	push   $0x2f
c0001bae:	e8 1e 00 00 00       	call   c0001bd1 <set_interrupt_handler>
c0001bb3:	83 c4 10             	add    $0x10,%esp



    idtd.base = (uint32_t) idt;
c0001bb6:	b8 20 f0 00 c0       	mov    $0xc000f020,%eax
c0001bbb:	a3 22 f8 00 c0       	mov    %eax,0xc000f822
    idtd.limit = sizeof(idt_entry_t) * NUM_INTERRUPT_HANDLERS - 1;
c0001bc0:	66 c7 05 20 f8 00 c0 	movw   $0x7ff,0xc000f820
c0001bc7:	ff 07 
    load_idt();
c0001bc9:	e8 ea 0c 00 00       	call   c00028b8 <load_idt>
}
c0001bce:	90                   	nop
c0001bcf:	c9                   	leave  
c0001bd0:	c3                   	ret    

c0001bd1 <set_interrupt_handler>:

void set_interrupt_handler(int int_num, void* handler)
{
c0001bd1:	55                   	push   %ebp
c0001bd2:	89 e5                	mov    %esp,%ebp
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c0001bd4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001bd7:	89 c2                	mov    %eax,%edx
c0001bd9:	8b 45 08             	mov    0x8(%ebp),%eax
c0001bdc:	66 89 14 c5 20 f0 00 	mov    %dx,-0x3fff0fe0(,%eax,8)
c0001be3:	c0 
	idt[int_num].segment = KERNEL_CODE_SEGMENT;
c0001be4:	8b 45 08             	mov    0x8(%ebp),%eax
c0001be7:	66 c7 04 c5 22 f0 00 	movw   $0x8,-0x3fff0fde(,%eax,8)
c0001bee:	c0 08 00 
	idt[int_num].zero = 0;
c0001bf1:	8b 45 08             	mov    0x8(%ebp),%eax
c0001bf4:	c6 04 c5 24 f0 00 c0 	movb   $0x0,-0x3fff0fdc(,%eax,8)
c0001bfb:	00 
	idt[int_num].type = 0x8e; /* INTERRUPT_GATE */
c0001bfc:	8b 45 08             	mov    0x8(%ebp),%eax
c0001bff:	c6 04 c5 25 f0 00 c0 	movb   $0x8e,-0x3fff0fdb(,%eax,8)
c0001c06:	8e 
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c0001c07:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001c0a:	c1 e8 10             	shr    $0x10,%eax
c0001c0d:	89 c2                	mov    %eax,%edx
c0001c0f:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c12:	66 89 14 c5 26 f0 00 	mov    %dx,-0x3fff0fda(,%eax,8)
c0001c19:	c0 
}
c0001c1a:	90                   	nop
c0001c1b:	5d                   	pop    %ebp
c0001c1c:	c3                   	ret    

c0001c1d <page_fault_handler>:

void page_fault_handler(uint32_t code, void* fault_addr)
{
c0001c1d:	55                   	push   %ebp
c0001c1e:	89 e5                	mov    %esp,%ebp
c0001c20:	83 ec 08             	sub    $0x8,%esp
    kprintf("\n\nPage Fault at address %x with code %x\n", fault_addr, code);
c0001c23:	83 ec 04             	sub    $0x4,%esp
c0001c26:	ff 75 08             	pushl  0x8(%ebp)
c0001c29:	ff 75 0c             	pushl  0xc(%ebp)
c0001c2c:	68 80 34 00 c0       	push   $0xc0003480
c0001c31:	e8 49 e8 ff ff       	call   c000047f <kprintf>
c0001c36:	83 c4 10             	add    $0x10,%esp
    while(1);
c0001c39:	eb fe                	jmp    c0001c39 <page_fault_handler+0x1c>

c0001c3b <exception_handler>:
}


void exception_handler(uint32_t exception_num, uint32_t code)
{
c0001c3b:	55                   	push   %ebp
c0001c3c:	89 e5                	mov    %esp,%ebp
c0001c3e:	83 ec 08             	sub    $0x8,%esp
    kprintf("\n\nException %u with code %u\n", exception_num, code);
c0001c41:	83 ec 04             	sub    $0x4,%esp
c0001c44:	ff 75 0c             	pushl  0xc(%ebp)
c0001c47:	ff 75 08             	pushl  0x8(%ebp)
c0001c4a:	68 a9 34 00 c0       	push   $0xc00034a9
c0001c4f:	e8 2b e8 ff ff       	call   c000047f <kprintf>
c0001c54:	83 c4 10             	add    $0x10,%esp
    while(1);
c0001c57:	eb fe                	jmp    c0001c57 <exception_handler+0x1c>

c0001c59 <irq_handler>:
}

void irq_handler(uint32_t irq_num)
{
c0001c59:	55                   	push   %ebp
c0001c5a:	89 e5                	mov    %esp,%ebp
c0001c5c:	83 ec 18             	sub    $0x18,%esp
    if(irq_num == 1)
c0001c5f:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0001c63:	75 36                	jne    c0001c9b <irq_handler+0x42>
    {
        unsigned char scan_code = inb(0x60);
c0001c65:	6a 60                	push   $0x60
c0001c67:	e8 f3 fb ff ff       	call   c000185f <inb>
c0001c6c:	83 c4 04             	add    $0x4,%esp
c0001c6f:	88 45 f7             	mov    %al,-0x9(%ebp)
        char key_ascii = scancode_to_ascii(scan_code);
c0001c72:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0001c76:	83 ec 0c             	sub    $0xc,%esp
c0001c79:	50                   	push   %eax
c0001c7a:	e8 6d 09 00 00       	call   c00025ec <scancode_to_ascii>
c0001c7f:	83 c4 10             	add    $0x10,%esp
c0001c82:	88 45 f6             	mov    %al,-0xa(%ebp)
        // kprintf("code: 0x%x, ascii:%c\n", scan_code, key_ascii);
        if(key_ascii>0)
c0001c85:	80 7d f6 00          	cmpb   $0x0,-0xa(%ebp)
c0001c89:	7e 10                	jle    c0001c9b <irq_handler+0x42>
            kprint_char(key_ascii);
c0001c8b:	0f be 45 f6          	movsbl -0xa(%ebp),%eax
c0001c8f:	83 ec 0c             	sub    $0xc,%esp
c0001c92:	50                   	push   %eax
c0001c93:	e8 96 e7 ff ff       	call   c000042e <kprint_char>
c0001c98:	83 c4 10             	add    $0x10,%esp
    
    }

    // notify PIC that interrupt handling is complete
    if(irq_num >= 8)
c0001c9b:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
c0001c9f:	76 12                	jbe    c0001cb3 <irq_handler+0x5a>
        outb(PIC_EOI, PIC2_CMD);
c0001ca1:	83 ec 08             	sub    $0x8,%esp
c0001ca4:	68 a0 00 00 00       	push   $0xa0
c0001ca9:	6a 20                	push   $0x20
c0001cab:	e8 cc fb ff ff       	call   c000187c <outb>
c0001cb0:	83 c4 10             	add    $0x10,%esp

    outb(PIC_EOI, PIC1_CMD);
c0001cb3:	83 ec 08             	sub    $0x8,%esp
c0001cb6:	6a 20                	push   $0x20
c0001cb8:	6a 20                	push   $0x20
c0001cba:	e8 bd fb ff ff       	call   c000187c <outb>
c0001cbf:	83 c4 10             	add    $0x10,%esp

    return;
c0001cc2:	90                   	nop
}
c0001cc3:	c9                   	leave  
c0001cc4:	c3                   	ret    

c0001cc5 <initialize_multitasking>:
task_control_block_t initial_task;

uint32_t pid_counter;

void initialize_multitasking()
{    
c0001cc5:	55                   	push   %ebp
c0001cc6:	89 e5                	mov    %esp,%ebp
c0001cc8:	83 ec 08             	sub    $0x8,%esp
    // initialize current task as initial task
    initial_task.pid = pid_counter = 0;
c0001ccb:	c7 05 5c f8 00 c0 00 	movl   $0x0,0xc000f85c
c0001cd2:	00 00 00 
c0001cd5:	a1 5c f8 00 c0       	mov    0xc000f85c,%eax
c0001cda:	a3 44 f8 00 c0       	mov    %eax,0xc000f844
    initial_task.state = RUNNING;
c0001cdf:	c7 05 48 f8 00 c0 00 	movl   $0x0,0xc000f848
c0001ce6:	00 00 00 
    initial_task.esp = NULL; //this is initialized only on task switch
c0001ce9:	c7 05 4c f8 00 c0 00 	movl   $0x0,0xc000f84c
c0001cf0:	00 00 00 
    initial_task.pd = get_page_dir();
c0001cf3:	e8 70 0f 00 00       	call   c0002c68 <get_page_dir>
c0001cf8:	a3 54 f8 00 c0       	mov    %eax,0xc000f854

    // this is the only task so far
    //as we add tasks this becomes circular linked list
    initial_task.next_task = &initial_task;
c0001cfd:	c7 05 58 f8 00 c0 44 	movl   $0xc000f844,0xc000f858
c0001d04:	f8 00 c0 
    current_task = &initial_task;
c0001d07:	c7 05 40 f8 00 c0 44 	movl   $0xc000f844,0xc000f840
c0001d0e:	f8 00 c0 
}
c0001d11:	90                   	nop
c0001d12:	c9                   	leave  
c0001d13:	c3                   	ret    

c0001d14 <new_kernel_task>:

task_control_block_t* new_kernel_task(void (*task_entry) (void))
{
c0001d14:	55                   	push   %ebp
c0001d15:	89 e5                	mov    %esp,%ebp
c0001d17:	83 ec 18             	sub    $0x18,%esp
    task_control_block_t* new_task = kmalloc(sizeof(task_control_block_t));
c0001d1a:	83 ec 0c             	sub    $0xc,%esp
c0001d1d:	6a 18                	push   $0x18
c0001d1f:	e8 13 08 00 00       	call   c0002537 <kmalloc>
c0001d24:	83 c4 10             	add    $0x10,%esp
c0001d27:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void* new_stack = kmalloc(KERNEL_STACK_SIZE);
c0001d2a:	83 ec 0c             	sub    $0xc,%esp
c0001d2d:	68 00 80 00 00       	push   $0x8000
c0001d32:	e8 00 08 00 00       	call   c0002537 <kmalloc>
c0001d37:	83 c4 10             	add    $0x10,%esp
c0001d3a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint32_t* esp0 = (uint32_t*) (new_stack + KERNEL_STACK_SIZE);
c0001d3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001d40:	05 00 80 00 00       	add    $0x8000,%eax
c0001d45:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // init new stack with valid context and new eip
    *(--esp0) = (uint32_t) task_entry; //push eip
c0001d48:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c0001d4c:	8b 55 08             	mov    0x8(%ebp),%edx
c0001d4f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001d52:	89 10                	mov    %edx,(%eax)
    *(--esp0) = 0; //push ebx
c0001d54:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c0001d58:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001d5b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp0) = 0; //push esi
c0001d61:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c0001d65:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001d68:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp0) = 0; //push edi
c0001d6e:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c0001d72:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001d75:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp0) = 0; //push ebp
c0001d7b:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c0001d7f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001d82:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    update_kstack(esp0); //update tss with esp0
c0001d88:	83 ec 0c             	sub    $0xc,%esp
c0001d8b:	ff 75 ec             	pushl  -0x14(%ebp)
c0001d8e:	e8 e2 0a 00 00       	call   c0002875 <update_kstack>
c0001d93:	83 c4 10             	add    $0x10,%esp

    //create copy of kernel page_dir
    void* new_pd = kmalloc_aligned(PAGE_SIZE, PAGE_SIZE);
c0001d96:	83 ec 08             	sub    $0x8,%esp
c0001d99:	68 00 10 00 00       	push   $0x1000
c0001d9e:	68 00 10 00 00       	push   $0x1000
c0001da3:	e8 c6 06 00 00       	call   c000246e <kmalloc_aligned>
c0001da8:	83 c4 10             	add    $0x10,%esp
c0001dab:	89 45 e8             	mov    %eax,-0x18(%ebp)
    memcpy(new_pd, (void*) &pd->dir,PAGE_SIZE);
c0001dae:	a1 00 40 00 c0       	mov    0xc0004000,%eax
c0001db3:	05 00 f0 3f 00       	add    $0x3ff000,%eax
c0001db8:	83 ec 04             	sub    $0x4,%esp
c0001dbb:	68 00 10 00 00       	push   $0x1000
c0001dc0:	50                   	push   %eax
c0001dc1:	ff 75 e8             	pushl  -0x18(%ebp)
c0001dc4:	e8 fa f4 ff ff       	call   c00012c3 <memcpy>
c0001dc9:	83 c4 10             	add    $0x10,%esp
    new_task->pd = get_physaddr(new_pd); //page dir is physical address.
c0001dcc:	83 ec 0c             	sub    $0xc,%esp
c0001dcf:	ff 75 e8             	pushl  -0x18(%ebp)
c0001dd2:	e8 0a 01 00 00       	call   c0001ee1 <get_physaddr>
c0001dd7:	83 c4 10             	add    $0x10,%esp
c0001dda:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0001ddd:	89 42 10             	mov    %eax,0x10(%edx)


    new_task->pid = ++pid_counter;
c0001de0:	a1 5c f8 00 c0       	mov    0xc000f85c,%eax
c0001de5:	83 c0 01             	add    $0x1,%eax
c0001de8:	a3 5c f8 00 c0       	mov    %eax,0xc000f85c
c0001ded:	8b 15 5c f8 00 c0    	mov    0xc000f85c,%edx
c0001df3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001df6:	89 10                	mov    %edx,(%eax)
    new_task->state = WAITING;
c0001df8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001dfb:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
    new_task->esp = esp0;
c0001e02:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001e05:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0001e08:	89 50 08             	mov    %edx,0x8(%eax)

    //insert task into the ll
    new_task->next_task = current_task->next_task;
c0001e0b:	a1 40 f8 00 c0       	mov    0xc000f840,%eax
c0001e10:	8b 50 14             	mov    0x14(%eax),%edx
c0001e13:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001e16:	89 50 14             	mov    %edx,0x14(%eax)
    current_task->next_task = new_task;
c0001e19:	a1 40 f8 00 c0       	mov    0xc000f840,%eax
c0001e1e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0001e21:	89 50 14             	mov    %edx,0x14(%eax)

    return new_task;
c0001e24:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0001e27:	c9                   	leave  
c0001e28:	c3                   	ret    

c0001e29 <switch_to_next_task>:

void switch_to_next_task(void)
{
c0001e29:	55                   	push   %ebp
c0001e2a:	89 e5                	mov    %esp,%ebp
c0001e2c:	83 ec 08             	sub    $0x8,%esp
    switch_to_task(current_task->next_task);
c0001e2f:	a1 40 f8 00 c0       	mov    0xc000f840,%eax
c0001e34:	8b 40 14             	mov    0x14(%eax),%eax
c0001e37:	83 ec 0c             	sub    $0xc,%esp
c0001e3a:	50                   	push   %eax
c0001e3b:	e8 d0 0d 00 00       	call   c0002c10 <switch_to_task>
c0001e40:	83 c4 10             	add    $0x10,%esp
}
c0001e43:	90                   	nop
c0001e44:	c9                   	leave  
c0001e45:	c3                   	ret    

c0001e46 <user_test>:
int user_test()
{
c0001e46:	55                   	push   %ebp
c0001e47:	89 e5                	mov    %esp,%ebp
c0001e49:	83 ec 10             	sub    $0x10,%esp
    int a = 1;
c0001e4c:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
    int b = 2;
c0001e53:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
    int c = b/a;
c0001e5a:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0001e5d:	99                   	cltd   
c0001e5e:	f7 7d fc             	idivl  -0x4(%ebp)
c0001e61:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return c;
c0001e64:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001e67:	c9                   	leave  
c0001e68:	c3                   	ret    

c0001e69 <get_ptindex>:
//global pointer to page directory
extern page_directory_virt_t* pd;   //initialized in paging_asm.S

// return page table index for virtual address
static inline uint32_t get_ptindex(void* addr)
{
c0001e69:	55                   	push   %ebp
c0001e6a:	89 e5                	mov    %esp,%ebp
    return (((uint32_t) addr) & PAGE_PTE_MASK ) >> 12;
c0001e6c:	8b 45 08             	mov    0x8(%ebp),%eax
c0001e6f:	c1 e8 0c             	shr    $0xc,%eax
c0001e72:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c0001e77:	5d                   	pop    %ebp
c0001e78:	c3                   	ret    

c0001e79 <get_pdindex>:

// return page directory index for virtual address
static inline uint32_t get_pdindex(void* addr)
{
c0001e79:	55                   	push   %ebp
c0001e7a:	89 e5                	mov    %esp,%ebp
    return ((uint32_t) addr) >> 22;
c0001e7c:	8b 45 08             	mov    0x8(%ebp),%eax
c0001e7f:	c1 e8 16             	shr    $0x16,%eax
}
c0001e82:	5d                   	pop    %ebp
c0001e83:	c3                   	ret    

c0001e84 <get_page_offset>:

// return offset into page
static inline uint32_t get_page_offset(void* addr)
{
c0001e84:	55                   	push   %ebp
c0001e85:	89 e5                	mov    %esp,%ebp
    return ((uint32_t) addr) & ~PAGE_ADDRMASK;
c0001e87:	8b 45 08             	mov    0x8(%ebp),%eax
c0001e8a:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c0001e8f:	5d                   	pop    %ebp
c0001e90:	c3                   	ret    

c0001e91 <get_table>:

page_directory_virt_t* pd = (page_directory_virt_t*) PD_ADDR;

// return page directory index for virtual address
page_table_t* get_table(void* addr)
{
c0001e91:	55                   	push   %ebp
c0001e92:	89 e5                	mov    %esp,%ebp
c0001e94:	53                   	push   %ebx
c0001e95:	83 ec 10             	sub    $0x10,%esp
    uint32_t idx = get_pdindex(addr);
c0001e98:	ff 75 08             	pushl  0x8(%ebp)
c0001e9b:	e8 d9 ff ff ff       	call   c0001e79 <get_pdindex>
c0001ea0:	83 c4 04             	add    $0x4,%esp
c0001ea3:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(pd->dir.pde[idx] & PAGE_FLAG_PRESENT)
c0001ea6:	a1 00 40 00 c0       	mov    0xc0004000,%eax
c0001eab:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0001eae:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c0001eb4:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0001eb7:	83 e0 01             	and    $0x1,%eax
c0001eba:	85 c0                	test   %eax,%eax
c0001ebc:	74 19                	je     c0001ed7 <get_table+0x46>
        return pd->tables + get_pdindex(addr);
c0001ebe:	a1 00 40 00 c0       	mov    0xc0004000,%eax
c0001ec3:	89 c3                	mov    %eax,%ebx
c0001ec5:	ff 75 08             	pushl  0x8(%ebp)
c0001ec8:	e8 ac ff ff ff       	call   c0001e79 <get_pdindex>
c0001ecd:	83 c4 04             	add    $0x4,%esp
c0001ed0:	c1 e0 0c             	shl    $0xc,%eax
c0001ed3:	01 d8                	add    %ebx,%eax
c0001ed5:	eb 05                	jmp    c0001edc <get_table+0x4b>
    else 
        return NULL;
c0001ed7:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0001edc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0001edf:	c9                   	leave  
c0001ee0:	c3                   	ret    

c0001ee1 <get_physaddr>:

// return physical addr from virt addr
void* get_physaddr(void* addr)
{
c0001ee1:	55                   	push   %ebp
c0001ee2:	89 e5                	mov    %esp,%ebp
c0001ee4:	53                   	push   %ebx
c0001ee5:	83 ec 10             	sub    $0x10,%esp
    //check pd entry is present
    uint32_t pdi = get_pdindex(addr);
c0001ee8:	ff 75 08             	pushl  0x8(%ebp)
c0001eeb:	e8 89 ff ff ff       	call   c0001e79 <get_pdindex>
c0001ef0:	83 c4 04             	add    $0x4,%esp
c0001ef3:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(! pd->dir.pde[pdi] & PAGE_FLAG_PRESENT)
c0001ef6:	a1 00 40 00 c0       	mov    0xc0004000,%eax
c0001efb:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0001efe:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c0001f04:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0001f07:	85 c0                	test   %eax,%eax
c0001f09:	75 07                	jne    c0001f12 <get_physaddr+0x31>
        return NULL;
c0001f0b:	b8 00 00 00 00       	mov    $0x0,%eax
c0001f10:	eb 45                	jmp    c0001f57 <get_physaddr+0x76>

    //check pt entry is present
    uint32_t pte = pd->tables[pdi].pte[get_ptindex(addr)];
c0001f12:	8b 1d 00 40 00 c0    	mov    0xc0004000,%ebx
c0001f18:	ff 75 08             	pushl  0x8(%ebp)
c0001f1b:	e8 49 ff ff ff       	call   c0001e69 <get_ptindex>
c0001f20:	83 c4 04             	add    $0x4,%esp
c0001f23:	89 c2                	mov    %eax,%edx
c0001f25:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0001f28:	c1 e0 0a             	shl    $0xa,%eax
c0001f2b:	01 d0                	add    %edx,%eax
c0001f2d:	8b 04 83             	mov    (%ebx,%eax,4),%eax
c0001f30:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(! pte & PAGE_FLAG_PRESENT)
c0001f33:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0001f37:	75 07                	jne    c0001f40 <get_physaddr+0x5f>
        return NULL;
c0001f39:	b8 00 00 00 00       	mov    $0x0,%eax
c0001f3e:	eb 17                	jmp    c0001f57 <get_physaddr+0x76>

    return (void*) ((pte & PAGE_ADDRMASK) +  get_page_offset(addr) );
c0001f40:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001f43:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0001f48:	89 c3                	mov    %eax,%ebx
c0001f4a:	ff 75 08             	pushl  0x8(%ebp)
c0001f4d:	e8 32 ff ff ff       	call   c0001e84 <get_page_offset>
c0001f52:	83 c4 04             	add    $0x4,%esp
c0001f55:	01 d8                	add    %ebx,%eax
}
c0001f57:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0001f5a:	c9                   	leave  
c0001f5b:	c3                   	ret    

c0001f5c <get_ptindex>:
{
c0001f5c:	55                   	push   %ebp
c0001f5d:	89 e5                	mov    %esp,%ebp
    return (((uint32_t) addr) & PAGE_PTE_MASK ) >> 12;
c0001f5f:	8b 45 08             	mov    0x8(%ebp),%eax
c0001f62:	c1 e8 0c             	shr    $0xc,%eax
c0001f65:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c0001f6a:	5d                   	pop    %ebp
c0001f6b:	c3                   	ret    

c0001f6c <get_pdindex>:
{
c0001f6c:	55                   	push   %ebp
c0001f6d:	89 e5                	mov    %esp,%ebp
    return ((uint32_t) addr) >> 22;
c0001f6f:	8b 45 08             	mov    0x8(%ebp),%eax
c0001f72:	c1 e8 16             	shr    $0x16,%eax
}
c0001f75:	5d                   	pop    %ebp
c0001f76:	c3                   	ret    

c0001f77 <align_addr>:
void* kmalloc(size_t sz);
void* kmalloc_aligned(size_t sz, size_t alignment);
void* memset(void* addr, int val, size_t cnt);

static inline void* align_addr(void* addr, uint32_t alignment)
{
c0001f77:	55                   	push   %ebp
c0001f78:	89 e5                	mov    %esp,%ebp
c0001f7a:	83 ec 10             	sub    $0x10,%esp
    uint32_t am = alignment - 1;
c0001f7d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001f80:	83 e8 01             	sub    $0x1,%eax
c0001f83:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (char*) (((uint32_t)addr + am) & ~am);
c0001f86:	8b 55 08             	mov    0x8(%ebp),%edx
c0001f89:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001f8c:	01 c2                	add    %eax,%edx
c0001f8e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001f91:	f7 d0                	not    %eax
c0001f93:	21 d0                	and    %edx,%eax
}
c0001f95:	c9                   	leave  
c0001f96:	c3                   	ret    

c0001f97 <is_pow_of_two>:

static inline int is_pow_of_two(uint32_t x)
{
c0001f97:	55                   	push   %ebp
c0001f98:	89 e5                	mov    %esp,%ebp
    return (x != 0) && ((x & (x - 1)) == 0);
c0001f9a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0001f9e:	74 14                	je     c0001fb4 <is_pow_of_two+0x1d>
c0001fa0:	8b 45 08             	mov    0x8(%ebp),%eax
c0001fa3:	83 e8 01             	sub    $0x1,%eax
c0001fa6:	23 45 08             	and    0x8(%ebp),%eax
c0001fa9:	85 c0                	test   %eax,%eax
c0001fab:	75 07                	jne    c0001fb4 <is_pow_of_two+0x1d>
c0001fad:	b8 01 00 00 00       	mov    $0x1,%eax
c0001fb2:	eb 05                	jmp    c0001fb9 <is_pow_of_two+0x22>
c0001fb4:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0001fb9:	5d                   	pop    %ebp
c0001fba:	c3                   	ret    

c0001fbb <memory_init>:
char* heap;
char* heap_end;
char* heap_end_phys;

int memory_init(multiboot_info_t* mbd)
{
c0001fbb:	55                   	push   %ebp
c0001fbc:	89 e5                	mov    %esp,%ebp
c0001fbe:	83 ec 08             	sub    $0x8,%esp
	if(! heap_init(mbd) )
c0001fc1:	83 ec 0c             	sub    $0xc,%esp
c0001fc4:	ff 75 08             	pushl  0x8(%ebp)
c0001fc7:	e8 3b 01 00 00       	call   c0002107 <heap_init>
c0001fcc:	83 c4 10             	add    $0x10,%esp
c0001fcf:	85 c0                	test   %eax,%eax
c0001fd1:	75 07                	jne    c0001fda <memory_init+0x1f>
        return -1;
c0001fd3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0001fd8:	eb 25                	jmp    c0001fff <memory_init+0x44>

	if( unmap_lowmem() )
c0001fda:	e8 22 00 00 00       	call   c0002001 <unmap_lowmem>
c0001fdf:	85 c0                	test   %eax,%eax
c0001fe1:	74 07                	je     c0001fea <memory_init+0x2f>
        return -1;
c0001fe3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0001fe8:	eb 15                	jmp    c0001fff <memory_init+0x44>

	// if(! map_multiboot() )
    //     return -1;

	if(! map_vga() )
c0001fea:	e8 33 00 00 00       	call   c0002022 <map_vga>
c0001fef:	85 c0                	test   %eax,%eax
c0001ff1:	75 07                	jne    c0001ffa <memory_init+0x3f>
        return -1;
c0001ff3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0001ff8:	eb 05                	jmp    c0001fff <memory_init+0x44>

    return 0;
c0001ffa:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0001fff:	c9                   	leave  
c0002000:	c3                   	ret    

c0002001 <unmap_lowmem>:

int unmap_lowmem()
{
c0002001:	55                   	push   %ebp
c0002002:	89 e5                	mov    %esp,%ebp
c0002004:	83 ec 08             	sub    $0x8,%esp
    pd->dir.pde[0] = PAGE_FLAG_EMPTY;
c0002007:	a1 00 40 00 c0       	mov    0xc0004000,%eax
c000200c:	c7 80 00 f0 3f 00 00 	movl   $0x0,0x3ff000(%eax)
c0002013:	00 00 00 
    refresh_tlb();
c0002016:	e8 51 0c 00 00       	call   c0002c6c <refresh_tlb>
    return 0;
c000201b:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002020:	c9                   	leave  
c0002021:	c3                   	ret    

c0002022 <map_vga>:
// {

// }

char* map_vga()
{
c0002022:	55                   	push   %ebp
c0002023:	89 e5                	mov    %esp,%ebp
c0002025:	83 ec 18             	sub    $0x18,%esp
    page_t* vga_buf = (page_t*) VGA_BUFFER;
c0002028:	c7 45 f4 00 80 0b 00 	movl   $0xb8000,-0xc(%ebp)

    //map 6 pages of vga memory    
    map_page_at(vga_buf,vga_buf, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c000202f:	83 ec 04             	sub    $0x4,%esp
c0002032:	6a 06                	push   $0x6
c0002034:	ff 75 f4             	pushl  -0xc(%ebp)
c0002037:	ff 75 f4             	pushl  -0xc(%ebp)
c000203a:	e8 fa 02 00 00       	call   c0002339 <map_page_at>
c000203f:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+1,vga_buf+1, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c0002042:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002045:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c000204b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000204e:	05 00 10 00 00       	add    $0x1000,%eax
c0002053:	83 ec 04             	sub    $0x4,%esp
c0002056:	6a 06                	push   $0x6
c0002058:	52                   	push   %edx
c0002059:	50                   	push   %eax
c000205a:	e8 da 02 00 00       	call   c0002339 <map_page_at>
c000205f:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+2,vga_buf+2, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c0002062:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002065:	8d 90 00 20 00 00    	lea    0x2000(%eax),%edx
c000206b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000206e:	05 00 20 00 00       	add    $0x2000,%eax
c0002073:	83 ec 04             	sub    $0x4,%esp
c0002076:	6a 06                	push   $0x6
c0002078:	52                   	push   %edx
c0002079:	50                   	push   %eax
c000207a:	e8 ba 02 00 00       	call   c0002339 <map_page_at>
c000207f:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+3,vga_buf+3, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c0002082:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002085:	8d 90 00 30 00 00    	lea    0x3000(%eax),%edx
c000208b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000208e:	05 00 30 00 00       	add    $0x3000,%eax
c0002093:	83 ec 04             	sub    $0x4,%esp
c0002096:	6a 06                	push   $0x6
c0002098:	52                   	push   %edx
c0002099:	50                   	push   %eax
c000209a:	e8 9a 02 00 00       	call   c0002339 <map_page_at>
c000209f:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+4,vga_buf+4, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c00020a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00020a5:	8d 90 00 40 00 00    	lea    0x4000(%eax),%edx
c00020ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00020ae:	05 00 40 00 00       	add    $0x4000,%eax
c00020b3:	83 ec 04             	sub    $0x4,%esp
c00020b6:	6a 06                	push   $0x6
c00020b8:	52                   	push   %edx
c00020b9:	50                   	push   %eax
c00020ba:	e8 7a 02 00 00       	call   c0002339 <map_page_at>
c00020bf:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+5,vga_buf+5, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c00020c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00020c5:	8d 90 00 50 00 00    	lea    0x5000(%eax),%edx
c00020cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00020ce:	05 00 50 00 00       	add    $0x5000,%eax
c00020d3:	83 ec 04             	sub    $0x4,%esp
c00020d6:	6a 06                	push   $0x6
c00020d8:	52                   	push   %edx
c00020d9:	50                   	push   %eax
c00020da:	e8 5a 02 00 00       	call   c0002339 <map_page_at>
c00020df:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+6,vga_buf+6, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c00020e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00020e5:	8d 90 00 60 00 00    	lea    0x6000(%eax),%edx
c00020eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00020ee:	05 00 60 00 00       	add    $0x6000,%eax
c00020f3:	83 ec 04             	sub    $0x4,%esp
c00020f6:	6a 06                	push   $0x6
c00020f8:	52                   	push   %edx
c00020f9:	50                   	push   %eax
c00020fa:	e8 3a 02 00 00       	call   c0002339 <map_page_at>
c00020ff:	83 c4 10             	add    $0x10,%esp

    return (char*) vga_buf;
c0002102:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0002105:	c9                   	leave  
c0002106:	c3                   	ret    

c0002107 <heap_init>:

char* heap_init(multiboot_info_t* mbd)
{
c0002107:	55                   	push   %ebp
c0002108:	89 e5                	mov    %esp,%ebp
c000210a:	83 ec 18             	sub    $0x18,%esp
    char* heap_phys;
	size_t free_mem_size = get_big_block(mbd, (void**) &heap_phys);
c000210d:	83 ec 08             	sub    $0x8,%esp
c0002110:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0002113:	50                   	push   %eax
c0002114:	ff 75 08             	pushl  0x8(%ebp)
c0002117:	e8 00 01 00 00       	call   c000221c <get_big_block>
c000211c:	83 c4 10             	add    $0x10,%esp
c000211f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	heap_end_phys = heap_phys+free_mem_size;
c0002122:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0002125:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002128:	01 d0                	add    %edx,%eax
c000212a:	a3 70 f8 00 c0       	mov    %eax,0xc000f870

	// this memory is not actually completely free, but includes the kernel
	if(&_kernel_end_phys >= heap_phys && &_kernel_end_phys < heap_end_phys)
c000212f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002132:	3d 48 09 11 00       	cmp    $0x110948,%eax
c0002137:	77 13                	ja     c000214c <heap_init+0x45>
c0002139:	a1 70 f8 00 c0       	mov    0xc000f870,%eax
c000213e:	3d 48 09 11 00       	cmp    $0x110948,%eax
c0002143:	76 07                	jbe    c000214c <heap_init+0x45>
		heap_phys = &_kernel_end_phys;
c0002145:	c7 45 f0 48 09 11 00 	movl   $0x110948,-0x10(%ebp)

    //start new allocations here in physical memory
    heap_page_phys = (page_t*) align_addr((void*) heap_phys, PAGE_SIZE);
c000214c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000214f:	83 ec 08             	sub    $0x8,%esp
c0002152:	68 00 10 00 00       	push   $0x1000
c0002157:	50                   	push   %eax
c0002158:	e8 1a fe ff ff       	call   c0001f77 <align_addr>
c000215d:	83 c4 10             	add    $0x10,%esp
c0002160:	a3 64 f8 00 c0       	mov    %eax,0xc000f864
    heap_phys = (char*) heap_page_phys;
c0002165:	a1 64 f8 00 c0       	mov    0xc000f864,%eax
c000216a:	89 45 f0             	mov    %eax,-0x10(%ebp)

    //start new allocations here in virtual memory
    heap_page = (page_t*) align_addr((void*) KERNEL_HEAP, PAGE_SIZE);
c000216d:	83 ec 08             	sub    $0x8,%esp
c0002170:	68 00 10 00 00       	push   $0x1000
c0002175:	68 00 00 00 c5       	push   $0xc5000000
c000217a:	e8 f8 fd ff ff       	call   c0001f77 <align_addr>
c000217f:	83 c4 10             	add    $0x10,%esp
c0002182:	a3 60 f8 00 c0       	mov    %eax,0xc000f860
    heap = (char*) heap_page;
c0002187:	a1 60 f8 00 c0       	mov    0xc000f860,%eax
c000218c:	a3 68 f8 00 c0       	mov    %eax,0xc000f868
    heap_end = (char*) KERNEL_HEAP_END;
c0002191:	c7 05 6c f8 00 c0 00 	movl   $0xf0000000,0xc000f86c
c0002198:	00 00 f0 

	kprintf("\nPhysical heap: 0x%.8x - 0x%.8x (%u MiB)\n", heap_phys, heap_end_phys,  (uint32_t) (heap_end_phys-heap_phys) >> 20);
c000219b:	a1 70 f8 00 c0       	mov    0xc000f870,%eax
c00021a0:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00021a3:	29 d0                	sub    %edx,%eax
c00021a5:	c1 e8 14             	shr    $0x14,%eax
c00021a8:	89 c1                	mov    %eax,%ecx
c00021aa:	8b 15 70 f8 00 c0    	mov    0xc000f870,%edx
c00021b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00021b3:	51                   	push   %ecx
c00021b4:	52                   	push   %edx
c00021b5:	50                   	push   %eax
c00021b6:	68 c8 34 00 c0       	push   $0xc00034c8
c00021bb:	e8 bf e2 ff ff       	call   c000047f <kprintf>
c00021c0:	83 c4 10             	add    $0x10,%esp
	kprintf("Virtual heap: 0x%.8x - 0x%.8x (%u MiB)\n\n", heap, heap_end,  (uint32_t) (heap_end-heap) >> 20);
c00021c3:	a1 6c f8 00 c0       	mov    0xc000f86c,%eax
c00021c8:	8b 15 68 f8 00 c0    	mov    0xc000f868,%edx
c00021ce:	29 d0                	sub    %edx,%eax
c00021d0:	c1 e8 14             	shr    $0x14,%eax
c00021d3:	89 c1                	mov    %eax,%ecx
c00021d5:	8b 15 6c f8 00 c0    	mov    0xc000f86c,%edx
c00021db:	a1 68 f8 00 c0       	mov    0xc000f868,%eax
c00021e0:	51                   	push   %ecx
c00021e1:	52                   	push   %edx
c00021e2:	50                   	push   %eax
c00021e3:	68 f4 34 00 c0       	push   $0xc00034f4
c00021e8:	e8 92 e2 ff ff       	call   c000047f <kprintf>
c00021ed:	83 c4 10             	add    $0x10,%esp

    //map the first page on the heap
    if(!map_page_at(heap_page, heap_page_phys, PAGE_FLAG_WRITE))
c00021f0:	8b 15 64 f8 00 c0    	mov    0xc000f864,%edx
c00021f6:	a1 60 f8 00 c0       	mov    0xc000f860,%eax
c00021fb:	83 ec 04             	sub    $0x4,%esp
c00021fe:	6a 02                	push   $0x2
c0002200:	52                   	push   %edx
c0002201:	50                   	push   %eax
c0002202:	e8 32 01 00 00       	call   c0002339 <map_page_at>
c0002207:	83 c4 10             	add    $0x10,%esp
c000220a:	85 c0                	test   %eax,%eax
c000220c:	75 07                	jne    c0002215 <heap_init+0x10e>
        return NULL;
c000220e:	b8 00 00 00 00       	mov    $0x0,%eax
c0002213:	eb 05                	jmp    c000221a <heap_init+0x113>

    return heap;
c0002215:	a1 68 f8 00 c0       	mov    0xc000f868,%eax
}
c000221a:	c9                   	leave  
c000221b:	c3                   	ret    

c000221c <get_big_block>:


size_t get_big_block(multiboot_info_t* mbd, void** block)
{
c000221c:	55                   	push   %ebp
c000221d:	89 e5                	mov    %esp,%ebp
c000221f:	57                   	push   %edi
c0002220:	56                   	push   %esi
c0002221:	53                   	push   %ebx
c0002222:	83 ec 14             	sub    $0x14,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c0002225:	8b 45 08             	mov    0x8(%ebp),%eax
c0002228:	8b 40 30             	mov    0x30(%eax),%eax
c000222b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    size_t block_size = 0;
c000222e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0002235:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c000223c:	e9 d8 00 00 00       	jmp    c0002319 <get_big_block+0xfd>
	{
        if(mmap_table[nn].size == 0)
c0002241:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0002244:	89 d0                	mov    %edx,%eax
c0002246:	01 c0                	add    %eax,%eax
c0002248:	01 d0                	add    %edx,%eax
c000224a:	c1 e0 03             	shl    $0x3,%eax
c000224d:	89 c2                	mov    %eax,%edx
c000224f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0002252:	01 d0                	add    %edx,%eax
c0002254:	8b 00                	mov    (%eax),%eax
c0002256:	85 c0                	test   %eax,%eax
c0002258:	0f 84 cc 00 00 00    	je     c000232a <get_big_block+0x10e>
            break;

		if(mmap_table[nn].len>block_size && mmap_table[nn].type == MULTIBOOT_MEMORY_AVAILABLE)
c000225e:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0002261:	89 d0                	mov    %edx,%eax
c0002263:	01 c0                	add    %eax,%eax
c0002265:	01 d0                	add    %edx,%eax
c0002267:	c1 e0 03             	shl    $0x3,%eax
c000226a:	89 c2                	mov    %eax,%edx
c000226c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000226f:	01 d0                	add    %edx,%eax
c0002271:	8b 50 10             	mov    0x10(%eax),%edx
c0002274:	8b 40 0c             	mov    0xc(%eax),%eax
c0002277:	8b 75 ec             	mov    -0x14(%ebp),%esi
c000227a:	bf 00 00 00 00       	mov    $0x0,%edi
c000227f:	39 c6                	cmp    %eax,%esi
c0002281:	89 fe                	mov    %edi,%esi
c0002283:	19 d6                	sbb    %edx,%esi
c0002285:	0f 83 8a 00 00 00    	jae    c0002315 <get_big_block+0xf9>
c000228b:	8b 55 e8             	mov    -0x18(%ebp),%edx
c000228e:	89 d0                	mov    %edx,%eax
c0002290:	01 c0                	add    %eax,%eax
c0002292:	01 d0                	add    %edx,%eax
c0002294:	c1 e0 03             	shl    $0x3,%eax
c0002297:	89 c2                	mov    %eax,%edx
c0002299:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000229c:	01 d0                	add    %edx,%eax
c000229e:	8b 40 14             	mov    0x14(%eax),%eax
c00022a1:	83 f8 01             	cmp    $0x1,%eax
c00022a4:	75 6f                	jne    c0002315 <get_big_block+0xf9>
        {
            block_size = mmap_table[nn].len;
c00022a6:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00022a9:	89 d0                	mov    %edx,%eax
c00022ab:	01 c0                	add    %eax,%eax
c00022ad:	01 d0                	add    %edx,%eax
c00022af:	c1 e0 03             	shl    $0x3,%eax
c00022b2:	89 c2                	mov    %eax,%edx
c00022b4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00022b7:	01 d0                	add    %edx,%eax
c00022b9:	8b 50 10             	mov    0x10(%eax),%edx
c00022bc:	8b 40 0c             	mov    0xc(%eax),%eax
c00022bf:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if(mmap_table[nn].addr >> 32)
c00022c2:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00022c5:	89 d0                	mov    %edx,%eax
c00022c7:	01 c0                	add    %eax,%eax
c00022c9:	01 d0                	add    %edx,%eax
c00022cb:	c1 e0 03             	shl    $0x3,%eax
c00022ce:	89 c2                	mov    %eax,%edx
c00022d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00022d3:	01 d0                	add    %edx,%eax
c00022d5:	8b 50 08             	mov    0x8(%eax),%edx
c00022d8:	8b 40 04             	mov    0x4(%eax),%eax
c00022db:	89 d0                	mov    %edx,%eax
c00022dd:	31 d2                	xor    %edx,%edx
c00022df:	89 c7                	mov    %eax,%edi
c00022e1:	83 f7 00             	xor    $0x0,%edi
c00022e4:	89 f9                	mov    %edi,%ecx
c00022e6:	89 d0                	mov    %edx,%eax
c00022e8:	80 f4 00             	xor    $0x0,%ah
c00022eb:	89 c3                	mov    %eax,%ebx
c00022ed:	89 d8                	mov    %ebx,%eax
c00022ef:	09 c8                	or     %ecx,%eax
c00022f1:	85 c0                	test   %eax,%eax
c00022f3:	75 38                	jne    c000232d <get_big_block+0x111>
            {
                // ignore anything above 32bits
                break;
            }
            *block = (void*) (uint32_t) mmap_table[nn].addr;
c00022f5:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00022f8:	89 d0                	mov    %edx,%eax
c00022fa:	01 c0                	add    %eax,%eax
c00022fc:	01 d0                	add    %edx,%eax
c00022fe:	c1 e0 03             	shl    $0x3,%eax
c0002301:	89 c2                	mov    %eax,%edx
c0002303:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0002306:	01 d0                	add    %edx,%eax
c0002308:	8b 50 08             	mov    0x8(%eax),%edx
c000230b:	8b 40 04             	mov    0x4(%eax),%eax
c000230e:	89 c2                	mov    %eax,%edx
c0002310:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002313:	89 10                	mov    %edx,(%eax)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0002315:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c0002319:	8b 45 08             	mov    0x8(%ebp),%eax
c000231c:	8b 40 2c             	mov    0x2c(%eax),%eax
c000231f:	39 45 e8             	cmp    %eax,-0x18(%ebp)
c0002322:	0f 82 19 ff ff ff    	jb     c0002241 <get_big_block+0x25>
c0002328:	eb 04                	jmp    c000232e <get_big_block+0x112>
            break;
c000232a:	90                   	nop
c000232b:	eb 01                	jmp    c000232e <get_big_block+0x112>
                break;
c000232d:	90                   	nop
        }
	}
    return block_size;
c000232e:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c0002331:	83 c4 14             	add    $0x14,%esp
c0002334:	5b                   	pop    %ebx
c0002335:	5e                   	pop    %esi
c0002336:	5f                   	pop    %edi
c0002337:	5d                   	pop    %ebp
c0002338:	c3                   	ret    

c0002339 <map_page_at>:


page_t* map_page_at(page_t* page_virt, page_t* page_phys, uint32_t flags)
{
c0002339:	55                   	push   %ebp
c000233a:	89 e5                	mov    %esp,%ebp
c000233c:	53                   	push   %ebx
c000233d:	83 ec 14             	sub    $0x14,%esp
    page_table_t* pt = get_table(page_virt);
c0002340:	83 ec 0c             	sub    $0xc,%esp
c0002343:	ff 75 08             	pushl  0x8(%ebp)
c0002346:	e8 46 fb ff ff       	call   c0001e91 <get_table>
c000234b:	83 c4 10             	add    $0x10,%esp
c000234e:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(!pt)
c0002351:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002355:	75 14                	jne    c000236b <map_page_at+0x32>
        pt = new_page_table(page_virt, flags); // page table is not present, allocate a new one
c0002357:	83 ec 08             	sub    $0x8,%esp
c000235a:	ff 75 10             	pushl  0x10(%ebp)
c000235d:	ff 75 08             	pushl  0x8(%ebp)
c0002360:	e8 64 00 00 00       	call   c00023c9 <new_page_table>
c0002365:	83 c4 10             	add    $0x10,%esp
c0002368:	89 45 f4             	mov    %eax,-0xc(%ebp)
    
    if(pt->pte[get_ptindex(page_virt)] & PAGE_FLAG_PRESENT)
c000236b:	83 ec 0c             	sub    $0xc,%esp
c000236e:	ff 75 08             	pushl  0x8(%ebp)
c0002371:	e8 e6 fb ff ff       	call   c0001f5c <get_ptindex>
c0002376:	83 c4 10             	add    $0x10,%esp
c0002379:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000237c:	8b 04 82             	mov    (%edx,%eax,4),%eax
c000237f:	83 e0 01             	and    $0x1,%eax
c0002382:	85 c0                	test   %eax,%eax
c0002384:	74 07                	je     c000238d <map_page_at+0x54>
        return NULL; //page already mapped
c0002386:	b8 00 00 00 00       	mov    $0x0,%eax
c000238b:	eb 37                	jmp    c00023c4 <map_page_at+0x8b>

    // map page
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c000238d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002390:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002395:	0b 45 10             	or     0x10(%ebp),%eax
c0002398:	89 c3                	mov    %eax,%ebx
c000239a:	83 ec 0c             	sub    $0xc,%esp
c000239d:	ff 75 08             	pushl  0x8(%ebp)
c00023a0:	e8 b7 fb ff ff       	call   c0001f5c <get_ptindex>
c00023a5:	83 c4 10             	add    $0x10,%esp
c00023a8:	89 d9                	mov    %ebx,%ecx
c00023aa:	83 c9 01             	or     $0x1,%ecx
c00023ad:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00023b0:	89 0c 82             	mov    %ecx,(%edx,%eax,4)

    refresh_page(page_virt);
c00023b3:	83 ec 0c             	sub    $0xc,%esp
c00023b6:	ff 75 08             	pushl  0x8(%ebp)
c00023b9:	e8 b6 08 00 00       	call   c0002c74 <refresh_page>
c00023be:	83 c4 10             	add    $0x10,%esp
    return page_virt;
c00023c1:	8b 45 08             	mov    0x8(%ebp),%eax
}
c00023c4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00023c7:	c9                   	leave  
c00023c8:	c3                   	ret    

c00023c9 <new_page_table>:

page_table_t* new_page_table(void* addr, uint32_t flags)
{
c00023c9:	55                   	push   %ebp
c00023ca:	89 e5                	mov    %esp,%ebp
c00023cc:	83 ec 18             	sub    $0x18,%esp
    uint32_t pdindex = get_pdindex(addr);      // index into page dir (which table does this address point to)
c00023cf:	ff 75 08             	pushl  0x8(%ebp)
c00023d2:	e8 95 fb ff ff       	call   c0001f6c <get_pdindex>
c00023d7:	83 c4 04             	add    $0x4,%esp
c00023da:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // is this table already mapped?
    if(pd->dir.pde[pdindex] & PAGE_FLAG_PRESENT)
c00023dd:	a1 00 40 00 c0       	mov    0xc0004000,%eax
c00023e2:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00023e5:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c00023eb:	8b 04 90             	mov    (%eax,%edx,4),%eax
c00023ee:	83 e0 01             	and    $0x1,%eax
c00023f1:	85 c0                	test   %eax,%eax
c00023f3:	74 07                	je     c00023fc <new_page_table+0x33>
        return NULL;
c00023f5:	b8 00 00 00 00       	mov    $0x0,%eax
c00023fa:	eb 70                	jmp    c000246c <new_page_table+0xa3>

    page_t* pp = get_next_heap_page_phys();         // find a free page in physical mem for page table
c00023fc:	e8 81 01 00 00       	call   c0002582 <get_next_heap_page_phys>
c0002401:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!pp) return NULL; // OOM
c0002404:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0002408:	75 07                	jne    c0002411 <new_page_table+0x48>
c000240a:	b8 00 00 00 00       	mov    $0x0,%eax
c000240f:	eb 5b                	jmp    c000246c <new_page_table+0xa3>

    // we don't need to allocate virtual memory space, since table lives in our paging structure
    page_table_t* pv = pd->tables + pdindex;        // pointer to table (virtual)
c0002411:	a1 00 40 00 c0       	mov    0xc0004000,%eax
c0002416:	89 c2                	mov    %eax,%edx
c0002418:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000241b:	c1 e0 0c             	shl    $0xc,%eax
c000241e:	01 d0                	add    %edx,%eax
c0002420:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // map table: point the pd entry at the physical page we just reserved, and set flags
    pd->dir.pde[pdindex] = (((uint32_t) pp) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0002423:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002426:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c000242b:	0b 45 0c             	or     0xc(%ebp),%eax
c000242e:	89 c2                	mov    %eax,%edx
c0002430:	a1 00 40 00 c0       	mov    0xc0004000,%eax
c0002435:	89 d1                	mov    %edx,%ecx
c0002437:	83 c9 01             	or     $0x1,%ecx
c000243a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000243d:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c0002443:	89 0c 90             	mov    %ecx,(%eax,%edx,4)

    // flush the tlb
    refresh_page(pv);
c0002446:	83 ec 0c             	sub    $0xc,%esp
c0002449:	ff 75 ec             	pushl  -0x14(%ebp)
c000244c:	e8 23 08 00 00       	call   c0002c74 <refresh_page>
c0002451:	83 c4 10             	add    $0x10,%esp

    //clear table
    memset((char*) pv, 0, PAGE_SIZE);     
c0002454:	83 ec 04             	sub    $0x4,%esp
c0002457:	68 00 10 00 00       	push   $0x1000
c000245c:	6a 00                	push   $0x0
c000245e:	ff 75 ec             	pushl  -0x14(%ebp)
c0002461:	e8 e9 00 00 00       	call   c000254f <memset>
c0002466:	83 c4 10             	add    $0x10,%esp

    // return pointer to table (virtual)
    return pv;
c0002469:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c000246c:	c9                   	leave  
c000246d:	c3                   	ret    

c000246e <kmalloc_aligned>:

void* kmalloc_aligned(size_t sz, size_t alignment)
{
c000246e:	55                   	push   %ebp
c000246f:	89 e5                	mov    %esp,%ebp
c0002471:	83 ec 28             	sub    $0x28,%esp
    if( sz == 0 || !is_pow_of_two(alignment) ) return NULL;
c0002474:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002478:	74 0f                	je     c0002489 <kmalloc_aligned+0x1b>
c000247a:	ff 75 0c             	pushl  0xc(%ebp)
c000247d:	e8 15 fb ff ff       	call   c0001f97 <is_pow_of_two>
c0002482:	83 c4 04             	add    $0x4,%esp
c0002485:	85 c0                	test   %eax,%eax
c0002487:	75 0a                	jne    c0002493 <kmalloc_aligned+0x25>
c0002489:	b8 00 00 00 00       	mov    $0x0,%eax
c000248e:	e9 a2 00 00 00       	jmp    c0002535 <kmalloc_aligned+0xc7>

    char* mem = align_addr(heap, alignment); //start of allocated region
c0002493:	a1 68 f8 00 c0       	mov    0xc000f868,%eax
c0002498:	ff 75 0c             	pushl  0xc(%ebp)
c000249b:	50                   	push   %eax
c000249c:	e8 d6 fa ff ff       	call   c0001f77 <align_addr>
c00024a1:	83 c4 08             	add    $0x8,%esp
c00024a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char* mem_end = align_addr(mem+sz, alignment); //first byte past end of allocated region
c00024a7:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00024aa:	8b 45 08             	mov    0x8(%ebp),%eax
c00024ad:	01 d0                	add    %edx,%eax
c00024af:	ff 75 0c             	pushl  0xc(%ebp)
c00024b2:	50                   	push   %eax
c00024b3:	e8 bf fa ff ff       	call   c0001f77 <align_addr>
c00024b8:	83 c4 08             	add    $0x8,%esp
c00024bb:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if(mem_end > heap_end)
c00024be:	a1 6c f8 00 c0       	mov    0xc000f86c,%eax
c00024c3:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c00024c6:	76 07                	jbe    c00024cf <kmalloc_aligned+0x61>
    {
        // out of memory!
        return NULL;
c00024c8:	b8 00 00 00 00       	mov    $0x0,%eax
c00024cd:	eb 66                	jmp    c0002535 <kmalloc_aligned+0xc7>
    }

    //map new pages
    page_t* page_end = (page_t*) (((uint32_t) mem_end - 1) & PAGE_ADDRMASK);
c00024cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00024d2:	83 e8 01             	sub    $0x1,%eax
c00024d5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00024da:	89 45 ec             	mov    %eax,-0x14(%ebp)
    while(page_end > heap_page)
c00024dd:	eb 41                	jmp    c0002520 <kmalloc_aligned+0xb2>
    {
        page_t* pp = get_next_heap_page_phys();    // find a free page in physical mem
c00024df:	e8 9e 00 00 00       	call   c0002582 <get_next_heap_page_phys>
c00024e4:	89 45 e8             	mov    %eax,-0x18(%ebp)
        page_t* pv = get_next_heap_page_virt();         // find a free page in virtual mem
c00024e7:	e8 cb 00 00 00       	call   c00025b7 <get_next_heap_page_virt>
c00024ec:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        if(!pp || !pv)
c00024ef:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c00024f3:	74 06                	je     c00024fb <kmalloc_aligned+0x8d>
c00024f5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c00024f9:	75 07                	jne    c0002502 <kmalloc_aligned+0x94>
            return NULL; //OOM
c00024fb:	b8 00 00 00 00       	mov    $0x0,%eax
c0002500:	eb 33                	jmp    c0002535 <kmalloc_aligned+0xc7>

        if(!map_page_at(pv, pp, PAGE_FLAG_WRITE))
c0002502:	83 ec 04             	sub    $0x4,%esp
c0002505:	6a 02                	push   $0x2
c0002507:	ff 75 e8             	pushl  -0x18(%ebp)
c000250a:	ff 75 e4             	pushl  -0x1c(%ebp)
c000250d:	e8 27 fe ff ff       	call   c0002339 <map_page_at>
c0002512:	83 c4 10             	add    $0x10,%esp
c0002515:	85 c0                	test   %eax,%eax
c0002517:	75 07                	jne    c0002520 <kmalloc_aligned+0xb2>
            return NULL;
c0002519:	b8 00 00 00 00       	mov    $0x0,%eax
c000251e:	eb 15                	jmp    c0002535 <kmalloc_aligned+0xc7>
    while(page_end > heap_page)
c0002520:	a1 60 f8 00 c0       	mov    0xc000f860,%eax
c0002525:	39 45 ec             	cmp    %eax,-0x14(%ebp)
c0002528:	77 b5                	ja     c00024df <kmalloc_aligned+0x71>
    }

    heap = mem_end;     //update pointer to end of used heap
c000252a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000252d:	a3 68 f8 00 c0       	mov    %eax,0xc000f868
    return (void*) mem;
c0002532:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0002535:	c9                   	leave  
c0002536:	c3                   	ret    

c0002537 <kmalloc>:


void* kmalloc(size_t sz)
{
c0002537:	55                   	push   %ebp
c0002538:	89 e5                	mov    %esp,%ebp
c000253a:	83 ec 08             	sub    $0x8,%esp
    return kmalloc_aligned(sz, 4);
c000253d:	83 ec 08             	sub    $0x8,%esp
c0002540:	6a 04                	push   $0x4
c0002542:	ff 75 08             	pushl  0x8(%ebp)
c0002545:	e8 24 ff ff ff       	call   c000246e <kmalloc_aligned>
c000254a:	83 c4 10             	add    $0x10,%esp
}
c000254d:	c9                   	leave  
c000254e:	c3                   	ret    

c000254f <memset>:

void* memset(void* addr, int val, size_t cnt)
{
c000254f:	55                   	push   %ebp
c0002550:	89 e5                	mov    %esp,%ebp
c0002552:	83 ec 10             	sub    $0x10,%esp
    char* m = (char*) addr;
c0002555:	8b 45 08             	mov    0x8(%ebp),%eax
c0002558:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for(size_t nn=0;nn<cnt; nn++)
c000255b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0002562:	eb 11                	jmp    c0002575 <memset+0x26>
        m[nn] = val;
c0002564:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0002567:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000256a:	01 d0                	add    %edx,%eax
c000256c:	8b 55 0c             	mov    0xc(%ebp),%edx
c000256f:	88 10                	mov    %dl,(%eax)
    for(size_t nn=0;nn<cnt; nn++)
c0002571:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0002575:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002578:	3b 45 10             	cmp    0x10(%ebp),%eax
c000257b:	72 e7                	jb     c0002564 <memset+0x15>

    return addr;
c000257d:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0002580:	c9                   	leave  
c0002581:	c3                   	ret    

c0002582 <get_next_heap_page_phys>:

// return next available physical page from the heap and updates the heap_page_phys pointer
// returns NULL on OOM
page_t* get_next_heap_page_phys()
{
c0002582:	55                   	push   %ebp
c0002583:	89 e5                	mov    %esp,%ebp
    if( (uint32_t) (heap_page_phys+1) > (uint32_t) heap_end_phys)
c0002585:	a1 64 f8 00 c0       	mov    0xc000f864,%eax
c000258a:	05 00 10 00 00       	add    $0x1000,%eax
c000258f:	89 c2                	mov    %eax,%edx
c0002591:	a1 70 f8 00 c0       	mov    0xc000f870,%eax
c0002596:	39 c2                	cmp    %eax,%edx
c0002598:	76 07                	jbe    c00025a1 <get_next_heap_page_phys+0x1f>
    {
        //out of memory
        return NULL;
c000259a:	b8 00 00 00 00       	mov    $0x0,%eax
c000259f:	eb 14                	jmp    c00025b5 <get_next_heap_page_phys+0x33>
    }
    return ++heap_page_phys;
c00025a1:	a1 64 f8 00 c0       	mov    0xc000f864,%eax
c00025a6:	05 00 10 00 00       	add    $0x1000,%eax
c00025ab:	a3 64 f8 00 c0       	mov    %eax,0xc000f864
c00025b0:	a1 64 f8 00 c0       	mov    0xc000f864,%eax
}
c00025b5:	5d                   	pop    %ebp
c00025b6:	c3                   	ret    

c00025b7 <get_next_heap_page_virt>:

// returns next available virtual page from the heap and updates the heap_page_phys pointer
// this does *not* update the heap pointer
// returns NULL on OOM
page_t* get_next_heap_page_virt()
{
c00025b7:	55                   	push   %ebp
c00025b8:	89 e5                	mov    %esp,%ebp
    if( (uint32_t) (heap_page+1) > (uint32_t) heap_end)
c00025ba:	a1 60 f8 00 c0       	mov    0xc000f860,%eax
c00025bf:	05 00 10 00 00       	add    $0x1000,%eax
c00025c4:	89 c2                	mov    %eax,%edx
c00025c6:	a1 6c f8 00 c0       	mov    0xc000f86c,%eax
c00025cb:	39 c2                	cmp    %eax,%edx
c00025cd:	76 07                	jbe    c00025d6 <get_next_heap_page_virt+0x1f>
    {
        //out of memory
        return NULL;
c00025cf:	b8 00 00 00 00       	mov    $0x0,%eax
c00025d4:	eb 14                	jmp    c00025ea <get_next_heap_page_virt+0x33>
    }
    return ++heap_page;
c00025d6:	a1 60 f8 00 c0       	mov    0xc000f860,%eax
c00025db:	05 00 10 00 00       	add    $0x1000,%eax
c00025e0:	a3 60 f8 00 c0       	mov    %eax,0xc000f860
c00025e5:	a1 60 f8 00 c0       	mov    0xc000f860,%eax
}
c00025ea:	5d                   	pop    %ebp
c00025eb:	c3                   	ret    

c00025ec <scancode_to_ascii>:
    0,  /* F12 Key */
    0,  /* All other keys are undefined */
};

char scancode_to_ascii(uint8_t scancode)
{
c00025ec:	55                   	push   %ebp
c00025ed:	89 e5                	mov    %esp,%ebp
c00025ef:	83 ec 04             	sub    $0x4,%esp
c00025f2:	8b 45 08             	mov    0x8(%ebp),%eax
c00025f5:	88 45 fc             	mov    %al,-0x4(%ebp)
    return kbd_US[scancode];
c00025f8:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c00025fc:	0f b6 80 20 40 00 c0 	movzbl -0x3fffbfe0(%eax),%eax
}
c0002603:	c9                   	leave  
c0002604:	c3                   	ret    

c0002605 <test_multitasking2>:
#if defined(__linux__)  || !defined(__i386__)
#error "This kernel requires ix86-elf cross compiler"
#endif

void test_multitasking2()
{
c0002605:	55                   	push   %ebp
c0002606:	89 e5                	mov    %esp,%ebp
c0002608:	83 ec 18             	sub    $0x18,%esp
	int count = 0;
c000260b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	while(1)
	{
		kprintf("task 2, count %d\n", count++);
c0002612:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002615:	8d 50 01             	lea    0x1(%eax),%edx
c0002618:	89 55 f4             	mov    %edx,-0xc(%ebp)
c000261b:	83 ec 08             	sub    $0x8,%esp
c000261e:	50                   	push   %eax
c000261f:	68 20 35 00 c0       	push   $0xc0003520
c0002624:	e8 56 de ff ff       	call   c000047f <kprintf>
c0002629:	83 c4 10             	add    $0x10,%esp
		switch_to_next_task();
c000262c:	e8 f8 f7 ff ff       	call   c0001e29 <switch_to_next_task>
		kprintf("task 2, count %d\n", count++);
c0002631:	eb df                	jmp    c0002612 <test_multitasking2+0xd>

c0002633 <test_multitasking1>:
	}
}

void test_multitasking1()
{
c0002633:	55                   	push   %ebp
c0002634:	89 e5                	mov    %esp,%ebp
c0002636:	83 ec 18             	sub    $0x18,%esp
	int count = 0;
c0002639:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	new_kernel_task( &test_multitasking2 );
c0002640:	83 ec 0c             	sub    $0xc,%esp
c0002643:	68 05 26 00 c0       	push   $0xc0002605
c0002648:	e8 c7 f6 ff ff       	call   c0001d14 <new_kernel_task>
c000264d:	83 c4 10             	add    $0x10,%esp

	while(1)
	{
		kprintf("task 1, count %d\n", count++);
c0002650:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002653:	8d 50 01             	lea    0x1(%eax),%edx
c0002656:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0002659:	83 ec 08             	sub    $0x8,%esp
c000265c:	50                   	push   %eax
c000265d:	68 32 35 00 c0       	push   $0xc0003532
c0002662:	e8 18 de ff ff       	call   c000047f <kprintf>
c0002667:	83 c4 10             	add    $0x10,%esp
		switch_to_next_task();
c000266a:	e8 ba f7 ff ff       	call   c0001e29 <switch_to_next_task>
		kprintf("task 1, count %d\n", count++);
c000266f:	eb df                	jmp    c0002650 <test_multitasking1+0x1d>

c0002671 <kernel_main>:
	}	
}

void kernel_main(multiboot_info_t* mbd)
{
c0002671:	55                   	push   %ebp
c0002672:	89 e5                	mov    %esp,%ebp
c0002674:	83 ec 08             	sub    $0x8,%esp
	init_gdt();
c0002677:	e8 3e 01 00 00       	call   c00027ba <init_gdt>
	init_interrupts();
c000267c:	e8 1a f2 ff ff       	call   c000189b <init_interrupts>

	terminal_init(&stdout);
c0002681:	83 ec 0c             	sub    $0xc,%esp
c0002684:	68 00 f0 00 c0       	push   $0xc000f000
c0002689:	e8 ca d9 ff ff       	call   c0000058 <terminal_init>
c000268e:	83 c4 10             	add    $0x10,%esp

    // terminal_setcolor(&stdout, VGA_COLOR_WHITE);
	kprintf("Let's learn about Operating Systems!\n");
c0002691:	83 ec 0c             	sub    $0xc,%esp
c0002694:	68 44 35 00 c0       	push   $0xc0003544
c0002699:	e8 e1 dd ff ff       	call   c000047f <kprintf>
c000269e:	83 c4 10             	add    $0x10,%esp
	kprintf("Jon Doane, 2020\n\n");
c00026a1:	83 ec 0c             	sub    $0xc,%esp
c00026a4:	68 6a 35 00 c0       	push   $0xc000356a
c00026a9:	e8 d1 dd ff ff       	call   c000047f <kprintf>
c00026ae:	83 c4 10             	add    $0x10,%esp

	print_memory_table(mbd);
c00026b1:	83 ec 0c             	sub    $0xc,%esp
c00026b4:	ff 75 08             	pushl  0x8(%ebp)
c00026b7:	e8 b0 ef ff ff       	call   c000166c <print_memory_table>
c00026bc:	83 c4 10             	add    $0x10,%esp
	memory_init(mbd);	//after this the multiboot structure is unmapped
c00026bf:	83 ec 0c             	sub    $0xc,%esp
c00026c2:	ff 75 08             	pushl  0x8(%ebp)
c00026c5:	e8 f1 f8 ff ff       	call   c0001fbb <memory_init>
c00026ca:	83 c4 10             	add    $0x10,%esp
	initialize_multitasking();
c00026cd:	e8 f3 f5 ff ff       	call   c0001cc5 <initialize_multitasking>
	// int* d = (int*) 0xbadbadba;
	// kprintf("Try a page fault...");
	// int e = *d;
	// kprintf("%d\n",e);

	kprintf("$ ");
c00026d2:	83 ec 0c             	sub    $0xc,%esp
c00026d5:	68 7c 35 00 c0       	push   $0xc000357c
c00026da:	e8 a0 dd ff ff       	call   c000047f <kprintf>
c00026df:	83 c4 10             	add    $0x10,%esp

	test_multitasking1();
c00026e2:	e8 4c ff ff ff       	call   c0002633 <test_multitasking1>

	while(1);
c00026e7:	eb fe                	jmp    c00026e7 <kernel_main+0x76>

c00026e9 <populate_gdt_entry>:
   uint16_t iomap_base;
} tss_entry_t;


static inline void populate_gdt_entry(gdt_entry_t* sd, uint32_t base, uint32_t limit, uint8_t access, uint8_t flags)
{
c00026e9:	55                   	push   %ebp
c00026ea:	89 e5                	mov    %esp,%ebp
c00026ec:	53                   	push   %ebx
c00026ed:	83 ec 08             	sub    $0x8,%esp
c00026f0:	8b 55 14             	mov    0x14(%ebp),%edx
c00026f3:	8b 45 18             	mov    0x18(%ebp),%eax
c00026f6:	88 55 f8             	mov    %dl,-0x8(%ebp)
c00026f9:	88 45 f4             	mov    %al,-0xc(%ebp)
    sd->limit_low = limit & SEGMENT_LIMIT_LOW_MASK;
c00026fc:	8b 45 10             	mov    0x10(%ebp),%eax
c00026ff:	89 c2                	mov    %eax,%edx
c0002701:	8b 45 08             	mov    0x8(%ebp),%eax
c0002704:	0f b7 ca             	movzwl %dx,%ecx
c0002707:	0f b6 d9             	movzbl %cl,%ebx
c000270a:	0f b6 08             	movzbl (%eax),%ecx
c000270d:	83 e1 00             	and    $0x0,%ecx
c0002710:	09 d9                	or     %ebx,%ecx
c0002712:	88 08                	mov    %cl,(%eax)
c0002714:	66 c1 ea 08          	shr    $0x8,%dx
c0002718:	0f b7 ca             	movzwl %dx,%ecx
c000271b:	0f b6 50 01          	movzbl 0x1(%eax),%edx
c000271f:	83 e2 00             	and    $0x0,%edx
c0002722:	09 ca                	or     %ecx,%edx
c0002724:	88 50 01             	mov    %dl,0x1(%eax)
    sd->limit_high = (limit & SEGMENT_LIMIT_HIGH_MASK) >> 16;
c0002727:	8b 45 10             	mov    0x10(%ebp),%eax
c000272a:	c1 e8 10             	shr    $0x10,%eax
c000272d:	83 e0 0f             	and    $0xf,%eax
c0002730:	8b 55 08             	mov    0x8(%ebp),%edx
c0002733:	83 e0 0f             	and    $0xf,%eax
c0002736:	89 c1                	mov    %eax,%ecx
c0002738:	0f b6 42 06          	movzbl 0x6(%edx),%eax
c000273c:	83 e0 f0             	and    $0xfffffff0,%eax
c000273f:	09 c8                	or     %ecx,%eax
c0002741:	88 42 06             	mov    %al,0x6(%edx)
    sd->base_low = base & SEGMENT_BASE_LOW_MASK;
c0002744:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002747:	89 c2                	mov    %eax,%edx
c0002749:	8b 45 08             	mov    0x8(%ebp),%eax
c000274c:	0f b7 ca             	movzwl %dx,%ecx
c000274f:	0f b6 d9             	movzbl %cl,%ebx
c0002752:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
c0002756:	83 e1 00             	and    $0x0,%ecx
c0002759:	09 d9                	or     %ebx,%ecx
c000275b:	88 48 02             	mov    %cl,0x2(%eax)
c000275e:	66 c1 ea 08          	shr    $0x8,%dx
c0002762:	0f b7 ca             	movzwl %dx,%ecx
c0002765:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c0002769:	83 e2 00             	and    $0x0,%edx
c000276c:	09 ca                	or     %ecx,%edx
c000276e:	88 50 03             	mov    %dl,0x3(%eax)
    sd->base_mid = (base & SEGMENT_BASE_MID_MASK) >> 16;
c0002771:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002774:	c1 e8 10             	shr    $0x10,%eax
c0002777:	89 c2                	mov    %eax,%edx
c0002779:	8b 45 08             	mov    0x8(%ebp),%eax
c000277c:	88 50 04             	mov    %dl,0x4(%eax)
    sd->base_high = (base & SEGMENT_BASE_HIGH_MASK) >> 24;
c000277f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002782:	c1 e8 18             	shr    $0x18,%eax
c0002785:	89 c2                	mov    %eax,%edx
c0002787:	8b 45 08             	mov    0x8(%ebp),%eax
c000278a:	88 50 07             	mov    %dl,0x7(%eax)
    sd->access = access;
c000278d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002790:	0f b6 55 f8          	movzbl -0x8(%ebp),%edx
c0002794:	88 50 05             	mov    %dl,0x5(%eax)
    sd->flags = flags;
c0002797:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c000279b:	83 e0 0f             	and    $0xf,%eax
c000279e:	89 c2                	mov    %eax,%edx
c00027a0:	8b 45 08             	mov    0x8(%ebp),%eax
c00027a3:	89 d1                	mov    %edx,%ecx
c00027a5:	c1 e1 04             	shl    $0x4,%ecx
c00027a8:	0f b6 50 06          	movzbl 0x6(%eax),%edx
c00027ac:	83 e2 0f             	and    $0xf,%edx
c00027af:	09 ca                	or     %ecx,%edx
c00027b1:	88 50 06             	mov    %dl,0x6(%eax)
}
c00027b4:	90                   	nop
c00027b5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00027b8:	c9                   	leave  
c00027b9:	c3                   	ret    

c00027ba <init_gdt>:
gdt_description_t __aligned  gdtd;

tss_entry_t tss = {0};

void init_gdt()
{
c00027ba:	55                   	push   %ebp
c00027bb:	89 e5                	mov    %esp,%ebp
c00027bd:	83 ec 08             	sub    $0x8,%esp
    // gdt[0] unused
    populate_gdt_entry(&gdt[1], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(0) | SEG_DESCTYPE(1) | SEG_CODE_EXRD, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // priv code, seg 0x008
c00027c0:	6a 0c                	push   $0xc
c00027c2:	68 9a 00 00 00       	push   $0x9a
c00027c7:	6a ff                	push   $0xffffffff
c00027c9:	6a 00                	push   $0x0
c00027cb:	68 88 f8 00 c0       	push   $0xc000f888
c00027d0:	e8 14 ff ff ff       	call   c00026e9 <populate_gdt_entry>
c00027d5:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[2], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(0) | SEG_DESCTYPE(1) | SEG_DATA_RDWR, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // priv data, seg 0x010
c00027d8:	6a 0c                	push   $0xc
c00027da:	68 92 00 00 00       	push   $0x92
c00027df:	6a ff                	push   $0xffffffff
c00027e1:	6a 00                	push   $0x0
c00027e3:	68 90 f8 00 c0       	push   $0xc000f890
c00027e8:	e8 fc fe ff ff       	call   c00026e9 <populate_gdt_entry>
c00027ed:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[3], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(3) | SEG_DESCTYPE(1) | SEG_CODE_EXRD, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // user code, seg 0x018
c00027f0:	6a 0c                	push   $0xc
c00027f2:	68 fa 00 00 00       	push   $0xfa
c00027f7:	6a ff                	push   $0xffffffff
c00027f9:	6a 00                	push   $0x0
c00027fb:	68 98 f8 00 c0       	push   $0xc000f898
c0002800:	e8 e4 fe ff ff       	call   c00026e9 <populate_gdt_entry>
c0002805:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[4], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(3) | SEG_DESCTYPE(1) | SEG_DATA_RDWR, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // user data  seg 0x020
c0002808:	6a 0c                	push   $0xc
c000280a:	68 f2 00 00 00       	push   $0xf2
c000280f:	6a ff                	push   $0xffffffff
c0002811:	6a 00                	push   $0x0
c0002813:	68 a0 f8 00 c0       	push   $0xc000f8a0
c0002818:	e8 cc fe ff ff       	call   c00026e9 <populate_gdt_entry>
c000281d:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[5], (uint32_t) &tss, sizeof(tss_entry_t), SEG_TSS, SEG_FLAG_TSS); // tss, seg 0x028
c0002820:	b8 e0 f8 00 c0       	mov    $0xc000f8e0,%eax
c0002825:	6a 04                	push   $0x4
c0002827:	68 89 00 00 00       	push   $0x89
c000282c:	6a 68                	push   $0x68
c000282e:	50                   	push   %eax
c000282f:	68 a8 f8 00 c0       	push   $0xc000f8a8
c0002834:	e8 b0 fe ff ff       	call   c00026e9 <populate_gdt_entry>
c0002839:	83 c4 14             	add    $0x14,%esp

    //tss.esp0 = XXXXX
    tss.ss0 = KERNEL_DATA_SEGMENT; //kernel data segment    
c000283c:	c7 05 e8 f8 00 c0 10 	movl   $0x10,0xc000f8e8
c0002843:	00 00 00 
    tss.iomap_base = sizeof(tss_entry_t);
c0002846:	66 c7 05 46 f9 00 c0 	movw   $0x68,0xc000f946
c000284d:	68 00 
    // before we can actually switch tasks, we must first set the kernel stack pointer, with update_tss()

    gdtd.addr = (uint32_t) gdt;
c000284f:	b8 80 f8 00 c0       	mov    $0xc000f880,%eax
c0002854:	a3 c2 f8 00 c0       	mov    %eax,0xc000f8c2
    gdtd.size = sizeof(gdt);    
c0002859:	66 c7 05 c0 f8 00 c0 	movw   $0x30,0xc000f8c0
c0002860:	30 00 
    load_gdt(&gdtd);
c0002862:	83 ec 0c             	sub    $0xc,%esp
c0002865:	68 c0 f8 00 c0       	push   $0xc000f8c0
c000286a:	e8 1d 00 00 00       	call   c000288c <load_gdt>
c000286f:	83 c4 10             	add    $0x10,%esp
}
c0002872:	90                   	nop
c0002873:	c9                   	leave  
c0002874:	c3                   	ret    

c0002875 <update_kstack>:

void update_kstack(void* kernel_stack_ptr)
{
c0002875:	55                   	push   %ebp
c0002876:	89 e5                	mov    %esp,%ebp
c0002878:	83 ec 08             	sub    $0x8,%esp
    tss.esp0 = (uint32_t) kernel_stack_ptr; //kernel stack ptr
c000287b:	8b 45 08             	mov    0x8(%ebp),%eax
c000287e:	a3 e4 f8 00 c0       	mov    %eax,0xc000f8e4
    load_tss();
c0002883:	e8 24 00 00 00       	call   c00028ac <load_tss>
}
c0002888:	90                   	nop
c0002889:	c9                   	leave  
c000288a:	c3                   	ret    
c000288b:	90                   	nop

c000288c <load_gdt>:
c000288c:	0f 01 15 c0 f8 00 c0 	lgdtl  0xc000f8c0
c0002893:	ea 9a 28 00 c0 08 00 	ljmp   $0x8,$0xc000289a

c000289a <complete_flush>:
c000289a:	66 b8 10 00          	mov    $0x10,%ax
c000289e:	8e d8                	mov    %eax,%ds
c00028a0:	8e c0                	mov    %eax,%es
c00028a2:	8e e0                	mov    %eax,%fs
c00028a4:	8e e8                	mov    %eax,%gs
c00028a6:	8e d0                	mov    %eax,%ss
c00028a8:	c3                   	ret    
c00028a9:	8d 76 00             	lea    0x0(%esi),%esi

c00028ac <load_tss>:
c00028ac:	66 b8 28 00          	mov    $0x28,%ax
c00028b0:	66 83 c8 03          	or     $0x3,%ax
c00028b4:	0f 00 d8             	ltr    %ax
c00028b7:	c3                   	ret    

c00028b8 <load_idt>:
c00028b8:	0f 01 1d 20 f8 00 c0 	lidtl  0xc000f820
c00028bf:	fb                   	sti    
c00028c0:	c3                   	ret    
c00028c1:	8d 76 00             	lea    0x0(%esi),%esi

c00028c4 <except_0>:
c00028c4:	60                   	pusha  
c00028c5:	b8 00 00 00 00       	mov    $0x0,%eax
c00028ca:	50                   	push   %eax
c00028cb:	b8 00 00 00 00       	mov    $0x0,%eax
c00028d0:	50                   	push   %eax
c00028d1:	e8 65 f3 ff ff       	call   c0001c3b <exception_handler>
c00028d6:	83 c4 08             	add    $0x8,%esp
c00028d9:	61                   	popa   
c00028da:	cf                   	iret   
c00028db:	90                   	nop

c00028dc <except_1>:
c00028dc:	60                   	pusha  
c00028dd:	b8 00 00 00 00       	mov    $0x0,%eax
c00028e2:	50                   	push   %eax
c00028e3:	b8 01 00 00 00       	mov    $0x1,%eax
c00028e8:	50                   	push   %eax
c00028e9:	e8 4d f3 ff ff       	call   c0001c3b <exception_handler>
c00028ee:	83 c4 08             	add    $0x8,%esp
c00028f1:	61                   	popa   
c00028f2:	cf                   	iret   
c00028f3:	90                   	nop

c00028f4 <except_2>:
c00028f4:	60                   	pusha  
c00028f5:	b8 00 00 00 00       	mov    $0x0,%eax
c00028fa:	50                   	push   %eax
c00028fb:	b8 02 00 00 00       	mov    $0x2,%eax
c0002900:	50                   	push   %eax
c0002901:	e8 35 f3 ff ff       	call   c0001c3b <exception_handler>
c0002906:	83 c4 08             	add    $0x8,%esp
c0002909:	61                   	popa   
c000290a:	cf                   	iret   
c000290b:	90                   	nop

c000290c <except_3>:
c000290c:	60                   	pusha  
c000290d:	b8 00 00 00 00       	mov    $0x0,%eax
c0002912:	50                   	push   %eax
c0002913:	b8 03 00 00 00       	mov    $0x3,%eax
c0002918:	50                   	push   %eax
c0002919:	e8 1d f3 ff ff       	call   c0001c3b <exception_handler>
c000291e:	83 c4 08             	add    $0x8,%esp
c0002921:	61                   	popa   
c0002922:	cf                   	iret   
c0002923:	90                   	nop

c0002924 <except_4>:
c0002924:	60                   	pusha  
c0002925:	b8 00 00 00 00       	mov    $0x0,%eax
c000292a:	50                   	push   %eax
c000292b:	b8 04 00 00 00       	mov    $0x4,%eax
c0002930:	50                   	push   %eax
c0002931:	e8 05 f3 ff ff       	call   c0001c3b <exception_handler>
c0002936:	83 c4 08             	add    $0x8,%esp
c0002939:	61                   	popa   
c000293a:	cf                   	iret   
c000293b:	90                   	nop

c000293c <except_5>:
c000293c:	60                   	pusha  
c000293d:	b8 00 00 00 00       	mov    $0x0,%eax
c0002942:	50                   	push   %eax
c0002943:	b8 05 00 00 00       	mov    $0x5,%eax
c0002948:	50                   	push   %eax
c0002949:	e8 ed f2 ff ff       	call   c0001c3b <exception_handler>
c000294e:	83 c4 08             	add    $0x8,%esp
c0002951:	61                   	popa   
c0002952:	cf                   	iret   
c0002953:	90                   	nop

c0002954 <except_6>:
c0002954:	60                   	pusha  
c0002955:	b8 00 00 00 00       	mov    $0x0,%eax
c000295a:	50                   	push   %eax
c000295b:	b8 06 00 00 00       	mov    $0x6,%eax
c0002960:	50                   	push   %eax
c0002961:	e8 d5 f2 ff ff       	call   c0001c3b <exception_handler>
c0002966:	83 c4 08             	add    $0x8,%esp
c0002969:	61                   	popa   
c000296a:	cf                   	iret   
c000296b:	90                   	nop

c000296c <except_7>:
c000296c:	60                   	pusha  
c000296d:	b8 00 00 00 00       	mov    $0x0,%eax
c0002972:	50                   	push   %eax
c0002973:	b8 07 00 00 00       	mov    $0x7,%eax
c0002978:	50                   	push   %eax
c0002979:	e8 bd f2 ff ff       	call   c0001c3b <exception_handler>
c000297e:	83 c4 08             	add    $0x8,%esp
c0002981:	61                   	popa   
c0002982:	cf                   	iret   
c0002983:	90                   	nop

c0002984 <except_8>:
c0002984:	60                   	pusha  
c0002985:	8b 44 24 24          	mov    0x24(%esp),%eax
c0002989:	50                   	push   %eax
c000298a:	b8 08 00 00 00       	mov    $0x8,%eax
c000298f:	50                   	push   %eax
c0002990:	e8 a6 f2 ff ff       	call   c0001c3b <exception_handler>
c0002995:	83 c4 08             	add    $0x8,%esp
c0002998:	61                   	popa   
c0002999:	83 c4 04             	add    $0x4,%esp
c000299c:	cf                   	iret   
c000299d:	8d 76 00             	lea    0x0(%esi),%esi

c00029a0 <except_10>:
c00029a0:	60                   	pusha  
c00029a1:	8b 44 24 24          	mov    0x24(%esp),%eax
c00029a5:	50                   	push   %eax
c00029a6:	b8 0a 00 00 00       	mov    $0xa,%eax
c00029ab:	50                   	push   %eax
c00029ac:	e8 8a f2 ff ff       	call   c0001c3b <exception_handler>
c00029b1:	83 c4 08             	add    $0x8,%esp
c00029b4:	61                   	popa   
c00029b5:	83 c4 04             	add    $0x4,%esp
c00029b8:	cf                   	iret   
c00029b9:	8d 76 00             	lea    0x0(%esi),%esi

c00029bc <except_11>:
c00029bc:	60                   	pusha  
c00029bd:	8b 44 24 24          	mov    0x24(%esp),%eax
c00029c1:	50                   	push   %eax
c00029c2:	b8 0b 00 00 00       	mov    $0xb,%eax
c00029c7:	50                   	push   %eax
c00029c8:	e8 6e f2 ff ff       	call   c0001c3b <exception_handler>
c00029cd:	83 c4 08             	add    $0x8,%esp
c00029d0:	61                   	popa   
c00029d1:	83 c4 04             	add    $0x4,%esp
c00029d4:	cf                   	iret   
c00029d5:	8d 76 00             	lea    0x0(%esi),%esi

c00029d8 <except_12>:
c00029d8:	60                   	pusha  
c00029d9:	8b 44 24 24          	mov    0x24(%esp),%eax
c00029dd:	50                   	push   %eax
c00029de:	b8 0c 00 00 00       	mov    $0xc,%eax
c00029e3:	50                   	push   %eax
c00029e4:	e8 52 f2 ff ff       	call   c0001c3b <exception_handler>
c00029e9:	83 c4 08             	add    $0x8,%esp
c00029ec:	61                   	popa   
c00029ed:	83 c4 04             	add    $0x4,%esp
c00029f0:	cf                   	iret   
c00029f1:	8d 76 00             	lea    0x0(%esi),%esi

c00029f4 <except_13>:
c00029f4:	60                   	pusha  
c00029f5:	8b 44 24 24          	mov    0x24(%esp),%eax
c00029f9:	50                   	push   %eax
c00029fa:	b8 0d 00 00 00       	mov    $0xd,%eax
c00029ff:	50                   	push   %eax
c0002a00:	e8 36 f2 ff ff       	call   c0001c3b <exception_handler>
c0002a05:	83 c4 08             	add    $0x8,%esp
c0002a08:	61                   	popa   
c0002a09:	83 c4 04             	add    $0x4,%esp
c0002a0c:	cf                   	iret   
c0002a0d:	8d 76 00             	lea    0x0(%esi),%esi

c0002a10 <except_16>:
c0002a10:	60                   	pusha  
c0002a11:	8b 44 24 24          	mov    0x24(%esp),%eax
c0002a15:	50                   	push   %eax
c0002a16:	b8 10 00 00 00       	mov    $0x10,%eax
c0002a1b:	50                   	push   %eax
c0002a1c:	e8 1a f2 ff ff       	call   c0001c3b <exception_handler>
c0002a21:	83 c4 08             	add    $0x8,%esp
c0002a24:	61                   	popa   
c0002a25:	83 c4 04             	add    $0x4,%esp
c0002a28:	cf                   	iret   
c0002a29:	8d 76 00             	lea    0x0(%esi),%esi

c0002a2c <except_17>:
c0002a2c:	60                   	pusha  
c0002a2d:	8b 44 24 24          	mov    0x24(%esp),%eax
c0002a31:	50                   	push   %eax
c0002a32:	b8 11 00 00 00       	mov    $0x11,%eax
c0002a37:	50                   	push   %eax
c0002a38:	e8 fe f1 ff ff       	call   c0001c3b <exception_handler>
c0002a3d:	83 c4 08             	add    $0x8,%esp
c0002a40:	61                   	popa   
c0002a41:	83 c4 04             	add    $0x4,%esp
c0002a44:	cf                   	iret   
c0002a45:	8d 76 00             	lea    0x0(%esi),%esi

c0002a48 <except_18>:
c0002a48:	60                   	pusha  
c0002a49:	8b 44 24 24          	mov    0x24(%esp),%eax
c0002a4d:	50                   	push   %eax
c0002a4e:	b8 12 00 00 00       	mov    $0x12,%eax
c0002a53:	50                   	push   %eax
c0002a54:	e8 e2 f1 ff ff       	call   c0001c3b <exception_handler>
c0002a59:	83 c4 08             	add    $0x8,%esp
c0002a5c:	61                   	popa   
c0002a5d:	83 c4 04             	add    $0x4,%esp
c0002a60:	cf                   	iret   
c0002a61:	8d 76 00             	lea    0x0(%esi),%esi

c0002a64 <except_19>:
c0002a64:	60                   	pusha  
c0002a65:	8b 44 24 24          	mov    0x24(%esp),%eax
c0002a69:	50                   	push   %eax
c0002a6a:	b8 13 00 00 00       	mov    $0x13,%eax
c0002a6f:	50                   	push   %eax
c0002a70:	e8 c6 f1 ff ff       	call   c0001c3b <exception_handler>
c0002a75:	83 c4 08             	add    $0x8,%esp
c0002a78:	61                   	popa   
c0002a79:	83 c4 04             	add    $0x4,%esp
c0002a7c:	cf                   	iret   
c0002a7d:	8d 76 00             	lea    0x0(%esi),%esi

c0002a80 <except_20>:
c0002a80:	60                   	pusha  
c0002a81:	8b 44 24 24          	mov    0x24(%esp),%eax
c0002a85:	50                   	push   %eax
c0002a86:	b8 14 00 00 00       	mov    $0x14,%eax
c0002a8b:	50                   	push   %eax
c0002a8c:	e8 aa f1 ff ff       	call   c0001c3b <exception_handler>
c0002a91:	83 c4 08             	add    $0x8,%esp
c0002a94:	61                   	popa   
c0002a95:	83 c4 04             	add    $0x4,%esp
c0002a98:	cf                   	iret   
c0002a99:	8d 76 00             	lea    0x0(%esi),%esi

c0002a9c <except_30>:
c0002a9c:	60                   	pusha  
c0002a9d:	8b 44 24 24          	mov    0x24(%esp),%eax
c0002aa1:	50                   	push   %eax
c0002aa2:	b8 1e 00 00 00       	mov    $0x1e,%eax
c0002aa7:	50                   	push   %eax
c0002aa8:	e8 8e f1 ff ff       	call   c0001c3b <exception_handler>
c0002aad:	83 c4 08             	add    $0x8,%esp
c0002ab0:	61                   	popa   
c0002ab1:	83 c4 04             	add    $0x4,%esp
c0002ab4:	cf                   	iret   
c0002ab5:	8d 76 00             	lea    0x0(%esi),%esi

c0002ab8 <except_pf>:
c0002ab8:	60                   	pusha  
c0002ab9:	0f 20 d0             	mov    %cr2,%eax
c0002abc:	50                   	push   %eax
c0002abd:	8b 44 24 24          	mov    0x24(%esp),%eax
c0002ac1:	50                   	push   %eax
c0002ac2:	e8 56 f1 ff ff       	call   c0001c1d <page_fault_handler>
c0002ac7:	83 c4 08             	add    $0x8,%esp
c0002aca:	61                   	popa   
c0002acb:	83 c4 04             	add    $0x4,%esp
c0002ace:	cf                   	iret   
c0002acf:	90                   	nop

c0002ad0 <irq_0>:
c0002ad0:	60                   	pusha  
c0002ad1:	b8 00 00 00 00       	mov    $0x0,%eax
c0002ad6:	50                   	push   %eax
c0002ad7:	e8 7d f1 ff ff       	call   c0001c59 <irq_handler>
c0002adc:	83 c4 04             	add    $0x4,%esp
c0002adf:	61                   	popa   
c0002ae0:	cf                   	iret   
c0002ae1:	8d 76 00             	lea    0x0(%esi),%esi

c0002ae4 <irq_1>:
c0002ae4:	60                   	pusha  
c0002ae5:	b8 01 00 00 00       	mov    $0x1,%eax
c0002aea:	50                   	push   %eax
c0002aeb:	e8 69 f1 ff ff       	call   c0001c59 <irq_handler>
c0002af0:	83 c4 04             	add    $0x4,%esp
c0002af3:	61                   	popa   
c0002af4:	cf                   	iret   
c0002af5:	8d 76 00             	lea    0x0(%esi),%esi

c0002af8 <irq_2>:
c0002af8:	60                   	pusha  
c0002af9:	b8 02 00 00 00       	mov    $0x2,%eax
c0002afe:	50                   	push   %eax
c0002aff:	e8 55 f1 ff ff       	call   c0001c59 <irq_handler>
c0002b04:	83 c4 04             	add    $0x4,%esp
c0002b07:	61                   	popa   
c0002b08:	cf                   	iret   
c0002b09:	8d 76 00             	lea    0x0(%esi),%esi

c0002b0c <irq_3>:
c0002b0c:	60                   	pusha  
c0002b0d:	b8 03 00 00 00       	mov    $0x3,%eax
c0002b12:	50                   	push   %eax
c0002b13:	e8 41 f1 ff ff       	call   c0001c59 <irq_handler>
c0002b18:	83 c4 04             	add    $0x4,%esp
c0002b1b:	61                   	popa   
c0002b1c:	cf                   	iret   
c0002b1d:	8d 76 00             	lea    0x0(%esi),%esi

c0002b20 <irq_4>:
c0002b20:	60                   	pusha  
c0002b21:	b8 04 00 00 00       	mov    $0x4,%eax
c0002b26:	50                   	push   %eax
c0002b27:	e8 2d f1 ff ff       	call   c0001c59 <irq_handler>
c0002b2c:	83 c4 04             	add    $0x4,%esp
c0002b2f:	61                   	popa   
c0002b30:	cf                   	iret   
c0002b31:	8d 76 00             	lea    0x0(%esi),%esi

c0002b34 <irq_5>:
c0002b34:	60                   	pusha  
c0002b35:	b8 05 00 00 00       	mov    $0x5,%eax
c0002b3a:	50                   	push   %eax
c0002b3b:	e8 19 f1 ff ff       	call   c0001c59 <irq_handler>
c0002b40:	83 c4 04             	add    $0x4,%esp
c0002b43:	61                   	popa   
c0002b44:	cf                   	iret   
c0002b45:	8d 76 00             	lea    0x0(%esi),%esi

c0002b48 <irq_6>:
c0002b48:	60                   	pusha  
c0002b49:	b8 06 00 00 00       	mov    $0x6,%eax
c0002b4e:	50                   	push   %eax
c0002b4f:	e8 05 f1 ff ff       	call   c0001c59 <irq_handler>
c0002b54:	83 c4 04             	add    $0x4,%esp
c0002b57:	61                   	popa   
c0002b58:	cf                   	iret   
c0002b59:	8d 76 00             	lea    0x0(%esi),%esi

c0002b5c <irq_7>:
c0002b5c:	60                   	pusha  
c0002b5d:	b8 07 00 00 00       	mov    $0x7,%eax
c0002b62:	50                   	push   %eax
c0002b63:	e8 f1 f0 ff ff       	call   c0001c59 <irq_handler>
c0002b68:	83 c4 04             	add    $0x4,%esp
c0002b6b:	61                   	popa   
c0002b6c:	cf                   	iret   
c0002b6d:	8d 76 00             	lea    0x0(%esi),%esi

c0002b70 <irq_8>:
c0002b70:	60                   	pusha  
c0002b71:	b8 08 00 00 00       	mov    $0x8,%eax
c0002b76:	50                   	push   %eax
c0002b77:	e8 dd f0 ff ff       	call   c0001c59 <irq_handler>
c0002b7c:	83 c4 04             	add    $0x4,%esp
c0002b7f:	61                   	popa   
c0002b80:	cf                   	iret   
c0002b81:	8d 76 00             	lea    0x0(%esi),%esi

c0002b84 <irq_9>:
c0002b84:	60                   	pusha  
c0002b85:	b8 09 00 00 00       	mov    $0x9,%eax
c0002b8a:	50                   	push   %eax
c0002b8b:	e8 c9 f0 ff ff       	call   c0001c59 <irq_handler>
c0002b90:	83 c4 04             	add    $0x4,%esp
c0002b93:	61                   	popa   
c0002b94:	cf                   	iret   
c0002b95:	8d 76 00             	lea    0x0(%esi),%esi

c0002b98 <irq_10>:
c0002b98:	60                   	pusha  
c0002b99:	b8 0a 00 00 00       	mov    $0xa,%eax
c0002b9e:	50                   	push   %eax
c0002b9f:	e8 b5 f0 ff ff       	call   c0001c59 <irq_handler>
c0002ba4:	83 c4 04             	add    $0x4,%esp
c0002ba7:	61                   	popa   
c0002ba8:	cf                   	iret   
c0002ba9:	8d 76 00             	lea    0x0(%esi),%esi

c0002bac <irq_11>:
c0002bac:	60                   	pusha  
c0002bad:	b8 0b 00 00 00       	mov    $0xb,%eax
c0002bb2:	50                   	push   %eax
c0002bb3:	e8 a1 f0 ff ff       	call   c0001c59 <irq_handler>
c0002bb8:	83 c4 04             	add    $0x4,%esp
c0002bbb:	61                   	popa   
c0002bbc:	cf                   	iret   
c0002bbd:	8d 76 00             	lea    0x0(%esi),%esi

c0002bc0 <irq_12>:
c0002bc0:	60                   	pusha  
c0002bc1:	b8 0c 00 00 00       	mov    $0xc,%eax
c0002bc6:	50                   	push   %eax
c0002bc7:	e8 8d f0 ff ff       	call   c0001c59 <irq_handler>
c0002bcc:	83 c4 04             	add    $0x4,%esp
c0002bcf:	61                   	popa   
c0002bd0:	cf                   	iret   
c0002bd1:	8d 76 00             	lea    0x0(%esi),%esi

c0002bd4 <irq_13>:
c0002bd4:	60                   	pusha  
c0002bd5:	b8 0d 00 00 00       	mov    $0xd,%eax
c0002bda:	50                   	push   %eax
c0002bdb:	e8 79 f0 ff ff       	call   c0001c59 <irq_handler>
c0002be0:	83 c4 04             	add    $0x4,%esp
c0002be3:	61                   	popa   
c0002be4:	cf                   	iret   
c0002be5:	8d 76 00             	lea    0x0(%esi),%esi

c0002be8 <irq_14>:
c0002be8:	60                   	pusha  
c0002be9:	b8 0e 00 00 00       	mov    $0xe,%eax
c0002bee:	50                   	push   %eax
c0002bef:	e8 65 f0 ff ff       	call   c0001c59 <irq_handler>
c0002bf4:	83 c4 04             	add    $0x4,%esp
c0002bf7:	61                   	popa   
c0002bf8:	cf                   	iret   
c0002bf9:	8d 76 00             	lea    0x0(%esi),%esi

c0002bfc <irq_15>:
c0002bfc:	60                   	pusha  
c0002bfd:	b8 0f 00 00 00       	mov    $0xf,%eax
c0002c02:	50                   	push   %eax
c0002c03:	e8 51 f0 ff ff       	call   c0001c59 <irq_handler>
c0002c08:	83 c4 04             	add    $0x4,%esp
c0002c0b:	61                   	popa   
c0002c0c:	cf                   	iret   
c0002c0d:	66 90                	xchg   %ax,%ax
c0002c0f:	90                   	nop

c0002c10 <switch_to_task>:
c0002c10:	53                   	push   %ebx
c0002c11:	56                   	push   %esi
c0002c12:	57                   	push   %edi
c0002c13:	55                   	push   %ebp
c0002c14:	66 87 db             	xchg   %bx,%bx
c0002c17:	8b 3d 40 f8 00 c0    	mov    0xc000f840,%edi
c0002c1d:	89 67 08             	mov    %esp,0x8(%edi)
c0002c20:	8b 74 24 14          	mov    0x14(%esp),%esi
c0002c24:	89 35 40 f8 00 c0    	mov    %esi,0xc000f840
c0002c2a:	8b 66 08             	mov    0x8(%esi),%esp
c0002c2d:	8b 5e 0c             	mov    0xc(%esi),%ebx
c0002c30:	8b 46 10             	mov    0x10(%esi),%eax
c0002c33:	89 1d e4 f8 00 c0    	mov    %ebx,0xc000f8e4
c0002c39:	0f 20 d9             	mov    %cr3,%ecx
c0002c3c:	39 c8                	cmp    %ecx,%eax
c0002c3e:	74 03                	je     c0002c43 <.done>
c0002c40:	0f 22 d8             	mov    %eax,%cr3

c0002c43 <.done>:
c0002c43:	5d                   	pop    %ebp
c0002c44:	5f                   	pop    %edi
c0002c45:	5e                   	pop    %esi
c0002c46:	5b                   	pop    %ebx
c0002c47:	c3                   	ret    

c0002c48 <enable_paging>:
c0002c48:	55                   	push   %ebp
c0002c49:	89 e5                	mov    %esp,%ebp
c0002c4b:	8b 45 04             	mov    0x4(%ebp),%eax
c0002c4e:	0f 22 d8             	mov    %eax,%cr3
c0002c51:	0f 20 c0             	mov    %cr0,%eax
c0002c54:	0d 01 00 00 80       	or     $0x80000001,%eax
c0002c59:	0f 22 c0             	mov    %eax,%cr0
c0002c5c:	89 ec                	mov    %ebp,%esp
c0002c5e:	5d                   	pop    %ebp
c0002c5f:	c3                   	ret    

c0002c60 <set_page_dir>:
c0002c60:	8b 44 24 04          	mov    0x4(%esp),%eax
c0002c64:	0f 22 d8             	mov    %eax,%cr3
c0002c67:	c3                   	ret    

c0002c68 <get_page_dir>:
c0002c68:	0f 20 d8             	mov    %cr3,%eax
c0002c6b:	c3                   	ret    

c0002c6c <refresh_tlb>:
c0002c6c:	0f 20 d8             	mov    %cr3,%eax
c0002c6f:	0f 22 d8             	mov    %eax,%cr3
c0002c72:	c3                   	ret    
c0002c73:	90                   	nop

c0002c74 <refresh_page>:
c0002c74:	8b 44 24 04          	mov    0x4(%esp),%eax
c0002c78:	0f 01 38             	invlpg (%eax)
c0002c7b:	c3                   	ret    
