
build/kernel:     file format elf32-i386


Disassembly of section .text.boot:

00100000 <_start-0xc>:
  100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fb                   	sti    
  100009:	4f                   	dec    %edi
  10000a:	52                   	push   %edx
  10000b:	e4                   	.byte 0xe4

0010000c <_start>:
  10000c:	fa                   	cli    
  10000d:	3d 02 b0 ad 2b       	cmp    $0x2badb002,%eax
  100012:	0f 85 e4 00 00 00    	jne    1000fc <kpanic>
  100018:	8d 25 00 10 11 00    	lea    0x111000,%esp
  10001e:	53                   	push   %ebx
  10001f:	8d 3d 00 10 11 00    	lea    0x111000,%edi
  100025:	b8 83 00 00 00       	mov    $0x83,%eax
  10002a:	89 07                	mov    %eax,(%edi)
  10002c:	0f 20 e0             	mov    %cr4,%eax
  10002f:	83 c8 10             	or     $0x10,%eax
  100032:	0f 22 e0             	mov    %eax,%cr4

00100035 <.init_pagedir>:
  100035:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  10003b:	c1 e8 16             	shr    $0x16,%eax
  10003e:	bb 04 00 00 00       	mov    $0x4,%ebx
  100043:	f7 e3                	mul    %ebx
  100045:	8d 3d 00 10 11 00    	lea    0x111000,%edi
  10004b:	01 c7                	add    %eax,%edi
  10004d:	8d 05 00 20 11 00    	lea    0x112000,%eax
  100053:	83 c8 03             	or     $0x3,%eax
  100056:	b9 ff 00 00 00       	mov    $0xff,%ecx
  10005b:	fc                   	cld    

0010005c <.nextpde>:
  10005c:	ab                   	stos   %eax,%es:(%edi)
  10005d:	05 00 10 00 00       	add    $0x1000,%eax
  100062:	e2 f8                	loop   10005c <.nextpde>
  100064:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  10006a:	c1 e8 16             	shr    $0x16,%eax
  10006d:	bb 04 00 00 00       	mov    $0x4,%ebx
  100072:	f7 e3                	mul    %ebx
  100074:	8d 3d 00 10 11 00    	lea    0x111000,%edi
  10007a:	01 c7                	add    %eax,%edi
  10007c:	8d 1d 00 00 00 c0    	lea    0xc0000000,%ebx
  100082:	c1 eb 0c             	shr    $0xc,%ebx
  100085:	8d 0d 00 00 11 c0    	lea    0xc0110000,%ecx
  10008b:	81 c1 ff 0f 00 00    	add    $0xfff,%ecx
  100091:	c1 e9 0c             	shr    $0xc,%ecx
  100094:	29 d9                	sub    %ebx,%ecx
  100096:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  10009c:	25 00 f0 3f 00       	and    $0x3ff000,%eax
  1000a1:	c1 e8 0c             	shr    $0xc,%eax
  1000a4:	bb 04 00 00 00       	mov    $0x4,%ebx
  1000a9:	f7 e3                	mul    %ebx
  1000ab:	8d 3d 00 20 11 00    	lea    0x112000,%edi
  1000b1:	01 c7                	add    %eax,%edi
  1000b3:	8d 05 00 10 10 00    	lea    0x101000,%eax
  1000b9:	83 c8 03             	or     $0x3,%eax

001000bc <.nextpte>:
  1000bc:	ab                   	stos   %eax,%es:(%edi)
  1000bd:	05 00 10 00 00       	add    $0x1000,%eax
  1000c2:	e2 f8                	loop   1000bc <.nextpte>
  1000c4:	8d 35 00 10 11 00    	lea    0x111000,%esi
  1000ca:	89 f7                	mov    %esi,%edi
  1000cc:	81 c7 fc 0f 00 00    	add    $0xffc,%edi
  1000d2:	83 ce 03             	or     $0x3,%esi
  1000d5:	89 37                	mov    %esi,(%edi)

001000d7 <_enable_paging>:
  1000d7:	5b                   	pop    %ebx
  1000d8:	8d 05 00 10 11 00    	lea    0x111000,%eax
  1000de:	0f 22 d8             	mov    %eax,%cr3
  1000e1:	0f 20 c0             	mov    %cr0,%eax
  1000e4:	0d 00 00 01 80       	or     $0x80010000,%eax
  1000e9:	0f 22 c0             	mov    %eax,%cr0
  1000ec:	8d 25 00 00 01 c0    	lea    0xc0010000,%esp
  1000f2:	50                   	push   %eax
  1000f3:	50                   	push   %eax
  1000f4:	50                   	push   %eax
  1000f5:	53                   	push   %ebx
  1000f6:	e8 32 37 f0 bf       	call   c000382d <kernel_main>
  1000fb:	fa                   	cli    

001000fc <kpanic>:
  1000fc:	f4                   	hlt    
  1000fd:	eb fd                	jmp    1000fc <kpanic>

001000ff <map_page_table>:
  1000ff:	25 00 f0 3f 00       	and    $0x3ff000,%eax
  100104:	c1 e8 0c             	shr    $0xc,%eax
  100107:	bb 04 00 00 00       	mov    $0x4,%ebx
  10010c:	f7 e3                	mul    %ebx
  10010e:	8d 3d 00 20 11 00    	lea    0x112000,%edi
  100114:	01 c7                	add    %eax,%edi
  100116:	83 c8 03             	or     $0x3,%eax

00100119 <.nextentry>:
  100119:	ab                   	stos   %eax,%es:(%edi)
  10011a:	05 00 10 00 00       	add    $0x1000,%eax
  10011f:	e2 f8                	loop   100119 <.nextentry>

Disassembly of section .text:

c0000000 <align_int>:
{
  __asm__ ("xchg %bx, %bx");
}

static inline size_t align_int(size_t len, size_t alignment)
{
c0000000:	55                   	push   %ebp
c0000001:	89 e5                	mov    %esp,%ebp
c0000003:	83 ec 10             	sub    $0x10,%esp
    size_t am = alignment - 1;
c0000006:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000009:	83 e8 01             	sub    $0x1,%eax
c000000c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (((size_t)len + am) & ~am);
c000000f:	8b 55 08             	mov    0x8(%ebp),%edx
c0000012:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0000015:	01 c2                	add    %eax,%edx
c0000017:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000001a:	f7 d0                	not    %eax
c000001c:	21 d0                	and    %edx,%eax
}
c000001e:	c9                   	leave  
c000001f:	c3                   	ret    

c0000020 <test_allocation>:


//allocate memory, return ptr
//check heap usage before and after for consistenty with expected allocation
int test_allocation(size_t sz, void** ptr)
{
c0000020:	55                   	push   %ebp
c0000021:	89 e5                	mov    %esp,%ebp
c0000023:	83 ec 28             	sub    $0x28,%esp
    size_t sz_used;
    size_t sz_free;
    // get initial size of heap
    if(kheap_size(&sz_used, &sz_free)) return -1;
c0000026:	83 ec 08             	sub    $0x8,%esp
c0000029:	8d 45 ec             	lea    -0x14(%ebp),%eax
c000002c:	50                   	push   %eax
c000002d:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0000030:	50                   	push   %eax
c0000031:	e8 af 36 00 00       	call   c00036e5 <kheap_size>
c0000036:	83 c4 10             	add    $0x10,%esp
c0000039:	85 c0                	test   %eax,%eax
c000003b:	74 0a                	je     c0000047 <test_allocation+0x27>
c000003d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000042:	e9 b5 00 00 00       	jmp    c00000fc <test_allocation+0xdc>

    // allocate memory
    *ptr = kmalloc(sz);
c0000047:	83 ec 0c             	sub    $0xc,%esp
c000004a:	ff 75 08             	pushl  0x8(%ebp)
c000004d:	e8 18 34 00 00       	call   c000346a <kmalloc>
c0000052:	83 c4 10             	add    $0x10,%esp
c0000055:	8b 55 0c             	mov    0xc(%ebp),%edx
c0000058:	89 02                	mov    %eax,(%edx)
    if(! *ptr) return -1;
c000005a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000005d:	8b 00                	mov    (%eax),%eax
c000005f:	85 c0                	test   %eax,%eax
c0000061:	75 0a                	jne    c000006d <test_allocation+0x4d>
c0000063:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000068:	e9 8f 00 00 00       	jmp    c00000fc <test_allocation+0xdc>

    // check heap size
    size_t sz_used_new;
    size_t sz_free_new;
    if(kheap_size(&sz_used_new, &sz_free_new)) return -1;
c000006d:	83 ec 08             	sub    $0x8,%esp
c0000070:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0000073:	50                   	push   %eax
c0000074:	8d 45 e8             	lea    -0x18(%ebp),%eax
c0000077:	50                   	push   %eax
c0000078:	e8 68 36 00 00       	call   c00036e5 <kheap_size>
c000007d:	83 c4 10             	add    $0x10,%esp
c0000080:	85 c0                	test   %eax,%eax
c0000082:	74 07                	je     c000008b <test_allocation+0x6b>
c0000084:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000089:	eb 71                	jmp    c00000fc <test_allocation+0xdc>
    // memory is allocated in increments of HEAP_BLOCKSIZE_UNITS, with extra HEAP_BLOCKSIZE_UNITS for header
    size_t sz_alloc = HEAP_BLOCKSIZE_UNITS + align_int(sz, HEAP_BLOCKSIZE_UNITS);
c000008b:	83 ec 08             	sub    $0x8,%esp
c000008e:	6a 10                	push   $0x10
c0000090:	ff 75 08             	pushl  0x8(%ebp)
c0000093:	e8 68 ff ff ff       	call   c0000000 <align_int>
c0000098:	83 c4 10             	add    $0x10,%esp
c000009b:	83 c0 10             	add    $0x10,%eax
c000009e:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // allocated memory should have increased by sz_alloc
    if(sz_used_new != sz_used + sz_alloc)
c00000a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00000a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00000a7:	01 c2                	add    %eax,%edx
c00000a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00000ac:	39 c2                	cmp    %eax,%edx
c00000ae:	74 07                	je     c00000b7 <test_allocation+0x97>
        return -1;
c00000b0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00000b5:	eb 45                	jmp    c00000fc <test_allocation+0xdc>

    // total heap size (used + free) should not have decreased
    if(sz_used_new + sz_free_new < sz_used + sz_free)
c00000b7:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00000ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00000bd:	01 c2                	add    %eax,%edx
c00000bf:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c00000c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00000c5:	01 c8                	add    %ecx,%eax
c00000c7:	39 c2                	cmp    %eax,%edx
c00000c9:	73 07                	jae    c00000d2 <test_allocation+0xb2>
        return -1;
c00000cb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00000d0:	eb 2a                	jmp    c00000fc <test_allocation+0xdc>

    // if heap size (used + free) has changed, it must have increased in units of HEAP_INCREMENT 
    if( ( (sz_used_new + sz_free_new) - (sz_used + sz_free) ) % HEAP_INCREMENT != 0)
c00000d2:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00000d5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00000d8:	01 d0                	add    %edx,%eax
c00000da:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c00000dd:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00000e0:	01 ca                	add    %ecx,%edx
c00000e2:	29 d0                	sub    %edx,%eax
c00000e4:	25 ff 0f 00 00       	and    $0xfff,%eax
c00000e9:	c1 e0 02             	shl    $0x2,%eax
c00000ec:	85 c0                	test   %eax,%eax
c00000ee:	74 07                	je     c00000f7 <test_allocation+0xd7>
        return -1;
c00000f0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00000f5:	eb 05                	jmp    c00000fc <test_allocation+0xdc>

    return 0;
c00000f7:	b8 00 00 00 00       	mov    $0x0,%eax

}
c00000fc:	c9                   	leave  
c00000fd:	c3                   	ret    

c00000fe <test_free>:

// free memory and check heap for consistenty with expected free
int test_free(size_t sz, void* ptr)
{
c00000fe:	55                   	push   %ebp
c00000ff:	89 e5                	mov    %esp,%ebp
c0000101:	83 ec 28             	sub    $0x28,%esp
    size_t sz_used;
    size_t sz_free;
    // get initial size of heap
    if(kheap_size(&sz_used, &sz_free)) return -1;
c0000104:	83 ec 08             	sub    $0x8,%esp
c0000107:	8d 45 ec             	lea    -0x14(%ebp),%eax
c000010a:	50                   	push   %eax
c000010b:	8d 45 f0             	lea    -0x10(%ebp),%eax
c000010e:	50                   	push   %eax
c000010f:	e8 d1 35 00 00       	call   c00036e5 <kheap_size>
c0000114:	83 c4 10             	add    $0x10,%esp
c0000117:	85 c0                	test   %eax,%eax
c0000119:	74 07                	je     c0000122 <test_free+0x24>
c000011b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000120:	eb 7e                	jmp    c00001a0 <test_free+0xa2>

    // test free and make sure we have recovered all the memory
    if( kfree(ptr) ) return -1;
c0000122:	83 ec 0c             	sub    $0xc,%esp
c0000125:	ff 75 0c             	pushl  0xc(%ebp)
c0000128:	e8 63 35 00 00       	call   c0003690 <kfree>
c000012d:	83 c4 10             	add    $0x10,%esp
c0000130:	85 c0                	test   %eax,%eax
c0000132:	74 07                	je     c000013b <test_free+0x3d>
c0000134:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000139:	eb 65                	jmp    c00001a0 <test_free+0xa2>
    // memory is allocated in increments of HEAP_BLOCKSIZE_UNITS, with extra HEAP_BLOCKSIZE_UNITS for header
    size_t sz_alloc = HEAP_BLOCKSIZE_UNITS + align_int(sz, HEAP_BLOCKSIZE_UNITS);
c000013b:	83 ec 08             	sub    $0x8,%esp
c000013e:	6a 10                	push   $0x10
c0000140:	ff 75 08             	pushl  0x8(%ebp)
c0000143:	e8 b8 fe ff ff       	call   c0000000 <align_int>
c0000148:	83 c4 10             	add    $0x10,%esp
c000014b:	83 c0 10             	add    $0x10,%eax
c000014e:	89 45 f4             	mov    %eax,-0xc(%ebp)

    size_t sz_used_new;
    size_t sz_free_new;
    if(kheap_size(&sz_used_new, &sz_free_new)) return -1;
c0000151:	83 ec 08             	sub    $0x8,%esp
c0000154:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0000157:	50                   	push   %eax
c0000158:	8d 45 e8             	lea    -0x18(%ebp),%eax
c000015b:	50                   	push   %eax
c000015c:	e8 84 35 00 00       	call   c00036e5 <kheap_size>
c0000161:	83 c4 10             	add    $0x10,%esp
c0000164:	85 c0                	test   %eax,%eax
c0000166:	74 07                	je     c000016f <test_free+0x71>
c0000168:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000016d:	eb 31                	jmp    c00001a0 <test_free+0xa2>

    if(sz_used_new != sz_used - sz_alloc)
c000016f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0000172:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0000175:	89 c2                	mov    %eax,%edx
c0000177:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000017a:	39 c2                	cmp    %eax,%edx
c000017c:	74 07                	je     c0000185 <test_free+0x87>
        return -1;
c000017e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000183:	eb 1b                	jmp    c00001a0 <test_free+0xa2>
    if(sz_free_new != sz_free + sz_alloc)
c0000185:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0000188:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000018b:	01 c2                	add    %eax,%edx
c000018d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0000190:	39 c2                	cmp    %eax,%edx
c0000192:	74 07                	je     c000019b <test_free+0x9d>
        return -1;
c0000194:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000199:	eb 05                	jmp    c00001a0 <test_free+0xa2>

    return 0;
c000019b:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00001a0:	c9                   	leave  
c00001a1:	c3                   	ret    

c00001a2 <test_kmalloc>:

int test_kmalloc()
{
c00001a2:	55                   	push   %ebp
c00001a3:	89 e5                	mov    %esp,%ebp
c00001a5:	83 ec 38             	sub    $0x38,%esp
    if(kmalloc_init()) return -1;
c00001a8:	e8 ca 2e 00 00       	call   c0003077 <kmalloc_init>
c00001ad:	85 c0                	test   %eax,%eax
c00001af:	74 0a                	je     c00001bb <test_kmalloc+0x19>
c00001b1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00001b6:	e9 78 02 00 00       	jmp    c0000433 <test_kmalloc+0x291>

    //allocate uint32_t
    uint32_t* a;
    if(test_allocation(sizeof(uint32_t), (void**) &a)) return -1;
c00001bb:	83 ec 08             	sub    $0x8,%esp
c00001be:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c00001c1:	50                   	push   %eax
c00001c2:	6a 04                	push   $0x4
c00001c4:	e8 57 fe ff ff       	call   c0000020 <test_allocation>
c00001c9:	83 c4 10             	add    $0x10,%esp
c00001cc:	85 c0                	test   %eax,%eax
c00001ce:	74 0a                	je     c00001da <test_kmalloc+0x38>
c00001d0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00001d5:	e9 59 02 00 00       	jmp    c0000433 <test_kmalloc+0x291>

    // test assignment and read
    *a = 5;
c00001da:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00001dd:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    if(*a != 5) return -1;
c00001e3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00001e6:	8b 00                	mov    (%eax),%eax
c00001e8:	83 f8 05             	cmp    $0x5,%eax
c00001eb:	74 0a                	je     c00001f7 <test_kmalloc+0x55>
c00001ed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00001f2:	e9 3c 02 00 00       	jmp    c0000433 <test_kmalloc+0x291>

    if(test_free(sizeof(uint32_t), a)) return -1;
c00001f7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00001fa:	83 ec 08             	sub    $0x8,%esp
c00001fd:	50                   	push   %eax
c00001fe:	6a 04                	push   $0x4
c0000200:	e8 f9 fe ff ff       	call   c00000fe <test_free>
c0000205:	83 c4 10             	add    $0x10,%esp
c0000208:	85 c0                	test   %eax,%eax
c000020a:	74 0a                	je     c0000216 <test_kmalloc+0x74>
c000020c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000211:	e9 1d 02 00 00       	jmp    c0000433 <test_kmalloc+0x291>

    // try to free again, make sure this FAILS
    if( !kfree(a) ) return -1;
c0000216:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0000219:	83 ec 0c             	sub    $0xc,%esp
c000021c:	50                   	push   %eax
c000021d:	e8 6e 34 00 00       	call   c0003690 <kfree>
c0000222:	83 c4 10             	add    $0x10,%esp
c0000225:	85 c0                	test   %eax,%eax
c0000227:	75 0a                	jne    c0000233 <test_kmalloc+0x91>
c0000229:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000022e:	e9 00 02 00 00       	jmp    c0000433 <test_kmalloc+0x291>


    //allocate some larger arrays
    uint32_t *b, *c, *d;
    size_t NB = 1000;
c0000233:	c7 45 e4 e8 03 00 00 	movl   $0x3e8,-0x1c(%ebp)
    size_t NC = 16000;
c000023a:	c7 45 e0 80 3e 00 00 	movl   $0x3e80,-0x20(%ebp)
    size_t ND = 1000;
c0000241:	c7 45 dc e8 03 00 00 	movl   $0x3e8,-0x24(%ebp)
        
    if(test_allocation(sizeof(uint32_t)*NB, (void**)&b)) return -1;
c0000248:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000024b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0000252:	83 ec 08             	sub    $0x8,%esp
c0000255:	8d 45 d0             	lea    -0x30(%ebp),%eax
c0000258:	50                   	push   %eax
c0000259:	52                   	push   %edx
c000025a:	e8 c1 fd ff ff       	call   c0000020 <test_allocation>
c000025f:	83 c4 10             	add    $0x10,%esp
c0000262:	85 c0                	test   %eax,%eax
c0000264:	74 0a                	je     c0000270 <test_kmalloc+0xce>
c0000266:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000026b:	e9 c3 01 00 00       	jmp    c0000433 <test_kmalloc+0x291>
    if(test_allocation(sizeof(uint32_t)*NC, (void**)&c)) return -1;
c0000270:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0000273:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000027a:	83 ec 08             	sub    $0x8,%esp
c000027d:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0000280:	50                   	push   %eax
c0000281:	52                   	push   %edx
c0000282:	e8 99 fd ff ff       	call   c0000020 <test_allocation>
c0000287:	83 c4 10             	add    $0x10,%esp
c000028a:	85 c0                	test   %eax,%eax
c000028c:	74 0a                	je     c0000298 <test_kmalloc+0xf6>
c000028e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000293:	e9 9b 01 00 00       	jmp    c0000433 <test_kmalloc+0x291>
    if(test_allocation(sizeof(uint32_t)*ND, (void**)&d)) return -1;
c0000298:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000029b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c00002a2:	83 ec 08             	sub    $0x8,%esp
c00002a5:	8d 45 c8             	lea    -0x38(%ebp),%eax
c00002a8:	50                   	push   %eax
c00002a9:	52                   	push   %edx
c00002aa:	e8 71 fd ff ff       	call   c0000020 <test_allocation>
c00002af:	83 c4 10             	add    $0x10,%esp
c00002b2:	85 c0                	test   %eax,%eax
c00002b4:	74 0a                	je     c00002c0 <test_kmalloc+0x11e>
c00002b6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00002bb:	e9 73 01 00 00       	jmp    c0000433 <test_kmalloc+0x291>

    //test read and write
    for(size_t nn=0; nn<NB; nn++)
c00002c0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00002c7:	eb 14                	jmp    c00002dd <test_kmalloc+0x13b>
        b[nn] = (uint32_t) nn;
c00002c9:	8b 55 d0             	mov    -0x30(%ebp),%edx
c00002cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00002cf:	c1 e0 02             	shl    $0x2,%eax
c00002d2:	01 c2                	add    %eax,%edx
c00002d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00002d7:	89 02                	mov    %eax,(%edx)
    for(size_t nn=0; nn<NB; nn++)
c00002d9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00002dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00002e0:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c00002e3:	72 e4                	jb     c00002c9 <test_kmalloc+0x127>
    for(size_t nn=0; nn<ND; nn++)
c00002e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00002ec:	eb 14                	jmp    c0000302 <test_kmalloc+0x160>
        d[nn] = (uint32_t) nn;
c00002ee:	8b 55 c8             	mov    -0x38(%ebp),%edx
c00002f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00002f4:	c1 e0 02             	shl    $0x2,%eax
c00002f7:	01 c2                	add    %eax,%edx
c00002f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00002fc:	89 02                	mov    %eax,(%edx)
    for(size_t nn=0; nn<ND; nn++)
c00002fe:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0000302:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0000305:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c0000308:	72 e4                	jb     c00002ee <test_kmalloc+0x14c>
    for(size_t nn=0; nn<NB; nn++)
c000030a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0000311:	eb 20                	jmp    c0000333 <test_kmalloc+0x191>
        if(b[nn] != (uint32_t) nn) return -1;
c0000313:	8b 55 d0             	mov    -0x30(%ebp),%edx
c0000316:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0000319:	c1 e0 02             	shl    $0x2,%eax
c000031c:	01 d0                	add    %edx,%eax
c000031e:	8b 00                	mov    (%eax),%eax
c0000320:	39 45 ec             	cmp    %eax,-0x14(%ebp)
c0000323:	74 0a                	je     c000032f <test_kmalloc+0x18d>
c0000325:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000032a:	e9 04 01 00 00       	jmp    c0000433 <test_kmalloc+0x291>
    for(size_t nn=0; nn<NB; nn++)
c000032f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0000333:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0000336:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0000339:	72 d8                	jb     c0000313 <test_kmalloc+0x171>
    for(size_t nn=0; nn<ND; nn++)
c000033b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c0000342:	eb 20                	jmp    c0000364 <test_kmalloc+0x1c2>
        if(d[nn] != (uint32_t) nn) return -1;
c0000344:	8b 55 c8             	mov    -0x38(%ebp),%edx
c0000347:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000034a:	c1 e0 02             	shl    $0x2,%eax
c000034d:	01 d0                	add    %edx,%eax
c000034f:	8b 00                	mov    (%eax),%eax
c0000351:	39 45 e8             	cmp    %eax,-0x18(%ebp)
c0000354:	74 0a                	je     c0000360 <test_kmalloc+0x1be>
c0000356:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000035b:	e9 d3 00 00 00       	jmp    c0000433 <test_kmalloc+0x291>
    for(size_t nn=0; nn<ND; nn++)
c0000360:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c0000364:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000367:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c000036a:	72 d8                	jb     c0000344 <test_kmalloc+0x1a2>


    // test aligned allocation
    uint32_t* e = kmalloc_aligned(sizeof(uint32_t), 4096); // align to page
c000036c:	83 ec 08             	sub    $0x8,%esp
c000036f:	68 00 10 00 00       	push   $0x1000
c0000374:	6a 04                	push   $0x4
c0000376:	e8 bc 31 00 00       	call   c0003537 <kmalloc_aligned>
c000037b:	83 c4 10             	add    $0x10,%esp
c000037e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if(!e) return -1;
c0000381:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c0000385:	75 0a                	jne    c0000391 <test_kmalloc+0x1ef>
c0000387:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000038c:	e9 a2 00 00 00       	jmp    c0000433 <test_kmalloc+0x291>
    if( (size_t) e % 4096 ) return -1;
c0000391:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0000394:	25 ff 0f 00 00       	and    $0xfff,%eax
c0000399:	85 c0                	test   %eax,%eax
c000039b:	74 0a                	je     c00003a7 <test_kmalloc+0x205>
c000039d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00003a2:	e9 8c 00 00 00       	jmp    c0000433 <test_kmalloc+0x291>
    if((*e = 128) != 128) return -1;
c00003a7:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00003aa:	c7 00 80 00 00 00    	movl   $0x80,(%eax)

    if(test_free(sizeof(uint32_t)*NB, b)) return -1;
c00003b0:	8b 45 d0             	mov    -0x30(%ebp),%eax
c00003b3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00003b6:	c1 e2 02             	shl    $0x2,%edx
c00003b9:	83 ec 08             	sub    $0x8,%esp
c00003bc:	50                   	push   %eax
c00003bd:	52                   	push   %edx
c00003be:	e8 3b fd ff ff       	call   c00000fe <test_free>
c00003c3:	83 c4 10             	add    $0x10,%esp
c00003c6:	85 c0                	test   %eax,%eax
c00003c8:	74 07                	je     c00003d1 <test_kmalloc+0x22f>
c00003ca:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00003cf:	eb 62                	jmp    c0000433 <test_kmalloc+0x291>
    if(test_free(sizeof(uint32_t)*NC, c)) return -1;
c00003d1:	8b 45 cc             	mov    -0x34(%ebp),%eax
c00003d4:	8b 55 e0             	mov    -0x20(%ebp),%edx
c00003d7:	c1 e2 02             	shl    $0x2,%edx
c00003da:	83 ec 08             	sub    $0x8,%esp
c00003dd:	50                   	push   %eax
c00003de:	52                   	push   %edx
c00003df:	e8 1a fd ff ff       	call   c00000fe <test_free>
c00003e4:	83 c4 10             	add    $0x10,%esp
c00003e7:	85 c0                	test   %eax,%eax
c00003e9:	74 07                	je     c00003f2 <test_kmalloc+0x250>
c00003eb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00003f0:	eb 41                	jmp    c0000433 <test_kmalloc+0x291>
    if(test_free(sizeof(uint32_t)*ND, d)) return -1;
c00003f2:	8b 45 c8             	mov    -0x38(%ebp),%eax
c00003f5:	8b 55 dc             	mov    -0x24(%ebp),%edx
c00003f8:	c1 e2 02             	shl    $0x2,%edx
c00003fb:	83 ec 08             	sub    $0x8,%esp
c00003fe:	50                   	push   %eax
c00003ff:	52                   	push   %edx
c0000400:	e8 f9 fc ff ff       	call   c00000fe <test_free>
c0000405:	83 c4 10             	add    $0x10,%esp
c0000408:	85 c0                	test   %eax,%eax
c000040a:	74 07                	je     c0000413 <test_kmalloc+0x271>
c000040c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000411:	eb 20                	jmp    c0000433 <test_kmalloc+0x291>
    if(test_free(sizeof(uint32_t), e)) return -1;
c0000413:	83 ec 08             	sub    $0x8,%esp
c0000416:	ff 75 d8             	pushl  -0x28(%ebp)
c0000419:	6a 04                	push   $0x4
c000041b:	e8 de fc ff ff       	call   c00000fe <test_free>
c0000420:	83 c4 10             	add    $0x10,%esp
c0000423:	85 c0                	test   %eax,%eax
c0000425:	74 07                	je     c000042e <test_kmalloc+0x28c>
c0000427:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000042c:	eb 05                	jmp    c0000433 <test_kmalloc+0x291>

    return 0;
c000042e:	b8 00 00 00 00       	mov    $0x0,%eax
c0000433:	c9                   	leave  
c0000434:	c3                   	ret    

c0000435 <syscall>:
#include "terminal.h"
#include "kprintf.h"

void syscall()
{
c0000435:	55                   	push   %ebp
c0000436:	89 e5                	mov    %esp,%ebp
}
c0000438:	90                   	nop
c0000439:	5d                   	pop    %ebp
c000043a:	c3                   	ret    

c000043b <vga_entry_color>:
	VGA_COLOR_LIGHT_BROWN = 14,
	VGA_COLOR_WHITE = 15,
};
 
static inline uint8_t vga_entry_color(enum vga_color fg, enum vga_color bg) 
{
c000043b:	55                   	push   %ebp
c000043c:	89 e5                	mov    %esp,%ebp
	return fg | bg << 4;
c000043e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000441:	c1 e0 04             	shl    $0x4,%eax
c0000444:	89 c2                	mov    %eax,%edx
c0000446:	8b 45 08             	mov    0x8(%ebp),%eax
c0000449:	09 d0                	or     %edx,%eax
}
c000044b:	5d                   	pop    %ebp
c000044c:	c3                   	ret    

c000044d <vga_entry>:
 
static inline uint16_t vga_entry(unsigned char uc, uint8_t color) 
{
c000044d:	55                   	push   %ebp
c000044e:	89 e5                	mov    %esp,%ebp
c0000450:	83 ec 08             	sub    $0x8,%esp
c0000453:	8b 55 08             	mov    0x8(%ebp),%edx
c0000456:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000459:	88 55 fc             	mov    %dl,-0x4(%ebp)
c000045c:	88 45 f8             	mov    %al,-0x8(%ebp)
	return (uint16_t) uc | (uint16_t) color << 8;
c000045f:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c0000463:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0000467:	c1 e0 08             	shl    $0x8,%eax
c000046a:	09 d0                	or     %edx,%eax
}
c000046c:	c9                   	leave  
c000046d:	c3                   	ret    

c000046e <outb>:
  return _v;
}

static inline void
outb (unsigned char __value, unsigned short int __port)
{
c000046e:	55                   	push   %ebp
c000046f:	89 e5                	mov    %esp,%ebp
c0000471:	83 ec 08             	sub    $0x8,%esp
c0000474:	8b 55 08             	mov    0x8(%ebp),%edx
c0000477:	8b 45 0c             	mov    0xc(%ebp),%eax
c000047a:	88 55 fc             	mov    %dl,-0x4(%ebp)
c000047d:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
c0000481:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0000485:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
c0000489:	ee                   	out    %al,(%dx)
}
c000048a:	90                   	nop
c000048b:	c9                   	leave  
c000048c:	c3                   	ret    

c000048d <terminal_init>:
#include "io.h"

struct terminal stdout;

void terminal_init(struct terminal* term) 
{
c000048d:	55                   	push   %ebp
c000048e:	89 e5                	mov    %esp,%ebp
c0000490:	53                   	push   %ebx
c0000491:	83 ec 14             	sub    $0x14,%esp
	//map vga buffer
	map_hardware_buffer((void*) VGA_BUFFER, (void*) VGA_BUFFER_PHYS, VGA_BUFFER_SIZE, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c0000494:	6a 06                	push   $0x6
c0000496:	68 00 70 00 00       	push   $0x7000
c000049b:	68 00 80 0b 00       	push   $0xb8000
c00004a0:	68 00 00 b1 ff       	push   $0xffb10000
c00004a5:	e8 a1 28 00 00       	call   c0002d4b <map_hardware_buffer>
c00004aa:	83 c4 10             	add    $0x10,%esp

	term->row = 0;
c00004ad:	8b 45 08             	mov    0x8(%ebp),%eax
c00004b0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	term->column = 0;
c00004b6:	8b 45 08             	mov    0x8(%ebp),%eax
c00004b9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	term->color = vga_entry_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
c00004c0:	83 ec 08             	sub    $0x8,%esp
c00004c3:	6a 00                	push   $0x0
c00004c5:	6a 07                	push   $0x7
c00004c7:	e8 6f ff ff ff       	call   c000043b <vga_entry_color>
c00004cc:	83 c4 10             	add    $0x10,%esp
c00004cf:	8b 55 08             	mov    0x8(%ebp),%edx
c00004d2:	88 42 08             	mov    %al,0x8(%edx)
	term->buffer = (uint16_t*) VGA_BUFFER;
c00004d5:	8b 45 08             	mov    0x8(%ebp),%eax
c00004d8:	c7 40 0c 00 00 b1 ff 	movl   $0xffb10000,0xc(%eax)
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
c00004df:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00004e6:	eb 57                	jmp    c000053f <terminal_init+0xb2>
		for (size_t x = 0; x < VGA_WIDTH; x++) {
c00004e8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00004ef:	eb 44                	jmp    c0000535 <terminal_init+0xa8>
			const size_t index = y * VGA_WIDTH + x;
c00004f1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00004f4:	89 d0                	mov    %edx,%eax
c00004f6:	c1 e0 02             	shl    $0x2,%eax
c00004f9:	01 d0                	add    %edx,%eax
c00004fb:	c1 e0 04             	shl    $0x4,%eax
c00004fe:	89 c2                	mov    %eax,%edx
c0000500:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0000503:	01 d0                	add    %edx,%eax
c0000505:	89 45 ec             	mov    %eax,-0x14(%ebp)
			term->buffer[index] = vga_entry(' ', term->color);
c0000508:	8b 45 08             	mov    0x8(%ebp),%eax
c000050b:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c000050f:	0f b6 c0             	movzbl %al,%eax
c0000512:	8b 55 08             	mov    0x8(%ebp),%edx
c0000515:	8b 4a 0c             	mov    0xc(%edx),%ecx
c0000518:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000051b:	01 d2                	add    %edx,%edx
c000051d:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
c0000520:	83 ec 08             	sub    $0x8,%esp
c0000523:	50                   	push   %eax
c0000524:	6a 20                	push   $0x20
c0000526:	e8 22 ff ff ff       	call   c000044d <vga_entry>
c000052b:	83 c4 10             	add    $0x10,%esp
c000052e:	66 89 03             	mov    %ax,(%ebx)
		for (size_t x = 0; x < VGA_WIDTH; x++) {
c0000531:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0000535:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
c0000539:	76 b6                	jbe    c00004f1 <terminal_init+0x64>
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
c000053b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c000053f:	83 7d f4 18          	cmpl   $0x18,-0xc(%ebp)
c0000543:	76 a3                	jbe    c00004e8 <terminal_init+0x5b>
		}
	}

	//disable cursor
	outb(0x0A, 0x3D4);
c0000545:	83 ec 08             	sub    $0x8,%esp
c0000548:	68 d4 03 00 00       	push   $0x3d4
c000054d:	6a 0a                	push   $0xa
c000054f:	e8 1a ff ff ff       	call   c000046e <outb>
c0000554:	83 c4 10             	add    $0x10,%esp
	outb(0x20, 0x3D5);
c0000557:	83 ec 08             	sub    $0x8,%esp
c000055a:	68 d5 03 00 00       	push   $0x3d5
c000055f:	6a 20                	push   $0x20
c0000561:	e8 08 ff ff ff       	call   c000046e <outb>
c0000566:	83 c4 10             	add    $0x10,%esp
	// outb(0x0A, 0x3D4);
	// outb((inb(0x3D5) & 0xC0) | cursor_start, 0x3D5);
 
	// outb(0x0B, 0x3D4);
	// outb((inb(0x3D5) & 0xE0) | cursor_end, 0x3D5);
}
c0000569:	90                   	nop
c000056a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000056d:	c9                   	leave  
c000056e:	c3                   	ret    

c000056f <terminal_setcolor>:
 
void terminal_setcolor(struct terminal* term, uint8_t color) 
{
c000056f:	55                   	push   %ebp
c0000570:	89 e5                	mov    %esp,%ebp
c0000572:	83 ec 04             	sub    $0x4,%esp
c0000575:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000578:	88 45 fc             	mov    %al,-0x4(%ebp)
	term->color = color;
c000057b:	8b 45 08             	mov    0x8(%ebp),%eax
c000057e:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c0000582:	88 50 08             	mov    %dl,0x8(%eax)
}
c0000585:	90                   	nop
c0000586:	c9                   	leave  
c0000587:	c3                   	ret    

c0000588 <terminal_getcolor>:

uint8_t terminal_getcolor(struct terminal* term) 
{
c0000588:	55                   	push   %ebp
c0000589:	89 e5                	mov    %esp,%ebp
	return term->color;
c000058b:	8b 45 08             	mov    0x8(%ebp),%eax
c000058e:	0f b6 40 08          	movzbl 0x8(%eax),%eax
}
c0000592:	5d                   	pop    %ebp
c0000593:	c3                   	ret    

c0000594 <terminal_putentryat>:
 
void terminal_putentryat(struct terminal* term, char c, uint8_t color, size_t x, size_t y) 
{
c0000594:	55                   	push   %ebp
c0000595:	89 e5                	mov    %esp,%ebp
c0000597:	53                   	push   %ebx
c0000598:	83 ec 18             	sub    $0x18,%esp
c000059b:	8b 55 0c             	mov    0xc(%ebp),%edx
c000059e:	8b 45 10             	mov    0x10(%ebp),%eax
c00005a1:	88 55 e8             	mov    %dl,-0x18(%ebp)
c00005a4:	88 45 e4             	mov    %al,-0x1c(%ebp)
	const size_t index = y * VGA_WIDTH + x;
c00005a7:	8b 55 18             	mov    0x18(%ebp),%edx
c00005aa:	89 d0                	mov    %edx,%eax
c00005ac:	c1 e0 02             	shl    $0x2,%eax
c00005af:	01 d0                	add    %edx,%eax
c00005b1:	c1 e0 04             	shl    $0x4,%eax
c00005b4:	89 c2                	mov    %eax,%edx
c00005b6:	8b 45 14             	mov    0x14(%ebp),%eax
c00005b9:	01 d0                	add    %edx,%eax
c00005bb:	89 45 f8             	mov    %eax,-0x8(%ebp)
	term->buffer[index] = vga_entry(c, color);
c00005be:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c00005c2:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c00005c6:	0f b6 c0             	movzbl %al,%eax
c00005c9:	8b 4d 08             	mov    0x8(%ebp),%ecx
c00005cc:	8b 59 0c             	mov    0xc(%ecx),%ebx
c00005cf:	8b 4d f8             	mov    -0x8(%ebp),%ecx
c00005d2:	01 c9                	add    %ecx,%ecx
c00005d4:	01 cb                	add    %ecx,%ebx
c00005d6:	52                   	push   %edx
c00005d7:	50                   	push   %eax
c00005d8:	e8 70 fe ff ff       	call   c000044d <vga_entry>
c00005dd:	83 c4 08             	add    $0x8,%esp
c00005e0:	66 89 03             	mov    %ax,(%ebx)
	// terminal_movecursor(term, x, y);
}
c00005e3:	90                   	nop
c00005e4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00005e7:	c9                   	leave  
c00005e8:	c3                   	ret    

c00005e9 <terminal_movecursor>:

void terminal_movecursor(struct terminal* term, size_t x, size_t y)
{
c00005e9:	55                   	push   %ebp
c00005ea:	89 e5                	mov    %esp,%ebp
c00005ec:	83 ec 10             	sub    $0x10,%esp
	(void) term; //we are directly manipulating curser, so were arean't using the term struct

	uint16_t pos = y * VGA_WIDTH + x;
c00005ef:	8b 45 10             	mov    0x10(%ebp),%eax
c00005f2:	89 c2                	mov    %eax,%edx
c00005f4:	89 d0                	mov    %edx,%eax
c00005f6:	c1 e0 02             	shl    $0x2,%eax
c00005f9:	01 d0                	add    %edx,%eax
c00005fb:	c1 e0 04             	shl    $0x4,%eax
c00005fe:	89 c2                	mov    %eax,%edx
c0000600:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000603:	01 d0                	add    %edx,%eax
c0000605:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

	outb(0x0F, 0x3D4);
c0000609:	68 d4 03 00 00       	push   $0x3d4
c000060e:	6a 0f                	push   $0xf
c0000610:	e8 59 fe ff ff       	call   c000046e <outb>
c0000615:	83 c4 08             	add    $0x8,%esp
	outb((uint8_t) (pos & 0xFF), 0x3D5);
c0000618:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c000061c:	0f b6 c0             	movzbl %al,%eax
c000061f:	68 d5 03 00 00       	push   $0x3d5
c0000624:	50                   	push   %eax
c0000625:	e8 44 fe ff ff       	call   c000046e <outb>
c000062a:	83 c4 08             	add    $0x8,%esp
	outb(0x0E, 0x3D4);
c000062d:	68 d4 03 00 00       	push   $0x3d4
c0000632:	6a 0e                	push   $0xe
c0000634:	e8 35 fe ff ff       	call   c000046e <outb>
c0000639:	83 c4 08             	add    $0x8,%esp
	outb((uint8_t) ((pos >> 8) & 0xFF), 0x3D5);
c000063c:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c0000640:	66 c1 e8 08          	shr    $0x8,%ax
c0000644:	0f b6 c0             	movzbl %al,%eax
c0000647:	68 d5 03 00 00       	push   $0x3d5
c000064c:	50                   	push   %eax
c000064d:	e8 1c fe ff ff       	call   c000046e <outb>
c0000652:	83 c4 08             	add    $0x8,%esp
}
c0000655:	90                   	nop
c0000656:	c9                   	leave  
c0000657:	c3                   	ret    

c0000658 <terminal_putchar>:

 
void terminal_putchar(struct terminal* term, char c) 
{
c0000658:	55                   	push   %ebp
c0000659:	89 e5                	mov    %esp,%ebp
c000065b:	53                   	push   %ebx
c000065c:	83 ec 14             	sub    $0x14,%esp
c000065f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000662:	88 45 f4             	mov    %al,-0xc(%ebp)
	if(c == '\n')
c0000665:	80 7d f4 0a          	cmpb   $0xa,-0xc(%ebp)
c0000669:	75 10                	jne    c000067b <terminal_putchar+0x23>
	{
		terminal_newline(term);
c000066b:	83 ec 0c             	sub    $0xc,%esp
c000066e:	ff 75 08             	pushl  0x8(%ebp)
c0000671:	e8 95 00 00 00       	call   c000070b <terminal_newline>
c0000676:	83 c4 10             	add    $0x10,%esp
		return;
c0000679:	eb 53                	jmp    c00006ce <terminal_putchar+0x76>
	}

	terminal_putentryat(term, c, term->color, term->column, term->row);
c000067b:	8b 45 08             	mov    0x8(%ebp),%eax
c000067e:	8b 18                	mov    (%eax),%ebx
c0000680:	8b 45 08             	mov    0x8(%ebp),%eax
c0000683:	8b 48 04             	mov    0x4(%eax),%ecx
c0000686:	8b 45 08             	mov    0x8(%ebp),%eax
c0000689:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c000068d:	0f b6 d0             	movzbl %al,%edx
c0000690:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c0000694:	83 ec 0c             	sub    $0xc,%esp
c0000697:	53                   	push   %ebx
c0000698:	51                   	push   %ecx
c0000699:	52                   	push   %edx
c000069a:	50                   	push   %eax
c000069b:	ff 75 08             	pushl  0x8(%ebp)
c000069e:	e8 f1 fe ff ff       	call   c0000594 <terminal_putentryat>
c00006a3:	83 c4 20             	add    $0x20,%esp
	if (++term->column == VGA_WIDTH)
c00006a6:	8b 45 08             	mov    0x8(%ebp),%eax
c00006a9:	8b 40 04             	mov    0x4(%eax),%eax
c00006ac:	8d 50 01             	lea    0x1(%eax),%edx
c00006af:	8b 45 08             	mov    0x8(%ebp),%eax
c00006b2:	89 50 04             	mov    %edx,0x4(%eax)
c00006b5:	8b 45 08             	mov    0x8(%ebp),%eax
c00006b8:	8b 40 04             	mov    0x4(%eax),%eax
c00006bb:	83 f8 50             	cmp    $0x50,%eax
c00006be:	75 0e                	jne    c00006ce <terminal_putchar+0x76>
		terminal_newline(term);
c00006c0:	83 ec 0c             	sub    $0xc,%esp
c00006c3:	ff 75 08             	pushl  0x8(%ebp)
c00006c6:	e8 40 00 00 00       	call   c000070b <terminal_newline>
c00006cb:	83 c4 10             	add    $0x10,%esp
}
c00006ce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00006d1:	c9                   	leave  
c00006d2:	c3                   	ret    

c00006d3 <terminal_putcharn>:

void terminal_putcharn(struct terminal* term, char c, size_t repeat) 
{
c00006d3:	55                   	push   %ebp
c00006d4:	89 e5                	mov    %esp,%ebp
c00006d6:	83 ec 28             	sub    $0x28,%esp
c00006d9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00006dc:	88 45 e4             	mov    %al,-0x1c(%ebp)
	for (size_t i = 0; i < repeat; i++)
c00006df:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00006e6:	eb 17                	jmp    c00006ff <terminal_putcharn+0x2c>
		terminal_putchar(term, c);
c00006e8:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
c00006ec:	83 ec 08             	sub    $0x8,%esp
c00006ef:	50                   	push   %eax
c00006f0:	ff 75 08             	pushl  0x8(%ebp)
c00006f3:	e8 60 ff ff ff       	call   c0000658 <terminal_putchar>
c00006f8:	83 c4 10             	add    $0x10,%esp
	for (size_t i = 0; i < repeat; i++)
c00006fb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00006ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000702:	3b 45 10             	cmp    0x10(%ebp),%eax
c0000705:	72 e1                	jb     c00006e8 <terminal_putcharn+0x15>
}
c0000707:	90                   	nop
c0000708:	90                   	nop
c0000709:	c9                   	leave  
c000070a:	c3                   	ret    

c000070b <terminal_newline>:

void terminal_newline(struct terminal* term)
{
c000070b:	55                   	push   %ebp
c000070c:	89 e5                	mov    %esp,%ebp
c000070e:	83 ec 08             	sub    $0x8,%esp
    term->column = 0;
c0000711:	8b 45 08             	mov    0x8(%ebp),%eax
c0000714:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if (++term->row == VGA_HEIGHT)
c000071b:	8b 45 08             	mov    0x8(%ebp),%eax
c000071e:	8b 00                	mov    (%eax),%eax
c0000720:	8d 50 01             	lea    0x1(%eax),%edx
c0000723:	8b 45 08             	mov    0x8(%ebp),%eax
c0000726:	89 10                	mov    %edx,(%eax)
c0000728:	8b 45 08             	mov    0x8(%ebp),%eax
c000072b:	8b 00                	mov    (%eax),%eax
c000072d:	83 f8 19             	cmp    $0x19,%eax
c0000730:	75 0e                	jne    c0000740 <terminal_newline+0x35>
        terminal_scrollline(term);
c0000732:	83 ec 0c             	sub    $0xc,%esp
c0000735:	ff 75 08             	pushl  0x8(%ebp)
c0000738:	e8 06 00 00 00       	call   c0000743 <terminal_scrollline>
c000073d:	83 c4 10             	add    $0x10,%esp
}
c0000740:	90                   	nop
c0000741:	c9                   	leave  
c0000742:	c3                   	ret    

c0000743 <terminal_scrollline>:

void terminal_scrollline(struct terminal* term)
{
c0000743:	55                   	push   %ebp
c0000744:	89 e5                	mov    %esp,%ebp
c0000746:	83 ec 08             	sub    $0x8,%esp
	// copy rows 2 though N to rows 1 through N-1
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c0000749:	8b 45 08             	mov    0x8(%ebp),%eax
c000074c:	8b 40 0c             	mov    0xc(%eax),%eax
c000074f:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c0000755:	8b 45 08             	mov    0x8(%ebp),%eax
c0000758:	8b 40 0c             	mov    0xc(%eax),%eax
c000075b:	83 ec 04             	sub    $0x4,%esp
c000075e:	68 00 0f 00 00       	push   $0xf00
c0000763:	52                   	push   %edx
c0000764:	50                   	push   %eax
c0000765:	e8 d5 0f 00 00       	call   c000173f <memcpy>
c000076a:	83 c4 10             	add    $0x10,%esp
	// clear last row
	term->row = VGA_HEIGHT-1;
c000076d:	8b 45 08             	mov    0x8(%ebp),%eax
c0000770:	c7 00 18 00 00 00    	movl   $0x18,(%eax)
	terminal_clearline(term);
c0000776:	83 ec 0c             	sub    $0xc,%esp
c0000779:	ff 75 08             	pushl  0x8(%ebp)
c000077c:	e8 06 00 00 00       	call   c0000787 <terminal_clearline>
c0000781:	83 c4 10             	add    $0x10,%esp
}
c0000784:	90                   	nop
c0000785:	c9                   	leave  
c0000786:	c3                   	ret    

c0000787 <terminal_clearline>:

void terminal_clearline(struct terminal* term)
{
c0000787:	55                   	push   %ebp
c0000788:	89 e5                	mov    %esp,%ebp
c000078a:	53                   	push   %ebx
c000078b:	83 ec 10             	sub    $0x10,%esp
	size_t row_start = term->row * VGA_WIDTH;
c000078e:	8b 45 08             	mov    0x8(%ebp),%eax
c0000791:	8b 10                	mov    (%eax),%edx
c0000793:	89 d0                	mov    %edx,%eax
c0000795:	c1 e0 02             	shl    $0x2,%eax
c0000798:	01 d0                	add    %edx,%eax
c000079a:	c1 e0 04             	shl    $0x4,%eax
c000079d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c00007a0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c00007a7:	eb 2f                	jmp    c00007d8 <terminal_clearline+0x51>
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c00007a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00007ac:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c00007b0:	0f b6 c0             	movzbl %al,%eax
c00007b3:	8b 55 08             	mov    0x8(%ebp),%edx
c00007b6:	8b 4a 0c             	mov    0xc(%edx),%ecx
c00007b9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c00007bc:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00007bf:	01 da                	add    %ebx,%edx
c00007c1:	01 d2                	add    %edx,%edx
c00007c3:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
c00007c6:	50                   	push   %eax
c00007c7:	6a 20                	push   $0x20
c00007c9:	e8 7f fc ff ff       	call   c000044d <vga_entry>
c00007ce:	83 c4 08             	add    $0x8,%esp
c00007d1:	66 89 03             	mov    %ax,(%ebx)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c00007d4:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c00007d8:	83 7d f8 4f          	cmpl   $0x4f,-0x8(%ebp)
c00007dc:	76 cb                	jbe    c00007a9 <terminal_clearline+0x22>

}
c00007de:	90                   	nop
c00007df:	90                   	nop
c00007e0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00007e3:	c9                   	leave  
c00007e4:	c3                   	ret    

c00007e5 <terminal_write>:


void terminal_write(struct terminal* term, const char* data, size_t size) 
{
c00007e5:	55                   	push   %ebp
c00007e6:	89 e5                	mov    %esp,%ebp
c00007e8:	83 ec 18             	sub    $0x18,%esp
	for (size_t i = 0; i < size; i++)
c00007eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00007f2:	eb 21                	jmp    c0000815 <terminal_write+0x30>
		terminal_putchar(term, data[i]);
c00007f4:	8b 55 0c             	mov    0xc(%ebp),%edx
c00007f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00007fa:	01 d0                	add    %edx,%eax
c00007fc:	0f b6 00             	movzbl (%eax),%eax
c00007ff:	0f be c0             	movsbl %al,%eax
c0000802:	83 ec 08             	sub    $0x8,%esp
c0000805:	50                   	push   %eax
c0000806:	ff 75 08             	pushl  0x8(%ebp)
c0000809:	e8 4a fe ff ff       	call   c0000658 <terminal_putchar>
c000080e:	83 c4 10             	add    $0x10,%esp
	for (size_t i = 0; i < size; i++)
c0000811:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0000815:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000818:	3b 45 10             	cmp    0x10(%ebp),%eax
c000081b:	72 d7                	jb     c00007f4 <terminal_write+0xf>
}
c000081d:	90                   	nop
c000081e:	90                   	nop
c000081f:	c9                   	leave  
c0000820:	c3                   	ret    

c0000821 <terminal_writestring>:
 
void terminal_writestring(struct terminal* term, const char* data) 
{
c0000821:	55                   	push   %ebp
c0000822:	89 e5                	mov    %esp,%ebp
c0000824:	83 ec 08             	sub    $0x8,%esp
	terminal_write(term, data, strlen(data));
c0000827:	83 ec 0c             	sub    $0xc,%esp
c000082a:	ff 75 0c             	pushl  0xc(%ebp)
c000082d:	e8 e6 0e 00 00       	call   c0001718 <strlen>
c0000832:	83 c4 10             	add    $0x10,%esp
c0000835:	83 ec 04             	sub    $0x4,%esp
c0000838:	50                   	push   %eax
c0000839:	ff 75 0c             	pushl  0xc(%ebp)
c000083c:	ff 75 08             	pushl  0x8(%ebp)
c000083f:	e8 a1 ff ff ff       	call   c00007e5 <terminal_write>
c0000844:	83 c4 10             	add    $0x10,%esp
}
c0000847:	90                   	nop
c0000848:	c9                   	leave  
c0000849:	c3                   	ret    

c000084a <kprint>:
unsigned int numdigits_uint(unsigned int value, unsigned int base);

int format_uint(unsigned int value, char* str, unsigned int base, int precision, int cap);

int kprint(const char* str)
{
c000084a:	55                   	push   %ebp
c000084b:	89 e5                	mov    %esp,%ebp
c000084d:	83 ec 08             	sub    $0x8,%esp
    terminal_writestring(&stdout, str);
c0000850:	83 ec 08             	sub    $0x8,%esp
c0000853:	ff 75 08             	pushl  0x8(%ebp)
c0000856:	68 00 70 00 c0       	push   $0xc0007000
c000085b:	e8 c1 ff ff ff       	call   c0000821 <terminal_writestring>
c0000860:	83 c4 10             	add    $0x10,%esp
    return strlen(str);
c0000863:	83 ec 0c             	sub    $0xc,%esp
c0000866:	ff 75 08             	pushl  0x8(%ebp)
c0000869:	e8 aa 0e 00 00       	call   c0001718 <strlen>
c000086e:	83 c4 10             	add    $0x10,%esp
}
c0000871:	c9                   	leave  
c0000872:	c3                   	ret    

c0000873 <kprintn>:

int kprintn(const char* str, size_t len)
{
c0000873:	55                   	push   %ebp
c0000874:	89 e5                	mov    %esp,%ebp
c0000876:	83 ec 08             	sub    $0x8,%esp
    terminal_write(&stdout, str, len);
c0000879:	83 ec 04             	sub    $0x4,%esp
c000087c:	ff 75 0c             	pushl  0xc(%ebp)
c000087f:	ff 75 08             	pushl  0x8(%ebp)
c0000882:	68 00 70 00 c0       	push   $0xc0007000
c0000887:	e8 59 ff ff ff       	call   c00007e5 <terminal_write>
c000088c:	83 c4 10             	add    $0x10,%esp
    return len;
c000088f:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c0000892:	c9                   	leave  
c0000893:	c3                   	ret    

c0000894 <kprint_char>:

int kprint_char(char c)
{
c0000894:	55                   	push   %ebp
c0000895:	89 e5                	mov    %esp,%ebp
c0000897:	83 ec 18             	sub    $0x18,%esp
c000089a:	8b 45 08             	mov    0x8(%ebp),%eax
c000089d:	88 45 f4             	mov    %al,-0xc(%ebp)
    terminal_putchar(&stdout, c); 
c00008a0:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c00008a4:	83 ec 08             	sub    $0x8,%esp
c00008a7:	50                   	push   %eax
c00008a8:	68 00 70 00 c0       	push   $0xc0007000
c00008ad:	e8 a6 fd ff ff       	call   c0000658 <terminal_putchar>
c00008b2:	83 c4 10             	add    $0x10,%esp
    return 1;
c00008b5:	b8 01 00 00 00       	mov    $0x1,%eax
}
c00008ba:	c9                   	leave  
c00008bb:	c3                   	ret    

c00008bc <kprintn_char>:

int kprintn_char(char c, size_t rpt)
{
c00008bc:	55                   	push   %ebp
c00008bd:	89 e5                	mov    %esp,%ebp
c00008bf:	83 ec 18             	sub    $0x18,%esp
c00008c2:	8b 45 08             	mov    0x8(%ebp),%eax
c00008c5:	88 45 f4             	mov    %al,-0xc(%ebp)
    terminal_putcharn(&stdout, c, rpt); 
c00008c8:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c00008cc:	83 ec 04             	sub    $0x4,%esp
c00008cf:	ff 75 0c             	pushl  0xc(%ebp)
c00008d2:	50                   	push   %eax
c00008d3:	68 00 70 00 c0       	push   $0xc0007000
c00008d8:	e8 f6 fd ff ff       	call   c00006d3 <terminal_putcharn>
c00008dd:	83 c4 10             	add    $0x10,%esp
    return rpt;
c00008e0:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c00008e3:	c9                   	leave  
c00008e4:	c3                   	ret    

c00008e5 <kprintf>:


int kprintf(const char* format, ...)
{
c00008e5:	55                   	push   %ebp
c00008e6:	89 e5                	mov    %esp,%ebp
c00008e8:	81 ec a8 02 00 00    	sub    $0x2a8,%esp
    /* initialize valist for num number of arguments */
    va_list valist;
    va_start(valist, format);
c00008ee:	8d 45 0c             	lea    0xc(%ebp),%eax
c00008f1:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)

    // parse format into str
    const char* f = format;
c00008f7:	8b 45 08             	mov    0x8(%ebp),%eax
c00008fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int nchar = 0;
c00008fd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    while(f[0] != 0)
c0000904:	e9 9e 0a 00 00       	jmp    c00013a7 <kprintf+0xac2>
    {
        if(f[0] == '\\' && f[1] == '%')
c0000909:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000090c:	0f b6 00             	movzbl (%eax),%eax
c000090f:	3c 5c                	cmp    $0x5c,%al
c0000911:	75 22                	jne    c0000935 <kprintf+0x50>
c0000913:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000916:	83 c0 01             	add    $0x1,%eax
c0000919:	0f b6 00             	movzbl (%eax),%eax
c000091c:	3c 25                	cmp    $0x25,%al
c000091e:	75 15                	jne    c0000935 <kprintf+0x50>
        {
            //write escaped "%%" as '%'
            kprint_char('%');
c0000920:	83 ec 0c             	sub    $0xc,%esp
c0000923:	6a 25                	push   $0x25
c0000925:	e8 6a ff ff ff       	call   c0000894 <kprint_char>
c000092a:	83 c4 10             	add    $0x10,%esp
            nchar++;
c000092d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
            f += 2;
c0000931:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
        }

        if(f[0] == '%')
c0000935:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000938:	0f b6 00             	movzbl (%eax),%eax
c000093b:	3c 25                	cmp    $0x25,%al
c000093d:	0f 85 45 0a 00 00    	jne    c0001388 <kprintf+0xaa3>
        {
            // found new field

            // parse flags
            struct format_flags flags = {0};
c0000943:	c7 85 77 ff ff ff 00 	movl   $0x0,-0x89(%ebp)
c000094a:	00 00 00 
c000094d:	c6 85 7b ff ff ff 00 	movb   $0x0,-0x85(%ebp)
            int check_flags = 1;
c0000954:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
            while(check_flags)
c000095b:	e9 ee 00 00 00       	jmp    c0000a4e <kprintf+0x169>
            {
                switch(*(++f))
c0000960:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0000964:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000967:	0f b6 00             	movzbl (%eax),%eax
c000096a:	0f be c0             	movsbl %al,%eax
c000096d:	85 c0                	test   %eax,%eax
c000096f:	0f 84 c8 00 00 00    	je     c0000a3d <kprintf+0x158>
c0000975:	85 c0                	test   %eax,%eax
c0000977:	0f 88 ca 00 00 00    	js     c0000a47 <kprintf+0x162>
c000097d:	83 f8 30             	cmp    $0x30,%eax
c0000980:	0f 8f c1 00 00 00    	jg     c0000a47 <kprintf+0x162>
c0000986:	83 f8 20             	cmp    $0x20,%eax
c0000989:	0f 8c b8 00 00 00    	jl     c0000a47 <kprintf+0x162>
c000098f:	83 e8 20             	sub    $0x20,%eax
c0000992:	83 f8 10             	cmp    $0x10,%eax
c0000995:	0f 87 ac 00 00 00    	ja     c0000a47 <kprintf+0x162>
c000099b:	8b 04 85 00 50 00 c0 	mov    -0x3fffb000(,%eax,4),%eax
c00009a2:	ff e0                	jmp    *%eax
                {
                    case '#':
                        if(flags.alt) return 0;
c00009a4:	0f b6 85 77 ff ff ff 	movzbl -0x89(%ebp),%eax
c00009ab:	84 c0                	test   %al,%al
c00009ad:	74 0a                	je     c00009b9 <kprintf+0xd4>
c00009af:	b8 00 00 00 00       	mov    $0x0,%eax
c00009b4:	e9 ff 09 00 00       	jmp    c00013b8 <kprintf+0xad3>
                        flags.alt = 1;
c00009b9:	c6 85 77 ff ff ff 01 	movb   $0x1,-0x89(%ebp)
                        break;
c00009c0:	e9 89 00 00 00       	jmp    c0000a4e <kprintf+0x169>
                    case '0':
                        if(flags.zero) return 0;
c00009c5:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c00009cc:	84 c0                	test   %al,%al
c00009ce:	74 0a                	je     c00009da <kprintf+0xf5>
c00009d0:	b8 00 00 00 00       	mov    $0x0,%eax
c00009d5:	e9 de 09 00 00       	jmp    c00013b8 <kprintf+0xad3>
                        flags.zero = 1;
c00009da:	c6 85 78 ff ff ff 01 	movb   $0x1,-0x88(%ebp)
                        break;
c00009e1:	eb 6b                	jmp    c0000a4e <kprintf+0x169>
                    case '-':
                        if(flags.left) return 0;
c00009e3:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c00009ea:	84 c0                	test   %al,%al
c00009ec:	74 0a                	je     c00009f8 <kprintf+0x113>
c00009ee:	b8 00 00 00 00       	mov    $0x0,%eax
c00009f3:	e9 c0 09 00 00       	jmp    c00013b8 <kprintf+0xad3>
                        flags.left = 1;
c00009f8:	c6 85 79 ff ff ff 01 	movb   $0x1,-0x87(%ebp)
                        break;
c00009ff:	eb 4d                	jmp    c0000a4e <kprintf+0x169>
                    case ' ':
                        if(flags.space) return 0;
c0000a01:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c0000a08:	84 c0                	test   %al,%al
c0000a0a:	74 0a                	je     c0000a16 <kprintf+0x131>
c0000a0c:	b8 00 00 00 00       	mov    $0x0,%eax
c0000a11:	e9 a2 09 00 00       	jmp    c00013b8 <kprintf+0xad3>
                        flags.space = 1;
c0000a16:	c6 85 7a ff ff ff 01 	movb   $0x1,-0x86(%ebp)
                        break;
c0000a1d:	eb 2f                	jmp    c0000a4e <kprintf+0x169>
                    case '+':
                        if(flags.sign) return 0;
c0000a1f:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c0000a26:	84 c0                	test   %al,%al
c0000a28:	74 0a                	je     c0000a34 <kprintf+0x14f>
c0000a2a:	b8 00 00 00 00       	mov    $0x0,%eax
c0000a2f:	e9 84 09 00 00       	jmp    c00013b8 <kprintf+0xad3>
                        flags.sign = 1;
c0000a34:	c6 85 7b ff ff ff 01 	movb   $0x1,-0x85(%ebp)
                        break;
c0000a3b:	eb 11                	jmp    c0000a4e <kprintf+0x169>
                    case '\0':
                        //unexpected string termination
                        return -1;
c0000a3d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000a42:	e9 71 09 00 00       	jmp    c00013b8 <kprintf+0xad3>
                        break;
                    default:
                        //no more flags
                        check_flags = 0;
c0000a47:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
            while(check_flags)
c0000a4e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0000a52:	0f 85 08 ff ff ff    	jne    c0000960 <kprintf+0x7b>
                }
            }

            if(flags.left) flags.zero = 0; //If the 0 and - flags both appear, the 0 flag is ignored
c0000a58:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000a5f:	84 c0                	test   %al,%al
c0000a61:	74 07                	je     c0000a6a <kprintf+0x185>
c0000a63:	c6 85 78 ff ff ff 00 	movb   $0x0,-0x88(%ebp)

            // parse field width
            int field_width=0;
c0000a6a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
            int nn=0;
c0000a71:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
            while(f[nn] >= '0' && f[nn] <= '9')
c0000a78:	eb 04                	jmp    c0000a7e <kprintf+0x199>
                nn++;            
c0000a7a:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
            while(f[nn] >= '0' && f[nn] <= '9')
c0000a7e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000a81:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000a84:	01 d0                	add    %edx,%eax
c0000a86:	0f b6 00             	movzbl (%eax),%eax
c0000a89:	3c 2f                	cmp    $0x2f,%al
c0000a8b:	7e 0f                	jle    c0000a9c <kprintf+0x1b7>
c0000a8d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000a90:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000a93:	01 d0                	add    %edx,%eax
c0000a95:	0f b6 00             	movzbl (%eax),%eax
c0000a98:	3c 39                	cmp    $0x39,%al
c0000a9a:	7e de                	jle    c0000a7a <kprintf+0x195>
            if(nn>0)
c0000a9c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0000aa0:	7e 17                	jle    c0000ab9 <kprintf+0x1d4>
            {
                field_width = atoi(f);
c0000aa2:	83 ec 0c             	sub    $0xc,%esp
c0000aa5:	ff 75 f4             	pushl  -0xc(%ebp)
c0000aa8:	e8 6a 0d 00 00       	call   c0001817 <atoi>
c0000aad:	83 c4 10             	add    $0x10,%esp
c0000ab0:	89 45 e8             	mov    %eax,-0x18(%ebp)
                f += nn;
c0000ab3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0000ab6:	01 45 f4             	add    %eax,-0xc(%ebp)
            }

            // parse field precision
            int field_prec=-1; //default is -1
c0000ab9:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
            if(f[0] == '.')
c0000ac0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000ac3:	0f b6 00             	movzbl (%eax),%eax
c0000ac6:	3c 2e                	cmp    $0x2e,%al
c0000ac8:	75 59                	jne    c0000b23 <kprintf+0x23e>
            {
                f++;
c0000aca:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                nn=0;
c0000ace:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
                while(f[nn] >= '0' && f[nn] <= '9')
c0000ad5:	eb 04                	jmp    c0000adb <kprintf+0x1f6>
                    nn++;            
c0000ad7:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                while(f[nn] >= '0' && f[nn] <= '9')
c0000adb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000ade:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000ae1:	01 d0                	add    %edx,%eax
c0000ae3:	0f b6 00             	movzbl (%eax),%eax
c0000ae6:	3c 2f                	cmp    $0x2f,%al
c0000ae8:	7e 0f                	jle    c0000af9 <kprintf+0x214>
c0000aea:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000aed:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000af0:	01 d0                	add    %edx,%eax
c0000af2:	0f b6 00             	movzbl (%eax),%eax
c0000af5:	3c 39                	cmp    $0x39,%al
c0000af7:	7e de                	jle    c0000ad7 <kprintf+0x1f2>
                if(nn>0)
c0000af9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0000afd:	7e 24                	jle    c0000b23 <kprintf+0x23e>
                {
                    field_prec = atoi(f);
c0000aff:	83 ec 0c             	sub    $0xc,%esp
c0000b02:	ff 75 f4             	pushl  -0xc(%ebp)
c0000b05:	e8 0d 0d 00 00       	call   c0001817 <atoi>
c0000b0a:	83 c4 10             	add    $0x10,%esp
c0000b0d:	89 45 e0             	mov    %eax,-0x20(%ebp)
                    if(field_prec<0) field_prec = 0;
c0000b10:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000b14:	79 07                	jns    c0000b1d <kprintf+0x238>
c0000b16:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
                    f += nn;
c0000b1d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0000b20:	01 45 f4             	add    %eax,-0xc(%ebp)

            //parse type
            enum length_mod_t {DEFAULT, CHARINT, SHORTINT, LONGINT, LONGLONGINT,
                            LONGDOUBLE, INTMAX, SIZE, PTRDIFF} length_mod;

            switch(*(f++))
c0000b23:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000b26:	8d 50 01             	lea    0x1(%eax),%edx
c0000b29:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0000b2c:	0f b6 00             	movzbl (%eax),%eax
c0000b2f:	0f be c0             	movsbl %al,%eax
c0000b32:	83 e8 4c             	sub    $0x4c,%eax
c0000b35:	83 f8 2e             	cmp    $0x2e,%eax
c0000b38:	77 6d                	ja     c0000ba7 <kprintf+0x2c2>
c0000b3a:	8b 04 85 44 50 00 c0 	mov    -0x3fffafbc(,%eax,4),%eax
c0000b41:	ff e0                	jmp    *%eax
            {
                case 'h':
                    if(*f == 'h')
c0000b43:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000b46:	0f b6 00             	movzbl (%eax),%eax
c0000b49:	3c 68                	cmp    $0x68,%al
c0000b4b:	75 0d                	jne    c0000b5a <kprintf+0x275>
                    {
                        f++;
c0000b4d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                        length_mod = CHARINT;
c0000b51:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
                    }
                    else
                        length_mod = SHORTINT;
                    break;
c0000b58:	eb 58                	jmp    c0000bb2 <kprintf+0x2cd>
                        length_mod = SHORTINT;
c0000b5a:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
                    break;
c0000b61:	eb 4f                	jmp    c0000bb2 <kprintf+0x2cd>
                case 'l':
                    if(*f == 'l')
c0000b63:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000b66:	0f b6 00             	movzbl (%eax),%eax
c0000b69:	3c 6c                	cmp    $0x6c,%al
c0000b6b:	75 0d                	jne    c0000b7a <kprintf+0x295>
                    {
                        f++;
c0000b6d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                        length_mod = LONGLONGINT;
c0000b71:	c7 45 dc 04 00 00 00 	movl   $0x4,-0x24(%ebp)
                    }
                    else
                        length_mod = LONGINT;
                    break;
c0000b78:	eb 38                	jmp    c0000bb2 <kprintf+0x2cd>
                        length_mod = LONGINT;
c0000b7a:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
                    break;
c0000b81:	eb 2f                	jmp    c0000bb2 <kprintf+0x2cd>
                case 'q':
                case 'L':
                    length_mod = LONGDOUBLE;
c0000b83:	c7 45 dc 05 00 00 00 	movl   $0x5,-0x24(%ebp)
                    break;
c0000b8a:	eb 26                	jmp    c0000bb2 <kprintf+0x2cd>
                case 'j':
                    length_mod = INTMAX;
c0000b8c:	c7 45 dc 06 00 00 00 	movl   $0x6,-0x24(%ebp)
                    break;
c0000b93:	eb 1d                	jmp    c0000bb2 <kprintf+0x2cd>
                case 'Z':
                case 'z':
                    length_mod = SIZE;
c0000b95:	c7 45 dc 07 00 00 00 	movl   $0x7,-0x24(%ebp)
                    break;
c0000b9c:	eb 14                	jmp    c0000bb2 <kprintf+0x2cd>
                case 't':
                    length_mod = PTRDIFF;
c0000b9e:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
                    break;
c0000ba5:	eb 0b                	jmp    c0000bb2 <kprintf+0x2cd>
                default:
                    f--; //no length mod, back up a char...
c0000ba7:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
                    length_mod = DEFAULT;
c0000bab:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
            }

            //parse field
            char val_buf[512]; //assuming here that numberical values cannot exceed 512 chars 
            if(field_width>511)
c0000bb2:	81 7d e8 ff 01 00 00 	cmpl   $0x1ff,-0x18(%ebp)
c0000bb9:	7e 0a                	jle    c0000bc5 <kprintf+0x2e0>
                return -1;
c0000bbb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000bc0:	e9 f3 07 00 00       	jmp    c00013b8 <kprintf+0xad3>

            switch(*f)
c0000bc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000bc8:	0f b6 00             	movzbl (%eax),%eax
c0000bcb:	0f be c0             	movsbl %al,%eax
c0000bce:	83 e8 45             	sub    $0x45,%eax
c0000bd1:	83 f8 33             	cmp    $0x33,%eax
c0000bd4:	0f 87 97 07 00 00    	ja     c0001371 <kprintf+0xa8c>
c0000bda:	8b 04 85 00 51 00 c0 	mov    -0x3fffaf00(,%eax,4),%eax
c0000be1:	ff e0                	jmp    *%eax
c0000be3:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000be7:	0f 87 67 01 00 00    	ja     c0000d54 <kprintf+0x46f>
                        case(LONGINT):
                        case(LONGLONGINT):
                        case(DEFAULT):
                            {
                                int i_value;
                                if(length_mod == LONGLONGINT)
c0000bed:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000bf1:	75 19                	jne    c0000c0c <kprintf+0x327>
                                    i_value = (int) va_arg(valist, long long int); //TODO: implement actual longlong handling
c0000bf3:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000bf9:	8d 50 08             	lea    0x8(%eax),%edx
c0000bfc:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000c02:	8b 50 04             	mov    0x4(%eax),%edx
c0000c05:	8b 00                	mov    (%eax),%eax
c0000c07:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0000c0a:	eb 14                	jmp    c0000c20 <kprintf+0x33b>
                                else
                                    i_value = va_arg(valist, int);
c0000c0c:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000c12:	8d 50 04             	lea    0x4(%eax),%edx
c0000c15:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000c1b:	8b 00                	mov    (%eax),%eax
c0000c1d:	89 45 d8             	mov    %eax,-0x28(%ebp)

                                char sign_char = 0; //sign character or 0 if none
c0000c20:	c6 45 d7 00          	movb   $0x0,-0x29(%ebp)
                                unsigned int ui_value; //unsigned value (abs value)
                                if(i_value<0)
c0000c24:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c0000c28:	79 0e                	jns    c0000c38 <kprintf+0x353>
                                {
                                    ui_value = -i_value;
c0000c2a:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0000c2d:	f7 d8                	neg    %eax
c0000c2f:	89 45 d0             	mov    %eax,-0x30(%ebp)
                                    sign_char = '-';
c0000c32:	c6 45 d7 2d          	movb   $0x2d,-0x29(%ebp)
c0000c36:	eb 26                	jmp    c0000c5e <kprintf+0x379>
                                }
                                else
                                {
                                    ui_value = i_value;
c0000c38:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0000c3b:	89 45 d0             	mov    %eax,-0x30(%ebp)
                                    if(flags.sign)
c0000c3e:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c0000c45:	84 c0                	test   %al,%al
c0000c47:	74 06                	je     c0000c4f <kprintf+0x36a>
                                        sign_char = '+';
c0000c49:	c6 45 d7 2b          	movb   $0x2b,-0x29(%ebp)
c0000c4d:	eb 0f                	jmp    c0000c5e <kprintf+0x379>
                                    else if(flags.space)
c0000c4f:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c0000c56:	84 c0                	test   %al,%al
c0000c58:	74 04                	je     c0000c5e <kprintf+0x379>
                                        sign_char = ' ';
c0000c5a:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
                                    
                                    //else positive number has no sign character
                                }

                                //convert value into string
                                int len = format_uint(ui_value, val_buf, 10, field_prec, 0);
c0000c5e:	83 ec 0c             	sub    $0xc,%esp
c0000c61:	6a 00                	push   $0x0
c0000c63:	ff 75 e0             	pushl  -0x20(%ebp)
c0000c66:	6a 0a                	push   $0xa
c0000c68:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000c6e:	50                   	push   %eax
c0000c6f:	ff 75 d0             	pushl  -0x30(%ebp)
c0000c72:	e8 43 07 00 00       	call   c00013ba <format_uint>
c0000c77:	83 c4 20             	add    $0x20,%esp
c0000c7a:	89 45 9c             	mov    %eax,-0x64(%ebp)
                                //amount of padding required to meet requested width
                                int lenpad = field_width - len; 
c0000c7d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000c80:	2b 45 9c             	sub    -0x64(%ebp),%eax
c0000c83:	89 45 cc             	mov    %eax,-0x34(%ebp)

                                if(sign_char)
c0000c86:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
c0000c8a:	74 22                	je     c0000cae <kprintf+0x3c9>
                                {
                                    lenpad--; //remove one char of padding to account for sign
c0000c8c:	83 6d cc 01          	subl   $0x1,-0x34(%ebp)
                                    if(flags.zero)
c0000c90:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000c97:	84 c0                	test   %al,%al
c0000c99:	74 13                	je     c0000cae <kprintf+0x3c9>
                                        nchar += kprint_char(sign_char); //if zero padding, sign is at beginning
c0000c9b:	0f be 45 d7          	movsbl -0x29(%ebp),%eax
c0000c9f:	83 ec 0c             	sub    $0xc,%esp
c0000ca2:	50                   	push   %eax
c0000ca3:	e8 ec fb ff ff       	call   c0000894 <kprint_char>
c0000ca8:	83 c4 10             	add    $0x10,%esp
c0000cab:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                if(!flags.left && lenpad>0)
c0000cae:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000cb5:	84 c0                	test   %al,%al
c0000cb7:	75 3b                	jne    c0000cf4 <kprintf+0x40f>
c0000cb9:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
c0000cbd:	7e 35                	jle    c0000cf4 <kprintf+0x40f>
                                {
                                    if(flags.zero)
c0000cbf:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000cc6:	84 c0                	test   %al,%al
c0000cc8:	74 16                	je     c0000ce0 <kprintf+0x3fb>
                                        nchar += kprintn_char('0', lenpad);
c0000cca:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0000ccd:	83 ec 08             	sub    $0x8,%esp
c0000cd0:	50                   	push   %eax
c0000cd1:	6a 30                	push   $0x30
c0000cd3:	e8 e4 fb ff ff       	call   c00008bc <kprintn_char>
c0000cd8:	83 c4 10             	add    $0x10,%esp
c0000cdb:	01 45 f0             	add    %eax,-0x10(%ebp)
c0000cde:	eb 14                	jmp    c0000cf4 <kprintf+0x40f>
                                    else
                                        nchar += kprintn_char(' ', lenpad);
c0000ce0:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0000ce3:	83 ec 08             	sub    $0x8,%esp
c0000ce6:	50                   	push   %eax
c0000ce7:	6a 20                	push   $0x20
c0000ce9:	e8 ce fb ff ff       	call   c00008bc <kprintn_char>
c0000cee:	83 c4 10             	add    $0x10,%esp
c0000cf1:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                if(!flags.zero && sign_char)
c0000cf4:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000cfb:	84 c0                	test   %al,%al
c0000cfd:	75 19                	jne    c0000d18 <kprintf+0x433>
c0000cff:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
c0000d03:	74 13                	je     c0000d18 <kprintf+0x433>
                                    nchar += kprint_char(sign_char); //if not zero padding, write sign here
c0000d05:	0f be 45 d7          	movsbl -0x29(%ebp),%eax
c0000d09:	83 ec 0c             	sub    $0xc,%esp
c0000d0c:	50                   	push   %eax
c0000d0d:	e8 82 fb ff ff       	call   c0000894 <kprint_char>
c0000d12:	83 c4 10             	add    $0x10,%esp
c0000d15:	01 45 f0             	add    %eax,-0x10(%ebp)

                                nchar += kprint(val_buf);
c0000d18:	83 ec 0c             	sub    $0xc,%esp
c0000d1b:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000d21:	50                   	push   %eax
c0000d22:	e8 23 fb ff ff       	call   c000084a <kprint>
c0000d27:	83 c4 10             	add    $0x10,%esp
c0000d2a:	01 45 f0             	add    %eax,-0x10(%ebp)

                                if(flags.left && lenpad>0)
c0000d2d:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000d34:	84 c0                	test   %al,%al
c0000d36:	74 26                	je     c0000d5e <kprintf+0x479>
c0000d38:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
c0000d3c:	7e 20                	jle    c0000d5e <kprintf+0x479>
                                    nchar += kprintn_char(' ', lenpad);
c0000d3e:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0000d41:	83 ec 08             	sub    $0x8,%esp
c0000d44:	50                   	push   %eax
c0000d45:	6a 20                	push   $0x20
c0000d47:	e8 70 fb ff ff       	call   c00008bc <kprintn_char>
c0000d4c:	83 c4 10             	add    $0x10,%esp
c0000d4f:	01 45 f0             	add    %eax,-0x10(%ebp)


                            }
                            break;
c0000d52:	eb 0a                	jmp    c0000d5e <kprintf+0x479>
                        default:
                            return -1; //invalid length mod
c0000d54:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000d59:	e9 5a 06 00 00       	jmp    c00013b8 <kprintf+0xad3>
                            break;
c0000d5e:	90                   	nop
                    }
                    break;
c0000d5f:	e9 1e 06 00 00       	jmp    c0001382 <kprintf+0xa9d>
c0000d64:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000d68:	0f 87 03 02 00 00    	ja     c0000f71 <kprintf+0x68c>
                        case(SHORTINT):
                        case(LONGINT):
                        case(LONGLONGINT):
                        case(DEFAULT):
                            {
                                unsigned int base = 10;
c0000d6e:	c7 45 c8 0a 00 00 00 	movl   $0xa,-0x38(%ebp)
                                unsigned int ui_value;
                                if(length_mod == LONGLONGINT)
c0000d75:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000d79:	75 19                	jne    c0000d94 <kprintf+0x4af>
                                    ui_value = (unsigned int) va_arg(valist, long long unsigned int); //TODO: implement actual longlong handling
c0000d7b:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000d81:	8d 50 08             	lea    0x8(%eax),%edx
c0000d84:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000d8a:	8b 50 04             	mov    0x4(%eax),%edx
c0000d8d:	8b 00                	mov    (%eax),%eax
c0000d8f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
c0000d92:	eb 14                	jmp    c0000da8 <kprintf+0x4c3>
                                else
                                    ui_value = va_arg(valist, unsigned int);
c0000d94:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000d9a:	8d 50 04             	lea    0x4(%eax),%edx
c0000d9d:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000da3:	8b 00                	mov    (%eax),%eax
c0000da5:	89 45 c4             	mov    %eax,-0x3c(%ebp)

                                if(*f == 'o')
c0000da8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000dab:	0f b6 00             	movzbl (%eax),%eax
c0000dae:	3c 6f                	cmp    $0x6f,%al
c0000db0:	75 09                	jne    c0000dbb <kprintf+0x4d6>
                                    base = 8;
c0000db2:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
c0000db9:	eb 3e                	jmp    c0000df9 <kprintf+0x514>
                                else if(*f == 'x' || *f == 'X')
c0000dbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000dbe:	0f b6 00             	movzbl (%eax),%eax
c0000dc1:	3c 78                	cmp    $0x78,%al
c0000dc3:	74 0a                	je     c0000dcf <kprintf+0x4ea>
c0000dc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000dc8:	0f b6 00             	movzbl (%eax),%eax
c0000dcb:	3c 58                	cmp    $0x58,%al
c0000dcd:	75 09                	jne    c0000dd8 <kprintf+0x4f3>
                                    base = 16;
c0000dcf:	c7 45 c8 10 00 00 00 	movl   $0x10,-0x38(%ebp)
c0000dd6:	eb 21                	jmp    c0000df9 <kprintf+0x514>
                                else if(*f == 'p')
c0000dd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000ddb:	0f b6 00             	movzbl (%eax),%eax
c0000dde:	3c 70                	cmp    $0x70,%al
c0000de0:	75 10                	jne    c0000df2 <kprintf+0x50d>
                                {
                                    //print as hex with 0x prefix
                                    base = 16;
c0000de2:	c7 45 c8 10 00 00 00 	movl   $0x10,-0x38(%ebp)
                                    flags.alt = 1; 
c0000de9:	c6 85 77 ff ff ff 01 	movb   $0x1,-0x89(%ebp)
c0000df0:	eb 07                	jmp    c0000df9 <kprintf+0x514>
                                }
                                else
                                    flags.alt = 0;
c0000df2:	c6 85 77 ff ff ff 00 	movb   $0x0,-0x89(%ebp)
                                
                                int cap = (*f == 'X') ? 1 : 0;
c0000df9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000dfc:	0f b6 00             	movzbl (%eax),%eax
c0000dff:	3c 58                	cmp    $0x58,%al
c0000e01:	0f 94 c0             	sete   %al
c0000e04:	0f b6 c0             	movzbl %al,%eax
c0000e07:	89 45 94             	mov    %eax,-0x6c(%ebp)

                                //convert value into string
                                int len = format_uint(ui_value, val_buf, base, field_prec, cap);
c0000e0a:	83 ec 0c             	sub    $0xc,%esp
c0000e0d:	ff 75 94             	pushl  -0x6c(%ebp)
c0000e10:	ff 75 e0             	pushl  -0x20(%ebp)
c0000e13:	ff 75 c8             	pushl  -0x38(%ebp)
c0000e16:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000e1c:	50                   	push   %eax
c0000e1d:	ff 75 c4             	pushl  -0x3c(%ebp)
c0000e20:	e8 95 05 00 00       	call   c00013ba <format_uint>
c0000e25:	83 c4 20             	add    $0x20,%esp
c0000e28:	89 45 90             	mov    %eax,-0x70(%ebp)
                                //amount of padding required to meet requested width
                                int lenpad = field_width - len; 
c0000e2b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000e2e:	2b 45 90             	sub    -0x70(%ebp),%eax
c0000e31:	89 45 c0             	mov    %eax,-0x40(%ebp)


                                //format radix prefix for oct and hex with alt flag
                                char radix[3]="";
c0000e34:	66 c7 85 74 ff ff ff 	movw   $0x0,-0x8c(%ebp)
c0000e3b:	00 00 
c0000e3d:	c6 85 76 ff ff ff 00 	movb   $0x0,-0x8a(%ebp)
                                if(flags.alt)
c0000e44:	0f b6 85 77 ff ff ff 	movzbl -0x89(%ebp),%eax
c0000e4b:	84 c0                	test   %al,%al
c0000e4d:	74 75                	je     c0000ec4 <kprintf+0x5df>
                                {
                                    if(base==16)
c0000e4f:	83 7d c8 10          	cmpl   $0x10,-0x38(%ebp)
c0000e53:	75 2c                	jne    c0000e81 <kprintf+0x59c>
                                    {
                                        lenpad -= 2;
c0000e55:	83 6d c0 02          	subl   $0x2,-0x40(%ebp)
                                        radix[0] = '0';
c0000e59:	c6 85 74 ff ff ff 30 	movb   $0x30,-0x8c(%ebp)
                                        radix[1] = cap ? 'X' : 'x';
c0000e60:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
c0000e64:	74 07                	je     c0000e6d <kprintf+0x588>
c0000e66:	b8 58 00 00 00       	mov    $0x58,%eax
c0000e6b:	eb 05                	jmp    c0000e72 <kprintf+0x58d>
c0000e6d:	b8 78 00 00 00       	mov    $0x78,%eax
c0000e72:	88 85 75 ff ff ff    	mov    %al,-0x8b(%ebp)
                                        radix[2] = 0;
c0000e78:	c6 85 76 ff ff ff 00 	movb   $0x0,-0x8a(%ebp)
c0000e7f:	eb 23                	jmp    c0000ea4 <kprintf+0x5bf>
                                    }
                                    else if(base==8 && val_buf[0] != '0')
c0000e81:	83 7d c8 08          	cmpl   $0x8,-0x38(%ebp)
c0000e85:	75 1d                	jne    c0000ea4 <kprintf+0x5bf>
c0000e87:	0f b6 85 74 fd ff ff 	movzbl -0x28c(%ebp),%eax
c0000e8e:	3c 30                	cmp    $0x30,%al
c0000e90:	74 12                	je     c0000ea4 <kprintf+0x5bf>
                                    {
                                        lenpad -= 1;
c0000e92:	83 6d c0 01          	subl   $0x1,-0x40(%ebp)
                                        radix[0] = '0';
c0000e96:	c6 85 74 ff ff ff 30 	movb   $0x30,-0x8c(%ebp)
                                        radix[1] = 0;
c0000e9d:	c6 85 75 ff ff ff 00 	movb   $0x0,-0x8b(%ebp)
                                    }

                                    //if zero padding, radix is printed first
                                    if(flags.zero)
c0000ea4:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000eab:	84 c0                	test   %al,%al
c0000ead:	74 15                	je     c0000ec4 <kprintf+0x5df>
                                        nchar += kprint(radix);
c0000eaf:	83 ec 0c             	sub    $0xc,%esp
c0000eb2:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
c0000eb8:	50                   	push   %eax
c0000eb9:	e8 8c f9 ff ff       	call   c000084a <kprint>
c0000ebe:	83 c4 10             	add    $0x10,%esp
c0000ec1:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }


                                //print leading padding, if any
                                if(!flags.left && lenpad>0)
c0000ec4:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000ecb:	84 c0                	test   %al,%al
c0000ecd:	75 3b                	jne    c0000f0a <kprintf+0x625>
c0000ecf:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
c0000ed3:	7e 35                	jle    c0000f0a <kprintf+0x625>
                                {
                                    if(flags.zero)
c0000ed5:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000edc:	84 c0                	test   %al,%al
c0000ede:	74 16                	je     c0000ef6 <kprintf+0x611>
                                        nchar += kprintn_char('0', lenpad);
c0000ee0:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000ee3:	83 ec 08             	sub    $0x8,%esp
c0000ee6:	50                   	push   %eax
c0000ee7:	6a 30                	push   $0x30
c0000ee9:	e8 ce f9 ff ff       	call   c00008bc <kprintn_char>
c0000eee:	83 c4 10             	add    $0x10,%esp
c0000ef1:	01 45 f0             	add    %eax,-0x10(%ebp)
c0000ef4:	eb 14                	jmp    c0000f0a <kprintf+0x625>
                                    else
                                        nchar += kprintn_char(' ', lenpad);
c0000ef6:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000ef9:	83 ec 08             	sub    $0x8,%esp
c0000efc:	50                   	push   %eax
c0000efd:	6a 20                	push   $0x20
c0000eff:	e8 b8 f9 ff ff       	call   c00008bc <kprintn_char>
c0000f04:	83 c4 10             	add    $0x10,%esp
c0000f07:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                //print radix prefix if valid and not leading zeros
                                if(!flags.zero && radix[0])
c0000f0a:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000f11:	84 c0                	test   %al,%al
c0000f13:	75 20                	jne    c0000f35 <kprintf+0x650>
c0000f15:	0f b6 85 74 ff ff ff 	movzbl -0x8c(%ebp),%eax
c0000f1c:	84 c0                	test   %al,%al
c0000f1e:	74 15                	je     c0000f35 <kprintf+0x650>
                                    nchar += kprint(radix);
c0000f20:	83 ec 0c             	sub    $0xc,%esp
c0000f23:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
c0000f29:	50                   	push   %eax
c0000f2a:	e8 1b f9 ff ff       	call   c000084a <kprint>
c0000f2f:	83 c4 10             	add    $0x10,%esp
c0000f32:	01 45 f0             	add    %eax,-0x10(%ebp)

                                //print number itself
                                nchar += kprint(val_buf);
c0000f35:	83 ec 0c             	sub    $0xc,%esp
c0000f38:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000f3e:	50                   	push   %eax
c0000f3f:	e8 06 f9 ff ff       	call   c000084a <kprint>
c0000f44:	83 c4 10             	add    $0x10,%esp
c0000f47:	01 45 f0             	add    %eax,-0x10(%ebp)

                                //print trailing padding if left justified
                                if(flags.left && lenpad>0)
c0000f4a:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000f51:	84 c0                	test   %al,%al
c0000f53:	74 26                	je     c0000f7b <kprintf+0x696>
c0000f55:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
c0000f59:	7e 20                	jle    c0000f7b <kprintf+0x696>
                                    nchar += kprintn_char(' ', lenpad);
c0000f5b:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000f5e:	83 ec 08             	sub    $0x8,%esp
c0000f61:	50                   	push   %eax
c0000f62:	6a 20                	push   $0x20
c0000f64:	e8 53 f9 ff ff       	call   c00008bc <kprintn_char>
c0000f69:	83 c4 10             	add    $0x10,%esp
c0000f6c:	01 45 f0             	add    %eax,-0x10(%ebp)

                            }
                            break;
c0000f6f:	eb 0a                	jmp    c0000f7b <kprintf+0x696>
                        default:
                            return -1; //invalid length mod
c0000f71:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000f76:	e9 3d 04 00 00       	jmp    c00013b8 <kprintf+0xad3>
                            break;
c0000f7b:	90                   	nop
                    }

                    break;
c0000f7c:	e9 01 04 00 00       	jmp    c0001382 <kprintf+0xa9d>

                case 'f':
                case 'F':
                    {
                        float f_value = (float) va_arg(valist, double);
c0000f81:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000f87:	8d 50 08             	lea    0x8(%eax),%edx
c0000f8a:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000f90:	dd 00                	fldl   (%eax)
c0000f92:	d9 5d 8c             	fstps  -0x74(%ebp)

                        //When 0 is printed with an explicit precision 0, the output is empty.
                        if(f_value==0 && field_prec==0)
c0000f95:	d9 45 8c             	flds   -0x74(%ebp)
c0000f98:	d9 ee                	fldz   
c0000f9a:	df e9                	fucomip %st(1),%st
c0000f9c:	dd d8                	fstp   %st(0)
c0000f9e:	7a 15                	jp     c0000fb5 <kprintf+0x6d0>
c0000fa0:	d9 45 8c             	flds   -0x74(%ebp)
c0000fa3:	d9 ee                	fldz   
c0000fa5:	df e9                	fucomip %st(1),%st
c0000fa7:	dd d8                	fstp   %st(0)
c0000fa9:	75 0a                	jne    c0000fb5 <kprintf+0x6d0>
c0000fab:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000faf:	0f 84 c3 03 00 00    	je     c0001378 <kprintf+0xa93>
                            break;
                        if(field_prec<0) field_prec = 6;  //default is prec = 6
c0000fb5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000fb9:	79 07                	jns    c0000fc2 <kprintf+0x6dd>
c0000fbb:	c7 45 e0 06 00 00 00 	movl   $0x6,-0x20(%ebp)

                        unsigned int ui_part;
                        char sign_char = 0;
c0000fc2:	c6 45 bb 00          	movb   $0x0,-0x45(%ebp)
                        if(f_value<0)
c0000fc6:	d9 45 8c             	flds   -0x74(%ebp)
c0000fc9:	d9 ee                	fldz   
c0000fcb:	df f1                	fcomip %st(1),%st
c0000fcd:	dd d8                	fstp   %st(0)
c0000fcf:	76 3d                	jbe    c000100e <kprintf+0x729>
                        {
                            ui_part = (unsigned int) -f_value;
c0000fd1:	d9 45 8c             	flds   -0x74(%ebp)
c0000fd4:	d9 e0                	fchs   
c0000fd6:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c0000fdc:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c0000fe3:	80 cc 0c             	or     $0xc,%ah
c0000fe6:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c0000fed:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c0000ff3:	df bd 58 fd ff ff    	fistpll -0x2a8(%ebp)
c0000ff9:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
c0000fff:	8b 85 58 fd ff ff    	mov    -0x2a8(%ebp),%eax
c0001005:	89 45 bc             	mov    %eax,-0x44(%ebp)
                            sign_char = '-';
c0001008:	c6 45 bb 2d          	movb   $0x2d,-0x45(%ebp)
c000100c:	eb 55                	jmp    c0001063 <kprintf+0x77e>
                        }
                        else
                        {
                            ui_part = (unsigned int) f_value;
c000100e:	d9 45 8c             	flds   -0x74(%ebp)
c0001011:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c0001017:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c000101e:	80 cc 0c             	or     $0xc,%ah
c0001021:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c0001028:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c000102e:	df bd 58 fd ff ff    	fistpll -0x2a8(%ebp)
c0001034:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
c000103a:	8b 85 58 fd ff ff    	mov    -0x2a8(%ebp),%eax
c0001040:	89 45 bc             	mov    %eax,-0x44(%ebp)
                            if(flags.sign)
c0001043:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c000104a:	84 c0                	test   %al,%al
c000104c:	74 06                	je     c0001054 <kprintf+0x76f>
                                sign_char = '+';
c000104e:	c6 45 bb 2b          	movb   $0x2b,-0x45(%ebp)
c0001052:	eb 0f                	jmp    c0001063 <kprintf+0x77e>
                            else if(flags.space)
c0001054:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c000105b:	84 c0                	test   %al,%al
c000105d:	74 04                	je     c0001063 <kprintf+0x77e>
                                sign_char = ' ';
c000105f:	c6 45 bb 20          	movb   $0x20,-0x45(%ebp)
                            
                            //else positive number has no sign character
                        }

                        int int_len = format_uint(ui_part,val_buf,10,-1,0);
c0001063:	83 ec 0c             	sub    $0xc,%esp
c0001066:	6a 00                	push   $0x0
c0001068:	6a ff                	push   $0xffffffff
c000106a:	6a 0a                	push   $0xa
c000106c:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0001072:	50                   	push   %eax
c0001073:	ff 75 bc             	pushl  -0x44(%ebp)
c0001076:	e8 3f 03 00 00       	call   c00013ba <format_uint>
c000107b:	83 c4 20             	add    $0x20,%esp
c000107e:	89 45 88             	mov    %eax,-0x78(%ebp)

                        int f_len = int_len + 1 + field_prec;
c0001081:	8b 45 88             	mov    -0x78(%ebp),%eax
c0001084:	8d 50 01             	lea    0x1(%eax),%edx
c0001087:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000108a:	01 d0                	add    %edx,%eax
c000108c:	89 45 84             	mov    %eax,-0x7c(%ebp)

                        //amount of padding required to meet requested width
                        int lenpad = field_width - f_len; 
c000108f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001092:	2b 45 84             	sub    -0x7c(%ebp),%eax
c0001095:	89 45 b4             	mov    %eax,-0x4c(%ebp)

                        if(sign_char)
c0001098:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
c000109c:	74 22                	je     c00010c0 <kprintf+0x7db>
                        {
                            lenpad--; //remove one char of padding to account for sign
c000109e:	83 6d b4 01          	subl   $0x1,-0x4c(%ebp)
                            if(flags.zero)
c00010a2:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c00010a9:	84 c0                	test   %al,%al
c00010ab:	74 13                	je     c00010c0 <kprintf+0x7db>
                                nchar += kprint_char(sign_char); //if zero padding, sign is at beginning
c00010ad:	0f be 45 bb          	movsbl -0x45(%ebp),%eax
c00010b1:	83 ec 0c             	sub    $0xc,%esp
c00010b4:	50                   	push   %eax
c00010b5:	e8 da f7 ff ff       	call   c0000894 <kprint_char>
c00010ba:	83 c4 10             	add    $0x10,%esp
c00010bd:	01 45 f0             	add    %eax,-0x10(%ebp)
                        }

                        if(!flags.left && lenpad>0)
c00010c0:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c00010c7:	84 c0                	test   %al,%al
c00010c9:	75 3b                	jne    c0001106 <kprintf+0x821>
c00010cb:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
c00010cf:	7e 35                	jle    c0001106 <kprintf+0x821>
                        {
                            if(flags.zero)
c00010d1:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c00010d8:	84 c0                	test   %al,%al
c00010da:	74 16                	je     c00010f2 <kprintf+0x80d>
                                nchar += kprintn_char('0', lenpad);
c00010dc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c00010df:	83 ec 08             	sub    $0x8,%esp
c00010e2:	50                   	push   %eax
c00010e3:	6a 30                	push   $0x30
c00010e5:	e8 d2 f7 ff ff       	call   c00008bc <kprintn_char>
c00010ea:	83 c4 10             	add    $0x10,%esp
c00010ed:	01 45 f0             	add    %eax,-0x10(%ebp)
c00010f0:	eb 14                	jmp    c0001106 <kprintf+0x821>
                            else
                                nchar += kprintn_char(' ', lenpad);
c00010f2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c00010f5:	83 ec 08             	sub    $0x8,%esp
c00010f8:	50                   	push   %eax
c00010f9:	6a 20                	push   $0x20
c00010fb:	e8 bc f7 ff ff       	call   c00008bc <kprintn_char>
c0001100:	83 c4 10             	add    $0x10,%esp
c0001103:	01 45 f0             	add    %eax,-0x10(%ebp)
                        }

                        if(!flags.zero && sign_char)
c0001106:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c000110d:	84 c0                	test   %al,%al
c000110f:	75 19                	jne    c000112a <kprintf+0x845>
c0001111:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
c0001115:	74 13                	je     c000112a <kprintf+0x845>
                            nchar += kprint_char(sign_char); //if not zero padding, write sign here
c0001117:	0f be 45 bb          	movsbl -0x45(%ebp),%eax
c000111b:	83 ec 0c             	sub    $0xc,%esp
c000111e:	50                   	push   %eax
c000111f:	e8 70 f7 ff ff       	call   c0000894 <kprint_char>
c0001124:	83 c4 10             	add    $0x10,%esp
c0001127:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprint(val_buf);
c000112a:	83 ec 0c             	sub    $0xc,%esp
c000112d:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0001133:	50                   	push   %eax
c0001134:	e8 11 f7 ff ff       	call   c000084a <kprint>
c0001139:	83 c4 10             	add    $0x10,%esp
c000113c:	01 45 f0             	add    %eax,-0x10(%ebp)
                        nchar += kprint_char('.');
c000113f:	83 ec 0c             	sub    $0xc,%esp
c0001142:	6a 2e                	push   $0x2e
c0001144:	e8 4b f7 ff ff       	call   c0000894 <kprint_char>
c0001149:	83 c4 10             	add    $0x10,%esp
c000114c:	01 45 f0             	add    %eax,-0x10(%ebp)

                        //compute fractional digits.
                        float frac = f_value<0 ? -f_value - ui_part : f_value - ui_part;
c000114f:	d9 45 8c             	flds   -0x74(%ebp)
c0001152:	d9 ee                	fldz   
c0001154:	df f1                	fcomip %st(1),%st
c0001156:	dd d8                	fstp   %st(0)
c0001158:	76 23                	jbe    c000117d <kprintf+0x898>
c000115a:	d9 45 8c             	flds   -0x74(%ebp)
c000115d:	d9 e0                	fchs   
c000115f:	8b 45 bc             	mov    -0x44(%ebp),%eax
c0001162:	ba 00 00 00 00       	mov    $0x0,%edx
c0001167:	89 85 58 fd ff ff    	mov    %eax,-0x2a8(%ebp)
c000116d:	89 95 5c fd ff ff    	mov    %edx,-0x2a4(%ebp)
c0001173:	df ad 58 fd ff ff    	fildll -0x2a8(%ebp)
c0001179:	de e9                	fsubrp %st,%st(1)
c000117b:	eb 1f                	jmp    c000119c <kprintf+0x8b7>
c000117d:	8b 45 bc             	mov    -0x44(%ebp),%eax
c0001180:	ba 00 00 00 00       	mov    $0x0,%edx
c0001185:	89 85 58 fd ff ff    	mov    %eax,-0x2a8(%ebp)
c000118b:	89 95 5c fd ff ff    	mov    %edx,-0x2a4(%ebp)
c0001191:	df ad 58 fd ff ff    	fildll -0x2a8(%ebp)
c0001197:	d9 45 8c             	flds   -0x74(%ebp)
c000119a:	de e1                	fsubp  %st,%st(1)
c000119c:	d9 5d b0             	fstps  -0x50(%ebp)
                        int d;
                        for(int nn=0;nn<field_prec; nn++)
c000119f:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
c00011a6:	eb 5e                	jmp    c0001206 <kprintf+0x921>
                        {
                            frac *= 10.;
c00011a8:	d9 45 b0             	flds   -0x50(%ebp)
c00011ab:	d9 05 1c 54 00 c0    	flds   0xc000541c
c00011b1:	de c9                	fmulp  %st,%st(1)
c00011b3:	d9 5d b0             	fstps  -0x50(%ebp)
                            d = (int) frac;
c00011b6:	d9 45 b0             	flds   -0x50(%ebp)
c00011b9:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c00011bf:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c00011c6:	80 cc 0c             	or     $0xc,%ah
c00011c9:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c00011d0:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c00011d6:	db 5d 80             	fistpl -0x80(%ebp)
c00011d9:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
                            frac -= d;
c00011df:	db 45 80             	fildl  -0x80(%ebp)
c00011e2:	d9 45 b0             	flds   -0x50(%ebp)
c00011e5:	de e1                	fsubp  %st,%st(1)
c00011e7:	d9 5d b0             	fstps  -0x50(%ebp)
                            nchar += kprint_char('0' + d);
c00011ea:	8b 45 80             	mov    -0x80(%ebp),%eax
c00011ed:	83 c0 30             	add    $0x30,%eax
c00011f0:	0f be c0             	movsbl %al,%eax
c00011f3:	83 ec 0c             	sub    $0xc,%esp
c00011f6:	50                   	push   %eax
c00011f7:	e8 98 f6 ff ff       	call   c0000894 <kprint_char>
c00011fc:	83 c4 10             	add    $0x10,%esp
c00011ff:	01 45 f0             	add    %eax,-0x10(%ebp)
                        for(int nn=0;nn<field_prec; nn++)
c0001202:	83 45 ac 01          	addl   $0x1,-0x54(%ebp)
c0001206:	8b 45 ac             	mov    -0x54(%ebp),%eax
c0001209:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c000120c:	7c 9a                	jl     c00011a8 <kprintf+0x8c3>
                        }

                        if(flags.left && lenpad>0)
c000120e:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0001215:	84 c0                	test   %al,%al
c0001217:	0f 84 5e 01 00 00    	je     c000137b <kprintf+0xa96>
c000121d:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
c0001221:	0f 8e 54 01 00 00    	jle    c000137b <kprintf+0xa96>
                            nchar += kprintn_char(' ', lenpad);
c0001227:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c000122a:	83 ec 08             	sub    $0x8,%esp
c000122d:	50                   	push   %eax
c000122e:	6a 20                	push   $0x20
c0001230:	e8 87 f6 ff ff       	call   c00008bc <kprintn_char>
c0001235:	83 c4 10             	add    $0x10,%esp
c0001238:	01 45 f0             	add    %eax,-0x10(%ebp)

                    }
                    break;
c000123b:	e9 3b 01 00 00       	jmp    c000137b <kprintf+0xa96>
                case 'e':
                case 'E':
                case 'g':
                case 'G':
                    return -1; // not yet implemented
c0001240:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0001245:	e9 6e 01 00 00       	jmp    c00013b8 <kprintf+0xad3>
                case 'c':
                    {
                        char c = (char) va_arg(valist, int);
c000124a:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0001250:	8d 50 04             	lea    0x4(%eax),%edx
c0001253:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0001259:	8b 00                	mov    (%eax),%eax
c000125b:	88 45 9b             	mov    %al,-0x65(%ebp)

                        if(field_width>1 && !flags.left)    
c000125e:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
c0001262:	7e 22                	jle    c0001286 <kprintf+0x9a1>
c0001264:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c000126b:	84 c0                	test   %al,%al
c000126d:	75 17                	jne    c0001286 <kprintf+0x9a1>
                            nchar += kprintn_char(' ', field_width-1);
c000126f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001272:	83 e8 01             	sub    $0x1,%eax
c0001275:	83 ec 08             	sub    $0x8,%esp
c0001278:	50                   	push   %eax
c0001279:	6a 20                	push   $0x20
c000127b:	e8 3c f6 ff ff       	call   c00008bc <kprintn_char>
c0001280:	83 c4 10             	add    $0x10,%esp
c0001283:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprint_char(c);
c0001286:	0f be 45 9b          	movsbl -0x65(%ebp),%eax
c000128a:	83 ec 0c             	sub    $0xc,%esp
c000128d:	50                   	push   %eax
c000128e:	e8 01 f6 ff ff       	call   c0000894 <kprint_char>
c0001293:	83 c4 10             	add    $0x10,%esp
c0001296:	01 45 f0             	add    %eax,-0x10(%ebp)

                        if(field_width>1 && flags.left)    
c0001299:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
c000129d:	0f 8e db 00 00 00    	jle    c000137e <kprintf+0xa99>
c00012a3:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c00012aa:	84 c0                	test   %al,%al
c00012ac:	0f 84 cc 00 00 00    	je     c000137e <kprintf+0xa99>
                            nchar += kprintn_char(' ', field_width-1);
c00012b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00012b5:	83 e8 01             	sub    $0x1,%eax
c00012b8:	83 ec 08             	sub    $0x8,%esp
c00012bb:	50                   	push   %eax
c00012bc:	6a 20                	push   $0x20
c00012be:	e8 f9 f5 ff ff       	call   c00008bc <kprintn_char>
c00012c3:	83 c4 10             	add    $0x10,%esp
c00012c6:	01 45 f0             	add    %eax,-0x10(%ebp)
                    }                    
                    break;
c00012c9:	e9 b0 00 00 00       	jmp    c000137e <kprintf+0xa99>

                case 's':
                    {
                        char* str = va_arg(valist, char*);
c00012ce:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c00012d4:	8d 50 04             	lea    0x4(%eax),%edx
c00012d7:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c00012dd:	8b 00                	mov    (%eax),%eax
c00012df:	89 45 a4             	mov    %eax,-0x5c(%ebp)
                        int len = strlen(str);
c00012e2:	83 ec 0c             	sub    $0xc,%esp
c00012e5:	ff 75 a4             	pushl  -0x5c(%ebp)
c00012e8:	e8 2b 04 00 00       	call   c0001718 <strlen>
c00012ed:	83 c4 10             	add    $0x10,%esp
c00012f0:	89 45 a8             	mov    %eax,-0x58(%ebp)
                        if(field_prec > 0 && field_prec < len)
c00012f3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c00012f7:	7e 0e                	jle    c0001307 <kprintf+0xa22>
c00012f9:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00012fc:	3b 45 a8             	cmp    -0x58(%ebp),%eax
c00012ff:	7d 06                	jge    c0001307 <kprintf+0xa22>
                            len = field_prec;
c0001301:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001304:	89 45 a8             	mov    %eax,-0x58(%ebp)

                        int lenpad = field_width - len; 
c0001307:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000130a:	2b 45 a8             	sub    -0x58(%ebp),%eax
c000130d:	89 45 a0             	mov    %eax,-0x60(%ebp)

                        if(lenpad>0 && !flags.left)    
c0001310:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
c0001314:	7e 1f                	jle    c0001335 <kprintf+0xa50>
c0001316:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c000131d:	84 c0                	test   %al,%al
c000131f:	75 14                	jne    c0001335 <kprintf+0xa50>
                            nchar += kprintn_char(' ', lenpad);
c0001321:	8b 45 a0             	mov    -0x60(%ebp),%eax
c0001324:	83 ec 08             	sub    $0x8,%esp
c0001327:	50                   	push   %eax
c0001328:	6a 20                	push   $0x20
c000132a:	e8 8d f5 ff ff       	call   c00008bc <kprintn_char>
c000132f:	83 c4 10             	add    $0x10,%esp
c0001332:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprintn(str,len);
c0001335:	8b 45 a8             	mov    -0x58(%ebp),%eax
c0001338:	83 ec 08             	sub    $0x8,%esp
c000133b:	50                   	push   %eax
c000133c:	ff 75 a4             	pushl  -0x5c(%ebp)
c000133f:	e8 2f f5 ff ff       	call   c0000873 <kprintn>
c0001344:	83 c4 10             	add    $0x10,%esp
c0001347:	01 45 f0             	add    %eax,-0x10(%ebp)

                        if(lenpad>0 && flags.left)
c000134a:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
c000134e:	7e 31                	jle    c0001381 <kprintf+0xa9c>
c0001350:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0001357:	84 c0                	test   %al,%al
c0001359:	74 26                	je     c0001381 <kprintf+0xa9c>
                            nchar += kprintn_char(' ', lenpad);
c000135b:	8b 45 a0             	mov    -0x60(%ebp),%eax
c000135e:	83 ec 08             	sub    $0x8,%esp
c0001361:	50                   	push   %eax
c0001362:	6a 20                	push   $0x20
c0001364:	e8 53 f5 ff ff       	call   c00008bc <kprintn_char>
c0001369:	83 c4 10             	add    $0x10,%esp
c000136c:	01 45 f0             	add    %eax,-0x10(%ebp)
                        
                    }
                    break;
c000136f:	eb 10                	jmp    c0001381 <kprintf+0xa9c>
                default:
                    //unsupported type
                    return -1;
c0001371:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0001376:	eb 40                	jmp    c00013b8 <kprintf+0xad3>
                            break;
c0001378:	90                   	nop
c0001379:	eb 07                	jmp    c0001382 <kprintf+0xa9d>
                    break;
c000137b:	90                   	nop
c000137c:	eb 04                	jmp    c0001382 <kprintf+0xa9d>
                    break;
c000137e:	90                   	nop
c000137f:	eb 01                	jmp    c0001382 <kprintf+0xa9d>
                    break;
c0001381:	90                   	nop
                
            }
            f++;
c0001382:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0001386:	eb 1f                	jmp    c00013a7 <kprintf+0xac2>
        }
        else
        {
            //this isnt part of a format code, just copy char to string and increment pointers
            kprint_char(*(f++));
c0001388:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000138b:	8d 50 01             	lea    0x1(%eax),%edx
c000138e:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0001391:	0f b6 00             	movzbl (%eax),%eax
c0001394:	0f be c0             	movsbl %al,%eax
c0001397:	83 ec 0c             	sub    $0xc,%esp
c000139a:	50                   	push   %eax
c000139b:	e8 f4 f4 ff ff       	call   c0000894 <kprint_char>
c00013a0:	83 c4 10             	add    $0x10,%esp
            nchar++;
c00013a3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    while(f[0] != 0)
c00013a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00013aa:	0f b6 00             	movzbl (%eax),%eax
c00013ad:	84 c0                	test   %al,%al
c00013af:	0f 85 54 f5 ff ff    	jne    c0000909 <kprintf+0x24>
    }

   /* clean memory reserved for valist */
   va_end(valist);

   return nchar; //number of characters copied to str
c00013b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c00013b8:	c9                   	leave  
c00013b9:	c3                   	ret    

c00013ba <format_uint>:
// base may be 2-32
// precision is per printf format, precision<0 represents default (unspecified) 
// cap = 0, alpha-numbers are capitalized [base>10 only]
// returns length of string (not counting null termination)
int format_uint(unsigned int value, char* str, unsigned int base, int precision, int cap)
{
c00013ba:	55                   	push   %ebp
c00013bb:	89 e5                	mov    %esp,%ebp
c00013bd:	83 ec 18             	sub    $0x18,%esp
    if(base < 2 || base > 32)
c00013c0:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c00013c4:	76 06                	jbe    c00013cc <format_uint+0x12>
c00013c6:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
c00013ca:	76 0a                	jbe    c00013d6 <format_uint+0x1c>
        return -1;
c00013cc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00013d1:	e9 d1 00 00 00       	jmp    c00014a7 <format_uint+0xed>

    //When 0 is printed with an explicit precision 0, the output is empty.
    if(value==0 && precision==0)
c00013d6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00013da:	75 16                	jne    c00013f2 <format_uint+0x38>
c00013dc:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c00013e0:	75 10                	jne    c00013f2 <format_uint+0x38>
    {
        str[0] = 0;
c00013e2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00013e5:	c6 00 00             	movb   $0x0,(%eax)
        return 0;
c00013e8:	b8 00 00 00 00       	mov    $0x0,%eax
c00013ed:	e9 b5 00 00 00       	jmp    c00014a7 <format_uint+0xed>
    }

    // find number of digits
    int num_digits = numdigits_uint(value, base);
c00013f2:	83 ec 08             	sub    $0x8,%esp
c00013f5:	ff 75 10             	pushl  0x10(%ebp)
c00013f8:	ff 75 08             	pushl  0x8(%ebp)
c00013fb:	e8 a9 00 00 00       	call   c00014a9 <numdigits_uint>
c0001400:	83 c4 10             	add    $0x10,%esp
c0001403:	89 45 ec             	mov    %eax,-0x14(%ebp)
    num_digits = num_digits>precision ? num_digits : precision;
c0001406:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001409:	39 45 14             	cmp    %eax,0x14(%ebp)
c000140c:	0f 4d 45 14          	cmovge 0x14(%ebp),%eax
c0001410:	89 45 ec             	mov    %eax,-0x14(%ebp)

    //write formatted number out in reverse order
    char* s = str + num_digits;
c0001413:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0001416:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001419:	01 d0                	add    %edx,%eax
c000141b:	89 45 f4             	mov    %eax,-0xc(%ebp)

    *(s--) = '\0'; //null termination
c000141e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001421:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001424:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0001427:	c6 00 00             	movb   $0x0,(%eax)

    //compute each digit from lowest to highest.
    unsigned int d;
    for(int nn=0;nn<num_digits; nn++)
c000142a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0001431:	eb 69                	jmp    c000149c <format_uint+0xe2>
    {
        d = value % base;
c0001433:	8b 45 08             	mov    0x8(%ebp),%eax
c0001436:	ba 00 00 00 00       	mov    $0x0,%edx
c000143b:	f7 75 10             	divl   0x10(%ebp)
c000143e:	89 55 e8             	mov    %edx,-0x18(%ebp)
        value /= base;
c0001441:	8b 45 08             	mov    0x8(%ebp),%eax
c0001444:	ba 00 00 00 00       	mov    $0x0,%edx
c0001449:	f7 75 10             	divl   0x10(%ebp)
c000144c:	89 45 08             	mov    %eax,0x8(%ebp)

        //write digit into string and decrement pointer
        if(d < 10)
c000144f:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
c0001453:	77 15                	ja     c000146a <format_uint+0xb0>
            *(s--) = d + '0';
c0001455:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001458:	8d 48 30             	lea    0x30(%eax),%ecx
c000145b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000145e:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001461:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0001464:	89 ca                	mov    %ecx,%edx
c0001466:	88 10                	mov    %dl,(%eax)
c0001468:	eb 2e                	jmp    c0001498 <format_uint+0xde>
        else if(cap == 0)
c000146a:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
c000146e:	75 15                	jne    c0001485 <format_uint+0xcb>
            *(s--) = d - 10 + 'a';
c0001470:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001473:	8d 48 57             	lea    0x57(%eax),%ecx
c0001476:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001479:	8d 50 ff             	lea    -0x1(%eax),%edx
c000147c:	89 55 f4             	mov    %edx,-0xc(%ebp)
c000147f:	89 ca                	mov    %ecx,%edx
c0001481:	88 10                	mov    %dl,(%eax)
c0001483:	eb 13                	jmp    c0001498 <format_uint+0xde>
        else
            *(s--) = d - 10 + 'A';
c0001485:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001488:	8d 48 37             	lea    0x37(%eax),%ecx
c000148b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000148e:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001491:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0001494:	89 ca                	mov    %ecx,%edx
c0001496:	88 10                	mov    %dl,(%eax)
    for(int nn=0;nn<num_digits; nn++)
c0001498:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c000149c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000149f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00014a2:	7c 8f                	jl     c0001433 <format_uint+0x79>
    }

    return num_digits;
c00014a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c00014a7:	c9                   	leave  
c00014a8:	c3                   	ret    

c00014a9 <numdigits_uint>:


//returns number of digits of unsigned int represented in given base
//num_digits is always >= 1
unsigned int numdigits_uint(unsigned int value, unsigned int base)
{
c00014a9:	55                   	push   %ebp
c00014aa:	89 e5                	mov    %esp,%ebp
c00014ac:	83 ec 10             	sub    $0x10,%esp
    unsigned int num_digits = 1;
c00014af:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
    while(value >= base)
c00014b6:	eb 12                	jmp    c00014ca <numdigits_uint+0x21>
    {
        num_digits++;
c00014b8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        value /= base;
c00014bc:	8b 45 08             	mov    0x8(%ebp),%eax
c00014bf:	ba 00 00 00 00       	mov    $0x0,%edx
c00014c4:	f7 75 0c             	divl   0xc(%ebp)
c00014c7:	89 45 08             	mov    %eax,0x8(%ebp)
    while(value >= base)
c00014ca:	8b 45 08             	mov    0x8(%ebp),%eax
c00014cd:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00014d0:	73 e6                	jae    c00014b8 <numdigits_uint+0xf>
    }
    return num_digits;
c00014d2:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00014d5:	c9                   	leave  
c00014d6:	c3                   	ret    

c00014d7 <kprintf_test>:



void kprintf_test()
{
c00014d7:	55                   	push   %ebp
c00014d8:	89 e5                	mov    %esp,%ebp
c00014da:	83 ec 18             	sub    $0x18,%esp
    int num = 12345678;    
c00014dd:	c7 45 f4 4e 61 bc 00 	movl   $0xbc614e,-0xc(%ebp)
    kprintf("\nkprintf() tests...\n", num);
c00014e4:	83 ec 08             	sub    $0x8,%esp
c00014e7:	ff 75 f4             	pushl  -0xc(%ebp)
c00014ea:	68 d0 51 00 c0       	push   $0xc00051d0
c00014ef:	e8 f1 f3 ff ff       	call   c00008e5 <kprintf>
c00014f4:	83 c4 10             	add    $0x10,%esp
    kprintf("Fixed width, right justify:\n");
c00014f7:	83 ec 0c             	sub    $0xc,%esp
c00014fa:	68 e5 51 00 c0       	push   $0xc00051e5
c00014ff:	e8 e1 f3 ff ff       	call   c00008e5 <kprintf>
c0001504:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%15d]\n", num);
c0001507:	83 ec 08             	sub    $0x8,%esp
c000150a:	ff 75 f4             	pushl  -0xc(%ebp)
c000150d:	68 02 52 00 c0       	push   $0xc0005202
c0001512:	e8 ce f3 ff ff       	call   c00008e5 <kprintf>
c0001517:	83 c4 10             	add    $0x10,%esp
    kprintf("Hex:     [%#15x]\n", num);
c000151a:	83 ec 08             	sub    $0x8,%esp
c000151d:	ff 75 f4             	pushl  -0xc(%ebp)
c0001520:	68 13 52 00 c0       	push   $0xc0005213
c0001525:	e8 bb f3 ff ff       	call   c00008e5 <kprintf>
c000152a:	83 c4 10             	add    $0x10,%esp
    kprintf("Oct:     [%#15o]\n", num);
c000152d:	83 ec 08             	sub    $0x8,%esp
c0001530:	ff 75 f4             	pushl  -0xc(%ebp)
c0001533:	68 25 52 00 c0       	push   $0xc0005225
c0001538:	e8 a8 f3 ff ff       	call   c00008e5 <kprintf>
c000153d:	83 c4 10             	add    $0x10,%esp
    kprintf("String:  [%15s]\n", "Hello World!");
c0001540:	83 ec 08             	sub    $0x8,%esp
c0001543:	68 37 52 00 c0       	push   $0xc0005237
c0001548:	68 44 52 00 c0       	push   $0xc0005244
c000154d:	e8 93 f3 ff ff       	call   c00008e5 <kprintf>
c0001552:	83 c4 10             	add    $0x10,%esp
    kprintf("Char:    [%15c]\n", '!');
c0001555:	83 ec 08             	sub    $0x8,%esp
c0001558:	6a 21                	push   $0x21
c000155a:	68 55 52 00 c0       	push   $0xc0005255
c000155f:	e8 81 f3 ff ff       	call   c00008e5 <kprintf>
c0001564:	83 c4 10             	add    $0x10,%esp

    kprintf("\nFixed width, left justify:\n");
c0001567:	83 ec 0c             	sub    $0xc,%esp
c000156a:	68 66 52 00 c0       	push   $0xc0005266
c000156f:	e8 71 f3 ff ff       	call   c00008e5 <kprintf>
c0001574:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%-15d]\n", num);
c0001577:	83 ec 08             	sub    $0x8,%esp
c000157a:	ff 75 f4             	pushl  -0xc(%ebp)
c000157d:	68 83 52 00 c0       	push   $0xc0005283
c0001582:	e8 5e f3 ff ff       	call   c00008e5 <kprintf>
c0001587:	83 c4 10             	add    $0x10,%esp
    kprintf("Hex:     [%-#15x]\n", num);
c000158a:	83 ec 08             	sub    $0x8,%esp
c000158d:	ff 75 f4             	pushl  -0xc(%ebp)
c0001590:	68 95 52 00 c0       	push   $0xc0005295
c0001595:	e8 4b f3 ff ff       	call   c00008e5 <kprintf>
c000159a:	83 c4 10             	add    $0x10,%esp
    kprintf("String:  [%-15s]\n", "Hello World!");
c000159d:	83 ec 08             	sub    $0x8,%esp
c00015a0:	68 37 52 00 c0       	push   $0xc0005237
c00015a5:	68 a8 52 00 c0       	push   $0xc00052a8
c00015aa:	e8 36 f3 ff ff       	call   c00008e5 <kprintf>
c00015af:	83 c4 10             	add    $0x10,%esp

    kprintf("\nFixed Precision:\n");
c00015b2:	83 ec 0c             	sub    $0xc,%esp
c00015b5:	68 ba 52 00 c0       	push   $0xc00052ba
c00015ba:	e8 26 f3 ff ff       	call   c00008e5 <kprintf>
c00015bf:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%15.10d]\nHex:     [%#15.10x]\nOct:     [%#15.10o]\nString:  [%15.10s]\n", 
c00015c2:	83 ec 0c             	sub    $0xc,%esp
c00015c5:	68 37 52 00 c0       	push   $0xc0005237
c00015ca:	ff 75 f4             	pushl  -0xc(%ebp)
c00015cd:	ff 75 f4             	pushl  -0xc(%ebp)
c00015d0:	ff 75 f4             	pushl  -0xc(%ebp)
c00015d3:	68 d0 52 00 c0       	push   $0xc00052d0
c00015d8:	e8 08 f3 ff ff       	call   c00008e5 <kprintf>
c00015dd:	83 c4 20             	add    $0x20,%esp
        num, num, num, "Hello World!");

    kprintf("\nLeading Zeros:\n");
c00015e0:	83 ec 0c             	sub    $0xc,%esp
c00015e3:	68 1f 53 00 c0       	push   $0xc000531f
c00015e8:	e8 f8 f2 ff ff       	call   c00008e5 <kprintf>
c00015ed:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%015.10d]\nHex:     [%#015.10x]\nOct:     [%#015.10o]\n",num, num, num);
c00015f0:	ff 75 f4             	pushl  -0xc(%ebp)
c00015f3:	ff 75 f4             	pushl  -0xc(%ebp)
c00015f6:	ff 75 f4             	pushl  -0xc(%ebp)
c00015f9:	68 30 53 00 c0       	push   $0xc0005330
c00015fe:	e8 e2 f2 ff ff       	call   c00008e5 <kprintf>
c0001603:	83 c4 10             	add    $0x10,%esp

    kprintf("Signed (none):  [%d], [%d]\n",num, -num);
c0001606:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001609:	f7 d8                	neg    %eax
c000160b:	83 ec 04             	sub    $0x4,%esp
c000160e:	50                   	push   %eax
c000160f:	ff 75 f4             	pushl  -0xc(%ebp)
c0001612:	68 6f 53 00 c0       	push   $0xc000536f
c0001617:	e8 c9 f2 ff ff       	call   c00008e5 <kprintf>
c000161c:	83 c4 10             	add    $0x10,%esp
    kprintf("Signed (space): [% d], [% d]\n",num, -num);
c000161f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001622:	f7 d8                	neg    %eax
c0001624:	83 ec 04             	sub    $0x4,%esp
c0001627:	50                   	push   %eax
c0001628:	ff 75 f4             	pushl  -0xc(%ebp)
c000162b:	68 8b 53 00 c0       	push   $0xc000538b
c0001630:	e8 b0 f2 ff ff       	call   c00008e5 <kprintf>
c0001635:	83 c4 10             	add    $0x10,%esp
    kprintf("Signed (+):     [%+d], [%+d]\n",num, -num);
c0001638:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000163b:	f7 d8                	neg    %eax
c000163d:	83 ec 04             	sub    $0x4,%esp
c0001640:	50                   	push   %eax
c0001641:	ff 75 f4             	pushl  -0xc(%ebp)
c0001644:	68 a9 53 00 c0       	push   $0xc00053a9
c0001649:	e8 97 f2 ff ff       	call   c00008e5 <kprintf>
c000164e:	83 c4 10             	add    $0x10,%esp

    float f = 1.23456789;
c0001651:	d9 05 20 54 00 c0    	flds   0xc0005420
c0001657:	d9 5d f0             	fstps  -0x10(%ebp)
    kprintf("\nfloat:     [%15.f]\n",f);
c000165a:	d9 45 f0             	flds   -0x10(%ebp)
c000165d:	83 ec 04             	sub    $0x4,%esp
c0001660:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001664:	dd 1c 24             	fstpl  (%esp)
c0001667:	68 c7 53 00 c0       	push   $0xc00053c7
c000166c:	e8 74 f2 ff ff       	call   c00008e5 <kprintf>
c0001671:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.3f]\n",f);
c0001674:	d9 45 f0             	flds   -0x10(%ebp)
c0001677:	83 ec 04             	sub    $0x4,%esp
c000167a:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c000167e:	dd 1c 24             	fstpl  (%esp)
c0001681:	68 dc 53 00 c0       	push   $0xc00053dc
c0001686:	e8 5a f2 ff ff       	call   c00008e5 <kprintf>
c000168b:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.10f]\n",f);
c000168e:	d9 45 f0             	flds   -0x10(%ebp)
c0001691:	83 ec 04             	sub    $0x4,%esp
c0001694:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001698:	dd 1c 24             	fstpl  (%esp)
c000169b:	68 f1 53 00 c0       	push   $0xc00053f1
c00016a0:	e8 40 f2 ff ff       	call   c00008e5 <kprintf>
c00016a5:	83 c4 10             	add    $0x10,%esp

    f = -12345.6789;
c00016a8:	d9 05 24 54 00 c0    	flds   0xc0005424
c00016ae:	d9 5d f0             	fstps  -0x10(%ebp)
    kprintf("float:     [%15f]\n",f);
c00016b1:	d9 45 f0             	flds   -0x10(%ebp)
c00016b4:	83 ec 04             	sub    $0x4,%esp
c00016b7:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c00016bb:	dd 1c 24             	fstpl  (%esp)
c00016be:	68 07 54 00 c0       	push   $0xc0005407
c00016c3:	e8 1d f2 ff ff       	call   c00008e5 <kprintf>
c00016c8:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.3f]\n",f);
c00016cb:	d9 45 f0             	flds   -0x10(%ebp)
c00016ce:	83 ec 04             	sub    $0x4,%esp
c00016d1:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c00016d5:	dd 1c 24             	fstpl  (%esp)
c00016d8:	68 dc 53 00 c0       	push   $0xc00053dc
c00016dd:	e8 03 f2 ff ff       	call   c00008e5 <kprintf>
c00016e2:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.10f]\n",f);
c00016e5:	d9 45 f0             	flds   -0x10(%ebp)
c00016e8:	83 ec 04             	sub    $0x4,%esp
c00016eb:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c00016ef:	dd 1c 24             	fstpl  (%esp)
c00016f2:	68 f1 53 00 c0       	push   $0xc00053f1
c00016f7:	e8 e9 f1 ff ff       	call   c00008e5 <kprintf>
c00016fc:	83 c4 10             	add    $0x10,%esp
}
c00016ff:	90                   	nop
c0001700:	c9                   	leave  
c0001701:	c3                   	ret    

c0001702 <panic>:
#include "common.h"
#include "kprintf.h"

void panic(char* str)
{
c0001702:	55                   	push   %ebp
c0001703:	89 e5                	mov    %esp,%ebp
c0001705:	83 ec 08             	sub    $0x8,%esp
    kprintf(str);
c0001708:	83 ec 0c             	sub    $0xc,%esp
c000170b:	ff 75 08             	pushl  0x8(%ebp)
c000170e:	e8 d2 f1 ff ff       	call   c00008e5 <kprintf>
c0001713:	83 c4 10             	add    $0x10,%esp
    while(true);
c0001716:	eb fe                	jmp    c0001716 <panic+0x14>

c0001718 <strlen>:
}

size_t strlen(const char* str) 
{
c0001718:	55                   	push   %ebp
c0001719:	89 e5                	mov    %esp,%ebp
c000171b:	83 ec 10             	sub    $0x10,%esp
	size_t len = 0;
c000171e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while (str[len])
c0001725:	eb 04                	jmp    c000172b <strlen+0x13>
		len++;
c0001727:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
	while (str[len])
c000172b:	8b 55 08             	mov    0x8(%ebp),%edx
c000172e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001731:	01 d0                	add    %edx,%eax
c0001733:	0f b6 00             	movzbl (%eax),%eax
c0001736:	84 c0                	test   %al,%al
c0001738:	75 ed                	jne    c0001727 <strlen+0xf>
	return len;
c000173a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c000173d:	c9                   	leave  
c000173e:	c3                   	ret    

c000173f <memcpy>:

// copy n bytes from src to dest
void *memcpy(void *dest, const void *src, size_t n)
{
c000173f:	55                   	push   %ebp
c0001740:	89 e5                	mov    %esp,%ebp
c0001742:	83 ec 20             	sub    $0x20,%esp
    //system wordsize is equal to length of size_t
    size_t n_words = n/sizeof(size_t);
c0001745:	8b 45 10             	mov    0x10(%ebp),%eax
c0001748:	c1 e8 02             	shr    $0x2,%eax
c000174b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t* dest_word = (size_t *) dest;
c000174e:	8b 45 08             	mov    0x8(%ebp),%eax
c0001751:	89 45 f0             	mov    %eax,-0x10(%ebp)
    size_t* src_word = (size_t *) src;
c0001754:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001757:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for(size_t nn=0; nn<n_words; nn++)
c000175a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0001761:	eb 26                	jmp    c0001789 <memcpy+0x4a>
        dest_word[nn]=src_word[nn];
c0001763:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001766:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000176d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001770:	01 d0                	add    %edx,%eax
c0001772:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0001775:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
c000177c:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000177f:	01 ca                	add    %ecx,%edx
c0001781:	8b 00                	mov    (%eax),%eax
c0001783:	89 02                	mov    %eax,(%edx)
    for(size_t nn=0; nn<n_words; nn++)
c0001785:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0001789:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000178c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c000178f:	72 d2                	jb     c0001763 <memcpy+0x24>
    
    //copy remaining bytes
    size_t n_bytes = n - n_words*sizeof(size_t);
c0001791:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001794:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000179b:	8b 45 10             	mov    0x10(%ebp),%eax
c000179e:	29 d0                	sub    %edx,%eax
c00017a0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(n_bytes > 0)
c00017a3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c00017a7:	74 36                	je     c00017df <memcpy+0xa0>
    {
        char* dest_byte = (char *) dest;
c00017a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00017ac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        char* src_byte = (char *) src;
c00017af:	8b 45 0c             	mov    0xc(%ebp),%eax
c00017b2:	89 45 e0             	mov    %eax,-0x20(%ebp)
        for(size_t nn=0; nn<n_bytes; nn++)
c00017b5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c00017bc:	eb 19                	jmp    c00017d7 <memcpy+0x98>
            dest_byte[nn]=src_byte[nn];
c00017be:	8b 55 e0             	mov    -0x20(%ebp),%edx
c00017c1:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00017c4:	01 d0                	add    %edx,%eax
c00017c6:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c00017c9:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00017cc:	01 ca                	add    %ecx,%edx
c00017ce:	0f b6 00             	movzbl (%eax),%eax
c00017d1:	88 02                	mov    %al,(%edx)
        for(size_t nn=0; nn<n_bytes; nn++)
c00017d3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c00017d7:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00017da:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c00017dd:	72 df                	jb     c00017be <memcpy+0x7f>
    }

    return dest;
c00017df:	8b 45 08             	mov    0x8(%ebp),%eax
}
c00017e2:	c9                   	leave  
c00017e3:	c3                   	ret    

c00017e4 <memset>:

void* memset(void* addr, int val, size_t cnt)
{
c00017e4:	55                   	push   %ebp
c00017e5:	89 e5                	mov    %esp,%ebp
c00017e7:	83 ec 10             	sub    $0x10,%esp
    char* m = (char*) addr;
c00017ea:	8b 45 08             	mov    0x8(%ebp),%eax
c00017ed:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for(size_t nn=0;nn<cnt; nn++)
c00017f0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00017f7:	eb 11                	jmp    c000180a <memset+0x26>
        m[nn] = val;
c00017f9:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00017fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00017ff:	01 d0                	add    %edx,%eax
c0001801:	8b 55 0c             	mov    0xc(%ebp),%edx
c0001804:	88 10                	mov    %dl,(%eax)
    for(size_t nn=0;nn<cnt; nn++)
c0001806:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c000180a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000180d:	3b 45 10             	cmp    0x10(%ebp),%eax
c0001810:	72 e7                	jb     c00017f9 <memset+0x15>

    return addr;
c0001812:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0001815:	c9                   	leave  
c0001816:	c3                   	ret    

c0001817 <atoi>:


int atoi(const char* str)
{
c0001817:	55                   	push   %ebp
c0001818:	89 e5                	mov    %esp,%ebp
c000181a:	83 ec 20             	sub    $0x20,%esp
    int p = 0;
c000181d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    int neg = 0;
c0001824:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    //find start of number string, ignore whitespace
    while(str[p] == '-' || str[p] == ' ' || (str[p] >= 9 && str[p] <= 13))
c000182b:	eb 41                	jmp    c000186e <atoi+0x57>
    {
        if(str[p++] == '-')
c000182d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001830:	8d 50 01             	lea    0x1(%eax),%edx
c0001833:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001836:	89 c2                	mov    %eax,%edx
c0001838:	8b 45 08             	mov    0x8(%ebp),%eax
c000183b:	01 d0                	add    %edx,%eax
c000183d:	0f b6 00             	movzbl (%eax),%eax
c0001840:	3c 2d                	cmp    $0x2d,%al
c0001842:	75 09                	jne    c000184d <atoi+0x36>
        {
            neg=1;
c0001844:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
            break;
c000184b:	eb 5d                	jmp    c00018aa <atoi+0x93>
        }
        if(str[p++] == '\0')
c000184d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001850:	8d 50 01             	lea    0x1(%eax),%edx
c0001853:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001856:	89 c2                	mov    %eax,%edx
c0001858:	8b 45 08             	mov    0x8(%ebp),%eax
c000185b:	01 d0                	add    %edx,%eax
c000185d:	0f b6 00             	movzbl (%eax),%eax
c0001860:	84 c0                	test   %al,%al
c0001862:	75 0a                	jne    c000186e <atoi+0x57>
            return 0; //invalid string (only whitespace found)
c0001864:	b8 00 00 00 00       	mov    $0x0,%eax
c0001869:	e9 ee 00 00 00       	jmp    c000195c <atoi+0x145>
    while(str[p] == '-' || str[p] == ' ' || (str[p] >= 9 && str[p] <= 13))
c000186e:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0001871:	8b 45 08             	mov    0x8(%ebp),%eax
c0001874:	01 d0                	add    %edx,%eax
c0001876:	0f b6 00             	movzbl (%eax),%eax
c0001879:	3c 2d                	cmp    $0x2d,%al
c000187b:	74 b0                	je     c000182d <atoi+0x16>
c000187d:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0001880:	8b 45 08             	mov    0x8(%ebp),%eax
c0001883:	01 d0                	add    %edx,%eax
c0001885:	0f b6 00             	movzbl (%eax),%eax
c0001888:	3c 20                	cmp    $0x20,%al
c000188a:	74 a1                	je     c000182d <atoi+0x16>
c000188c:	8b 55 fc             	mov    -0x4(%ebp),%edx
c000188f:	8b 45 08             	mov    0x8(%ebp),%eax
c0001892:	01 d0                	add    %edx,%eax
c0001894:	0f b6 00             	movzbl (%eax),%eax
c0001897:	3c 08                	cmp    $0x8,%al
c0001899:	7e 0f                	jle    c00018aa <atoi+0x93>
c000189b:	8b 55 fc             	mov    -0x4(%ebp),%edx
c000189e:	8b 45 08             	mov    0x8(%ebp),%eax
c00018a1:	01 d0                	add    %edx,%eax
c00018a3:	0f b6 00             	movzbl (%eax),%eax
c00018a6:	3c 0d                	cmp    $0xd,%al
c00018a8:	7e 83                	jle    c000182d <atoi+0x16>
    }

    int num_start = p;
c00018aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00018ad:	89 45 e8             	mov    %eax,-0x18(%ebp)

    //find end of integer string (ints only, no decimal point)
    while(str[p] >= '0' && str[p] <= '9')
c00018b0:	eb 21                	jmp    c00018d3 <atoi+0xbc>
    {
        if(str[p++] == '\0')
c00018b2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00018b5:	8d 50 01             	lea    0x1(%eax),%edx
c00018b8:	89 55 fc             	mov    %edx,-0x4(%ebp)
c00018bb:	89 c2                	mov    %eax,%edx
c00018bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00018c0:	01 d0                	add    %edx,%eax
c00018c2:	0f b6 00             	movzbl (%eax),%eax
c00018c5:	84 c0                	test   %al,%al
c00018c7:	75 0a                	jne    c00018d3 <atoi+0xbc>
            return 0; //invalid string (only whitespace found)
c00018c9:	b8 00 00 00 00       	mov    $0x0,%eax
c00018ce:	e9 89 00 00 00       	jmp    c000195c <atoi+0x145>
    while(str[p] >= '0' && str[p] <= '9')
c00018d3:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00018d6:	8b 45 08             	mov    0x8(%ebp),%eax
c00018d9:	01 d0                	add    %edx,%eax
c00018db:	0f b6 00             	movzbl (%eax),%eax
c00018de:	3c 2f                	cmp    $0x2f,%al
c00018e0:	7e 0f                	jle    c00018f1 <atoi+0xda>
c00018e2:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00018e5:	8b 45 08             	mov    0x8(%ebp),%eax
c00018e8:	01 d0                	add    %edx,%eax
c00018ea:	0f b6 00             	movzbl (%eax),%eax
c00018ed:	3c 39                	cmp    $0x39,%al
c00018ef:	7e c1                	jle    c00018b2 <atoi+0x9b>
    }

    if(num_start == p) return 0; //length 0 string
c00018f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00018f4:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c00018f7:	75 07                	jne    c0001900 <atoi+0xe9>
c00018f9:	b8 00 00 00 00       	mov    $0x0,%eax
c00018fe:	eb 5c                	jmp    c000195c <atoi+0x145>

    int number = 0;
c0001900:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    int place = 1;
c0001907:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    //iterate backwards through number to add each digit
    for(int digit = p-1; digit >= num_start; digit--)
c000190e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001911:	83 e8 01             	sub    $0x1,%eax
c0001914:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0001917:	eb 2b                	jmp    c0001944 <atoi+0x12d>
    {
        number += (int) (str[digit] - '0') * place;
c0001919:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000191c:	8b 45 08             	mov    0x8(%ebp),%eax
c000191f:	01 d0                	add    %edx,%eax
c0001921:	0f b6 00             	movzbl (%eax),%eax
c0001924:	0f be c0             	movsbl %al,%eax
c0001927:	83 e8 30             	sub    $0x30,%eax
c000192a:	0f af 45 f0          	imul   -0x10(%ebp),%eax
c000192e:	01 45 f4             	add    %eax,-0xc(%ebp)
        place *= 10;
c0001931:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001934:	89 d0                	mov    %edx,%eax
c0001936:	c1 e0 02             	shl    $0x2,%eax
c0001939:	01 d0                	add    %edx,%eax
c000193b:	01 c0                	add    %eax,%eax
c000193d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for(int digit = p-1; digit >= num_start; digit--)
c0001940:	83 6d ec 01          	subl   $0x1,-0x14(%ebp)
c0001944:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001947:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c000194a:	7d cd                	jge    c0001919 <atoi+0x102>
    }

    if(neg)
c000194c:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0001950:	74 07                	je     c0001959 <atoi+0x142>
        return -1*number;
c0001952:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001955:	f7 d8                	neg    %eax
c0001957:	eb 03                	jmp    c000195c <atoi+0x145>
    else
        return number;
c0001959:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c000195c:	c9                   	leave  
c000195d:	c3                   	ret    

c000195e <itoa>:

char* itoa( int value, char* str, int base)
{
c000195e:	55                   	push   %ebp
c000195f:	89 e5                	mov    %esp,%ebp
c0001961:	83 ec 20             	sub    $0x20,%esp
    if(base < 2 || base > 32)
c0001964:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c0001968:	7e 06                	jle    c0001970 <itoa+0x12>
c000196a:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
c000196e:	7e 0a                	jle    c000197a <itoa+0x1c>
        return NULL;
c0001970:	b8 00 00 00 00       	mov    $0x0,%eax
c0001975:	e9 df 00 00 00       	jmp    c0001a59 <itoa+0xfb>

    //handle zero as special case 
    if(value == 0)
c000197a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c000197e:	75 17                	jne    c0001997 <itoa+0x39>
    {
        str[0] = '0';
c0001980:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001983:	c6 00 30             	movb   $0x30,(%eax)
        str[1] = '\0';
c0001986:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001989:	83 c0 01             	add    $0x1,%eax
c000198c:	c6 00 00             	movb   $0x0,(%eax)
        return str;
c000198f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001992:	e9 c2 00 00 00       	jmp    c0001a59 <itoa+0xfb>
    }

    char* s = str;
c0001997:	8b 45 0c             	mov    0xc(%ebp),%eax
c000199a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    unsigned int residual; //holds the unsigned value still to be parsed
    if(base == 10 && value < 0)
c000199d:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
c00019a1:	75 1c                	jne    c00019bf <itoa+0x61>
c00019a3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00019a7:	79 16                	jns    c00019bf <itoa+0x61>
    {
        residual = -value;
c00019a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00019ac:	f7 d8                	neg    %eax
c00019ae:	89 45 f8             	mov    %eax,-0x8(%ebp)
        *(s++) = '-';
c00019b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00019b4:	8d 50 01             	lea    0x1(%eax),%edx
c00019b7:	89 55 fc             	mov    %edx,-0x4(%ebp)
c00019ba:	c6 00 2d             	movb   $0x2d,(%eax)
c00019bd:	eb 06                	jmp    c00019c5 <itoa+0x67>
    }
    else
    {
        //all non-decimal numbers are treated as unsigned
        residual = (unsigned int) value;
c00019bf:	8b 45 08             	mov    0x8(%ebp),%eax
c00019c2:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    
    // find number of digits so that we can parse number
    // directly into string from lowest to highest digit    
    unsigned int num_digits = 0;
c00019c5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    unsigned int temp = residual;
c00019cc:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00019cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(temp>0)
c00019d2:	eb 14                	jmp    c00019e8 <itoa+0x8a>
    {
        num_digits++;
c00019d4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
        temp /= base;
c00019d8:	8b 4d 10             	mov    0x10(%ebp),%ecx
c00019db:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00019de:	ba 00 00 00 00       	mov    $0x0,%edx
c00019e3:	f7 f1                	div    %ecx
c00019e5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(temp>0)
c00019e8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00019ec:	75 e6                	jne    c00019d4 <itoa+0x76>
    }

    //point at end of string
    s += num_digits;
c00019ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00019f1:	01 45 fc             	add    %eax,-0x4(%ebp)
    *(s--) = '\0'; //null termination
c00019f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00019f7:	8d 50 ff             	lea    -0x1(%eax),%edx
c00019fa:	89 55 fc             	mov    %edx,-0x4(%ebp)
c00019fd:	c6 00 00             	movb   $0x0,(%eax)

    //compute each digit from lowest to highest.
    unsigned int digit;
    while(residual>0)
c0001a00:	eb 4e                	jmp    c0001a50 <itoa+0xf2>
    {
        digit = residual % base;
c0001a02:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0001a05:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0001a08:	ba 00 00 00 00       	mov    $0x0,%edx
c0001a0d:	f7 f1                	div    %ecx
c0001a0f:	89 55 ec             	mov    %edx,-0x14(%ebp)
        residual /= base;
c0001a12:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0001a15:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0001a18:	ba 00 00 00 00       	mov    $0x0,%edx
c0001a1d:	f7 f1                	div    %ecx
c0001a1f:	89 45 f8             	mov    %eax,-0x8(%ebp)

        //write digit into string and decrement pointer
        if(digit < 10)
c0001a22:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
c0001a26:	77 15                	ja     c0001a3d <itoa+0xdf>
            *(s--) = digit + '0';
c0001a28:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001a2b:	8d 48 30             	lea    0x30(%eax),%ecx
c0001a2e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001a31:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001a34:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001a37:	89 ca                	mov    %ecx,%edx
c0001a39:	88 10                	mov    %dl,(%eax)
c0001a3b:	eb 13                	jmp    c0001a50 <itoa+0xf2>
        else
            *(s--) = digit - 10 + 'A';        
c0001a3d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001a40:	8d 48 37             	lea    0x37(%eax),%ecx
c0001a43:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001a46:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001a49:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001a4c:	89 ca                	mov    %ecx,%edx
c0001a4e:	88 10                	mov    %dl,(%eax)
    while(residual>0)
c0001a50:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0001a54:	75 ac                	jne    c0001a02 <itoa+0xa4>
    }

    return str;
c0001a56:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c0001a59:	c9                   	leave  
c0001a5a:	c3                   	ret    

c0001a5b <printregs>:
#include "regs.h"
#include "kprintf.h"

void printregs(const reg_t* regs)
{
c0001a5b:	55                   	push   %ebp
c0001a5c:	89 e5                	mov    %esp,%ebp
c0001a5e:	57                   	push   %edi
c0001a5f:	56                   	push   %esi
c0001a60:	53                   	push   %ebx
c0001a61:	83 ec 0c             	sub    $0xc,%esp
    kprintf("Registers:\n");
c0001a64:	83 ec 0c             	sub    $0xc,%esp
c0001a67:	68 28 54 00 c0       	push   $0xc0005428
c0001a6c:	e8 74 ee ff ff       	call   c00008e5 <kprintf>
c0001a71:	83 c4 10             	add    $0x10,%esp
    kprintf("eax: 0x%x\n", regs->eax);
c0001a74:	8b 45 08             	mov    0x8(%ebp),%eax
c0001a77:	8b 00                	mov    (%eax),%eax
c0001a79:	83 ec 08             	sub    $0x8,%esp
c0001a7c:	50                   	push   %eax
c0001a7d:	68 34 54 00 c0       	push   $0xc0005434
c0001a82:	e8 5e ee ff ff       	call   c00008e5 <kprintf>
c0001a87:	83 c4 10             	add    $0x10,%esp
    kprintf("ebx: 0x%x\n", regs->ebx);
c0001a8a:	8b 45 08             	mov    0x8(%ebp),%eax
c0001a8d:	8b 40 04             	mov    0x4(%eax),%eax
c0001a90:	83 ec 08             	sub    $0x8,%esp
c0001a93:	50                   	push   %eax
c0001a94:	68 3f 54 00 c0       	push   $0xc000543f
c0001a99:	e8 47 ee ff ff       	call   c00008e5 <kprintf>
c0001a9e:	83 c4 10             	add    $0x10,%esp
    kprintf("ecx: 0x%x\n", regs->ecx);
c0001aa1:	8b 45 08             	mov    0x8(%ebp),%eax
c0001aa4:	8b 40 08             	mov    0x8(%eax),%eax
c0001aa7:	83 ec 08             	sub    $0x8,%esp
c0001aaa:	50                   	push   %eax
c0001aab:	68 4a 54 00 c0       	push   $0xc000544a
c0001ab0:	e8 30 ee ff ff       	call   c00008e5 <kprintf>
c0001ab5:	83 c4 10             	add    $0x10,%esp
    kprintf("edx: 0x%x\n", regs->edx);
c0001ab8:	8b 45 08             	mov    0x8(%ebp),%eax
c0001abb:	8b 40 0c             	mov    0xc(%eax),%eax
c0001abe:	83 ec 08             	sub    $0x8,%esp
c0001ac1:	50                   	push   %eax
c0001ac2:	68 55 54 00 c0       	push   $0xc0005455
c0001ac7:	e8 19 ee ff ff       	call   c00008e5 <kprintf>
c0001acc:	83 c4 10             	add    $0x10,%esp
    kprintf("esi: 0x%x\n", regs->esi);
c0001acf:	8b 45 08             	mov    0x8(%ebp),%eax
c0001ad2:	8b 40 10             	mov    0x10(%eax),%eax
c0001ad5:	83 ec 08             	sub    $0x8,%esp
c0001ad8:	50                   	push   %eax
c0001ad9:	68 60 54 00 c0       	push   $0xc0005460
c0001ade:	e8 02 ee ff ff       	call   c00008e5 <kprintf>
c0001ae3:	83 c4 10             	add    $0x10,%esp
    kprintf("edi: 0x%x\n", regs->edi);
c0001ae6:	8b 45 08             	mov    0x8(%ebp),%eax
c0001ae9:	8b 40 14             	mov    0x14(%eax),%eax
c0001aec:	83 ec 08             	sub    $0x8,%esp
c0001aef:	50                   	push   %eax
c0001af0:	68 6b 54 00 c0       	push   $0xc000546b
c0001af5:	e8 eb ed ff ff       	call   c00008e5 <kprintf>
c0001afa:	83 c4 10             	add    $0x10,%esp
    kprintf("ebp: 0x%x\n", regs->ebp);
c0001afd:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b00:	8b 40 1c             	mov    0x1c(%eax),%eax
c0001b03:	83 ec 08             	sub    $0x8,%esp
c0001b06:	50                   	push   %eax
c0001b07:	68 76 54 00 c0       	push   $0xc0005476
c0001b0c:	e8 d4 ed ff ff       	call   c00008e5 <kprintf>
c0001b11:	83 c4 10             	add    $0x10,%esp
    kprintf("esp: 0x%x\n", regs->esp);
c0001b14:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b17:	8b 40 18             	mov    0x18(%eax),%eax
c0001b1a:	83 ec 08             	sub    $0x8,%esp
c0001b1d:	50                   	push   %eax
c0001b1e:	68 81 54 00 c0       	push   $0xc0005481
c0001b23:	e8 bd ed ff ff       	call   c00008e5 <kprintf>
c0001b28:	83 c4 10             	add    $0x10,%esp
    kprintf("eip: 0x%x\n", regs->eip);
c0001b2b:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b2e:	8b 40 20             	mov    0x20(%eax),%eax
c0001b31:	83 ec 08             	sub    $0x8,%esp
c0001b34:	50                   	push   %eax
c0001b35:	68 8c 54 00 c0       	push   $0xc000548c
c0001b3a:	e8 a6 ed ff ff       	call   c00008e5 <kprintf>
c0001b3f:	83 c4 10             	add    $0x10,%esp
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
                                                            (regs->eflags&EFLAGS_PF) == EFLAGS_PF,
                                                            (regs->eflags&EFLAGS_AF) == EFLAGS_AF,
                                                            (regs->eflags&EFLAGS_ZF) == EFLAGS_ZF,
                                                            (regs->eflags&EFLAGS_SF) == EFLAGS_SF,
                                                            (regs->eflags&EFLAGS_TF) == EFLAGS_TF);
c0001b42:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b45:	8b 40 24             	mov    0x24(%eax),%eax
c0001b48:	25 00 01 00 00       	and    $0x100,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c0001b4d:	85 c0                	test   %eax,%eax
c0001b4f:	0f 95 c0             	setne  %al
c0001b52:	0f b6 f8             	movzbl %al,%edi
                                                            (regs->eflags&EFLAGS_SF) == EFLAGS_SF,
c0001b55:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b58:	8b 40 24             	mov    0x24(%eax),%eax
c0001b5b:	25 80 00 00 00       	and    $0x80,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c0001b60:	85 c0                	test   %eax,%eax
c0001b62:	0f 95 c0             	setne  %al
c0001b65:	0f b6 f0             	movzbl %al,%esi
                                                            (regs->eflags&EFLAGS_ZF) == EFLAGS_ZF,
c0001b68:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b6b:	8b 40 24             	mov    0x24(%eax),%eax
c0001b6e:	83 e0 40             	and    $0x40,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c0001b71:	85 c0                	test   %eax,%eax
c0001b73:	0f 95 c0             	setne  %al
c0001b76:	0f b6 d8             	movzbl %al,%ebx
                                                            (regs->eflags&EFLAGS_AF) == EFLAGS_AF,
c0001b79:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b7c:	8b 40 24             	mov    0x24(%eax),%eax
c0001b7f:	83 e0 10             	and    $0x10,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c0001b82:	85 c0                	test   %eax,%eax
c0001b84:	0f 95 c0             	setne  %al
c0001b87:	0f b6 c8             	movzbl %al,%ecx
                                                            (regs->eflags&EFLAGS_PF) == EFLAGS_PF,
c0001b8a:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b8d:	8b 40 24             	mov    0x24(%eax),%eax
c0001b90:	83 e0 04             	and    $0x4,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c0001b93:	85 c0                	test   %eax,%eax
c0001b95:	0f 95 c0             	setne  %al
c0001b98:	0f b6 d0             	movzbl %al,%edx
c0001b9b:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b9e:	8b 40 24             	mov    0x24(%eax),%eax
c0001ba1:	83 e0 01             	and    $0x1,%eax
c0001ba4:	85 c0                	test   %eax,%eax
c0001ba6:	0f 95 c0             	setne  %al
c0001ba9:	0f b6 c0             	movzbl %al,%eax
c0001bac:	83 ec 04             	sub    $0x4,%esp
c0001baf:	57                   	push   %edi
c0001bb0:	56                   	push   %esi
c0001bb1:	53                   	push   %ebx
c0001bb2:	51                   	push   %ecx
c0001bb3:	52                   	push   %edx
c0001bb4:	50                   	push   %eax
c0001bb5:	68 98 54 00 c0       	push   $0xc0005498
c0001bba:	e8 26 ed ff ff       	call   c00008e5 <kprintf>
c0001bbf:	83 c4 20             	add    $0x20,%esp
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
                                                            (regs->eflags&EFLAGS_DF) == EFLAGS_DF,
                                                            (regs->eflags&EFLAGS_OF) == EFLAGS_OF,
                                                            (regs->eflags&EFLAGS_IOPL) >> 12,
                                                            (regs->eflags&EFLAGS_NT) == EFLAGS_NT,
                                                            (regs->eflags&EFLAGS_RF) == EFLAGS_RF);
c0001bc2:	8b 45 08             	mov    0x8(%ebp),%eax
c0001bc5:	8b 40 24             	mov    0x24(%eax),%eax
c0001bc8:	25 00 00 01 00       	and    $0x10000,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001bcd:	85 c0                	test   %eax,%eax
c0001bcf:	0f 95 c0             	setne  %al
c0001bd2:	0f b6 f0             	movzbl %al,%esi
                                                            (regs->eflags&EFLAGS_NT) == EFLAGS_NT,
c0001bd5:	8b 45 08             	mov    0x8(%ebp),%eax
c0001bd8:	8b 40 24             	mov    0x24(%eax),%eax
c0001bdb:	25 00 40 00 00       	and    $0x4000,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001be0:	85 c0                	test   %eax,%eax
c0001be2:	0f 95 c0             	setne  %al
c0001be5:	0f b6 d8             	movzbl %al,%ebx
                                                            (regs->eflags&EFLAGS_IOPL) >> 12,
c0001be8:	8b 45 08             	mov    0x8(%ebp),%eax
c0001beb:	8b 40 24             	mov    0x24(%eax),%eax
c0001bee:	c1 e8 0c             	shr    $0xc,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001bf1:	83 e0 03             	and    $0x3,%eax
c0001bf4:	89 c7                	mov    %eax,%edi
                                                            (regs->eflags&EFLAGS_OF) == EFLAGS_OF,
c0001bf6:	8b 45 08             	mov    0x8(%ebp),%eax
c0001bf9:	8b 40 24             	mov    0x24(%eax),%eax
c0001bfc:	25 00 08 00 00       	and    $0x800,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001c01:	85 c0                	test   %eax,%eax
c0001c03:	0f 95 c0             	setne  %al
c0001c06:	0f b6 c8             	movzbl %al,%ecx
                                                            (regs->eflags&EFLAGS_DF) == EFLAGS_DF,
c0001c09:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c0c:	8b 40 24             	mov    0x24(%eax),%eax
c0001c0f:	25 00 04 00 00       	and    $0x400,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001c14:	85 c0                	test   %eax,%eax
c0001c16:	0f 95 c0             	setne  %al
c0001c19:	0f b6 d0             	movzbl %al,%edx
c0001c1c:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c1f:	8b 40 24             	mov    0x24(%eax),%eax
c0001c22:	25 00 02 00 00       	and    $0x200,%eax
c0001c27:	85 c0                	test   %eax,%eax
c0001c29:	0f 95 c0             	setne  %al
c0001c2c:	0f b6 c0             	movzbl %al,%eax
c0001c2f:	83 ec 04             	sub    $0x4,%esp
c0001c32:	56                   	push   %esi
c0001c33:	53                   	push   %ebx
c0001c34:	57                   	push   %edi
c0001c35:	51                   	push   %ecx
c0001c36:	52                   	push   %edx
c0001c37:	50                   	push   %eax
c0001c38:	68 c8 54 00 c0       	push   $0xc00054c8
c0001c3d:	e8 a3 ec ff ff       	call   c00008e5 <kprintf>
c0001c42:	83 c4 20             	add    $0x20,%esp
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
                                                            (regs->eflags&EFLAGS_AC) == EFLAGS_AC,
                                                            (regs->eflags&EFLAGS_VIF) == EFLAGS_VIF,
                                                            (regs->eflags&EFLAGS_VIP) == EFLAGS_VIP,
                                                            (regs->eflags&EFLAGS_ID) == EFLAGS_ID);
c0001c45:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c48:	8b 40 24             	mov    0x24(%eax),%eax
c0001c4b:	25 00 00 20 00       	and    $0x200000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c0001c50:	85 c0                	test   %eax,%eax
c0001c52:	0f 95 c0             	setne  %al
c0001c55:	0f b6 f0             	movzbl %al,%esi
                                                            (regs->eflags&EFLAGS_VIP) == EFLAGS_VIP,
c0001c58:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c5b:	8b 40 24             	mov    0x24(%eax),%eax
c0001c5e:	25 00 00 10 00       	and    $0x100000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c0001c63:	85 c0                	test   %eax,%eax
c0001c65:	0f 95 c0             	setne  %al
c0001c68:	0f b6 d8             	movzbl %al,%ebx
                                                            (regs->eflags&EFLAGS_VIF) == EFLAGS_VIF,
c0001c6b:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c6e:	8b 40 24             	mov    0x24(%eax),%eax
c0001c71:	25 00 00 08 00       	and    $0x80000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c0001c76:	85 c0                	test   %eax,%eax
c0001c78:	0f 95 c0             	setne  %al
c0001c7b:	0f b6 c8             	movzbl %al,%ecx
                                                            (regs->eflags&EFLAGS_AC) == EFLAGS_AC,
c0001c7e:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c81:	8b 40 24             	mov    0x24(%eax),%eax
c0001c84:	25 00 00 04 00       	and    $0x40000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c0001c89:	85 c0                	test   %eax,%eax
c0001c8b:	0f 95 c0             	setne  %al
c0001c8e:	0f b6 d0             	movzbl %al,%edx
c0001c91:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c94:	8b 40 24             	mov    0x24(%eax),%eax
c0001c97:	25 00 00 02 00       	and    $0x20000,%eax
c0001c9c:	85 c0                	test   %eax,%eax
c0001c9e:	0f 95 c0             	setne  %al
c0001ca1:	0f b6 c0             	movzbl %al,%eax
c0001ca4:	83 ec 08             	sub    $0x8,%esp
c0001ca7:	56                   	push   %esi
c0001ca8:	53                   	push   %ebx
c0001ca9:	51                   	push   %ecx
c0001caa:	52                   	push   %edx
c0001cab:	50                   	push   %eax
c0001cac:	68 f8 54 00 c0       	push   $0xc00054f8
c0001cb1:	e8 2f ec ff ff       	call   c00008e5 <kprintf>
c0001cb6:	83 c4 20             	add    $0x20,%esp
    kprintf("cr0: 0x%x\n", regs->cr0);
c0001cb9:	8b 45 08             	mov    0x8(%ebp),%eax
c0001cbc:	8b 40 28             	mov    0x28(%eax),%eax
c0001cbf:	83 ec 08             	sub    $0x8,%esp
c0001cc2:	50                   	push   %eax
c0001cc3:	68 21 55 00 c0       	push   $0xc0005521
c0001cc8:	e8 18 ec ff ff       	call   c00008e5 <kprintf>
c0001ccd:	83 c4 10             	add    $0x10,%esp
    kprintf("cr2: 0x%x\n", regs->cr2);
c0001cd0:	8b 45 08             	mov    0x8(%ebp),%eax
c0001cd3:	8b 40 2c             	mov    0x2c(%eax),%eax
c0001cd6:	83 ec 08             	sub    $0x8,%esp
c0001cd9:	50                   	push   %eax
c0001cda:	68 2c 55 00 c0       	push   $0xc000552c
c0001cdf:	e8 01 ec ff ff       	call   c00008e5 <kprintf>
c0001ce4:	83 c4 10             	add    $0x10,%esp
    kprintf("cr3: 0x%x\n", regs->cr3);
c0001ce7:	8b 45 08             	mov    0x8(%ebp),%eax
c0001cea:	8b 40 30             	mov    0x30(%eax),%eax
c0001ced:	83 ec 08             	sub    $0x8,%esp
c0001cf0:	50                   	push   %eax
c0001cf1:	68 37 55 00 c0       	push   $0xc0005537
c0001cf6:	e8 ea eb ff ff       	call   c00008e5 <kprintf>
c0001cfb:	83 c4 10             	add    $0x10,%esp
    kprintf("cr4: 0x%x\n", regs->cr4);
c0001cfe:	8b 45 08             	mov    0x8(%ebp),%eax
c0001d01:	8b 40 34             	mov    0x34(%eax),%eax
c0001d04:	83 ec 08             	sub    $0x8,%esp
c0001d07:	50                   	push   %eax
c0001d08:	68 42 55 00 c0       	push   $0xc0005542
c0001d0d:	e8 d3 eb ff ff       	call   c00008e5 <kprintf>
c0001d12:	83 c4 10             	add    $0x10,%esp
}
c0001d15:	90                   	nop
c0001d16:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0001d19:	5b                   	pop    %ebx
c0001d1a:	5e                   	pop    %esi
c0001d1b:	5f                   	pop    %edi
c0001d1c:	5d                   	pop    %ebp
c0001d1d:	c3                   	ret    

c0001d1e <memory_table>:
#include "multiboot.h"
#include "kprintf.h"

size_t memory_table(multiboot_info_t* mbd)
{
c0001d1e:	55                   	push   %ebp
c0001d1f:	89 e5                	mov    %esp,%ebp
c0001d21:	56                   	push   %esi
c0001d22:	53                   	push   %ebx
c0001d23:	83 ec 10             	sub    $0x10,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c0001d26:	8b 45 08             	mov    0x8(%ebp),%eax
c0001d29:	8b 40 30             	mov    0x30(%eax),%eax
c0001d2c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    size_t available_mem = 0;
c0001d2f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001d36:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0001d3d:	e9 83 00 00 00       	jmp    c0001dc5 <memory_table+0xa7>
	{
		if(mmap_table[nn].len>0 && mmap_table[nn].size>0)
c0001d42:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001d45:	89 d0                	mov    %edx,%eax
c0001d47:	01 c0                	add    %eax,%eax
c0001d49:	01 d0                	add    %edx,%eax
c0001d4b:	c1 e0 03             	shl    $0x3,%eax
c0001d4e:	89 c2                	mov    %eax,%edx
c0001d50:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001d53:	01 d0                	add    %edx,%eax
c0001d55:	8b 50 10             	mov    0x10(%eax),%edx
c0001d58:	8b 40 0c             	mov    0xc(%eax),%eax
c0001d5b:	89 c6                	mov    %eax,%esi
c0001d5d:	83 f6 00             	xor    $0x0,%esi
c0001d60:	89 f1                	mov    %esi,%ecx
c0001d62:	89 d0                	mov    %edx,%eax
c0001d64:	80 f4 00             	xor    $0x0,%ah
c0001d67:	89 c3                	mov    %eax,%ebx
c0001d69:	89 d8                	mov    %ebx,%eax
c0001d6b:	09 c8                	or     %ecx,%eax
c0001d6d:	85 c0                	test   %eax,%eax
c0001d6f:	74 50                	je     c0001dc1 <memory_table+0xa3>
c0001d71:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001d74:	89 d0                	mov    %edx,%eax
c0001d76:	01 c0                	add    %eax,%eax
c0001d78:	01 d0                	add    %edx,%eax
c0001d7a:	c1 e0 03             	shl    $0x3,%eax
c0001d7d:	89 c2                	mov    %eax,%edx
c0001d7f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001d82:	01 d0                	add    %edx,%eax
c0001d84:	8b 00                	mov    (%eax),%eax
c0001d86:	85 c0                	test   %eax,%eax
c0001d88:	74 37                	je     c0001dc1 <memory_table+0xa3>
        {
            if(mmap_table[nn].type == 1)
c0001d8a:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001d8d:	89 d0                	mov    %edx,%eax
c0001d8f:	01 c0                	add    %eax,%eax
c0001d91:	01 d0                	add    %edx,%eax
c0001d93:	c1 e0 03             	shl    $0x3,%eax
c0001d96:	89 c2                	mov    %eax,%edx
c0001d98:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001d9b:	01 d0                	add    %edx,%eax
c0001d9d:	8b 40 14             	mov    0x14(%eax),%eax
c0001da0:	83 f8 01             	cmp    $0x1,%eax
c0001da3:	75 1c                	jne    c0001dc1 <memory_table+0xa3>
            available_mem += mmap_table[nn].len;
c0001da5:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001da8:	89 d0                	mov    %edx,%eax
c0001daa:	01 c0                	add    %eax,%eax
c0001dac:	01 d0                	add    %edx,%eax
c0001dae:	c1 e0 03             	shl    $0x3,%eax
c0001db1:	89 c2                	mov    %eax,%edx
c0001db3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001db6:	01 d0                	add    %edx,%eax
c0001db8:	8b 50 10             	mov    0x10(%eax),%edx
c0001dbb:	8b 40 0c             	mov    0xc(%eax),%eax
c0001dbe:	01 45 f4             	add    %eax,-0xc(%ebp)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001dc1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0001dc5:	8b 45 08             	mov    0x8(%ebp),%eax
c0001dc8:	8b 40 2c             	mov    0x2c(%eax),%eax
c0001dcb:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0001dce:	0f 82 6e ff ff ff    	jb     c0001d42 <memory_table+0x24>
        }
		
	}

    return available_mem;
c0001dd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0001dd7:	83 c4 10             	add    $0x10,%esp
c0001dda:	5b                   	pop    %ebx
c0001ddb:	5e                   	pop    %esi
c0001ddc:	5d                   	pop    %ebp
c0001ddd:	c3                   	ret    

c0001dde <print_memory_table>:

int print_memory_table(multiboot_info_t* mbd)
{
c0001dde:	55                   	push   %ebp
c0001ddf:	89 e5                	mov    %esp,%ebp
c0001de1:	57                   	push   %edi
c0001de2:	56                   	push   %esi
c0001de3:	53                   	push   %ebx
c0001de4:	83 ec 2c             	sub    $0x2c,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c0001de7:	8b 45 08             	mov    0x8(%ebp),%eax
c0001dea:	8b 40 30             	mov    0x30(%eax),%eax
c0001ded:	89 45 e0             	mov    %eax,-0x20(%ebp)
	kprintf("Memory Table:\n");
c0001df0:	83 ec 0c             	sub    $0xc,%esp
c0001df3:	68 50 55 00 c0       	push   $0xc0005550
c0001df8:	e8 e8 ea ff ff       	call   c00008e5 <kprintf>
c0001dfd:	83 c4 10             	add    $0x10,%esp
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001e00:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c0001e07:	e9 a6 01 00 00       	jmp    c0001fb2 <print_memory_table+0x1d4>
	{
        if(mmap_table[nn].size == 0)
c0001e0c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001e0f:	89 d0                	mov    %edx,%eax
c0001e11:	01 c0                	add    %eax,%eax
c0001e13:	01 d0                	add    %edx,%eax
c0001e15:	c1 e0 03             	shl    $0x3,%eax
c0001e18:	89 c2                	mov    %eax,%edx
c0001e1a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001e1d:	01 d0                	add    %edx,%eax
c0001e1f:	8b 00                	mov    (%eax),%eax
c0001e21:	85 c0                	test   %eax,%eax
c0001e23:	0f 84 9a 01 00 00    	je     c0001fc3 <print_memory_table+0x1e5>
            break;

		if(mmap_table[nn].len>0)
c0001e29:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001e2c:	89 d0                	mov    %edx,%eax
c0001e2e:	01 c0                	add    %eax,%eax
c0001e30:	01 d0                	add    %edx,%eax
c0001e32:	c1 e0 03             	shl    $0x3,%eax
c0001e35:	89 c2                	mov    %eax,%edx
c0001e37:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001e3a:	01 d0                	add    %edx,%eax
c0001e3c:	8b 50 10             	mov    0x10(%eax),%edx
c0001e3f:	8b 40 0c             	mov    0xc(%eax),%eax
c0001e42:	89 c7                	mov    %eax,%edi
c0001e44:	83 f7 00             	xor    $0x0,%edi
c0001e47:	89 7d d0             	mov    %edi,-0x30(%ebp)
c0001e4a:	89 d0                	mov    %edx,%eax
c0001e4c:	80 f4 00             	xor    $0x0,%ah
c0001e4f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
c0001e52:	8b 5d d0             	mov    -0x30(%ebp),%ebx
c0001e55:	8b 75 d4             	mov    -0x2c(%ebp),%esi
c0001e58:	89 f0                	mov    %esi,%eax
c0001e5a:	09 d8                	or     %ebx,%eax
c0001e5c:	85 c0                	test   %eax,%eax
c0001e5e:	0f 84 4a 01 00 00    	je     c0001fae <print_memory_table+0x1d0>
		{
			if(mmap_table[nn].type == MULTIBOOT_MEMORY_AVAILABLE)
c0001e64:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001e67:	89 d0                	mov    %edx,%eax
c0001e69:	01 c0                	add    %eax,%eax
c0001e6b:	01 d0                	add    %edx,%eax
c0001e6d:	c1 e0 03             	shl    $0x3,%eax
c0001e70:	89 c2                	mov    %eax,%edx
c0001e72:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001e75:	01 d0                	add    %edx,%eax
c0001e77:	8b 40 14             	mov    0x14(%eax),%eax
c0001e7a:	83 f8 01             	cmp    $0x1,%eax
c0001e7d:	0f 85 98 00 00 00    	jne    c0001f1b <print_memory_table+0x13d>
				kprintf("%.8llp - %.8llp [AVAILABLE] (%6llu kiB)\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c0001e83:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001e86:	89 d0                	mov    %edx,%eax
c0001e88:	01 c0                	add    %eax,%eax
c0001e8a:	01 d0                	add    %edx,%eax
c0001e8c:	c1 e0 03             	shl    $0x3,%eax
c0001e8f:	89 c2                	mov    %eax,%edx
c0001e91:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001e94:	01 d0                	add    %edx,%eax
c0001e96:	8b 50 10             	mov    0x10(%eax),%edx
c0001e99:	8b 40 0c             	mov    0xc(%eax),%eax
c0001e9c:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c0001ea0:	c1 ea 0a             	shr    $0xa,%edx
c0001ea3:	89 c6                	mov    %eax,%esi
c0001ea5:	89 d7                	mov    %edx,%edi
c0001ea7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001eaa:	89 d0                	mov    %edx,%eax
c0001eac:	01 c0                	add    %eax,%eax
c0001eae:	01 d0                	add    %edx,%eax
c0001eb0:	c1 e0 03             	shl    $0x3,%eax
c0001eb3:	89 c2                	mov    %eax,%edx
c0001eb5:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001eb8:	01 d0                	add    %edx,%eax
c0001eba:	8b 48 04             	mov    0x4(%eax),%ecx
c0001ebd:	8b 58 08             	mov    0x8(%eax),%ebx
c0001ec0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001ec3:	89 d0                	mov    %edx,%eax
c0001ec5:	01 c0                	add    %eax,%eax
c0001ec7:	01 d0                	add    %edx,%eax
c0001ec9:	c1 e0 03             	shl    $0x3,%eax
c0001ecc:	89 c2                	mov    %eax,%edx
c0001ece:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001ed1:	01 d0                	add    %edx,%eax
c0001ed3:	8b 50 10             	mov    0x10(%eax),%edx
c0001ed6:	8b 40 0c             	mov    0xc(%eax),%eax
c0001ed9:	01 c8                	add    %ecx,%eax
c0001edb:	11 da                	adc    %ebx,%edx
c0001edd:	83 c0 ff             	add    $0xffffffff,%eax
c0001ee0:	83 d2 ff             	adc    $0xffffffff,%edx
c0001ee3:	89 c1                	mov    %eax,%ecx
c0001ee5:	89 d3                	mov    %edx,%ebx
c0001ee7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001eea:	89 d0                	mov    %edx,%eax
c0001eec:	01 c0                	add    %eax,%eax
c0001eee:	01 d0                	add    %edx,%eax
c0001ef0:	c1 e0 03             	shl    $0x3,%eax
c0001ef3:	89 c2                	mov    %eax,%edx
c0001ef5:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001ef8:	01 d0                	add    %edx,%eax
c0001efa:	8b 50 08             	mov    0x8(%eax),%edx
c0001efd:	8b 40 04             	mov    0x4(%eax),%eax
c0001f00:	83 ec 04             	sub    $0x4,%esp
c0001f03:	57                   	push   %edi
c0001f04:	56                   	push   %esi
c0001f05:	53                   	push   %ebx
c0001f06:	51                   	push   %ecx
c0001f07:	52                   	push   %edx
c0001f08:	50                   	push   %eax
c0001f09:	68 60 55 00 c0       	push   $0xc0005560
c0001f0e:	e8 d2 e9 ff ff       	call   c00008e5 <kprintf>
c0001f13:	83 c4 20             	add    $0x20,%esp
c0001f16:	e9 93 00 00 00       	jmp    c0001fae <print_memory_table+0x1d0>
			else
				kprintf("%.8llp - %.8llp [RESERVED]\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c0001f1b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001f1e:	89 d0                	mov    %edx,%eax
c0001f20:	01 c0                	add    %eax,%eax
c0001f22:	01 d0                	add    %edx,%eax
c0001f24:	c1 e0 03             	shl    $0x3,%eax
c0001f27:	89 c2                	mov    %eax,%edx
c0001f29:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001f2c:	01 d0                	add    %edx,%eax
c0001f2e:	8b 50 10             	mov    0x10(%eax),%edx
c0001f31:	8b 40 0c             	mov    0xc(%eax),%eax
c0001f34:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c0001f38:	c1 ea 0a             	shr    $0xa,%edx
c0001f3b:	89 c6                	mov    %eax,%esi
c0001f3d:	89 d7                	mov    %edx,%edi
c0001f3f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001f42:	89 d0                	mov    %edx,%eax
c0001f44:	01 c0                	add    %eax,%eax
c0001f46:	01 d0                	add    %edx,%eax
c0001f48:	c1 e0 03             	shl    $0x3,%eax
c0001f4b:	89 c2                	mov    %eax,%edx
c0001f4d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001f50:	01 d0                	add    %edx,%eax
c0001f52:	8b 48 04             	mov    0x4(%eax),%ecx
c0001f55:	8b 58 08             	mov    0x8(%eax),%ebx
c0001f58:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001f5b:	89 d0                	mov    %edx,%eax
c0001f5d:	01 c0                	add    %eax,%eax
c0001f5f:	01 d0                	add    %edx,%eax
c0001f61:	c1 e0 03             	shl    $0x3,%eax
c0001f64:	89 c2                	mov    %eax,%edx
c0001f66:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001f69:	01 d0                	add    %edx,%eax
c0001f6b:	8b 50 10             	mov    0x10(%eax),%edx
c0001f6e:	8b 40 0c             	mov    0xc(%eax),%eax
c0001f71:	01 c8                	add    %ecx,%eax
c0001f73:	11 da                	adc    %ebx,%edx
c0001f75:	83 c0 ff             	add    $0xffffffff,%eax
c0001f78:	83 d2 ff             	adc    $0xffffffff,%edx
c0001f7b:	89 c1                	mov    %eax,%ecx
c0001f7d:	89 d3                	mov    %edx,%ebx
c0001f7f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001f82:	89 d0                	mov    %edx,%eax
c0001f84:	01 c0                	add    %eax,%eax
c0001f86:	01 d0                	add    %edx,%eax
c0001f88:	c1 e0 03             	shl    $0x3,%eax
c0001f8b:	89 c2                	mov    %eax,%edx
c0001f8d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001f90:	01 d0                	add    %edx,%eax
c0001f92:	8b 50 08             	mov    0x8(%eax),%edx
c0001f95:	8b 40 04             	mov    0x4(%eax),%eax
c0001f98:	83 ec 04             	sub    $0x4,%esp
c0001f9b:	57                   	push   %edi
c0001f9c:	56                   	push   %esi
c0001f9d:	53                   	push   %ebx
c0001f9e:	51                   	push   %ecx
c0001f9f:	52                   	push   %edx
c0001fa0:	50                   	push   %eax
c0001fa1:	68 89 55 00 c0       	push   $0xc0005589
c0001fa6:	e8 3a e9 ff ff       	call   c00008e5 <kprintf>
c0001fab:	83 c4 20             	add    $0x20,%esp
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001fae:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c0001fb2:	8b 45 08             	mov    0x8(%ebp),%eax
c0001fb5:	8b 40 2c             	mov    0x2c(%eax),%eax
c0001fb8:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c0001fbb:	0f 82 4b fe ff ff    	jb     c0001e0c <print_memory_table+0x2e>
c0001fc1:	eb 01                	jmp    c0001fc4 <print_memory_table+0x1e6>
            break;
c0001fc3:	90                   	nop
    //         kprintf("[%3u] %p (%#x)\n", nn, addr, flags);		
	// }

    // print_crs();

    return 0;
c0001fc4:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0001fc9:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0001fcc:	5b                   	pop    %ebx
c0001fcd:	5e                   	pop    %esi
c0001fce:	5f                   	pop    %edi
c0001fcf:	5d                   	pop    %ebp
c0001fd0:	c3                   	ret    

c0001fd1 <inb>:
{
c0001fd1:	55                   	push   %ebp
c0001fd2:	89 e5                	mov    %esp,%ebp
c0001fd4:	83 ec 14             	sub    $0x14,%esp
c0001fd7:	8b 45 08             	mov    0x8(%ebp),%eax
c0001fda:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  __asm__ __volatile__ ("inb %w1,%0":"=a" (_v):"Nd" (__port));
c0001fde:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0001fe2:	89 c2                	mov    %eax,%edx
c0001fe4:	ec                   	in     (%dx),%al
c0001fe5:	88 45 ff             	mov    %al,-0x1(%ebp)
  return _v;
c0001fe8:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0001fec:	c9                   	leave  
c0001fed:	c3                   	ret    

c0001fee <outb>:
{
c0001fee:	55                   	push   %ebp
c0001fef:	89 e5                	mov    %esp,%ebp
c0001ff1:	83 ec 08             	sub    $0x8,%esp
c0001ff4:	8b 55 08             	mov    0x8(%ebp),%edx
c0001ff7:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001ffa:	88 55 fc             	mov    %dl,-0x4(%ebp)
c0001ffd:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
c0002001:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0002005:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
c0002009:	ee                   	out    %al,(%dx)
}
c000200a:	90                   	nop
c000200b:	c9                   	leave  
c000200c:	c3                   	ret    

c000200d <init_interrupts>:

idt_entry_t __aligned idt[NUM_INTERRUPT_HANDLERS] = {0};
idt_descriptor_t __aligned idtd;

int init_interrupts()
{
c000200d:	55                   	push   %ebp
c000200e:	89 e5                	mov    %esp,%ebp
c0002010:	83 ec 08             	sub    $0x8,%esp
    /* init the PIC */
	outb(PIC_INIT, PIC1_CMD);  // init PIC 1
c0002013:	6a 20                	push   $0x20
c0002015:	6a 11                	push   $0x11
c0002017:	e8 d2 ff ff ff       	call   c0001fee <outb>
c000201c:	83 c4 08             	add    $0x8,%esp
    outb(PIC_INIT, PIC2_CMD);  // init PIC 2
c000201f:	68 a0 00 00 00       	push   $0xa0
c0002024:	6a 11                	push   $0x11
c0002026:	e8 c3 ff ff ff       	call   c0001fee <outb>
c000202b:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_OFFSET, PIC1_DATA); // map irq 0x0-0x7 to int 0x20-0x27
c000202e:	6a 21                	push   $0x21
c0002030:	6a 20                	push   $0x20
c0002032:	e8 b7 ff ff ff       	call   c0001fee <outb>
c0002037:	83 c4 08             	add    $0x8,%esp
    outb(PIC2_OFFSET, PIC2_DATA); // map irq 0x8-0xf to int 0x28-0x2f
c000203a:	68 a1 00 00 00       	push   $0xa1
c000203f:	6a 28                	push   $0x28
c0002041:	e8 a8 ff ff ff       	call   c0001fee <outb>
c0002046:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_MS, PIC1_DATA);     // pic1 is master, with slave at irq 2
c0002049:	6a 21                	push   $0x21
c000204b:	6a 04                	push   $0x4
c000204d:	e8 9c ff ff ff       	call   c0001fee <outb>
c0002052:	83 c4 08             	add    $0x8,%esp
    outb(PIC2_MS, PIC2_DATA);     // pic2 is slave with id 2
c0002055:	68 a1 00 00 00       	push   $0xa1
c000205a:	6a 02                	push   $0x2
c000205c:	e8 8d ff ff ff       	call   c0001fee <outb>
c0002061:	83 c4 08             	add    $0x8,%esp
    outb(PIC_8086MODE, PIC1_DATA); //enable 8086 mode
c0002064:	6a 21                	push   $0x21
c0002066:	6a 01                	push   $0x1
c0002068:	e8 81 ff ff ff       	call   c0001fee <outb>
c000206d:	83 c4 08             	add    $0x8,%esp
    outb(PIC_8086MODE, PIC2_DATA); //enable 8086 mode
c0002070:	68 a1 00 00 00       	push   $0xa1
c0002075:	6a 01                	push   $0x1
c0002077:	e8 72 ff ff ff       	call   c0001fee <outb>
c000207c:	83 c4 08             	add    $0x8,%esp
    // interrupt mask
    outb( ~(1<<1) , PIC1_DATA); //enable irq1 (keyboard)
c000207f:	6a 21                	push   $0x21
c0002081:	68 fd 00 00 00       	push   $0xfd
c0002086:	e8 63 ff ff ff       	call   c0001fee <outb>
c000208b:	83 c4 08             	add    $0x8,%esp
    outb(0xff, PIC2_DATA); //disable interrupts from slave
c000208e:	68 a1 00 00 00       	push   $0xa1
c0002093:	68 ff 00 00 00       	push   $0xff
c0002098:	e8 51 ff ff ff       	call   c0001fee <outb>
c000209d:	83 c4 08             	add    $0x8,%esp


    // individual handler routines defined in interrupt.S
    // these call back to exception_handler() and irq_handler()
    set_interrupt_handler(0,except_0);
c00020a0:	83 ec 08             	sub    $0x8,%esp
c00020a3:	68 d8 3b 00 c0       	push   $0xc0003bd8
c00020a8:	6a 00                	push   $0x0
c00020aa:	e8 98 02 00 00       	call   c0002347 <set_interrupt_handler>
c00020af:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(1,except_1);
c00020b2:	83 ec 08             	sub    $0x8,%esp
c00020b5:	68 f8 3b 00 c0       	push   $0xc0003bf8
c00020ba:	6a 01                	push   $0x1
c00020bc:	e8 86 02 00 00       	call   c0002347 <set_interrupt_handler>
c00020c1:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(2,except_2);
c00020c4:	83 ec 08             	sub    $0x8,%esp
c00020c7:	68 18 3c 00 c0       	push   $0xc0003c18
c00020cc:	6a 02                	push   $0x2
c00020ce:	e8 74 02 00 00       	call   c0002347 <set_interrupt_handler>
c00020d3:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(3,except_3);
c00020d6:	83 ec 08             	sub    $0x8,%esp
c00020d9:	68 38 3c 00 c0       	push   $0xc0003c38
c00020de:	6a 03                	push   $0x3
c00020e0:	e8 62 02 00 00       	call   c0002347 <set_interrupt_handler>
c00020e5:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(4,except_4);
c00020e8:	83 ec 08             	sub    $0x8,%esp
c00020eb:	68 58 3c 00 c0       	push   $0xc0003c58
c00020f0:	6a 04                	push   $0x4
c00020f2:	e8 50 02 00 00       	call   c0002347 <set_interrupt_handler>
c00020f7:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(5,except_5);
c00020fa:	83 ec 08             	sub    $0x8,%esp
c00020fd:	68 78 3c 00 c0       	push   $0xc0003c78
c0002102:	6a 05                	push   $0x5
c0002104:	e8 3e 02 00 00       	call   c0002347 <set_interrupt_handler>
c0002109:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(6,except_6);
c000210c:	83 ec 08             	sub    $0x8,%esp
c000210f:	68 98 3c 00 c0       	push   $0xc0003c98
c0002114:	6a 06                	push   $0x6
c0002116:	e8 2c 02 00 00       	call   c0002347 <set_interrupt_handler>
c000211b:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(7,except_7);
c000211e:	83 ec 08             	sub    $0x8,%esp
c0002121:	68 b8 3c 00 c0       	push   $0xc0003cb8
c0002126:	6a 07                	push   $0x7
c0002128:	e8 1a 02 00 00       	call   c0002347 <set_interrupt_handler>
c000212d:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(8,except_8);
c0002130:	83 ec 08             	sub    $0x8,%esp
c0002133:	68 d8 3c 00 c0       	push   $0xc0003cd8
c0002138:	6a 08                	push   $0x8
c000213a:	e8 08 02 00 00       	call   c0002347 <set_interrupt_handler>
c000213f:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(10,except_10);
c0002142:	83 ec 08             	sub    $0x8,%esp
c0002145:	68 f8 3c 00 c0       	push   $0xc0003cf8
c000214a:	6a 0a                	push   $0xa
c000214c:	e8 f6 01 00 00       	call   c0002347 <set_interrupt_handler>
c0002151:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(11,except_11);
c0002154:	83 ec 08             	sub    $0x8,%esp
c0002157:	68 18 3d 00 c0       	push   $0xc0003d18
c000215c:	6a 0b                	push   $0xb
c000215e:	e8 e4 01 00 00       	call   c0002347 <set_interrupt_handler>
c0002163:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(12,except_12);
c0002166:	83 ec 08             	sub    $0x8,%esp
c0002169:	68 38 3d 00 c0       	push   $0xc0003d38
c000216e:	6a 0c                	push   $0xc
c0002170:	e8 d2 01 00 00       	call   c0002347 <set_interrupt_handler>
c0002175:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(13,except_13);
c0002178:	83 ec 08             	sub    $0x8,%esp
c000217b:	68 58 3d 00 c0       	push   $0xc0003d58
c0002180:	6a 0d                	push   $0xd
c0002182:	e8 c0 01 00 00       	call   c0002347 <set_interrupt_handler>
c0002187:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(14,except_14);
c000218a:	83 ec 08             	sub    $0x8,%esp
c000218d:	68 78 3d 00 c0       	push   $0xc0003d78
c0002192:	6a 0e                	push   $0xe
c0002194:	e8 ae 01 00 00       	call   c0002347 <set_interrupt_handler>
c0002199:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(16,except_16);
c000219c:	83 ec 08             	sub    $0x8,%esp
c000219f:	68 98 3d 00 c0       	push   $0xc0003d98
c00021a4:	6a 10                	push   $0x10
c00021a6:	e8 9c 01 00 00       	call   c0002347 <set_interrupt_handler>
c00021ab:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(17,except_17);
c00021ae:	83 ec 08             	sub    $0x8,%esp
c00021b1:	68 b8 3d 00 c0       	push   $0xc0003db8
c00021b6:	6a 11                	push   $0x11
c00021b8:	e8 8a 01 00 00       	call   c0002347 <set_interrupt_handler>
c00021bd:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(18,except_18);
c00021c0:	83 ec 08             	sub    $0x8,%esp
c00021c3:	68 d8 3d 00 c0       	push   $0xc0003dd8
c00021c8:	6a 12                	push   $0x12
c00021ca:	e8 78 01 00 00       	call   c0002347 <set_interrupt_handler>
c00021cf:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(19,except_19);
c00021d2:	83 ec 08             	sub    $0x8,%esp
c00021d5:	68 f8 3d 00 c0       	push   $0xc0003df8
c00021da:	6a 13                	push   $0x13
c00021dc:	e8 66 01 00 00       	call   c0002347 <set_interrupt_handler>
c00021e1:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(20,except_20);
c00021e4:	83 ec 08             	sub    $0x8,%esp
c00021e7:	68 18 3e 00 c0       	push   $0xc0003e18
c00021ec:	6a 14                	push   $0x14
c00021ee:	e8 54 01 00 00       	call   c0002347 <set_interrupt_handler>
c00021f3:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(30,except_30);
c00021f6:	83 ec 08             	sub    $0x8,%esp
c00021f9:	68 38 3e 00 c0       	push   $0xc0003e38
c00021fe:	6a 1e                	push   $0x1e
c0002200:	e8 42 01 00 00       	call   c0002347 <set_interrupt_handler>
c0002205:	83 c4 10             	add    $0x10,%esp

    set_interrupt_handler(32,irq_0);
c0002208:	83 ec 08             	sub    $0x8,%esp
c000220b:	68 58 3e 00 c0       	push   $0xc0003e58
c0002210:	6a 20                	push   $0x20
c0002212:	e8 30 01 00 00       	call   c0002347 <set_interrupt_handler>
c0002217:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(33,irq_1);
c000221a:	83 ec 08             	sub    $0x8,%esp
c000221d:	68 6c 3e 00 c0       	push   $0xc0003e6c
c0002222:	6a 21                	push   $0x21
c0002224:	e8 1e 01 00 00       	call   c0002347 <set_interrupt_handler>
c0002229:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(34,irq_2);
c000222c:	83 ec 08             	sub    $0x8,%esp
c000222f:	68 80 3e 00 c0       	push   $0xc0003e80
c0002234:	6a 22                	push   $0x22
c0002236:	e8 0c 01 00 00       	call   c0002347 <set_interrupt_handler>
c000223b:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(35,irq_3);
c000223e:	83 ec 08             	sub    $0x8,%esp
c0002241:	68 94 3e 00 c0       	push   $0xc0003e94
c0002246:	6a 23                	push   $0x23
c0002248:	e8 fa 00 00 00       	call   c0002347 <set_interrupt_handler>
c000224d:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(36,irq_4);
c0002250:	83 ec 08             	sub    $0x8,%esp
c0002253:	68 a8 3e 00 c0       	push   $0xc0003ea8
c0002258:	6a 24                	push   $0x24
c000225a:	e8 e8 00 00 00       	call   c0002347 <set_interrupt_handler>
c000225f:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(37,irq_5);
c0002262:	83 ec 08             	sub    $0x8,%esp
c0002265:	68 bc 3e 00 c0       	push   $0xc0003ebc
c000226a:	6a 25                	push   $0x25
c000226c:	e8 d6 00 00 00       	call   c0002347 <set_interrupt_handler>
c0002271:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(38,irq_6);
c0002274:	83 ec 08             	sub    $0x8,%esp
c0002277:	68 d0 3e 00 c0       	push   $0xc0003ed0
c000227c:	6a 26                	push   $0x26
c000227e:	e8 c4 00 00 00       	call   c0002347 <set_interrupt_handler>
c0002283:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(39,irq_7);
c0002286:	83 ec 08             	sub    $0x8,%esp
c0002289:	68 e4 3e 00 c0       	push   $0xc0003ee4
c000228e:	6a 27                	push   $0x27
c0002290:	e8 b2 00 00 00       	call   c0002347 <set_interrupt_handler>
c0002295:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(40,irq_8);
c0002298:	83 ec 08             	sub    $0x8,%esp
c000229b:	68 f8 3e 00 c0       	push   $0xc0003ef8
c00022a0:	6a 28                	push   $0x28
c00022a2:	e8 a0 00 00 00       	call   c0002347 <set_interrupt_handler>
c00022a7:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(41,irq_9);
c00022aa:	83 ec 08             	sub    $0x8,%esp
c00022ad:	68 0c 3f 00 c0       	push   $0xc0003f0c
c00022b2:	6a 29                	push   $0x29
c00022b4:	e8 8e 00 00 00       	call   c0002347 <set_interrupt_handler>
c00022b9:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(42,irq_10);
c00022bc:	83 ec 08             	sub    $0x8,%esp
c00022bf:	68 20 3f 00 c0       	push   $0xc0003f20
c00022c4:	6a 2a                	push   $0x2a
c00022c6:	e8 7c 00 00 00       	call   c0002347 <set_interrupt_handler>
c00022cb:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(43,irq_11);
c00022ce:	83 ec 08             	sub    $0x8,%esp
c00022d1:	68 34 3f 00 c0       	push   $0xc0003f34
c00022d6:	6a 2b                	push   $0x2b
c00022d8:	e8 6a 00 00 00       	call   c0002347 <set_interrupt_handler>
c00022dd:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(44,irq_12);
c00022e0:	83 ec 08             	sub    $0x8,%esp
c00022e3:	68 48 3f 00 c0       	push   $0xc0003f48
c00022e8:	6a 2c                	push   $0x2c
c00022ea:	e8 58 00 00 00       	call   c0002347 <set_interrupt_handler>
c00022ef:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(45,irq_13);
c00022f2:	83 ec 08             	sub    $0x8,%esp
c00022f5:	68 5c 3f 00 c0       	push   $0xc0003f5c
c00022fa:	6a 2d                	push   $0x2d
c00022fc:	e8 46 00 00 00       	call   c0002347 <set_interrupt_handler>
c0002301:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(46,irq_14);
c0002304:	83 ec 08             	sub    $0x8,%esp
c0002307:	68 70 3f 00 c0       	push   $0xc0003f70
c000230c:	6a 2e                	push   $0x2e
c000230e:	e8 34 00 00 00       	call   c0002347 <set_interrupt_handler>
c0002313:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(47,irq_15);
c0002316:	83 ec 08             	sub    $0x8,%esp
c0002319:	68 84 3f 00 c0       	push   $0xc0003f84
c000231e:	6a 2f                	push   $0x2f
c0002320:	e8 22 00 00 00       	call   c0002347 <set_interrupt_handler>
c0002325:	83 c4 10             	add    $0x10,%esp



    idtd.base = (uint32_t) idt;
c0002328:	b8 20 70 00 c0       	mov    $0xc0007020,%eax
c000232d:	a3 22 78 00 c0       	mov    %eax,0xc0007822
    idtd.limit = sizeof(idt_entry_t) * NUM_INTERRUPT_HANDLERS - 1;
c0002332:	66 c7 05 20 78 00 c0 	movw   $0x7ff,0xc0007820
c0002339:	ff 07 
    load_idt();
c000233b:	e8 88 18 00 00       	call   c0003bc8 <load_idt>

    return 0;
c0002340:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002345:	c9                   	leave  
c0002346:	c3                   	ret    

c0002347 <set_interrupt_handler>:

void set_interrupt_handler(int int_num, void* handler)
{
c0002347:	55                   	push   %ebp
c0002348:	89 e5                	mov    %esp,%ebp
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c000234a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000234d:	89 c2                	mov    %eax,%edx
c000234f:	8b 45 08             	mov    0x8(%ebp),%eax
c0002352:	66 89 14 c5 20 70 00 	mov    %dx,-0x3fff8fe0(,%eax,8)
c0002359:	c0 
	idt[int_num].segment = KERNEL_CODE_SEGMENT;
c000235a:	8b 45 08             	mov    0x8(%ebp),%eax
c000235d:	66 c7 04 c5 22 70 00 	movw   $0x8,-0x3fff8fde(,%eax,8)
c0002364:	c0 08 00 
	idt[int_num].zero = 0;
c0002367:	8b 45 08             	mov    0x8(%ebp),%eax
c000236a:	c6 04 c5 24 70 00 c0 	movb   $0x0,-0x3fff8fdc(,%eax,8)
c0002371:	00 
	idt[int_num].type = 0x8e; /* INTERRUPT_GATE */
c0002372:	8b 45 08             	mov    0x8(%ebp),%eax
c0002375:	c6 04 c5 25 70 00 c0 	movb   $0x8e,-0x3fff8fdb(,%eax,8)
c000237c:	8e 
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c000237d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002380:	c1 e8 10             	shr    $0x10,%eax
c0002383:	89 c2                	mov    %eax,%edx
c0002385:	8b 45 08             	mov    0x8(%ebp),%eax
c0002388:	66 89 14 c5 26 70 00 	mov    %dx,-0x3fff8fda(,%eax,8)
c000238f:	c0 
}
c0002390:	90                   	nop
c0002391:	5d                   	pop    %ebp
c0002392:	c3                   	ret    

c0002393 <page_fault_handler>:

void page_fault_handler(uint32_t code, void* fault_ip)
{
c0002393:	55                   	push   %ebp
c0002394:	89 e5                	mov    %esp,%ebp
c0002396:	83 ec 08             	sub    $0x8,%esp

    if(code & PF_CODE_WRITE)
c0002399:	8b 45 08             	mov    0x8(%ebp),%eax
c000239c:	83 e0 02             	and    $0x2,%eax
c000239f:	85 c0                	test   %eax,%eax
c00023a1:	74 1b                	je     c00023be <page_fault_handler+0x2b>
        kprintf("\n\nPage Fault writing to 0x%x (instruction 0x%x)\n", pf_addr(), fault_ip);
c00023a3:	e8 2c 18 00 00       	call   c0003bd4 <pf_addr>
c00023a8:	83 ec 04             	sub    $0x4,%esp
c00023ab:	ff 75 0c             	pushl  0xc(%ebp)
c00023ae:	50                   	push   %eax
c00023af:	68 a8 55 00 c0       	push   $0xc00055a8
c00023b4:	e8 2c e5 ff ff       	call   c00008e5 <kprintf>
c00023b9:	83 c4 10             	add    $0x10,%esp
c00023bc:	eb 19                	jmp    c00023d7 <page_fault_handler+0x44>
    else        
        kprintf("\n\nPage Fault reading from 0x%x (instruction 0x%x)\n", pf_addr(), fault_ip);
c00023be:	e8 11 18 00 00       	call   c0003bd4 <pf_addr>
c00023c3:	83 ec 04             	sub    $0x4,%esp
c00023c6:	ff 75 0c             	pushl  0xc(%ebp)
c00023c9:	50                   	push   %eax
c00023ca:	68 dc 55 00 c0       	push   $0xc00055dc
c00023cf:	e8 11 e5 ff ff       	call   c00008e5 <kprintf>
c00023d4:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_PGPROT)
c00023d7:	8b 45 08             	mov    0x8(%ebp),%eax
c00023da:	83 e0 01             	and    $0x1,%eax
c00023dd:	85 c0                	test   %eax,%eax
c00023df:	74 12                	je     c00023f3 <page_fault_handler+0x60>
        kprintf("Page protection violation\n");
c00023e1:	83 ec 0c             	sub    $0xc,%esp
c00023e4:	68 0f 56 00 c0       	push   $0xc000560f
c00023e9:	e8 f7 e4 ff ff       	call   c00008e5 <kprintf>
c00023ee:	83 c4 10             	add    $0x10,%esp
c00023f1:	eb 10                	jmp    c0002403 <page_fault_handler+0x70>
    else
        kprintf("Page not present\n");
c00023f3:	83 ec 0c             	sub    $0xc,%esp
c00023f6:	68 2a 56 00 c0       	push   $0xc000562a
c00023fb:	e8 e5 e4 ff ff       	call   c00008e5 <kprintf>
c0002400:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_USER)
c0002403:	8b 45 08             	mov    0x8(%ebp),%eax
c0002406:	83 e0 04             	and    $0x4,%eax
c0002409:	85 c0                	test   %eax,%eax
c000240b:	74 10                	je     c000241d <page_fault_handler+0x8a>
        kprintf("\n\nFault caused by user code\n");
c000240d:	83 ec 0c             	sub    $0xc,%esp
c0002410:	68 3c 56 00 c0       	push   $0xc000563c
c0002415:	e8 cb e4 ff ff       	call   c00008e5 <kprintf>
c000241a:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_RES)
c000241d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002420:	83 e0 08             	and    $0x8,%eax
c0002423:	85 c0                	test   %eax,%eax
c0002425:	74 10                	je     c0002437 <page_fault_handler+0xa4>
        kprintf("Page reserved bit set\n");
c0002427:	83 ec 0c             	sub    $0xc,%esp
c000242a:	68 59 56 00 c0       	push   $0xc0005659
c000242f:	e8 b1 e4 ff ff       	call   c00008e5 <kprintf>
c0002434:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_IF)
c0002437:	8b 45 08             	mov    0x8(%ebp),%eax
c000243a:	83 e0 10             	and    $0x10,%eax
c000243d:	85 c0                	test   %eax,%eax
c000243f:	74 10                	je     c0002451 <page_fault_handler+0xbe>
        kprintf("Fault caused by instruction fetch\n");
c0002441:	83 ec 0c             	sub    $0xc,%esp
c0002444:	68 70 56 00 c0       	push   $0xc0005670
c0002449:	e8 97 e4 ff ff       	call   c00008e5 <kprintf>
c000244e:	83 c4 10             	add    $0x10,%esp

    while(1);
c0002451:	eb fe                	jmp    c0002451 <page_fault_handler+0xbe>

c0002453 <exception_handler>:
}


void exception_handler(uint32_t exception_num, uint32_t code, void* fault_ip)
{
c0002453:	55                   	push   %ebp
c0002454:	89 e5                	mov    %esp,%ebp
c0002456:	83 ec 08             	sub    $0x8,%esp
    if(exception_num==14)
c0002459:	83 7d 08 0e          	cmpl   $0xe,0x8(%ebp)
c000245d:	75 13                	jne    c0002472 <exception_handler+0x1f>
        page_fault_handler(code, fault_ip);
c000245f:	83 ec 08             	sub    $0x8,%esp
c0002462:	ff 75 10             	pushl  0x10(%ebp)
c0002465:	ff 75 0c             	pushl  0xc(%ebp)
c0002468:	e8 26 ff ff ff       	call   c0002393 <page_fault_handler>
c000246d:	83 c4 10             	add    $0x10,%esp
c0002470:	eb 16                	jmp    c0002488 <exception_handler+0x35>
    else
        kprintf("\n\nException %u with code 0x%x at instruction 0x%x\n", exception_num, code, fault_ip);
c0002472:	ff 75 10             	pushl  0x10(%ebp)
c0002475:	ff 75 0c             	pushl  0xc(%ebp)
c0002478:	ff 75 08             	pushl  0x8(%ebp)
c000247b:	68 94 56 00 c0       	push   $0xc0005694
c0002480:	e8 60 e4 ff ff       	call   c00008e5 <kprintf>
c0002485:	83 c4 10             	add    $0x10,%esp
    while(1);
c0002488:	eb fe                	jmp    c0002488 <exception_handler+0x35>

c000248a <irq_handler>:
}

void irq_handler(uint32_t irq_num)
{
c000248a:	55                   	push   %ebp
c000248b:	89 e5                	mov    %esp,%ebp
c000248d:	83 ec 18             	sub    $0x18,%esp
    if(irq_num == 1)
c0002490:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0002494:	75 36                	jne    c00024cc <irq_handler+0x42>
    {
        unsigned char scan_code = inb(0x60);
c0002496:	6a 60                	push   $0x60
c0002498:	e8 34 fb ff ff       	call   c0001fd1 <inb>
c000249d:	83 c4 04             	add    $0x4,%esp
c00024a0:	88 45 f7             	mov    %al,-0x9(%ebp)
        char key_ascii = scancode_to_ascii(scan_code);
c00024a3:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c00024a7:	83 ec 0c             	sub    $0xc,%esp
c00024aa:	50                   	push   %eax
c00024ab:	e8 e9 12 00 00       	call   c0003799 <scancode_to_ascii>
c00024b0:	83 c4 10             	add    $0x10,%esp
c00024b3:	88 45 f6             	mov    %al,-0xa(%ebp)
        // kprintf("code: 0x%x, ascii:%c\n", scan_code, key_ascii);
        if(key_ascii>0)
c00024b6:	80 7d f6 00          	cmpb   $0x0,-0xa(%ebp)
c00024ba:	7e 10                	jle    c00024cc <irq_handler+0x42>
            kprint_char(key_ascii);
c00024bc:	0f be 45 f6          	movsbl -0xa(%ebp),%eax
c00024c0:	83 ec 0c             	sub    $0xc,%esp
c00024c3:	50                   	push   %eax
c00024c4:	e8 cb e3 ff ff       	call   c0000894 <kprint_char>
c00024c9:	83 c4 10             	add    $0x10,%esp
    
    }

    // notify PIC that interrupt handling is complete
    if(irq_num >= 8)
c00024cc:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
c00024d0:	76 12                	jbe    c00024e4 <irq_handler+0x5a>
        outb(PIC_EOI, PIC2_CMD);
c00024d2:	83 ec 08             	sub    $0x8,%esp
c00024d5:	68 a0 00 00 00       	push   $0xa0
c00024da:	6a 20                	push   $0x20
c00024dc:	e8 0d fb ff ff       	call   c0001fee <outb>
c00024e1:	83 c4 10             	add    $0x10,%esp

    outb(PIC_EOI, PIC1_CMD);
c00024e4:	83 ec 08             	sub    $0x8,%esp
c00024e7:	6a 20                	push   $0x20
c00024e9:	6a 20                	push   $0x20
c00024eb:	e8 fe fa ff ff       	call   c0001fee <outb>
c00024f0:	83 c4 10             	add    $0x10,%esp

    return;
c00024f3:	90                   	nop
}
c00024f4:	c9                   	leave  
c00024f5:	c3                   	ret    

c00024f6 <initialize_multitasking>:
task_control_block_t kernel_main_task;

uint32_t pid_counter;

int initialize_multitasking()
{    
c00024f6:	55                   	push   %ebp
c00024f7:	89 e5                	mov    %esp,%ebp
c00024f9:	83 ec 08             	sub    $0x8,%esp
    // initialize current task as initial task
    kernel_main_task.pid = pid_counter = 0;
c00024fc:	c7 05 80 78 00 c0 00 	movl   $0x0,0xc0007880
c0002503:	00 00 00 
c0002506:	a1 80 78 00 c0       	mov    0xc0007880,%eax
c000250b:	a3 60 78 00 c0       	mov    %eax,0xc0007860
    kernel_main_task.state = RUNNING;
c0002510:	c7 05 64 78 00 c0 00 	movl   $0x0,0xc0007864
c0002517:	00 00 00 
    kernel_main_task.esp = NULL; //this is initialized only on task switch
c000251a:	c7 05 68 78 00 c0 00 	movl   $0x0,0xc0007868
c0002521:	00 00 00 
    kernel_main_task.pd = get_page_dir();
c0002524:	e8 ef 1a 00 00       	call   c0004018 <get_page_dir>
c0002529:	a3 70 78 00 c0       	mov    %eax,0xc0007870

    // this is the only task so far
    //as we add tasks this becomes circular linked list
    kernel_main_task.next_task = &kernel_main_task;
c000252e:	c7 05 74 78 00 c0 60 	movl   $0xc0007860,0xc0007874
c0002535:	78 00 c0 
    current_task = &kernel_main_task;
c0002538:	c7 05 40 78 00 c0 60 	movl   $0xc0007860,0xc0007840
c000253f:	78 00 c0 

    return 0;
c0002542:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002547:	c9                   	leave  
c0002548:	c3                   	ret    

c0002549 <new_kernel_task>:

task_control_block_t* new_kernel_task(int32_t (*task_entry) (void))
{
c0002549:	55                   	push   %ebp
c000254a:	89 e5                	mov    %esp,%ebp
c000254c:	83 ec 18             	sub    $0x18,%esp
    task_control_block_t* new_task = kmalloc(sizeof(task_control_block_t));
c000254f:	83 ec 0c             	sub    $0xc,%esp
c0002552:	6a 20                	push   $0x20
c0002554:	e8 11 0f 00 00       	call   c000346a <kmalloc>
c0002559:	83 c4 10             	add    $0x10,%esp
c000255c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void* new_stack = kmalloc(KERNEL_STACK_SIZE);
c000255f:	83 ec 0c             	sub    $0xc,%esp
c0002562:	68 00 80 00 00       	push   $0x8000
c0002567:	e8 fe 0e 00 00       	call   c000346a <kmalloc>
c000256c:	83 c4 10             	add    $0x10,%esp
c000256f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint32_t* esp0 = (uint32_t*) (new_stack + KERNEL_STACK_SIZE);
c0002572:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002575:	05 00 80 00 00       	add    $0x8000,%eax
c000257a:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // init new stack with valid context to launch new task
    *(--esp0) = (uint32_t) new_task; //argument to launch_task
c000257d:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c0002581:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002584:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002587:	89 10                	mov    %edx,(%eax)
    *(--esp0) = (uint32_t) terminate_task; // launch_task() returns to here, to close out task
c0002589:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c000258d:	ba cd 3f 00 c0       	mov    $0xc0003fcd,%edx
c0002592:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002595:	89 10                	mov    %edx,(%eax)
    *(--esp0) = (uint32_t) launch_task; //common entry function for new tasks
c0002597:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c000259b:	ba 06 27 00 c0       	mov    $0xc0002706,%edx
c00025a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00025a3:	89 10                	mov    %edx,(%eax)
    *(--esp0) = 0; //push ebx
c00025a5:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c00025a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00025ac:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp0) = 0; //push esi
c00025b2:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c00025b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00025b9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp0) = 0; //push edi
c00025bf:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c00025c3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00025c6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp0) = 0; //push ebp
c00025cc:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c00025d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00025d3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    update_kstack(esp0); //update tss with esp0
c00025d9:	83 ec 0c             	sub    $0xc,%esp
c00025dc:	ff 75 ec             	pushl  -0x14(%ebp)
c00025df:	e8 4e 15 00 00       	call   c0003b32 <update_kstack>
c00025e4:	83 c4 10             	add    $0x10,%esp

    //create copy of kernel page_dir
    void* new_pd = kmalloc_aligned(PAGE_SIZE, PAGE_SIZE);
c00025e7:	83 ec 08             	sub    $0x8,%esp
c00025ea:	68 00 10 00 00       	push   $0x1000
c00025ef:	68 00 10 00 00       	push   $0x1000
c00025f4:	e8 3e 0f 00 00       	call   c0003537 <kmalloc_aligned>
c00025f9:	83 c4 10             	add    $0x10,%esp
c00025fc:	89 45 e8             	mov    %eax,-0x18(%ebp)
    memcpy(new_pd, (void*) &pd->dir,PAGE_SIZE);
c00025ff:	a1 00 60 00 c0       	mov    0xc0006000,%eax
c0002604:	05 00 f0 3f 00       	add    $0x3ff000,%eax
c0002609:	83 ec 04             	sub    $0x4,%esp
c000260c:	68 00 10 00 00       	push   $0x1000
c0002611:	50                   	push   %eax
c0002612:	ff 75 e8             	pushl  -0x18(%ebp)
c0002615:	e8 25 f1 ff ff       	call   c000173f <memcpy>
c000261a:	83 c4 10             	add    $0x10,%esp
    new_task->pd = get_physaddr(new_pd); //page dir is physical address.
c000261d:	83 ec 0c             	sub    $0xc,%esp
c0002620:	ff 75 e8             	pushl  -0x18(%ebp)
c0002623:	e8 0a 02 00 00       	call   c0002832 <get_physaddr>
c0002628:	83 c4 10             	add    $0x10,%esp
c000262b:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000262e:	89 42 10             	mov    %eax,0x10(%edx)


    new_task->pid = ++pid_counter;
c0002631:	a1 80 78 00 c0       	mov    0xc0007880,%eax
c0002636:	83 c0 01             	add    $0x1,%eax
c0002639:	a3 80 78 00 c0       	mov    %eax,0xc0007880
c000263e:	8b 15 80 78 00 c0    	mov    0xc0007880,%edx
c0002644:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002647:	89 10                	mov    %edx,(%eax)
    new_task->state = WAITING;
c0002649:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000264c:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
    new_task->esp = esp0;
c0002653:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002656:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0002659:	89 50 08             	mov    %edx,0x8(%eax)
    new_task->task_entry = task_entry;
c000265c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000265f:	8b 55 08             	mov    0x8(%ebp),%edx
c0002662:	89 50 18             	mov    %edx,0x18(%eax)
    new_task->return_val = -1;
c0002665:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002668:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%eax)

    //insert task into the ll
    new_task->next_task = current_task->next_task;
c000266f:	a1 40 78 00 c0       	mov    0xc0007840,%eax
c0002674:	8b 50 14             	mov    0x14(%eax),%edx
c0002677:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000267a:	89 50 14             	mov    %edx,0x14(%eax)
    current_task->next_task = new_task;
c000267d:	a1 40 78 00 c0       	mov    0xc0007840,%eax
c0002682:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002685:	89 50 14             	mov    %edx,0x14(%eax)

    return new_task;
c0002688:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c000268b:	c9                   	leave  
c000268c:	c3                   	ret    

c000268d <yield>:

void yield(void)
{
c000268d:	55                   	push   %ebp
c000268e:	89 e5                	mov    %esp,%ebp
c0002690:	83 ec 08             	sub    $0x8,%esp
    current_task->state = WAITING;
c0002693:	a1 40 78 00 c0       	mov    0xc0007840,%eax
c0002698:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
    current_task->next_task->state = RUNNING;    
c000269f:	a1 40 78 00 c0       	mov    0xc0007840,%eax
c00026a4:	8b 40 14             	mov    0x14(%eax),%eax
c00026a7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    switch_to_task(current_task->next_task);
c00026ae:	a1 40 78 00 c0       	mov    0xc0007840,%eax
c00026b3:	8b 40 14             	mov    0x14(%eax),%eax
c00026b6:	83 ec 0c             	sub    $0xc,%esp
c00026b9:	50                   	push   %eax
c00026ba:	e8 d9 18 00 00       	call   c0003f98 <switch_to_task>
c00026bf:	83 c4 10             	add    $0x10,%esp
}
c00026c2:	90                   	nop
c00026c3:	c9                   	leave  
c00026c4:	c3                   	ret    

c00026c5 <join>:

int32_t join(task_control_block_t* task)
{
c00026c5:	55                   	push   %ebp
c00026c6:	89 e5                	mov    %esp,%ebp
c00026c8:	83 ec 08             	sub    $0x8,%esp
    // make sure we are not trying to join the current task or the main kernel task
    if(task == current_task || task == &kernel_main_task)
c00026cb:	a1 40 78 00 c0       	mov    0xc0007840,%eax
c00026d0:	39 45 08             	cmp    %eax,0x8(%ebp)
c00026d3:	74 09                	je     c00026de <join+0x19>
c00026d5:	81 7d 08 60 78 00 c0 	cmpl   $0xc0007860,0x8(%ebp)
c00026dc:	75 0c                	jne    c00026ea <join+0x25>
        return -1; 
c00026de:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00026e3:	eb 1f                	jmp    c0002704 <join+0x3f>

    while(task->state == WAITING || task->state == RUNNING)
        yield();
c00026e5:	e8 a3 ff ff ff       	call   c000268d <yield>
    while(task->state == WAITING || task->state == RUNNING)
c00026ea:	8b 45 08             	mov    0x8(%ebp),%eax
c00026ed:	8b 40 04             	mov    0x4(%eax),%eax
c00026f0:	83 f8 02             	cmp    $0x2,%eax
c00026f3:	74 f0                	je     c00026e5 <join+0x20>
c00026f5:	8b 45 08             	mov    0x8(%ebp),%eax
c00026f8:	8b 40 04             	mov    0x4(%eax),%eax
c00026fb:	85 c0                	test   %eax,%eax
c00026fd:	74 e6                	je     c00026e5 <join+0x20>
    // free task memory: stack, heap and paging structures
    // free tcb? << what should lifetime be?  Want to interrogate after process completes, but dont want it to live forever...

//    kfree(task);

    return 0;
c00026ff:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002704:	c9                   	leave  
c0002705:	c3                   	ret    

c0002706 <launch_task>:


void launch_task(task_control_block_t* task)
{
c0002706:	55                   	push   %ebp
c0002707:	89 e5                	mov    %esp,%ebp
c0002709:	83 ec 18             	sub    $0x18,%esp
    task->state = RUNNING;
c000270c:	8b 45 08             	mov    0x8(%ebp),%eax
c000270f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

   // call task main function
    task->return_val = (*task->task_entry)();
c0002716:	8b 45 08             	mov    0x8(%ebp),%eax
c0002719:	8b 40 18             	mov    0x18(%eax),%eax
c000271c:	ff d0                	call   *%eax
c000271e:	8b 55 08             	mov    0x8(%ebp),%edx
c0002721:	89 42 1c             	mov    %eax,0x1c(%edx)

    //remove this task from active task list
    task_control_block_t* t = task->next_task;
c0002724:	8b 45 08             	mov    0x8(%ebp),%eax
c0002727:	8b 40 14             	mov    0x14(%eax),%eax
c000272a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while( t->next_task != task)
c000272d:	eb 09                	jmp    c0002738 <launch_task+0x32>
        t = t->next_task;
c000272f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002732:	8b 40 14             	mov    0x14(%eax),%eax
c0002735:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while( t->next_task != task)
c0002738:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000273b:	8b 40 14             	mov    0x14(%eax),%eax
c000273e:	39 45 08             	cmp    %eax,0x8(%ebp)
c0002741:	75 ec                	jne    c000272f <launch_task+0x29>
    t->next_task = t->next_task->next_task;
c0002743:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002746:	8b 40 14             	mov    0x14(%eax),%eax
c0002749:	8b 50 14             	mov    0x14(%eax),%edx
c000274c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000274f:	89 50 14             	mov    %edx,0x14(%eax)

    task->state = COMPLETE;
c0002752:	8b 45 08             	mov    0x8(%ebp),%eax
c0002755:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)

    // this will "return" to terminite_task 
}
c000275c:	90                   	nop
c000275d:	c9                   	leave  
c000275e:	c3                   	ret    

c000275f <num_tasks>:

int num_tasks()
{
c000275f:	55                   	push   %ebp
c0002760:	89 e5                	mov    %esp,%ebp
c0002762:	83 ec 10             	sub    $0x10,%esp
    task_control_block_t* t = current_task;
c0002765:	a1 40 78 00 c0       	mov    0xc0007840,%eax
c000276a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int nn = 1;
c000276d:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    while( t->next_task != current_task)
c0002774:	eb 0d                	jmp    c0002783 <num_tasks+0x24>
    {
        t = t->next_task;
c0002776:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002779:	8b 40 14             	mov    0x14(%eax),%eax
c000277c:	89 45 fc             	mov    %eax,-0x4(%ebp)
        nn++;
c000277f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while( t->next_task != current_task)
c0002783:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002786:	8b 50 14             	mov    0x14(%eax),%edx
c0002789:	a1 40 78 00 c0       	mov    0xc0007840,%eax
c000278e:	39 c2                	cmp    %eax,%edx
c0002790:	75 e4                	jne    c0002776 <num_tasks+0x17>
    }
    return nn;
c0002792:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c0002795:	c9                   	leave  
c0002796:	c3                   	ret    

c0002797 <user_test>:
int user_test()
{
c0002797:	55                   	push   %ebp
c0002798:	89 e5                	mov    %esp,%ebp
c000279a:	83 ec 10             	sub    $0x10,%esp
    int a = 1;
c000279d:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
    int b = 2;
c00027a4:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
    int c = b/a;
c00027ab:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00027ae:	99                   	cltd   
c00027af:	f7 7d fc             	idivl  -0x4(%ebp)
c00027b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return c;
c00027b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00027b8:	c9                   	leave  
c00027b9:	c3                   	ret    

c00027ba <get_ptindex>:
//global pointer to page directory
extern page_directory_virt_t* pd;

// return page table index for virtual address
static inline uint32_t get_ptindex(void* addr)
{
c00027ba:	55                   	push   %ebp
c00027bb:	89 e5                	mov    %esp,%ebp
    return (((uint32_t) addr) & PAGE_PTE_MASK ) >> 12;
c00027bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00027c0:	c1 e8 0c             	shr    $0xc,%eax
c00027c3:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c00027c8:	5d                   	pop    %ebp
c00027c9:	c3                   	ret    

c00027ca <get_pdindex>:

// return page directory index for virtual address
static inline uint32_t get_pdindex(void* addr)
{
c00027ca:	55                   	push   %ebp
c00027cb:	89 e5                	mov    %esp,%ebp
    return ((uint32_t) addr) >> 22;
c00027cd:	8b 45 08             	mov    0x8(%ebp),%eax
c00027d0:	c1 e8 16             	shr    $0x16,%eax
}
c00027d3:	5d                   	pop    %ebp
c00027d4:	c3                   	ret    

c00027d5 <get_page_offset>:

// return offset into page
static inline uint32_t get_page_offset(void* addr)
{
c00027d5:	55                   	push   %ebp
c00027d6:	89 e5                	mov    %esp,%ebp
    return ((uint32_t) addr) & ~PAGE_ADDRMASK;
c00027d8:	8b 45 08             	mov    0x8(%ebp),%eax
c00027db:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c00027e0:	5d                   	pop    %ebp
c00027e1:	c3                   	ret    

c00027e2 <get_table>:

page_directory_virt_t* pd = (page_directory_virt_t*) PD_ADDR;

// return page directory index for virtual address
page_table_t* get_table(void* addr)
{
c00027e2:	55                   	push   %ebp
c00027e3:	89 e5                	mov    %esp,%ebp
c00027e5:	53                   	push   %ebx
c00027e6:	83 ec 10             	sub    $0x10,%esp
    uint32_t idx = get_pdindex(addr);
c00027e9:	ff 75 08             	pushl  0x8(%ebp)
c00027ec:	e8 d9 ff ff ff       	call   c00027ca <get_pdindex>
c00027f1:	83 c4 04             	add    $0x4,%esp
c00027f4:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(pd->dir.pde[idx] & PAGE_FLAG_PRESENT)
c00027f7:	a1 00 60 00 c0       	mov    0xc0006000,%eax
c00027fc:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00027ff:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c0002805:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0002808:	83 e0 01             	and    $0x1,%eax
c000280b:	85 c0                	test   %eax,%eax
c000280d:	74 19                	je     c0002828 <get_table+0x46>
        return pd->tables + get_pdindex(addr);
c000280f:	a1 00 60 00 c0       	mov    0xc0006000,%eax
c0002814:	89 c3                	mov    %eax,%ebx
c0002816:	ff 75 08             	pushl  0x8(%ebp)
c0002819:	e8 ac ff ff ff       	call   c00027ca <get_pdindex>
c000281e:	83 c4 04             	add    $0x4,%esp
c0002821:	c1 e0 0c             	shl    $0xc,%eax
c0002824:	01 d8                	add    %ebx,%eax
c0002826:	eb 05                	jmp    c000282d <get_table+0x4b>
    else 
        return NULL;
c0002828:	b8 00 00 00 00       	mov    $0x0,%eax
}
c000282d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0002830:	c9                   	leave  
c0002831:	c3                   	ret    

c0002832 <get_physaddr>:

// return physical addr from virt addr
void* get_physaddr(void* addr)
{
c0002832:	55                   	push   %ebp
c0002833:	89 e5                	mov    %esp,%ebp
c0002835:	53                   	push   %ebx
c0002836:	83 ec 10             	sub    $0x10,%esp
    //check pd entry is present
    uint32_t pdi = get_pdindex(addr);
c0002839:	ff 75 08             	pushl  0x8(%ebp)
c000283c:	e8 89 ff ff ff       	call   c00027ca <get_pdindex>
c0002841:	83 c4 04             	add    $0x4,%esp
c0002844:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(! pd->dir.pde[pdi] & PAGE_FLAG_PRESENT)
c0002847:	a1 00 60 00 c0       	mov    0xc0006000,%eax
c000284c:	8b 55 f8             	mov    -0x8(%ebp),%edx
c000284f:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c0002855:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0002858:	85 c0                	test   %eax,%eax
c000285a:	75 07                	jne    c0002863 <get_physaddr+0x31>
        return NULL;
c000285c:	b8 00 00 00 00       	mov    $0x0,%eax
c0002861:	eb 45                	jmp    c00028a8 <get_physaddr+0x76>

    //check pt entry is present
    uint32_t pte = pd->tables[pdi].pte[get_ptindex(addr)];
c0002863:	8b 1d 00 60 00 c0    	mov    0xc0006000,%ebx
c0002869:	ff 75 08             	pushl  0x8(%ebp)
c000286c:	e8 49 ff ff ff       	call   c00027ba <get_ptindex>
c0002871:	83 c4 04             	add    $0x4,%esp
c0002874:	89 c2                	mov    %eax,%edx
c0002876:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0002879:	c1 e0 0a             	shl    $0xa,%eax
c000287c:	01 d0                	add    %edx,%eax
c000287e:	8b 04 83             	mov    (%ebx,%eax,4),%eax
c0002881:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(! pte & PAGE_FLAG_PRESENT)
c0002884:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002888:	75 07                	jne    c0002891 <get_physaddr+0x5f>
        return NULL;
c000288a:	b8 00 00 00 00       	mov    $0x0,%eax
c000288f:	eb 17                	jmp    c00028a8 <get_physaddr+0x76>

    return (void*) ((pte & PAGE_ADDRMASK) +  get_page_offset(addr) );
c0002891:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002894:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002899:	89 c3                	mov    %eax,%ebx
c000289b:	ff 75 08             	pushl  0x8(%ebp)
c000289e:	e8 32 ff ff ff       	call   c00027d5 <get_page_offset>
c00028a3:	83 c4 04             	add    $0x4,%esp
c00028a6:	01 d8                	add    %ebx,%eax
}
c00028a8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00028ab:	c9                   	leave  
c00028ac:	c3                   	ret    

c00028ad <get_ptindex>:
{
c00028ad:	55                   	push   %ebp
c00028ae:	89 e5                	mov    %esp,%ebp
    return (((uint32_t) addr) & PAGE_PTE_MASK ) >> 12;
c00028b0:	8b 45 08             	mov    0x8(%ebp),%eax
c00028b3:	c1 e8 0c             	shr    $0xc,%eax
c00028b6:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c00028bb:	5d                   	pop    %ebp
c00028bc:	c3                   	ret    

c00028bd <get_pdindex>:
{
c00028bd:	55                   	push   %ebp
c00028be:	89 e5                	mov    %esp,%ebp
    return ((uint32_t) addr) >> 22;
c00028c0:	8b 45 08             	mov    0x8(%ebp),%eax
c00028c3:	c1 e8 16             	shr    $0x16,%eax
}
c00028c6:	5d                   	pop    %ebp
c00028c7:	c3                   	ret    

c00028c8 <align_int>:
{
c00028c8:	55                   	push   %ebp
c00028c9:	89 e5                	mov    %esp,%ebp
c00028cb:	83 ec 10             	sub    $0x10,%esp
    size_t am = alignment - 1;
c00028ce:	8b 45 0c             	mov    0xc(%ebp),%eax
c00028d1:	83 e8 01             	sub    $0x1,%eax
c00028d4:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (((size_t)len + am) & ~am);
c00028d7:	8b 55 08             	mov    0x8(%ebp),%edx
c00028da:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00028dd:	01 c2                	add    %eax,%edx
c00028df:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00028e2:	f7 d0                	not    %eax
c00028e4:	21 d0                	and    %edx,%eax
}
c00028e6:	c9                   	leave  
c00028e7:	c3                   	ret    

c00028e8 <align_ptr>:

static inline void* align_ptr(void* addr, size_t alignment)
{
c00028e8:	55                   	push   %ebp
c00028e9:	89 e5                	mov    %esp,%ebp
    // alignment must be increment of 4
    if(alignment % sizeof(void*) != 0 ) return NULL;
c00028eb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00028ee:	83 e0 03             	and    $0x3,%eax
c00028f1:	85 c0                	test   %eax,%eax
c00028f3:	74 07                	je     c00028fc <align_ptr+0x14>
c00028f5:	b8 00 00 00 00       	mov    $0x0,%eax
c00028fa:	eb 0f                	jmp    c000290b <align_ptr+0x23>
    return (void*) align_int((size_t) addr, alignment);
c00028fc:	8b 45 08             	mov    0x8(%ebp),%eax
c00028ff:	ff 75 0c             	pushl  0xc(%ebp)
c0002902:	50                   	push   %eax
c0002903:	e8 c0 ff ff ff       	call   c00028c8 <align_int>
c0002908:	83 c4 08             	add    $0x8,%esp
}
c000290b:	c9                   	leave  
c000290c:	c3                   	ret    

c000290d <pop_free_frame>:
// 0xffc00000-0xffffffff:                   page tables


// allocate a physical page from the stack
page_t* pop_free_frame()
{
c000290d:	55                   	push   %ebp
c000290e:	89 e5                	mov    %esp,%ebp
c0002910:	83 ec 10             	sub    $0x10,%esp
    page_t* free_frame = *(frame_stack_top++);
c0002913:	a1 98 78 00 c0       	mov    0xc0007898,%eax
c0002918:	8d 50 04             	lea    0x4(%eax),%edx
c000291b:	89 15 98 78 00 c0    	mov    %edx,0xc0007898
c0002921:	8b 00                	mov    (%eax),%eax
c0002923:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(frame_stack_top<frame_stack_base)
c0002926:	8b 15 98 78 00 c0    	mov    0xc0007898,%edx
c000292c:	a1 9c 78 00 c0       	mov    0xc000789c,%eax
c0002931:	39 c2                	cmp    %eax,%edx
c0002933:	73 05                	jae    c000293a <pop_free_frame+0x2d>
        return free_frame;
c0002935:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002938:	eb 05                	jmp    c000293f <pop_free_frame+0x32>
    else
        return NULL; //out of memory!    
c000293a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c000293f:	c9                   	leave  
c0002940:	c3                   	ret    

c0002941 <push_free_frame>:

// free a physical page back to the stack
int push_free_frame(page_t* free_frame)
{
c0002941:	55                   	push   %ebp
c0002942:	89 e5                	mov    %esp,%ebp
    if(frame_stack_top<=frame_stack_start)
c0002944:	8b 15 98 78 00 c0    	mov    0xc0007898,%edx
c000294a:	a1 94 78 00 c0       	mov    0xc0007894,%eax
c000294f:	39 c2                	cmp    %eax,%edx
c0002951:	77 07                	ja     c000295a <push_free_frame+0x19>
        return -1;
c0002953:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002958:	eb 18                	jmp    c0002972 <push_free_frame+0x31>

    *(frame_stack_top--) = free_frame;
c000295a:	a1 98 78 00 c0       	mov    0xc0007898,%eax
c000295f:	8d 50 fc             	lea    -0x4(%eax),%edx
c0002962:	89 15 98 78 00 c0    	mov    %edx,0xc0007898
c0002968:	8b 55 08             	mov    0x8(%ebp),%edx
c000296b:	89 10                	mov    %edx,(%eax)
    return 0;
c000296d:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002972:	5d                   	pop    %ebp
c0002973:	c3                   	ret    

c0002974 <init_frame_stack>:

// set up a stack will all free pages of physical memory
void init_frame_stack(multiboot_info_t* mbd)
{
c0002974:	55                   	push   %ebp
c0002975:	89 e5                	mov    %esp,%ebp
c0002977:	57                   	push   %edi
c0002978:	56                   	push   %esi
c0002979:	83 ec 20             	sub    $0x20,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c000297c:	8b 45 08             	mov    0x8(%ebp),%eax
c000297f:	8b 40 30             	mov    0x30(%eax),%eax
c0002982:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // We will start looking for free physical memory just above the kernel
    page_t* first_free_frame = align_ptr( &_kernel_end_phys, PAGE_SIZE); //physical address of first free page after the kernel
c0002985:	68 00 10 00 00       	push   $0x1000
c000298a:	68 00 10 21 00       	push   $0x211000
c000298f:	e8 54 ff ff ff       	call   c00028e8 <align_ptr>
c0002994:	83 c4 08             	add    $0x8,%esp
c0002997:	89 45 e8             	mov    %eax,-0x18(%ebp)

    // Map the stack just past the end of the kernel in virtual mem

    // stack_break points to the end of the allocated region for the stack  
    frame_stack_brk = align_ptr( &_kernel_end, PAGE_SIZE);
c000299a:	68 00 10 00 00       	push   $0x1000
c000299f:	68 00 00 11 c0       	push   $0xc0110000
c00029a4:	e8 3f ff ff ff       	call   c00028e8 <align_ptr>
c00029a9:	83 c4 08             	add    $0x8,%esp
c00029ac:	a3 a0 78 00 c0       	mov    %eax,0xc00078a0

    // initialize stack pointers
    // we will initialize the stack by adding new pages to the base
    // first pages (in low mem) will be at top of the stack
    frame_stack_start = (page_t**) frame_stack_brk;
c00029b1:	a1 a0 78 00 c0       	mov    0xc00078a0,%eax
c00029b6:	a3 94 78 00 c0       	mov    %eax,0xc0007894
    frame_stack_top = frame_stack_start;
c00029bb:	a1 94 78 00 c0       	mov    0xc0007894,%eax
c00029c0:	a3 98 78 00 c0       	mov    %eax,0xc0007898
    frame_stack_base = frame_stack_top;
c00029c5:	a1 98 78 00 c0       	mov    0xc0007898,%eax
c00029ca:	a3 9c 78 00 c0       	mov    %eax,0xc000789c

    // allocate one page for the stack, incrementing the stack_break and first_free_frame pointers
    // We will allocate more pages for the stack as we go as needed
    if(!map_page_at(frame_stack_brk++, first_free_frame++, PAGE_FLAG_WRITE))
c00029cf:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00029d2:	8d 82 00 10 00 00    	lea    0x1000(%edx),%eax
c00029d8:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00029db:	a1 a0 78 00 c0       	mov    0xc00078a0,%eax
c00029e0:	8d 88 00 10 00 00    	lea    0x1000(%eax),%ecx
c00029e6:	89 0d a0 78 00 c0    	mov    %ecx,0xc00078a0
c00029ec:	83 ec 04             	sub    $0x4,%esp
c00029ef:	6a 02                	push   $0x2
c00029f1:	52                   	push   %edx
c00029f2:	50                   	push   %eax
c00029f3:	e8 f1 03 00 00       	call   c0002de9 <map_page_at>
c00029f8:	83 c4 10             	add    $0x10,%esp
c00029fb:	85 c0                	test   %eax,%eax
c00029fd:	75 10                	jne    c0002a0f <init_frame_stack+0x9b>
        panic("Error reserving memory for physical page allocation!");
c00029ff:	83 ec 0c             	sub    $0xc,%esp
c0002a02:	68 c8 56 00 c0       	push   $0xc00056c8
c0002a07:	e8 f6 ec ff ff       	call   c0001702 <panic>
c0002a0c:	83 c4 10             	add    $0x10,%esp

    // loop through each block of memory defined in the multiboot record
    // for each block of memory, add free pages to stack
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0002a0f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0002a16:	e9 50 01 00 00       	jmp    c0002b6b <init_frame_stack+0x1f7>
	{
        if(mmap_table[nn].size == 0) // end of table
c0002a1b:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002a1e:	89 d0                	mov    %edx,%eax
c0002a20:	01 c0                	add    %eax,%eax
c0002a22:	01 d0                	add    %edx,%eax
c0002a24:	c1 e0 03             	shl    $0x3,%eax
c0002a27:	89 c2                	mov    %eax,%edx
c0002a29:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002a2c:	01 d0                	add    %edx,%eax
c0002a2e:	8b 00                	mov    (%eax),%eax
c0002a30:	85 c0                	test   %eax,%eax
c0002a32:	0f 84 44 01 00 00    	je     c0002b7c <init_frame_stack+0x208>
            break;

        if(mmap_table[nn].addr >> 32) // ignore anything above 32bits
c0002a38:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002a3b:	89 d0                	mov    %edx,%eax
c0002a3d:	01 c0                	add    %eax,%eax
c0002a3f:	01 d0                	add    %edx,%eax
c0002a41:	c1 e0 03             	shl    $0x3,%eax
c0002a44:	89 c2                	mov    %eax,%edx
c0002a46:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002a49:	01 d0                	add    %edx,%eax
c0002a4b:	8b 50 08             	mov    0x8(%eax),%edx
c0002a4e:	8b 40 04             	mov    0x4(%eax),%eax
c0002a51:	89 d0                	mov    %edx,%eax
c0002a53:	31 d2                	xor    %edx,%edx
c0002a55:	89 c1                	mov    %eax,%ecx
c0002a57:	80 f5 00             	xor    $0x0,%ch
c0002a5a:	89 ce                	mov    %ecx,%esi
c0002a5c:	89 d0                	mov    %edx,%eax
c0002a5e:	80 f4 00             	xor    $0x0,%ah
c0002a61:	89 c7                	mov    %eax,%edi
c0002a63:	89 f8                	mov    %edi,%eax
c0002a65:	09 f0                	or     %esi,%eax
c0002a67:	85 c0                	test   %eax,%eax
c0002a69:	0f 85 f7 00 00 00    	jne    c0002b66 <init_frame_stack+0x1f2>
            continue;

		if(mmap_table[nn].type == MULTIBOOT_MEMORY_AVAILABLE)
c0002a6f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002a72:	89 d0                	mov    %edx,%eax
c0002a74:	01 c0                	add    %eax,%eax
c0002a76:	01 d0                	add    %edx,%eax
c0002a78:	c1 e0 03             	shl    $0x3,%eax
c0002a7b:	89 c2                	mov    %eax,%edx
c0002a7d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002a80:	01 d0                	add    %edx,%eax
c0002a82:	8b 40 14             	mov    0x14(%eax),%eax
c0002a85:	83 f8 01             	cmp    $0x1,%eax
c0002a88:	0f 85 d9 00 00 00    	jne    c0002b67 <init_frame_stack+0x1f3>
        {
            //pointers to the first and last page in this memory block 
            size_t block_addr = mmap_table[nn].addr;
c0002a8e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002a91:	89 d0                	mov    %edx,%eax
c0002a93:	01 c0                	add    %eax,%eax
c0002a95:	01 d0                	add    %edx,%eax
c0002a97:	c1 e0 03             	shl    $0x3,%eax
c0002a9a:	89 c2                	mov    %eax,%edx
c0002a9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002a9f:	01 d0                	add    %edx,%eax
c0002aa1:	8b 50 08             	mov    0x8(%eax),%edx
c0002aa4:	8b 40 04             	mov    0x4(%eax),%eax
c0002aa7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            size_t block_len = mmap_table[nn].len;
c0002aaa:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002aad:	89 d0                	mov    %edx,%eax
c0002aaf:	01 c0                	add    %eax,%eax
c0002ab1:	01 d0                	add    %edx,%eax
c0002ab3:	c1 e0 03             	shl    $0x3,%eax
c0002ab6:	89 c2                	mov    %eax,%edx
c0002ab8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002abb:	01 d0                	add    %edx,%eax
c0002abd:	8b 50 10             	mov    0x10(%eax),%edx
c0002ac0:	8b 40 0c             	mov    0xc(%eax),%eax
c0002ac3:	89 45 e0             	mov    %eax,-0x20(%ebp)
            page_t* pg = align_ptr( (char*) block_addr, PAGE_SIZE); // first whole page in block
c0002ac6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0002ac9:	83 ec 08             	sub    $0x8,%esp
c0002acc:	68 00 10 00 00       	push   $0x1000
c0002ad1:	50                   	push   %eax
c0002ad2:	e8 11 fe ff ff       	call   c00028e8 <align_ptr>
c0002ad7:	83 c4 10             	add    $0x10,%esp
c0002ada:	89 45 f0             	mov    %eax,-0x10(%ebp)
            page_t* pg_end = (page_t*) ((block_addr+block_len) & PAGE_ADDRMASK); // first page *after* last whole page in block
c0002add:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0002ae0:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0002ae3:	01 d0                	add    %edx,%eax
c0002ae5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002aea:	89 45 dc             	mov    %eax,-0x24(%ebp)

            //don't map any memory before end of the kernel
            pg = pg<first_free_frame ? first_free_frame : pg; 
c0002aed:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002af0:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0002af3:	0f 43 45 f0          	cmovae -0x10(%ebp),%eax
c0002af7:	89 45 f0             	mov    %eax,-0x10(%ebp)

            //fill stack with pointers to each page in the block
            for(; pg<pg_end; pg++)
c0002afa:	eb 60                	jmp    c0002b5c <init_frame_stack+0x1e8>
            {
                // extend end of stack and make sure we have allocated enough memory
                if( (void*) ++frame_stack_base >= (void*) frame_stack_brk)
c0002afc:	a1 9c 78 00 c0       	mov    0xc000789c,%eax
c0002b01:	83 c0 04             	add    $0x4,%eax
c0002b04:	a3 9c 78 00 c0       	mov    %eax,0xc000789c
c0002b09:	8b 15 9c 78 00 c0    	mov    0xc000789c,%edx
c0002b0f:	a1 a0 78 00 c0       	mov    0xc00078a0,%eax
c0002b14:	39 c2                	cmp    %eax,%edx
c0002b16:	72 33                	jb     c0002b4b <init_frame_stack+0x1d7>
                {
                    // map a new page at the end of the stack
                    // note that this will pop a free page off the top of the stack
                    if(!map_page(frame_stack_brk++, PAGE_FLAG_WRITE))
c0002b18:	a1 a0 78 00 c0       	mov    0xc00078a0,%eax
c0002b1d:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c0002b23:	89 15 a0 78 00 c0    	mov    %edx,0xc00078a0
c0002b29:	83 ec 08             	sub    $0x8,%esp
c0002b2c:	6a 02                	push   $0x2
c0002b2e:	50                   	push   %eax
c0002b2f:	e8 41 03 00 00       	call   c0002e75 <map_page>
c0002b34:	83 c4 10             	add    $0x10,%esp
c0002b37:	85 c0                	test   %eax,%eax
c0002b39:	75 10                	jne    c0002b4b <init_frame_stack+0x1d7>
                        panic("Error reserving memory for physical page allocation!");
c0002b3b:	83 ec 0c             	sub    $0xc,%esp
c0002b3e:	68 c8 56 00 c0       	push   $0xc00056c8
c0002b43:	e8 ba eb ff ff       	call   c0001702 <panic>
c0002b48:	83 c4 10             	add    $0x10,%esp
                }

                //record physical page at end stack
                *frame_stack_base = pg;
c0002b4b:	a1 9c 78 00 c0       	mov    0xc000789c,%eax
c0002b50:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0002b53:	89 10                	mov    %edx,(%eax)
            for(; pg<pg_end; pg++)
c0002b55:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
c0002b5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002b5f:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c0002b62:	72 98                	jb     c0002afc <init_frame_stack+0x188>
c0002b64:	eb 01                	jmp    c0002b67 <init_frame_stack+0x1f3>
            continue;
c0002b66:	90                   	nop
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0002b67:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0002b6b:	8b 45 08             	mov    0x8(%ebp),%eax
c0002b6e:	8b 40 2c             	mov    0x2c(%eax),%eax
c0002b71:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0002b74:	0f 82 a1 fe ff ff    	jb     c0002a1b <init_frame_stack+0xa7>
	}

    // size_t free_frames = frame_stack_base-frame_stack_top;
	// kprintf("\nFound %d frames of RAM (%f MB)\n", free_frames, free_frames*PAGE_SIZE/1e6);

}
c0002b7a:	eb 01                	jmp    c0002b7d <init_frame_stack+0x209>
            break;
c0002b7c:	90                   	nop
}
c0002b7d:	90                   	nop
c0002b7e:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0002b81:	5e                   	pop    %esi
c0002b82:	5f                   	pop    %edi
c0002b83:	5d                   	pop    %ebp
c0002b84:	c3                   	ret    

c0002b85 <ksbrk>:



// increment heap size, return pointer to *old* break (beginning of newly allocated memory)
void* ksbrk(size_t increment)
{
c0002b85:	55                   	push   %ebp
c0002b86:	89 e5                	mov    %esp,%ebp
c0002b88:	83 ec 18             	sub    $0x18,%esp
    if(increment == 0) return kheap_brk;
c0002b8b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002b8f:	75 07                	jne    c0002b98 <ksbrk+0x13>
c0002b91:	a1 8c 78 00 c0       	mov    0xc000788c,%eax
c0002b96:	eb 2d                	jmp    c0002bc5 <ksbrk+0x40>

    page_t* old_brk = kheap_brk;
c0002b98:	a1 8c 78 00 c0       	mov    0xc000788c,%eax
c0002b9d:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(kbrk(((char*)kheap_brk) + increment)) return NULL;
c0002ba0:	8b 15 8c 78 00 c0    	mov    0xc000788c,%edx
c0002ba6:	8b 45 08             	mov    0x8(%ebp),%eax
c0002ba9:	01 d0                	add    %edx,%eax
c0002bab:	83 ec 0c             	sub    $0xc,%esp
c0002bae:	50                   	push   %eax
c0002baf:	e8 13 00 00 00       	call   c0002bc7 <kbrk>
c0002bb4:	83 c4 10             	add    $0x10,%esp
c0002bb7:	85 c0                	test   %eax,%eax
c0002bb9:	74 07                	je     c0002bc2 <ksbrk+0x3d>
c0002bbb:	b8 00 00 00 00       	mov    $0x0,%eax
c0002bc0:	eb 03                	jmp    c0002bc5 <ksbrk+0x40>

    return old_brk;
c0002bc2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0002bc5:	c9                   	leave  
c0002bc6:	c3                   	ret    

c0002bc7 <kbrk>:

// set kheap break to addr, growing or shrinking heap accordingly
// returns 0 on success
int kbrk(void* addr)
{
c0002bc7:	55                   	push   %ebp
c0002bc8:	89 e5                	mov    %esp,%ebp
c0002bca:	83 ec 18             	sub    $0x18,%esp
    //make sure this is a valid break (not before heap begins or into stack)
    if(addr < (void*) kheap_base || addr >= (void*) kstack_brk)
c0002bcd:	a1 90 78 00 c0       	mov    0xc0007890,%eax
c0002bd2:	39 45 08             	cmp    %eax,0x8(%ebp)
c0002bd5:	72 0a                	jb     c0002be1 <kbrk+0x1a>
c0002bd7:	a1 88 78 00 c0       	mov    0xc0007888,%eax
c0002bdc:	39 45 08             	cmp    %eax,0x8(%ebp)
c0002bdf:	72 0a                	jb     c0002beb <kbrk+0x24>
        return -1; 
c0002be1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002be6:	e9 8f 00 00 00       	jmp    c0002c7a <kbrk+0xb3>

    page_t* pg_addr = align_ptr(addr, PAGE_SIZE); // align addr to a page
c0002beb:	68 00 10 00 00       	push   $0x1000
c0002bf0:	ff 75 08             	pushl  0x8(%ebp)
c0002bf3:	e8 f0 fc ff ff       	call   c00028e8 <align_ptr>
c0002bf8:	83 c4 08             	add    $0x8,%esp
c0002bfb:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(pg_addr > kheap_brk)
c0002bfe:	a1 8c 78 00 c0       	mov    0xc000788c,%eax
c0002c03:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0002c06:	76 63                	jbe    c0002c6b <kbrk+0xa4>
    {
        // we are increasing size of the heap
        while(pg_addr > kheap_brk)
c0002c08:	eb 2a                	jmp    c0002c34 <kbrk+0x6d>
        {
            // allocate a new page and map to end of heap
            if(!map_page(kheap_brk++, PAGE_FLAG_WRITE))
c0002c0a:	a1 8c 78 00 c0       	mov    0xc000788c,%eax
c0002c0f:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c0002c15:	89 15 8c 78 00 c0    	mov    %edx,0xc000788c
c0002c1b:	83 ec 08             	sub    $0x8,%esp
c0002c1e:	6a 02                	push   $0x2
c0002c20:	50                   	push   %eax
c0002c21:	e8 4f 02 00 00       	call   c0002e75 <map_page>
c0002c26:	83 c4 10             	add    $0x10,%esp
c0002c29:	85 c0                	test   %eax,%eax
c0002c2b:	75 07                	jne    c0002c34 <kbrk+0x6d>
                return -1; // out of physical memory
c0002c2d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002c32:	eb 46                	jmp    c0002c7a <kbrk+0xb3>
        while(pg_addr > kheap_brk)
c0002c34:	a1 8c 78 00 c0       	mov    0xc000788c,%eax
c0002c39:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0002c3c:	77 cc                	ja     c0002c0a <kbrk+0x43>
c0002c3e:	eb 35                	jmp    c0002c75 <kbrk+0xae>
    {
        // we are decreasing size of the heap
        while(pg_addr < kheap_brk)
        {
            //free page from end of heap
            if(unmap_page(--kheap_brk))
c0002c40:	a1 8c 78 00 c0       	mov    0xc000788c,%eax
c0002c45:	2d 00 10 00 00       	sub    $0x1000,%eax
c0002c4a:	a3 8c 78 00 c0       	mov    %eax,0xc000788c
c0002c4f:	a1 8c 78 00 c0       	mov    0xc000788c,%eax
c0002c54:	83 ec 0c             	sub    $0xc,%esp
c0002c57:	50                   	push   %eax
c0002c58:	e8 37 02 00 00       	call   c0002e94 <unmap_page>
c0002c5d:	83 c4 10             	add    $0x10,%esp
c0002c60:	85 c0                	test   %eax,%eax
c0002c62:	74 07                	je     c0002c6b <kbrk+0xa4>
                return -1; // error!
c0002c64:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002c69:	eb 0f                	jmp    c0002c7a <kbrk+0xb3>
        while(pg_addr < kheap_brk)
c0002c6b:	a1 8c 78 00 c0       	mov    0xc000788c,%eax
c0002c70:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0002c73:	72 cb                	jb     c0002c40 <kbrk+0x79>
        }
    }

	// kprintf("Setting kernel heap break to 0x%x\n", kheap_brk);
    
    return 0;
c0002c75:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002c7a:	c9                   	leave  
c0002c7b:	c3                   	ret    

c0002c7c <global_memory_init>:


int global_memory_init(multiboot_info_t* mbd)
{
c0002c7c:	55                   	push   %ebp
c0002c7d:	89 e5                	mov    %esp,%ebp
c0002c7f:	83 ec 08             	sub    $0x8,%esp
    init_frame_stack(mbd);
c0002c82:	83 ec 0c             	sub    $0xc,%esp
c0002c85:	ff 75 08             	pushl  0x8(%ebp)
c0002c88:	e8 e7 fc ff ff       	call   c0002974 <init_frame_stack>
c0002c8d:	83 c4 10             	add    $0x10,%esp

    // define some dummy pointers for where we will put the stack
    // TODO: actually set up a stack here
    kstack_base = (page_t*) 0xffb00000;
c0002c90:	c7 05 84 78 00 c0 00 	movl   $0xffb00000,0xc0007884
c0002c97:	00 b0 ff 
    kstack_brk = (page_t*)  0xf0000000;
c0002c9a:	c7 05 88 78 00 c0 00 	movl   $0xf0000000,0xc0007888
c0002ca1:	00 00 f0 

    kheap_base = frame_stack_brk; //start heap after the page stack allocator
c0002ca4:	a1 a0 78 00 c0       	mov    0xc00078a0,%eax
c0002ca9:	a3 90 78 00 c0       	mov    %eax,0xc0007890
    kheap_brk = kheap_base;     // heap starts empty - increase with ksbrk
c0002cae:	a1 90 78 00 c0       	mov    0xc0007890,%eax
c0002cb3:	a3 8c 78 00 c0       	mov    %eax,0xc000788c

    // we don't need the 1st MB anymore so unmap it
	if( unmap_lowmem() )
c0002cb8:	e8 12 00 00 00       	call   c0002ccf <unmap_lowmem>
c0002cbd:	85 c0                	test   %eax,%eax
c0002cbf:	74 07                	je     c0002cc8 <global_memory_init+0x4c>
        return -1;
c0002cc1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002cc6:	eb 05                	jmp    c0002ccd <global_memory_init+0x51>

    // except for VGA memory - still need that..
	// if(! map_vga() )
    //     return -1;

    return 0;
c0002cc8:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002ccd:	c9                   	leave  
c0002cce:	c3                   	ret    

c0002ccf <unmap_lowmem>:
//     return 0;
// }


int unmap_lowmem()
{
c0002ccf:	55                   	push   %ebp
c0002cd0:	89 e5                	mov    %esp,%ebp
c0002cd2:	83 ec 08             	sub    $0x8,%esp
    pd->dir.pde[0] = PAGE_FLAG_EMPTY;
c0002cd5:	a1 00 60 00 c0       	mov    0xc0006000,%eax
c0002cda:	c7 80 00 f0 3f 00 00 	movl   $0x0,0x3ff000(%eax)
c0002ce1:	00 00 00 
    refresh_tlb();
c0002ce4:	e8 33 13 00 00       	call   c000401c <refresh_tlb>
    return 0;
c0002ce9:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002cee:	c9                   	leave  
c0002cef:	c3                   	ret    

c0002cf0 <init_vga_buffer>:
// }


//map vga buffer memory
void init_vga_buffer()
{
c0002cf0:	55                   	push   %ebp
c0002cf1:	89 e5                	mov    %esp,%ebp
c0002cf3:	83 ec 18             	sub    $0x18,%esp
    page_t* vga_buf = (page_t*) VGA_BUFFER;
c0002cf6:	c7 45 f4 00 00 b1 ff 	movl   $0xffb10000,-0xc(%ebp)
    page_t* vga_buf_phys = (page_t*) VGA_BUFFER_PHYS;
c0002cfd:	c7 45 f0 00 80 0b 00 	movl   $0xb8000,-0x10(%ebp)

    size_t Npages = VGA_BUFFER_SIZE >> 12;
c0002d04:	c7 45 e8 07 00 00 00 	movl   $0x7,-0x18(%ebp)
    for(size_t nn = 0; nn < Npages; nn++)
c0002d0b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0002d12:	eb 2b                	jmp    c0002d3f <init_vga_buffer+0x4f>
        map_page_at(vga_buf++,vga_buf_phys++, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c0002d14:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0002d17:	8d 82 00 10 00 00    	lea    0x1000(%edx),%eax
c0002d1d:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0002d20:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002d23:	8d 88 00 10 00 00    	lea    0x1000(%eax),%ecx
c0002d29:	89 4d f4             	mov    %ecx,-0xc(%ebp)
c0002d2c:	83 ec 04             	sub    $0x4,%esp
c0002d2f:	6a 06                	push   $0x6
c0002d31:	52                   	push   %edx
c0002d32:	50                   	push   %eax
c0002d33:	e8 b1 00 00 00       	call   c0002de9 <map_page_at>
c0002d38:	83 c4 10             	add    $0x10,%esp
    for(size_t nn = 0; nn < Npages; nn++)
c0002d3b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0002d3f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002d42:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0002d45:	72 cd                	jb     c0002d14 <init_vga_buffer+0x24>
}
c0002d47:	90                   	nop
c0002d48:	90                   	nop
c0002d49:	c9                   	leave  
c0002d4a:	c3                   	ret    

c0002d4b <map_hardware_buffer>:


int map_hardware_buffer(void* buffer_virtual, void* buffer_physical, size_t buffer_size, uint32_t page_flags)
{
c0002d4b:	55                   	push   %ebp
c0002d4c:	89 e5                	mov    %esp,%ebp
c0002d4e:	83 ec 18             	sub    $0x18,%esp
    //ensure buffers are page-aligned
    if(((size_t) buffer_virtual & ~PAGE_ADDRMASK) || ((size_t) buffer_physical & ~PAGE_ADDRMASK) )
c0002d51:	8b 45 08             	mov    0x8(%ebp),%eax
c0002d54:	25 ff 0f 00 00       	and    $0xfff,%eax
c0002d59:	85 c0                	test   %eax,%eax
c0002d5b:	75 0c                	jne    c0002d69 <map_hardware_buffer+0x1e>
c0002d5d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002d60:	25 ff 0f 00 00       	and    $0xfff,%eax
c0002d65:	85 c0                	test   %eax,%eax
c0002d67:	74 07                	je     c0002d70 <map_hardware_buffer+0x25>
        return -1;
c0002d69:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002d6e:	eb 77                	jmp    c0002de7 <map_hardware_buffer+0x9c>

    //ensure virtual address is in kernel space
    if(buffer_virtual < (void*) KERNEL_BASE)
c0002d70:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
c0002d77:	77 07                	ja     c0002d80 <map_hardware_buffer+0x35>
        return -1;
c0002d79:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002d7e:	eb 67                	jmp    c0002de7 <map_hardware_buffer+0x9c>

    page_t* page = (page_t*) buffer_virtual;
c0002d80:	8b 45 08             	mov    0x8(%ebp),%eax
c0002d83:	89 45 f4             	mov    %eax,-0xc(%ebp)
    page_t* frame = (page_t*) buffer_physical;
c0002d86:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002d89:	89 45 f0             	mov    %eax,-0x10(%ebp)

    size_t Npages = (buffer_size + PAGE_SIZE - 1) >> 12;
c0002d8c:	8b 45 10             	mov    0x10(%ebp),%eax
c0002d8f:	05 ff 0f 00 00       	add    $0xfff,%eax
c0002d94:	c1 e8 0c             	shr    $0xc,%eax
c0002d97:	89 45 e8             	mov    %eax,-0x18(%ebp)
    for(size_t nn = 0; nn < Npages; nn++)
c0002d9a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0002da1:	eb 37                	jmp    c0002dda <map_hardware_buffer+0x8f>
        if(!map_page_at(page++,frame++, page_flags)) return -1;
c0002da3:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0002da6:	8d 82 00 10 00 00    	lea    0x1000(%edx),%eax
c0002dac:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0002daf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002db2:	8d 88 00 10 00 00    	lea    0x1000(%eax),%ecx
c0002db8:	89 4d f4             	mov    %ecx,-0xc(%ebp)
c0002dbb:	83 ec 04             	sub    $0x4,%esp
c0002dbe:	ff 75 14             	pushl  0x14(%ebp)
c0002dc1:	52                   	push   %edx
c0002dc2:	50                   	push   %eax
c0002dc3:	e8 21 00 00 00       	call   c0002de9 <map_page_at>
c0002dc8:	83 c4 10             	add    $0x10,%esp
c0002dcb:	85 c0                	test   %eax,%eax
c0002dcd:	75 07                	jne    c0002dd6 <map_hardware_buffer+0x8b>
c0002dcf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002dd4:	eb 11                	jmp    c0002de7 <map_hardware_buffer+0x9c>
    for(size_t nn = 0; nn < Npages; nn++)
c0002dd6:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0002dda:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002ddd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0002de0:	72 c1                	jb     c0002da3 <map_hardware_buffer+0x58>
    
    return 0;
c0002de2:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002de7:	c9                   	leave  
c0002de8:	c3                   	ret    

c0002de9 <map_page_at>:


page_t* map_page_at(page_t* page, page_t* frame, uint32_t flags)
{
c0002de9:	55                   	push   %ebp
c0002dea:	89 e5                	mov    %esp,%ebp
c0002dec:	53                   	push   %ebx
c0002ded:	83 ec 14             	sub    $0x14,%esp
    page_table_t* pt = get_table(page);
c0002df0:	83 ec 0c             	sub    $0xc,%esp
c0002df3:	ff 75 08             	pushl  0x8(%ebp)
c0002df6:	e8 e7 f9 ff ff       	call   c00027e2 <get_table>
c0002dfb:	83 c4 10             	add    $0x10,%esp
c0002dfe:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(!pt)
c0002e01:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002e05:	75 10                	jne    c0002e17 <map_page_at+0x2e>
    {
        // we are setting up all the page tables for kernel space (>0xc0000000) at boot,
        // so if a PT missing theres a problem
        panic("Kernel page table missing!");
c0002e07:	83 ec 0c             	sub    $0xc,%esp
c0002e0a:	68 fd 56 00 c0       	push   $0xc00056fd
c0002e0f:	e8 ee e8 ff ff       	call   c0001702 <panic>
c0002e14:	83 c4 10             	add    $0x10,%esp
        // pt = new_page_table(page, flags); // page table is not present, allocate a new one
    }
    
    if(pt->pte[get_ptindex(page)] & PAGE_FLAG_PRESENT)
c0002e17:	83 ec 0c             	sub    $0xc,%esp
c0002e1a:	ff 75 08             	pushl  0x8(%ebp)
c0002e1d:	e8 8b fa ff ff       	call   c00028ad <get_ptindex>
c0002e22:	83 c4 10             	add    $0x10,%esp
c0002e25:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002e28:	8b 04 82             	mov    (%edx,%eax,4),%eax
c0002e2b:	83 e0 01             	and    $0x1,%eax
c0002e2e:	85 c0                	test   %eax,%eax
c0002e30:	74 07                	je     c0002e39 <map_page_at+0x50>
        return NULL; //page already mapped
c0002e32:	b8 00 00 00 00       	mov    $0x0,%eax
c0002e37:	eb 37                	jmp    c0002e70 <map_page_at+0x87>

    // map page
    pt->pte[get_ptindex(page)] = (((uint32_t) frame) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0002e39:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002e3c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002e41:	0b 45 10             	or     0x10(%ebp),%eax
c0002e44:	89 c3                	mov    %eax,%ebx
c0002e46:	83 ec 0c             	sub    $0xc,%esp
c0002e49:	ff 75 08             	pushl  0x8(%ebp)
c0002e4c:	e8 5c fa ff ff       	call   c00028ad <get_ptindex>
c0002e51:	83 c4 10             	add    $0x10,%esp
c0002e54:	89 d9                	mov    %ebx,%ecx
c0002e56:	83 c9 01             	or     $0x1,%ecx
c0002e59:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002e5c:	89 0c 82             	mov    %ecx,(%edx,%eax,4)

    refresh_page(page);
c0002e5f:	83 ec 0c             	sub    $0xc,%esp
c0002e62:	ff 75 08             	pushl  0x8(%ebp)
c0002e65:	e8 ba 11 00 00       	call   c0004024 <refresh_page>
c0002e6a:	83 c4 10             	add    $0x10,%esp
    return page;
c0002e6d:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0002e70:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0002e73:	c9                   	leave  
c0002e74:	c3                   	ret    

c0002e75 <map_page>:

page_t* map_page(page_t* page, uint32_t flags)
{
c0002e75:	55                   	push   %ebp
c0002e76:	89 e5                	mov    %esp,%ebp
c0002e78:	83 ec 08             	sub    $0x8,%esp
    return map_page_at(page, pop_free_frame(), flags);
c0002e7b:	e8 8d fa ff ff       	call   c000290d <pop_free_frame>
c0002e80:	83 ec 04             	sub    $0x4,%esp
c0002e83:	ff 75 0c             	pushl  0xc(%ebp)
c0002e86:	50                   	push   %eax
c0002e87:	ff 75 08             	pushl  0x8(%ebp)
c0002e8a:	e8 5a ff ff ff       	call   c0002de9 <map_page_at>
c0002e8f:	83 c4 10             	add    $0x10,%esp
}
c0002e92:	c9                   	leave  
c0002e93:	c3                   	ret    

c0002e94 <unmap_page>:

int unmap_page(page_t* page)
{
c0002e94:	55                   	push   %ebp
c0002e95:	89 e5                	mov    %esp,%ebp
c0002e97:	83 ec 08             	sub    $0x8,%esp
    return push_free_frame(get_physaddr(page));
c0002e9a:	83 ec 0c             	sub    $0xc,%esp
c0002e9d:	ff 75 08             	pushl  0x8(%ebp)
c0002ea0:	e8 8d f9 ff ff       	call   c0002832 <get_physaddr>
c0002ea5:	83 c4 10             	add    $0x10,%esp
c0002ea8:	83 ec 0c             	sub    $0xc,%esp
c0002eab:	50                   	push   %eax
c0002eac:	e8 90 fa ff ff       	call   c0002941 <push_free_frame>
c0002eb1:	83 c4 10             	add    $0x10,%esp
}
c0002eb4:	c9                   	leave  
c0002eb5:	c3                   	ret    

c0002eb6 <new_page_table>:

page_table_t* new_page_table(void* addr, uint32_t flags)
{
c0002eb6:	55                   	push   %ebp
c0002eb7:	89 e5                	mov    %esp,%ebp
c0002eb9:	83 ec 18             	sub    $0x18,%esp
    uint32_t pdindex = get_pdindex(addr);      // index into page dir (which table does this address point to)
c0002ebc:	ff 75 08             	pushl  0x8(%ebp)
c0002ebf:	e8 f9 f9 ff ff       	call   c00028bd <get_pdindex>
c0002ec4:	83 c4 04             	add    $0x4,%esp
c0002ec7:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // is this table already mapped?
    if(pd->dir.pde[pdindex] & PAGE_FLAG_PRESENT)
c0002eca:	a1 00 60 00 c0       	mov    0xc0006000,%eax
c0002ecf:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002ed2:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c0002ed8:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0002edb:	83 e0 01             	and    $0x1,%eax
c0002ede:	85 c0                	test   %eax,%eax
c0002ee0:	74 07                	je     c0002ee9 <new_page_table+0x33>
        return NULL;
c0002ee2:	b8 00 00 00 00       	mov    $0x0,%eax
c0002ee7:	eb 70                	jmp    c0002f59 <new_page_table+0xa3>

    page_t* pp = pop_free_frame();         // find a free page in physical mem for page table
c0002ee9:	e8 1f fa ff ff       	call   c000290d <pop_free_frame>
c0002eee:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!pp) return NULL; // OOM
c0002ef1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0002ef5:	75 07                	jne    c0002efe <new_page_table+0x48>
c0002ef7:	b8 00 00 00 00       	mov    $0x0,%eax
c0002efc:	eb 5b                	jmp    c0002f59 <new_page_table+0xa3>

    // we don't need to allocate virtual memory space, since table lives in our paging structure
    page_table_t* pv = pd->tables + pdindex;        // pointer to table (virtual)
c0002efe:	a1 00 60 00 c0       	mov    0xc0006000,%eax
c0002f03:	89 c2                	mov    %eax,%edx
c0002f05:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002f08:	c1 e0 0c             	shl    $0xc,%eax
c0002f0b:	01 d0                	add    %edx,%eax
c0002f0d:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // map table: point the pd entry at the physical page we just reserved, and set flags
    pd->dir.pde[pdindex] = (((uint32_t) pp) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0002f10:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002f13:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002f18:	0b 45 0c             	or     0xc(%ebp),%eax
c0002f1b:	89 c2                	mov    %eax,%edx
c0002f1d:	a1 00 60 00 c0       	mov    0xc0006000,%eax
c0002f22:	89 d1                	mov    %edx,%ecx
c0002f24:	83 c9 01             	or     $0x1,%ecx
c0002f27:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002f2a:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c0002f30:	89 0c 90             	mov    %ecx,(%eax,%edx,4)

    // flush the tlb
    refresh_page(pv);
c0002f33:	83 ec 0c             	sub    $0xc,%esp
c0002f36:	ff 75 ec             	pushl  -0x14(%ebp)
c0002f39:	e8 e6 10 00 00       	call   c0004024 <refresh_page>
c0002f3e:	83 c4 10             	add    $0x10,%esp

    //clear table
    memset((char*) pv, 0, PAGE_SIZE);     
c0002f41:	83 ec 04             	sub    $0x4,%esp
c0002f44:	68 00 10 00 00       	push   $0x1000
c0002f49:	6a 00                	push   $0x0
c0002f4b:	ff 75 ec             	pushl  -0x14(%ebp)
c0002f4e:	e8 91 e8 ff ff       	call   c00017e4 <memset>
c0002f53:	83 c4 10             	add    $0x10,%esp

    // return pointer to table (virtual)
    return pv;
c0002f56:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c0002f59:	c9                   	leave  
c0002f5a:	c3                   	ret    

c0002f5b <print_testresult>:

#include "test.h"
#include "kprintf.h"

int print_testresult(int status, char* message)
{
c0002f5b:	55                   	push   %ebp
c0002f5c:	89 e5                	mov    %esp,%ebp
c0002f5e:	83 ec 18             	sub    $0x18,%esp
    uint8_t color = terminal_getcolor(&stdout);
c0002f61:	83 ec 0c             	sub    $0xc,%esp
c0002f64:	68 00 70 00 c0       	push   $0xc0007000
c0002f69:	e8 1a d6 ff ff       	call   c0000588 <terminal_getcolor>
c0002f6e:	83 c4 10             	add    $0x10,%esp
c0002f71:	88 45 f7             	mov    %al,-0x9(%ebp)
    kprintf("[");
c0002f74:	83 ec 0c             	sub    $0xc,%esp
c0002f77:	68 18 57 00 c0       	push   $0xc0005718
c0002f7c:	e8 64 d9 ff ff       	call   c00008e5 <kprintf>
c0002f81:	83 c4 10             	add    $0x10,%esp
    if(status)
c0002f84:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002f88:	74 24                	je     c0002fae <print_testresult+0x53>
    {
        terminal_setcolor(&stdout, VGA_COLOR_RED);
c0002f8a:	83 ec 08             	sub    $0x8,%esp
c0002f8d:	6a 04                	push   $0x4
c0002f8f:	68 00 70 00 c0       	push   $0xc0007000
c0002f94:	e8 d6 d5 ff ff       	call   c000056f <terminal_setcolor>
c0002f99:	83 c4 10             	add    $0x10,%esp
        kprintf("FAILED");
c0002f9c:	83 ec 0c             	sub    $0xc,%esp
c0002f9f:	68 1a 57 00 c0       	push   $0xc000571a
c0002fa4:	e8 3c d9 ff ff       	call   c00008e5 <kprintf>
c0002fa9:	83 c4 10             	add    $0x10,%esp
c0002fac:	eb 22                	jmp    c0002fd0 <print_testresult+0x75>
    }
    else
    {
        terminal_setcolor(&stdout, VGA_COLOR_GREEN);
c0002fae:	83 ec 08             	sub    $0x8,%esp
c0002fb1:	6a 02                	push   $0x2
c0002fb3:	68 00 70 00 c0       	push   $0xc0007000
c0002fb8:	e8 b2 d5 ff ff       	call   c000056f <terminal_setcolor>
c0002fbd:	83 c4 10             	add    $0x10,%esp
        kprintf("SUCCESS");
c0002fc0:	83 ec 0c             	sub    $0xc,%esp
c0002fc3:	68 21 57 00 c0       	push   $0xc0005721
c0002fc8:	e8 18 d9 ff ff       	call   c00008e5 <kprintf>
c0002fcd:	83 c4 10             	add    $0x10,%esp
    }

    terminal_setcolor(&stdout, color);
c0002fd0:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0002fd4:	83 ec 08             	sub    $0x8,%esp
c0002fd7:	50                   	push   %eax
c0002fd8:	68 00 70 00 c0       	push   $0xc0007000
c0002fdd:	e8 8d d5 ff ff       	call   c000056f <terminal_setcolor>
c0002fe2:	83 c4 10             	add    $0x10,%esp
    kprintf("] ");
c0002fe5:	83 ec 0c             	sub    $0xc,%esp
c0002fe8:	68 29 57 00 c0       	push   $0xc0005729
c0002fed:	e8 f3 d8 ff ff       	call   c00008e5 <kprintf>
c0002ff2:	83 c4 10             	add    $0x10,%esp

    kprintf(message);
c0002ff5:	83 ec 0c             	sub    $0xc,%esp
c0002ff8:	ff 75 0c             	pushl  0xc(%ebp)
c0002ffb:	e8 e5 d8 ff ff       	call   c00008e5 <kprintf>
c0003000:	83 c4 10             	add    $0x10,%esp
    kprintf("\n");
c0003003:	83 ec 0c             	sub    $0xc,%esp
c0003006:	68 2c 57 00 c0       	push   $0xc000572c
c000300b:	e8 d5 d8 ff ff       	call   c00008e5 <kprintf>
c0003010:	83 c4 10             	add    $0x10,%esp
    
    return status;
c0003013:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0003016:	c9                   	leave  
c0003017:	c3                   	ret    

c0003018 <kheap_validate_block>:
int kheap_size(size_t* allocated, size_t* free);


// check magic number
static inline int kheap_validate_block(heap_block_t* b)
{
c0003018:	55                   	push   %ebp
c0003019:	89 e5                	mov    %esp,%ebp
    return b->magic != HEAP_BLOCK_MAGIC;
c000301b:	8b 45 08             	mov    0x8(%ebp),%eax
c000301e:	8b 00                	mov    (%eax),%eax
c0003020:	25 ff ff ff 0f       	and    $0xfffffff,%eax
c0003025:	3d ef be 23 01       	cmp    $0x123beef,%eax
c000302a:	0f 95 c0             	setne  %al
c000302d:	0f b6 c0             	movzbl %al,%eax
}
c0003030:	5d                   	pop    %ebp
c0003031:	c3                   	ret    

c0003032 <align_int>:
{
c0003032:	55                   	push   %ebp
c0003033:	89 e5                	mov    %esp,%ebp
c0003035:	83 ec 10             	sub    $0x10,%esp
    size_t am = alignment - 1;
c0003038:	8b 45 0c             	mov    0xc(%ebp),%eax
c000303b:	83 e8 01             	sub    $0x1,%eax
c000303e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (((size_t)len + am) & ~am);
c0003041:	8b 55 08             	mov    0x8(%ebp),%edx
c0003044:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003047:	01 c2                	add    %eax,%edx
c0003049:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000304c:	f7 d0                	not    %eax
c000304e:	21 d0                	and    %edx,%eax
}
c0003050:	c9                   	leave  
c0003051:	c3                   	ret    

c0003052 <align_ptr>:
{
c0003052:	55                   	push   %ebp
c0003053:	89 e5                	mov    %esp,%ebp
    if(alignment % sizeof(void*) != 0 ) return NULL;
c0003055:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003058:	83 e0 03             	and    $0x3,%eax
c000305b:	85 c0                	test   %eax,%eax
c000305d:	74 07                	je     c0003066 <align_ptr+0x14>
c000305f:	b8 00 00 00 00       	mov    $0x0,%eax
c0003064:	eb 0f                	jmp    c0003075 <align_ptr+0x23>
    return (void*) align_int((size_t) addr, alignment);
c0003066:	8b 45 08             	mov    0x8(%ebp),%eax
c0003069:	ff 75 0c             	pushl  0xc(%ebp)
c000306c:	50                   	push   %eax
c000306d:	e8 c0 ff ff ff       	call   c0003032 <align_int>
c0003072:	83 c4 08             	add    $0x8,%esp
}
c0003075:	c9                   	leave  
c0003076:	c3                   	ret    

c0003077 <kmalloc_init>:
#include "common.h"

heap_block_t* kheap_head = NULL;

int kmalloc_init()
{
c0003077:	55                   	push   %ebp
c0003078:	89 e5                	mov    %esp,%ebp
c000307a:	83 ec 08             	sub    $0x8,%esp
    kheap_head = ksbrk(HEAP_INCREMENT);
c000307d:	83 ec 0c             	sub    $0xc,%esp
c0003080:	68 00 40 00 00       	push   $0x4000
c0003085:	e8 fb fa ff ff       	call   c0002b85 <ksbrk>
c000308a:	83 c4 10             	add    $0x10,%esp
c000308d:	a3 a4 78 00 c0       	mov    %eax,0xc00078a4
   
    if(!kheap_head)
c0003092:	a1 a4 78 00 c0       	mov    0xc00078a4,%eax
c0003097:	85 c0                	test   %eax,%eax
c0003099:	75 0a                	jne    c00030a5 <kmalloc_init+0x2e>
        return -1;
c000309b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00030a0:	e9 95 00 00 00       	jmp    c000313a <kmalloc_init+0xc3>

    kheap_head = align_ptr(kheap_head,HEAP_BLOCKSIZE_UNITS);
c00030a5:	a1 a4 78 00 c0       	mov    0xc00078a4,%eax
c00030aa:	83 ec 08             	sub    $0x8,%esp
c00030ad:	6a 10                	push   $0x10
c00030af:	50                   	push   %eax
c00030b0:	e8 9d ff ff ff       	call   c0003052 <align_ptr>
c00030b5:	83 c4 10             	add    $0x10,%esp
c00030b8:	a3 a4 78 00 c0       	mov    %eax,0xc00078a4

    kheap_head->magic = HEAP_BLOCK_MAGIC;
c00030bd:	a1 a4 78 00 c0       	mov    0xc00078a4,%eax
c00030c2:	8b 10                	mov    (%eax),%edx
c00030c4:	81 e2 00 00 00 f0    	and    $0xf0000000,%edx
c00030ca:	81 ca ef be 23 01    	or     $0x123beef,%edx
c00030d0:	89 10                	mov    %edx,(%eax)
    kheap_head->status = HEAP_BLOCK_FREE;
c00030d2:	a1 a4 78 00 c0       	mov    0xc00078a4,%eax
c00030d7:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c00030db:	83 e2 0f             	and    $0xf,%edx
c00030de:	88 50 03             	mov    %dl,0x3(%eax)
    kheap_head->prev = kheap_head;
c00030e1:	a1 a4 78 00 c0       	mov    0xc00078a4,%eax
c00030e6:	8b 15 a4 78 00 c0    	mov    0xc00078a4,%edx
c00030ec:	89 50 04             	mov    %edx,0x4(%eax)
    kheap_head->next = kheap_head;
c00030ef:	a1 a4 78 00 c0       	mov    0xc00078a4,%eax
c00030f4:	8b 15 a4 78 00 c0    	mov    0xc00078a4,%edx
c00030fa:	89 50 08             	mov    %edx,0x8(%eax)

    kheap_head->size = ((heap_block_t*) ksbrk(0)) - kheap_head;
c00030fd:	83 ec 0c             	sub    $0xc,%esp
c0003100:	6a 00                	push   $0x0
c0003102:	e8 7e fa ff ff       	call   c0002b85 <ksbrk>
c0003107:	83 c4 10             	add    $0x10,%esp
c000310a:	8b 15 a4 78 00 c0    	mov    0xc00078a4,%edx
c0003110:	29 d0                	sub    %edx,%eax
c0003112:	c1 f8 04             	sar    $0x4,%eax
c0003115:	89 c2                	mov    %eax,%edx
c0003117:	a1 a4 78 00 c0       	mov    0xc00078a4,%eax
c000311c:	89 50 0c             	mov    %edx,0xc(%eax)

    if(kheap_head->size < HEAP_INCREMENT/HEAP_BLOCKSIZE_UNITS)
c000311f:	a1 a4 78 00 c0       	mov    0xc00078a4,%eax
c0003124:	8b 40 0c             	mov    0xc(%eax),%eax
c0003127:	3d ff 03 00 00       	cmp    $0x3ff,%eax
c000312c:	77 07                	ja     c0003135 <kmalloc_init+0xbe>
        return -1;    
c000312e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003133:	eb 05                	jmp    c000313a <kmalloc_init+0xc3>

    return 0;    
c0003135:	b8 00 00 00 00       	mov    $0x0,%eax
}
c000313a:	c9                   	leave  
c000313b:	c3                   	ret    

c000313c <kheap_insert_block>:

// insert new_block into LL between b and b->next
// return 0 on success 
int kheap_insert_block(heap_block_t* b, heap_block_t* new_block)
{
c000313c:	55                   	push   %ebp
c000313d:	89 e5                	mov    %esp,%ebp
c000313f:	83 ec 08             	sub    $0x8,%esp
    
    if(kheap_validate_block(b) || kheap_validate_block(new_block))
c0003142:	ff 75 08             	pushl  0x8(%ebp)
c0003145:	e8 ce fe ff ff       	call   c0003018 <kheap_validate_block>
c000314a:	83 c4 04             	add    $0x4,%esp
c000314d:	85 c0                	test   %eax,%eax
c000314f:	75 0f                	jne    c0003160 <kheap_insert_block+0x24>
c0003151:	ff 75 0c             	pushl  0xc(%ebp)
c0003154:	e8 bf fe ff ff       	call   c0003018 <kheap_validate_block>
c0003159:	83 c4 04             	add    $0x4,%esp
c000315c:	85 c0                	test   %eax,%eax
c000315e:	74 17                	je     c0003177 <kheap_insert_block+0x3b>
    {
        panic("kernel heap corrupted");
c0003160:	83 ec 0c             	sub    $0xc,%esp
c0003163:	68 30 57 00 c0       	push   $0xc0005730
c0003168:	e8 95 e5 ff ff       	call   c0001702 <panic>
c000316d:	83 c4 10             	add    $0x10,%esp
        return -1;
c0003170:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003175:	eb 2f                	jmp    c00031a6 <kheap_insert_block+0x6a>
    }

    new_block->prev = b;
c0003177:	8b 45 0c             	mov    0xc(%ebp),%eax
c000317a:	8b 55 08             	mov    0x8(%ebp),%edx
c000317d:	89 50 04             	mov    %edx,0x4(%eax)
    new_block->next = b->next;            
c0003180:	8b 45 08             	mov    0x8(%ebp),%eax
c0003183:	8b 50 08             	mov    0x8(%eax),%edx
c0003186:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003189:	89 50 08             	mov    %edx,0x8(%eax)
    b->next->prev = new_block;
c000318c:	8b 45 08             	mov    0x8(%ebp),%eax
c000318f:	8b 40 08             	mov    0x8(%eax),%eax
c0003192:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003195:	89 50 04             	mov    %edx,0x4(%eax)
    b->next = new_block;
c0003198:	8b 45 08             	mov    0x8(%ebp),%eax
c000319b:	8b 55 0c             	mov    0xc(%ebp),%edx
c000319e:	89 50 08             	mov    %edx,0x8(%eax)

    return 0;
c00031a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00031a6:	c9                   	leave  
c00031a7:	c3                   	ret    

c00031a8 <kheap_delete_block>:


// remove block b from LL
// return pointer to previous block, NULL on error
heap_block_t* kheap_delete_block(heap_block_t* b)
{
c00031a8:	55                   	push   %ebp
c00031a9:	89 e5                	mov    %esp,%ebp
c00031ab:	83 ec 08             	sub    $0x8,%esp
    if(kheap_validate_block(b->prev) || kheap_validate_block(b->next))
c00031ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00031b1:	8b 40 04             	mov    0x4(%eax),%eax
c00031b4:	50                   	push   %eax
c00031b5:	e8 5e fe ff ff       	call   c0003018 <kheap_validate_block>
c00031ba:	83 c4 04             	add    $0x4,%esp
c00031bd:	85 c0                	test   %eax,%eax
c00031bf:	75 13                	jne    c00031d4 <kheap_delete_block+0x2c>
c00031c1:	8b 45 08             	mov    0x8(%ebp),%eax
c00031c4:	8b 40 08             	mov    0x8(%eax),%eax
c00031c7:	50                   	push   %eax
c00031c8:	e8 4b fe ff ff       	call   c0003018 <kheap_validate_block>
c00031cd:	83 c4 04             	add    $0x4,%esp
c00031d0:	85 c0                	test   %eax,%eax
c00031d2:	74 17                	je     c00031eb <kheap_delete_block+0x43>
    {
        panic("kernel heap corrupted");
c00031d4:	83 ec 0c             	sub    $0xc,%esp
c00031d7:	68 30 57 00 c0       	push   $0xc0005730
c00031dc:	e8 21 e5 ff ff       	call   c0001702 <panic>
c00031e1:	83 c4 10             	add    $0x10,%esp
        return NULL;
c00031e4:	b8 00 00 00 00       	mov    $0x0,%eax
c00031e9:	eb 24                	jmp    c000320f <kheap_delete_block+0x67>
    }

    b->prev->next = b->next;
c00031eb:	8b 45 08             	mov    0x8(%ebp),%eax
c00031ee:	8b 40 04             	mov    0x4(%eax),%eax
c00031f1:	8b 55 08             	mov    0x8(%ebp),%edx
c00031f4:	8b 52 08             	mov    0x8(%edx),%edx
c00031f7:	89 50 08             	mov    %edx,0x8(%eax)
    b->next->prev = b->prev;
c00031fa:	8b 45 08             	mov    0x8(%ebp),%eax
c00031fd:	8b 40 08             	mov    0x8(%eax),%eax
c0003200:	8b 55 08             	mov    0x8(%ebp),%edx
c0003203:	8b 52 04             	mov    0x4(%edx),%edx
c0003206:	89 50 04             	mov    %edx,0x4(%eax)

    return b->prev;
c0003209:	8b 45 08             	mov    0x8(%ebp),%eax
c000320c:	8b 40 04             	mov    0x4(%eax),%eax
}
c000320f:	c9                   	leave  
c0003210:	c3                   	ret    

c0003211 <kheap_free_block>:

// free block and merge with free neighbors
// return ptr to new free block
heap_block_t* kheap_free_block(heap_block_t* b)
{
c0003211:	55                   	push   %ebp
c0003212:	89 e5                	mov    %esp,%ebp
c0003214:	83 ec 08             	sub    $0x8,%esp
    //check magic numbers to make sure theres no overrun
    if(kheap_validate_block(b))
c0003217:	ff 75 08             	pushl  0x8(%ebp)
c000321a:	e8 f9 fd ff ff       	call   c0003018 <kheap_validate_block>
c000321f:	83 c4 04             	add    $0x4,%esp
c0003222:	85 c0                	test   %eax,%eax
c0003224:	74 1a                	je     c0003240 <kheap_free_block+0x2f>
    {
        panic("kernel heap corrupted");
c0003226:	83 ec 0c             	sub    $0xc,%esp
c0003229:	68 30 57 00 c0       	push   $0xc0005730
c000322e:	e8 cf e4 ff ff       	call   c0001702 <panic>
c0003233:	83 c4 10             	add    $0x10,%esp
        return NULL;
c0003236:	b8 00 00 00 00       	mov    $0x0,%eax
c000323b:	e9 b4 00 00 00       	jmp    c00032f4 <kheap_free_block+0xe3>
    }

    // make sure this block isnt already free allocated
    if(b->status == HEAP_BLOCK_FREE)
c0003240:	8b 45 08             	mov    0x8(%ebp),%eax
c0003243:	0f b6 40 03          	movzbl 0x3(%eax),%eax
c0003247:	83 e0 f0             	and    $0xfffffff0,%eax
c000324a:	84 c0                	test   %al,%al
c000324c:	75 0a                	jne    c0003258 <kheap_free_block+0x47>
        return NULL;
c000324e:	b8 00 00 00 00       	mov    $0x0,%eax
c0003253:	e9 9c 00 00 00       	jmp    c00032f4 <kheap_free_block+0xe3>

    b->status = HEAP_BLOCK_FREE;
c0003258:	8b 45 08             	mov    0x8(%ebp),%eax
c000325b:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c000325f:	83 e2 0f             	and    $0xf,%edx
c0003262:	88 50 03             	mov    %dl,0x3(%eax)

    //merge with next block if free
    if(b->next == HEAP_BLOCK_FREE && b->next != kheap_head)
c0003265:	8b 45 08             	mov    0x8(%ebp),%eax
c0003268:	8b 40 08             	mov    0x8(%eax),%eax
c000326b:	85 c0                	test   %eax,%eax
c000326d:	75 43                	jne    c00032b2 <kheap_free_block+0xa1>
c000326f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003272:	8b 50 08             	mov    0x8(%eax),%edx
c0003275:	a1 a4 78 00 c0       	mov    0xc00078a4,%eax
c000327a:	39 c2                	cmp    %eax,%edx
c000327c:	74 34                	je     c00032b2 <kheap_free_block+0xa1>
    {
        b->size += b->next->size;
c000327e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003281:	8b 50 0c             	mov    0xc(%eax),%edx
c0003284:	8b 45 08             	mov    0x8(%ebp),%eax
c0003287:	8b 40 08             	mov    0x8(%eax),%eax
c000328a:	8b 40 0c             	mov    0xc(%eax),%eax
c000328d:	01 c2                	add    %eax,%edx
c000328f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003292:	89 50 0c             	mov    %edx,0xc(%eax)
        if(!kheap_delete_block(b->next)) return NULL;
c0003295:	8b 45 08             	mov    0x8(%ebp),%eax
c0003298:	8b 40 08             	mov    0x8(%eax),%eax
c000329b:	83 ec 0c             	sub    $0xc,%esp
c000329e:	50                   	push   %eax
c000329f:	e8 04 ff ff ff       	call   c00031a8 <kheap_delete_block>
c00032a4:	83 c4 10             	add    $0x10,%esp
c00032a7:	85 c0                	test   %eax,%eax
c00032a9:	75 07                	jne    c00032b2 <kheap_free_block+0xa1>
c00032ab:	b8 00 00 00 00       	mov    $0x0,%eax
c00032b0:	eb 42                	jmp    c00032f4 <kheap_free_block+0xe3>
    }

    //merge with previous block if free, and set b = b->prev
    if(b->prev == HEAP_BLOCK_FREE && b != kheap_head)
c00032b2:	8b 45 08             	mov    0x8(%ebp),%eax
c00032b5:	8b 40 04             	mov    0x4(%eax),%eax
c00032b8:	85 c0                	test   %eax,%eax
c00032ba:	75 35                	jne    c00032f1 <kheap_free_block+0xe0>
c00032bc:	a1 a4 78 00 c0       	mov    0xc00078a4,%eax
c00032c1:	39 45 08             	cmp    %eax,0x8(%ebp)
c00032c4:	74 2b                	je     c00032f1 <kheap_free_block+0xe0>
    {
        b->prev->size += b->size;
c00032c6:	8b 45 08             	mov    0x8(%ebp),%eax
c00032c9:	8b 40 04             	mov    0x4(%eax),%eax
c00032cc:	8b 48 0c             	mov    0xc(%eax),%ecx
c00032cf:	8b 45 08             	mov    0x8(%ebp),%eax
c00032d2:	8b 50 0c             	mov    0xc(%eax),%edx
c00032d5:	8b 45 08             	mov    0x8(%ebp),%eax
c00032d8:	8b 40 04             	mov    0x4(%eax),%eax
c00032db:	01 ca                	add    %ecx,%edx
c00032dd:	89 50 0c             	mov    %edx,0xc(%eax)
        b = kheap_delete_block(b);
c00032e0:	83 ec 0c             	sub    $0xc,%esp
c00032e3:	ff 75 08             	pushl  0x8(%ebp)
c00032e6:	e8 bd fe ff ff       	call   c00031a8 <kheap_delete_block>
c00032eb:	83 c4 10             	add    $0x10,%esp
c00032ee:	89 45 08             	mov    %eax,0x8(%ebp)
    }

    return b;
c00032f1:	8b 45 08             	mov    0x8(%ebp),%eax
}
c00032f4:	c9                   	leave  
c00032f5:	c3                   	ret    

c00032f6 <kheap_split_block>:
// if there is enough extra room, split b into two
// return new size of block on successful split (in HEAP_BLOCKSIZE_UNITS)
// return 0 on insufficinet size for splitting into new block (b->size < size+1)
// return <0 on error
int kheap_split_block(heap_block_t* b, size_t size)
{
c00032f6:	55                   	push   %ebp
c00032f7:	89 e5                	mov    %esp,%ebp
c00032f9:	83 ec 18             	sub    $0x18,%esp
    //check magic numbers to make sure theres no overrun
    if(kheap_validate_block(b))
c00032fc:	ff 75 08             	pushl  0x8(%ebp)
c00032ff:	e8 14 fd ff ff       	call   c0003018 <kheap_validate_block>
c0003304:	83 c4 04             	add    $0x4,%esp
c0003307:	85 c0                	test   %eax,%eax
c0003309:	74 1a                	je     c0003325 <kheap_split_block+0x2f>
    {
        panic("kernel heap corrupted");
c000330b:	83 ec 0c             	sub    $0xc,%esp
c000330e:	68 30 57 00 c0       	push   $0xc0005730
c0003313:	e8 ea e3 ff ff       	call   c0001702 <panic>
c0003318:	83 c4 10             	add    $0x10,%esp
        return -1;
c000331b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003320:	e9 83 00 00 00       	jmp    c00033a8 <kheap_split_block+0xb2>
    }

    if(b->size < size + 1 ) return 0;
c0003325:	8b 45 08             	mov    0x8(%ebp),%eax
c0003328:	8b 40 0c             	mov    0xc(%eax),%eax
c000332b:	8b 55 0c             	mov    0xc(%ebp),%edx
c000332e:	83 c2 01             	add    $0x1,%edx
c0003331:	39 d0                	cmp    %edx,%eax
c0003333:	73 07                	jae    c000333c <kheap_split_block+0x46>
c0003335:	b8 00 00 00 00       	mov    $0x0,%eax
c000333a:	eb 6c                	jmp    c00033a8 <kheap_split_block+0xb2>

    // create new empty block
    heap_block_t* new_block = b + size;
c000333c:	8b 45 0c             	mov    0xc(%ebp),%eax
c000333f:	c1 e0 04             	shl    $0x4,%eax
c0003342:	89 c2                	mov    %eax,%edx
c0003344:	8b 45 08             	mov    0x8(%ebp),%eax
c0003347:	01 d0                	add    %edx,%eax
c0003349:	89 45 f4             	mov    %eax,-0xc(%ebp)
    new_block->magic = HEAP_BLOCK_MAGIC;
c000334c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000334f:	8b 10                	mov    (%eax),%edx
c0003351:	81 e2 00 00 00 f0    	and    $0xf0000000,%edx
c0003357:	81 ca ef be 23 01    	or     $0x123beef,%edx
c000335d:	89 10                	mov    %edx,(%eax)
    new_block->status = HEAP_BLOCK_FREE;
c000335f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003362:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c0003366:	83 e2 0f             	and    $0xf,%edx
c0003369:	88 50 03             	mov    %dl,0x3(%eax)
    new_block->size = b->size - size;
c000336c:	8b 45 08             	mov    0x8(%ebp),%eax
c000336f:	8b 40 0c             	mov    0xc(%eax),%eax
c0003372:	2b 45 0c             	sub    0xc(%ebp),%eax
c0003375:	89 c2                	mov    %eax,%edx
c0003377:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000337a:	89 50 0c             	mov    %edx,0xc(%eax)

    // insert new block to into LL after b
    if(kheap_insert_block(b,new_block)) return -1;
c000337d:	83 ec 08             	sub    $0x8,%esp
c0003380:	ff 75 f4             	pushl  -0xc(%ebp)
c0003383:	ff 75 08             	pushl  0x8(%ebp)
c0003386:	e8 b1 fd ff ff       	call   c000313c <kheap_insert_block>
c000338b:	83 c4 10             	add    $0x10,%esp
c000338e:	85 c0                	test   %eax,%eax
c0003390:	74 07                	je     c0003399 <kheap_split_block+0xa3>
c0003392:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003397:	eb 0f                	jmp    c00033a8 <kheap_split_block+0xb2>

    // shrink b and return new size
    return b->size = size;
c0003399:	8b 45 08             	mov    0x8(%ebp),%eax
c000339c:	8b 55 0c             	mov    0xc(%ebp),%edx
c000339f:	89 50 0c             	mov    %edx,0xc(%eax)
c00033a2:	8b 45 08             	mov    0x8(%ebp),%eax
c00033a5:	8b 40 0c             	mov    0xc(%eax),%eax
}
c00033a8:	c9                   	leave  
c00033a9:	c3                   	ret    

c00033aa <grow_kheap>:

// grow the kernel heap by at least minimum_block_size*HEAP_BLOCKSIZE_UNITS bytes
// and return new tail block that is guaranteeed to be at least minimum_block_size
// return NULL on error or OOM
heap_block_t* grow_kheap(size_t minimum_block_size)
{
c00033aa:	55                   	push   %ebp
c00033ab:	89 e5                	mov    %esp,%ebp
c00033ad:	83 ec 18             	sub    $0x18,%esp
    size_t grow_size = minimum_block_size*HEAP_BLOCKSIZE_UNITS > HEAP_INCREMENT ? minimum_block_size*HEAP_BLOCKSIZE_UNITS : HEAP_INCREMENT;
c00033b0:	8b 45 08             	mov    0x8(%ebp),%eax
c00033b3:	c1 e0 04             	shl    $0x4,%eax
c00033b6:	ba 00 40 00 00       	mov    $0x4000,%edx
c00033bb:	3d 00 40 00 00       	cmp    $0x4000,%eax
c00033c0:	0f 42 c2             	cmovb  %edx,%eax
c00033c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    heap_block_t* new_block = ksbrk(grow_size);
c00033c6:	83 ec 0c             	sub    $0xc,%esp
c00033c9:	ff 75 f4             	pushl  -0xc(%ebp)
c00033cc:	e8 b4 f7 ff ff       	call   c0002b85 <ksbrk>
c00033d1:	83 c4 10             	add    $0x10,%esp
c00033d4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!new_block)
c00033d7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00033db:	75 0a                	jne    c00033e7 <grow_kheap+0x3d>
        return NULL; // error in ksbrk, e.g. out of memory
c00033dd:	b8 00 00 00 00       	mov    $0x0,%eax
c00033e2:	e9 81 00 00 00       	jmp    c0003468 <grow_kheap+0xbe>

    //ksbrk doesnt guarantee properly aligned blocks, so make sure we are aligned
    new_block = align_ptr(new_block,HEAP_BLOCKSIZE_UNITS);
c00033e7:	83 ec 08             	sub    $0x8,%esp
c00033ea:	6a 10                	push   $0x10
c00033ec:	ff 75 f0             	pushl  -0x10(%ebp)
c00033ef:	e8 5e fc ff ff       	call   c0003052 <align_ptr>
c00033f4:	83 c4 10             	add    $0x10,%esp
c00033f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    
    new_block->magic = HEAP_BLOCK_MAGIC;
c00033fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00033fd:	8b 10                	mov    (%eax),%edx
c00033ff:	81 e2 00 00 00 f0    	and    $0xf0000000,%edx
c0003405:	81 ca ef be 23 01    	or     $0x123beef,%edx
c000340b:	89 10                	mov    %edx,(%eax)
    new_block->status = HEAP_BLOCK_FREE;
c000340d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003410:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c0003414:	83 e2 0f             	and    $0xf,%edx
c0003417:	88 50 03             	mov    %dl,0x3(%eax)

    // get end of block from ksbrk(0), and again make sure it is aligned.
    // this time align with a mask so that aligned address is <= ksbrk(0)
    new_block->size = new_block - (heap_block_t*) ( (uint32_t) ksbrk(0) & HEAP_BLOCKSIZE_MASK);
c000341a:	83 ec 0c             	sub    $0xc,%esp
c000341d:	6a 00                	push   $0x0
c000341f:	e8 61 f7 ff ff       	call   c0002b85 <ksbrk>
c0003424:	83 c4 10             	add    $0x10,%esp
c0003427:	83 e0 f0             	and    $0xfffffff0,%eax
c000342a:	89 c2                	mov    %eax,%edx
c000342c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000342f:	29 d0                	sub    %edx,%eax
c0003431:	c1 f8 04             	sar    $0x4,%eax
c0003434:	89 c2                	mov    %eax,%edx
c0003436:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003439:	89 50 0c             	mov    %edx,0xc(%eax)

    //doublecheck that new block is large enough
    if(new_block->size < minimum_block_size) return NULL;
c000343c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000343f:	8b 40 0c             	mov    0xc(%eax),%eax
c0003442:	39 45 08             	cmp    %eax,0x8(%ebp)
c0003445:	76 07                	jbe    c000344e <grow_kheap+0xa4>
c0003447:	b8 00 00 00 00       	mov    $0x0,%eax
c000344c:	eb 1a                	jmp    c0003468 <grow_kheap+0xbe>

    kheap_insert_block(kheap_head->prev, new_block); //add new block to tail
c000344e:	a1 a4 78 00 c0       	mov    0xc00078a4,%eax
c0003453:	8b 40 04             	mov    0x4(%eax),%eax
c0003456:	83 ec 08             	sub    $0x8,%esp
c0003459:	ff 75 f0             	pushl  -0x10(%ebp)
c000345c:	50                   	push   %eax
c000345d:	e8 da fc ff ff       	call   c000313c <kheap_insert_block>
c0003462:	83 c4 10             	add    $0x10,%esp
    return new_block;
c0003465:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0003468:	c9                   	leave  
c0003469:	c3                   	ret    

c000346a <kmalloc>:

void* kmalloc(size_t sz)
{
c000346a:	55                   	push   %ebp
c000346b:	89 e5                	mov    %esp,%ebp
c000346d:	83 ec 18             	sub    $0x18,%esp
    //convert to HEAP_BLOCKSIZE_UNITS, rounding up, and add one for header
    size_t block_size = 1 + (sz+ HEAP_BLOCKSIZE_UNITS -1)/HEAP_BLOCKSIZE_UNITS;
c0003470:	8b 45 08             	mov    0x8(%ebp),%eax
c0003473:	83 c0 0f             	add    $0xf,%eax
c0003476:	c1 e8 04             	shr    $0x4,%eax
c0003479:	83 c0 01             	add    $0x1,%eax
c000347c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    
    if(!kheap_head)
c000347f:	a1 a4 78 00 c0       	mov    0xc00078a4,%eax
c0003484:	85 c0                	test   %eax,%eax
c0003486:	75 19                	jne    c00034a1 <kmalloc+0x37>
    {
        //initialize the heap with some space
        if(kmalloc_init())
c0003488:	e8 ea fb ff ff       	call   c0003077 <kmalloc_init>
c000348d:	85 c0                	test   %eax,%eax
c000348f:	74 10                	je     c00034a1 <kmalloc+0x37>
            panic("Error initializing kernel heap");
c0003491:	83 ec 0c             	sub    $0xc,%esp
c0003494:	68 48 57 00 c0       	push   $0xc0005748
c0003499:	e8 64 e2 ff ff       	call   c0001702 <panic>
c000349e:	83 c4 10             	add    $0x10,%esp
    }

    heap_block_t* block = kheap_head;
c00034a1:	a1 a4 78 00 c0       	mov    0xc00078a4,%eax
c00034a6:	89 45 f4             	mov    %eax,-0xc(%ebp)

    while(block->status != HEAP_BLOCK_FREE || block->size < block_size)
c00034a9:	eb 36                	jmp    c00034e1 <kmalloc+0x77>
    {
        //if we've returned to the head, we have run through the entire list without finding a free block
        if(block->next == kheap_head)
c00034ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00034ae:	8b 50 08             	mov    0x8(%eax),%edx
c00034b1:	a1 a4 78 00 c0       	mov    0xc00078a4,%eax
c00034b6:	39 c2                	cmp    %eax,%edx
c00034b8:	75 1e                	jne    c00034d8 <kmalloc+0x6e>
        {
            //we've reached the end of the heap, so add a new block at the end
            block = grow_kheap(block_size);
c00034ba:	83 ec 0c             	sub    $0xc,%esp
c00034bd:	ff 75 f0             	pushl  -0x10(%ebp)
c00034c0:	e8 e5 fe ff ff       	call   c00033aa <grow_kheap>
c00034c5:	83 c4 10             	add    $0x10,%esp
c00034c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
            if(!block) return NULL; //grow_kheap() failed, e.g. OOM 
c00034cb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00034cf:	75 10                	jne    c00034e1 <kmalloc+0x77>
c00034d1:	b8 00 00 00 00       	mov    $0x0,%eax
c00034d6:	eb 5d                	jmp    c0003535 <kmalloc+0xcb>
        }
        else
        {
            block = block->next;
c00034d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00034db:	8b 40 08             	mov    0x8(%eax),%eax
c00034de:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(block->status != HEAP_BLOCK_FREE || block->size < block_size)
c00034e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00034e4:	0f b6 40 03          	movzbl 0x3(%eax),%eax
c00034e8:	83 e0 f0             	and    $0xfffffff0,%eax
c00034eb:	84 c0                	test   %al,%al
c00034ed:	75 bc                	jne    c00034ab <kmalloc+0x41>
c00034ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00034f2:	8b 40 0c             	mov    0xc(%eax),%eax
c00034f5:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c00034f8:	77 b1                	ja     c00034ab <kmalloc+0x41>
    }

    // block is a free block that is large enough for this allocation

    //split block if its big enough
    if(kheap_split_block(block, block_size)<0)
c00034fa:	83 ec 08             	sub    $0x8,%esp
c00034fd:	ff 75 f0             	pushl  -0x10(%ebp)
c0003500:	ff 75 f4             	pushl  -0xc(%ebp)
c0003503:	e8 ee fd ff ff       	call   c00032f6 <kheap_split_block>
c0003508:	83 c4 10             	add    $0x10,%esp
c000350b:	85 c0                	test   %eax,%eax
c000350d:	79 10                	jns    c000351f <kmalloc+0xb5>
        panic("Critical error in malloc()");
c000350f:	83 ec 0c             	sub    $0xc,%esp
c0003512:	68 67 57 00 c0       	push   $0xc0005767
c0003517:	e8 e6 e1 ff ff       	call   c0001702 <panic>
c000351c:	83 c4 10             	add    $0x10,%esp

    block->status = HEAP_BLOCK_USED;
c000351f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003522:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c0003526:	83 e2 0f             	and    $0xf,%edx
c0003529:	83 ca 10             	or     $0x10,%edx
c000352c:	88 50 03             	mov    %dl,0x3(%eax)
    return block+1; // return pointer after header
c000352f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003532:	83 c0 10             	add    $0x10,%eax
}
c0003535:	c9                   	leave  
c0003536:	c3                   	ret    

c0003537 <kmalloc_aligned>:

void* kmalloc_aligned(size_t sz, size_t alignment)
{
c0003537:	55                   	push   %ebp
c0003538:	89 e5                	mov    %esp,%ebp
c000353a:	83 ec 28             	sub    $0x28,%esp
    //alignement must be multiple of HEAP_BLOCKSIZE_UNITS
    if(alignment % HEAP_BLOCKSIZE_UNITS) return NULL;
c000353d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003540:	83 e0 0f             	and    $0xf,%eax
c0003543:	85 c0                	test   %eax,%eax
c0003545:	74 0a                	je     c0003551 <kmalloc_aligned+0x1a>
c0003547:	b8 00 00 00 00       	mov    $0x0,%eax
c000354c:	e9 3d 01 00 00       	jmp    c000368e <kmalloc_aligned+0x157>

    //convert alignment to HEAP_BLOCKSIZE_UNITS
    size_t block_alignment = alignment/HEAP_BLOCKSIZE_UNITS;
c0003551:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003554:	c1 e8 04             	shr    $0x4,%eax
c0003557:	89 45 f0             	mov    %eax,-0x10(%ebp)

    //convert sz to HEAP_BLOCKSIZE_UNITS, rounding up, and add one for header
    size_t block_size = 1 + (sz+ HEAP_BLOCKSIZE_UNITS -1)/HEAP_BLOCKSIZE_UNITS;
c000355a:	8b 45 08             	mov    0x8(%ebp),%eax
c000355d:	83 c0 0f             	add    $0xf,%eax
c0003560:	c1 e8 04             	shr    $0x4,%eax
c0003563:	83 c0 01             	add    $0x1,%eax
c0003566:	89 45 ec             	mov    %eax,-0x14(%ebp)

    
    if(!kheap_head)
c0003569:	a1 a4 78 00 c0       	mov    0xc00078a4,%eax
c000356e:	85 c0                	test   %eax,%eax
c0003570:	75 19                	jne    c000358b <kmalloc_aligned+0x54>
    {
        //initialize the heap with some space
        if(!kmalloc_init())
c0003572:	e8 00 fb ff ff       	call   c0003077 <kmalloc_init>
c0003577:	85 c0                	test   %eax,%eax
c0003579:	75 10                	jne    c000358b <kmalloc_aligned+0x54>
            panic("Error initializing kernel heap");
c000357b:	83 ec 0c             	sub    $0xc,%esp
c000357e:	68 48 57 00 c0       	push   $0xc0005748
c0003583:	e8 7a e1 ff ff       	call   c0001702 <panic>
c0003588:	83 c4 10             	add    $0x10,%esp
    }

    heap_block_t* block = kheap_head;
c000358b:	a1 a4 78 00 c0       	mov    0xc00078a4,%eax
c0003590:	89 45 f4             	mov    %eax,-0xc(%ebp)
    //how many additional units are needed to align this block?
    size_t alignment_space;

    while(true)
    {
        if(block->status == HEAP_BLOCK_FREE)
c0003593:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003596:	0f b6 40 03          	movzbl 0x3(%eax),%eax
c000359a:	83 e0 f0             	and    $0xfffffff0,%eax
c000359d:	84 c0                	test   %al,%al
c000359f:	75 42                	jne    c00035e3 <kmalloc_aligned+0xac>
        {
            // where would aligned data start in this block?
            size_t block_data = (size_t)block/HEAP_BLOCKSIZE_UNITS + 1;  //(unaligned) data starts after header
c00035a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00035a4:	c1 e8 04             	shr    $0x4,%eax
c00035a7:	83 c0 01             	add    $0x1,%eax
c00035aa:	89 45 e8             	mov    %eax,-0x18(%ebp)
            size_t am = block_alignment - 1;
c00035ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00035b0:	83 e8 01             	sub    $0x1,%eax
c00035b3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            size_t block_data_aligned = ((block_data + am) & ~am); //align data
c00035b6:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00035b9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00035bc:	01 c2                	add    %eax,%edx
c00035be:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00035c1:	f7 d0                	not    %eax
c00035c3:	21 d0                	and    %edx,%eax
c00035c5:	89 45 e0             	mov    %eax,-0x20(%ebp)

            alignment_space = block_data_aligned-block_data; 
c00035c8:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00035cb:	2b 45 e8             	sub    -0x18(%ebp),%eax
c00035ce:	89 45 dc             	mov    %eax,-0x24(%ebp)

            if(block->size >= block_size + alignment_space)
c00035d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00035d4:	8b 40 0c             	mov    0xc(%eax),%eax
c00035d7:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c00035da:	8b 55 dc             	mov    -0x24(%ebp),%edx
c00035dd:	01 ca                	add    %ecx,%edx
c00035df:	39 d0                	cmp    %edx,%eax
c00035e1:	73 3b                	jae    c000361e <kmalloc_aligned+0xe7>
                break;

        }

        //if we've returned to the head, we have run through the entire list without finding a free block
        if(block->next == kheap_head)
c00035e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00035e6:	8b 50 08             	mov    0x8(%eax),%edx
c00035e9:	a1 a4 78 00 c0       	mov    0xc00078a4,%eax
c00035ee:	39 c2                	cmp    %eax,%edx
c00035f0:	75 1e                	jne    c0003610 <kmalloc_aligned+0xd9>
        {
            //we've reached the end of the heap, so add a new block at the end
            block = grow_kheap(block_size);
c00035f2:	83 ec 0c             	sub    $0xc,%esp
c00035f5:	ff 75 ec             	pushl  -0x14(%ebp)
c00035f8:	e8 ad fd ff ff       	call   c00033aa <grow_kheap>
c00035fd:	83 c4 10             	add    $0x10,%esp
c0003600:	89 45 f4             	mov    %eax,-0xc(%ebp)
            if(!block) return NULL; //grow_kheap() failed, e.g. OOM 
c0003603:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0003607:	75 8a                	jne    c0003593 <kmalloc_aligned+0x5c>
c0003609:	b8 00 00 00 00       	mov    $0x0,%eax
c000360e:	eb 7e                	jmp    c000368e <kmalloc_aligned+0x157>
        }
        else
        {
            block = block->next;
c0003610:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003613:	8b 40 08             	mov    0x8(%eax),%eax
c0003616:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(block->status == HEAP_BLOCK_FREE)
c0003619:	e9 75 ff ff ff       	jmp    c0003593 <kmalloc_aligned+0x5c>
                break;
c000361e:	90                   	nop
    }

    // block is a free block that is large enough for this allocation

    //if we need to realign, split off the first part of the block
    if(alignment_space>0)
c000361f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0003623:	74 2e                	je     c0003653 <kmalloc_aligned+0x11c>
    {
        if(kheap_split_block(block, alignment_space)<0)
c0003625:	83 ec 08             	sub    $0x8,%esp
c0003628:	ff 75 dc             	pushl  -0x24(%ebp)
c000362b:	ff 75 f4             	pushl  -0xc(%ebp)
c000362e:	e8 c3 fc ff ff       	call   c00032f6 <kheap_split_block>
c0003633:	83 c4 10             	add    $0x10,%esp
c0003636:	85 c0                	test   %eax,%eax
c0003638:	79 10                	jns    c000364a <kmalloc_aligned+0x113>
            panic("Critical error in malloc()");
c000363a:	83 ec 0c             	sub    $0xc,%esp
c000363d:	68 67 57 00 c0       	push   $0xc0005767
c0003642:	e8 bb e0 ff ff       	call   c0001702 <panic>
c0003647:	83 c4 10             	add    $0x10,%esp
        block = block->next;
c000364a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000364d:	8b 40 08             	mov    0x8(%eax),%eax
c0003650:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    
    //split end of block off its big enough
    if(kheap_split_block(block, block_size)<0)
c0003653:	83 ec 08             	sub    $0x8,%esp
c0003656:	ff 75 ec             	pushl  -0x14(%ebp)
c0003659:	ff 75 f4             	pushl  -0xc(%ebp)
c000365c:	e8 95 fc ff ff       	call   c00032f6 <kheap_split_block>
c0003661:	83 c4 10             	add    $0x10,%esp
c0003664:	85 c0                	test   %eax,%eax
c0003666:	79 10                	jns    c0003678 <kmalloc_aligned+0x141>
        panic("Critical error in malloc()");
c0003668:	83 ec 0c             	sub    $0xc,%esp
c000366b:	68 67 57 00 c0       	push   $0xc0005767
c0003670:	e8 8d e0 ff ff       	call   c0001702 <panic>
c0003675:	83 c4 10             	add    $0x10,%esp

    block->status = HEAP_BLOCK_USED;
c0003678:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000367b:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c000367f:	83 e2 0f             	and    $0xf,%edx
c0003682:	83 ca 10             	or     $0x10,%edx
c0003685:	88 50 03             	mov    %dl,0x3(%eax)
    return block+1; // return pointer after header
c0003688:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000368b:	83 c0 10             	add    $0x10,%eax
}
c000368e:	c9                   	leave  
c000368f:	c3                   	ret    

c0003690 <kfree>:

// free memory previously allocated with kmalloc
// return 0 on success.
// return -1 on fail (e.g. if p was not allocated with malloc, or memory corruption detected)
int kfree(void* p)
{
c0003690:	55                   	push   %ebp
c0003691:	89 e5                	mov    %esp,%ebp
c0003693:	83 ec 18             	sub    $0x18,%esp
    //get pointer to block header
    heap_block_t* b = ((heap_block_t*) p) - 1;
c0003696:	8b 45 08             	mov    0x8(%ebp),%eax
c0003699:	83 e8 10             	sub    $0x10,%eax
c000369c:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(kheap_validate_block(b))
c000369f:	ff 75 f4             	pushl  -0xc(%ebp)
c00036a2:	e8 71 f9 ff ff       	call   c0003018 <kheap_validate_block>
c00036a7:	83 c4 04             	add    $0x4,%esp
c00036aa:	85 c0                	test   %eax,%eax
c00036ac:	74 17                	je     c00036c5 <kfree+0x35>
    {
        panic("kernel heap corrupted");
c00036ae:	83 ec 0c             	sub    $0xc,%esp
c00036b1:	68 30 57 00 c0       	push   $0xc0005730
c00036b6:	e8 47 e0 ff ff       	call   c0001702 <panic>
c00036bb:	83 c4 10             	add    $0x10,%esp
        return -1;
c00036be:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00036c3:	eb 1e                	jmp    c00036e3 <kfree+0x53>
    }

    if(kheap_free_block(b)) return 0;
c00036c5:	83 ec 0c             	sub    $0xc,%esp
c00036c8:	ff 75 f4             	pushl  -0xc(%ebp)
c00036cb:	e8 41 fb ff ff       	call   c0003211 <kheap_free_block>
c00036d0:	83 c4 10             	add    $0x10,%esp
c00036d3:	85 c0                	test   %eax,%eax
c00036d5:	74 07                	je     c00036de <kfree+0x4e>
c00036d7:	b8 00 00 00 00       	mov    $0x0,%eax
c00036dc:	eb 05                	jmp    c00036e3 <kfree+0x53>

    return -1;
c00036de:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c00036e3:	c9                   	leave  
c00036e4:	c3                   	ret    

c00036e5 <kheap_size>:


// size of allocated and free mem in heap
// returns 0 on success
int kheap_size(size_t* allocated, size_t* free)
{
c00036e5:	55                   	push   %ebp
c00036e6:	89 e5                	mov    %esp,%ebp
c00036e8:	83 ec 10             	sub    $0x10,%esp
    *allocated = 0;
c00036eb:	8b 45 08             	mov    0x8(%ebp),%eax
c00036ee:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *free = 0;
c00036f4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00036f7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    // make sure heap is initilialized
    if(!kheap_head)
c00036fd:	a1 a4 78 00 c0       	mov    0xc00078a4,%eax
c0003702:	85 c0                	test   %eax,%eax
c0003704:	75 0a                	jne    c0003710 <kheap_size+0x2b>
        return -1;
c0003706:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000370b:	e9 87 00 00 00       	jmp    c0003797 <kheap_size+0xb2>

    heap_block_t* block = kheap_head;
c0003710:	a1 a4 78 00 c0       	mov    0xc00078a4,%eax
c0003715:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while(true)
    {        
        if(kheap_validate_block(block))
c0003718:	ff 75 fc             	pushl  -0x4(%ebp)
c000371b:	e8 f8 f8 ff ff       	call   c0003018 <kheap_validate_block>
c0003720:	83 c4 04             	add    $0x4,%esp
c0003723:	85 c0                	test   %eax,%eax
c0003725:	74 07                	je     c000372e <kheap_size+0x49>
            return -1;        
c0003727:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000372c:	eb 69                	jmp    c0003797 <kheap_size+0xb2>

        if(block->status == HEAP_BLOCK_FREE)
c000372e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003731:	0f b6 40 03          	movzbl 0x3(%eax),%eax
c0003735:	83 e0 f0             	and    $0xfffffff0,%eax
c0003738:	84 c0                	test   %al,%al
c000373a:	75 17                	jne    c0003753 <kheap_size+0x6e>
            *free += block->size*HEAP_BLOCKSIZE_UNITS;
c000373c:	8b 45 0c             	mov    0xc(%ebp),%eax
c000373f:	8b 10                	mov    (%eax),%edx
c0003741:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003744:	8b 40 0c             	mov    0xc(%eax),%eax
c0003747:	c1 e0 04             	shl    $0x4,%eax
c000374a:	01 c2                	add    %eax,%edx
c000374c:	8b 45 0c             	mov    0xc(%ebp),%eax
c000374f:	89 10                	mov    %edx,(%eax)
c0003751:	eb 2c                	jmp    c000377f <kheap_size+0x9a>
        else if(block->status == HEAP_BLOCK_USED)
c0003753:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003756:	0f b6 40 03          	movzbl 0x3(%eax),%eax
c000375a:	83 e0 f0             	and    $0xfffffff0,%eax
c000375d:	3c 10                	cmp    $0x10,%al
c000375f:	75 17                	jne    c0003778 <kheap_size+0x93>
            *allocated += block->size*HEAP_BLOCKSIZE_UNITS;
c0003761:	8b 45 08             	mov    0x8(%ebp),%eax
c0003764:	8b 10                	mov    (%eax),%edx
c0003766:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003769:	8b 40 0c             	mov    0xc(%eax),%eax
c000376c:	c1 e0 04             	shl    $0x4,%eax
c000376f:	01 c2                	add    %eax,%edx
c0003771:	8b 45 08             	mov    0x8(%ebp),%eax
c0003774:	89 10                	mov    %edx,(%eax)
c0003776:	eb 07                	jmp    c000377f <kheap_size+0x9a>
        else
            return -1;        
c0003778:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000377d:	eb 18                	jmp    c0003797 <kheap_size+0xb2>

        block = block->next;
c000377f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003782:	8b 40 08             	mov    0x8(%eax),%eax
c0003785:	89 45 fc             	mov    %eax,-0x4(%ebp)
        if(block == kheap_head)
c0003788:	a1 a4 78 00 c0       	mov    0xc00078a4,%eax
c000378d:	39 45 fc             	cmp    %eax,-0x4(%ebp)
c0003790:	75 86                	jne    c0003718 <kheap_size+0x33>
            return 0;
c0003792:	b8 00 00 00 00       	mov    $0x0,%eax
    }

}
c0003797:	c9                   	leave  
c0003798:	c3                   	ret    

c0003799 <scancode_to_ascii>:
    0,  /* F12 Key */
    0,  /* All other keys are undefined */
};

char scancode_to_ascii(uint8_t scancode)
{
c0003799:	55                   	push   %ebp
c000379a:	89 e5                	mov    %esp,%ebp
c000379c:	83 ec 04             	sub    $0x4,%esp
c000379f:	8b 45 08             	mov    0x8(%ebp),%eax
c00037a2:	88 45 fc             	mov    %al,-0x4(%ebp)
    return kbd_US[scancode];
c00037a5:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c00037a9:	0f b6 80 20 60 00 c0 	movzbl -0x3fff9fe0(%eax),%eax
}
c00037b0:	c9                   	leave  
c00037b1:	c3                   	ret    

c00037b2 <test_multitasking2>:
#include "test.h"
#include "kprintf.h"
#include "task.h"

int32_t test_multitasking2()
{
c00037b2:	55                   	push   %ebp
c00037b3:	89 e5                	mov    %esp,%ebp
c00037b5:	83 ec 18             	sub    $0x18,%esp
	int nn;
	for(nn=0;nn<5;nn++)
c00037b8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00037bf:	eb 09                	jmp    c00037ca <test_multitasking2+0x18>
		yield();
c00037c1:	e8 c7 ee ff ff       	call   c000268d <yield>
	for(nn=0;nn<5;nn++)
c00037c6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00037ca:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
c00037ce:	7e f1                	jle    c00037c1 <test_multitasking2+0xf>
	return nn;
c00037d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00037d3:	c9                   	leave  
c00037d4:	c3                   	ret    

c00037d5 <test_multitasking>:

int test_multitasking()
{
c00037d5:	55                   	push   %ebp
c00037d6:	89 e5                	mov    %esp,%ebp
c00037d8:	83 ec 18             	sub    $0x18,%esp
	task_control_block_t* task2 = new_kernel_task( &test_multitasking2 );
c00037db:	83 ec 0c             	sub    $0xc,%esp
c00037de:	68 b2 37 00 c0       	push   $0xc00037b2
c00037e3:	e8 61 ed ff ff       	call   c0002549 <new_kernel_task>
c00037e8:	83 c4 10             	add    $0x10,%esp
c00037eb:	89 45 f0             	mov    %eax,-0x10(%ebp)

	int nn;
	for(nn=0;nn<10;nn++)
c00037ee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00037f5:	eb 09                	jmp    c0003800 <test_multitasking+0x2b>
		yield();
c00037f7:	e8 91 ee ff ff       	call   c000268d <yield>
	for(nn=0;nn<10;nn++)
c00037fc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0003800:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c0003804:	7e f1                	jle    c00037f7 <test_multitasking+0x22>

	join(task2);
c0003806:	83 ec 0c             	sub    $0xc,%esp
c0003809:	ff 75 f0             	pushl  -0x10(%ebp)
c000380c:	e8 b4 ee ff ff       	call   c00026c5 <join>
c0003811:	83 c4 10             	add    $0x10,%esp

    if(task2->return_val == 5) return 0;
c0003814:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003817:	8b 40 1c             	mov    0x1c(%eax),%eax
c000381a:	83 f8 05             	cmp    $0x5,%eax
c000381d:	75 07                	jne    c0003826 <test_multitasking+0x51>
c000381f:	b8 00 00 00 00       	mov    $0x0,%eax
c0003824:	eb 05                	jmp    c000382b <test_multitasking+0x56>

    return -1;
c0003826:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c000382b:	c9                   	leave  
c000382c:	c3                   	ret    

c000382d <kernel_main>:
#if defined(__linux__)  || !defined(__i386__)
#error "This kernel requires ix86-elf cross compiler"
#endif

void kernel_main(multiboot_info_t* mbd)
{
c000382d:	55                   	push   %ebp
c000382e:	89 e5                	mov    %esp,%ebp
c0003830:	83 ec 18             	sub    $0x18,%esp
	terminal_init(&stdout);
c0003833:	83 ec 0c             	sub    $0xc,%esp
c0003836:	68 00 70 00 c0       	push   $0xc0007000
c000383b:	e8 4d cc ff ff       	call   c000048d <terminal_init>
c0003840:	83 c4 10             	add    $0x10,%esp
    // terminal_setcolor(&stdout, VGA_COLOR_WHITE);
	kprintf("Let's learn about Operating Systems!\n");
c0003843:	83 ec 0c             	sub    $0xc,%esp
c0003846:	68 84 57 00 c0       	push   $0xc0005784
c000384b:	e8 95 d0 ff ff       	call   c00008e5 <kprintf>
c0003850:	83 c4 10             	add    $0x10,%esp
	kprintf("Jon Doane, 2020\n\n");
c0003853:	83 ec 0c             	sub    $0xc,%esp
c0003856:	68 aa 57 00 c0       	push   $0xc00057aa
c000385b:	e8 85 d0 ff ff       	call   c00008e5 <kprintf>
c0003860:	83 c4 10             	add    $0x10,%esp
	
    int result = 0;
c0003863:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    result = result || print_testresult(init_gdt(), "Initialize descriptor tables");
c000386a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c000386e:	75 1a                	jne    c000388a <kernel_main+0x5d>
c0003870:	e8 fe 01 00 00       	call   c0003a73 <init_gdt>
c0003875:	83 ec 08             	sub    $0x8,%esp
c0003878:	68 bc 57 00 c0       	push   $0xc00057bc
c000387d:	50                   	push   %eax
c000387e:	e8 d8 f6 ff ff       	call   c0002f5b <print_testresult>
c0003883:	83 c4 10             	add    $0x10,%esp
c0003886:	85 c0                	test   %eax,%eax
c0003888:	74 07                	je     c0003891 <kernel_main+0x64>
c000388a:	b8 01 00 00 00       	mov    $0x1,%eax
c000388f:	eb 05                	jmp    c0003896 <kernel_main+0x69>
c0003891:	b8 00 00 00 00       	mov    $0x0,%eax
c0003896:	89 45 f4             	mov    %eax,-0xc(%ebp)

    result = result || print_testresult(init_interrupts(), "Initialize interrupts");
c0003899:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c000389d:	75 1a                	jne    c00038b9 <kernel_main+0x8c>
c000389f:	e8 69 e7 ff ff       	call   c000200d <init_interrupts>
c00038a4:	83 ec 08             	sub    $0x8,%esp
c00038a7:	68 d9 57 00 c0       	push   $0xc00057d9
c00038ac:	50                   	push   %eax
c00038ad:	e8 a9 f6 ff ff       	call   c0002f5b <print_testresult>
c00038b2:	83 c4 10             	add    $0x10,%esp
c00038b5:	85 c0                	test   %eax,%eax
c00038b7:	74 07                	je     c00038c0 <kernel_main+0x93>
c00038b9:	b8 01 00 00 00       	mov    $0x1,%eax
c00038be:	eb 05                	jmp    c00038c5 <kernel_main+0x98>
c00038c0:	b8 00 00 00 00       	mov    $0x0,%eax
c00038c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    result = result || print_testresult(global_memory_init(mbd), "Initialize memory");
c00038c8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00038cc:	75 23                	jne    c00038f1 <kernel_main+0xc4>
c00038ce:	83 ec 0c             	sub    $0xc,%esp
c00038d1:	ff 75 08             	pushl  0x8(%ebp)
c00038d4:	e8 a3 f3 ff ff       	call   c0002c7c <global_memory_init>
c00038d9:	83 c4 10             	add    $0x10,%esp
c00038dc:	83 ec 08             	sub    $0x8,%esp
c00038df:	68 ef 57 00 c0       	push   $0xc00057ef
c00038e4:	50                   	push   %eax
c00038e5:	e8 71 f6 ff ff       	call   c0002f5b <print_testresult>
c00038ea:	83 c4 10             	add    $0x10,%esp
c00038ed:	85 c0                	test   %eax,%eax
c00038ef:	74 07                	je     c00038f8 <kernel_main+0xcb>
c00038f1:	b8 01 00 00 00       	mov    $0x1,%eax
c00038f6:	eb 05                	jmp    c00038fd <kernel_main+0xd0>
c00038f8:	b8 00 00 00 00       	mov    $0x0,%eax
c00038fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    result = result || print_testresult(initialize_multitasking(), "Initialize multitasking");
c0003900:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0003904:	75 1a                	jne    c0003920 <kernel_main+0xf3>
c0003906:	e8 eb eb ff ff       	call   c00024f6 <initialize_multitasking>
c000390b:	83 ec 08             	sub    $0x8,%esp
c000390e:	68 01 58 00 c0       	push   $0xc0005801
c0003913:	50                   	push   %eax
c0003914:	e8 42 f6 ff ff       	call   c0002f5b <print_testresult>
c0003919:	83 c4 10             	add    $0x10,%esp
c000391c:	85 c0                	test   %eax,%eax
c000391e:	74 07                	je     c0003927 <kernel_main+0xfa>
c0003920:	b8 01 00 00 00       	mov    $0x1,%eax
c0003925:	eb 05                	jmp    c000392c <kernel_main+0xff>
c0003927:	b8 00 00 00 00       	mov    $0x0,%eax
c000392c:	89 45 f4             	mov    %eax,-0xc(%ebp)

    result = result || print_testresult(test_kmalloc(), "kmalloc() unit tests");
c000392f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0003933:	75 1a                	jne    c000394f <kernel_main+0x122>
c0003935:	e8 68 c8 ff ff       	call   c00001a2 <test_kmalloc>
c000393a:	83 ec 08             	sub    $0x8,%esp
c000393d:	68 19 58 00 c0       	push   $0xc0005819
c0003942:	50                   	push   %eax
c0003943:	e8 13 f6 ff ff       	call   c0002f5b <print_testresult>
c0003948:	83 c4 10             	add    $0x10,%esp
c000394b:	85 c0                	test   %eax,%eax
c000394d:	74 07                	je     c0003956 <kernel_main+0x129>
c000394f:	b8 01 00 00 00       	mov    $0x1,%eax
c0003954:	eb 05                	jmp    c000395b <kernel_main+0x12e>
c0003956:	b8 00 00 00 00       	mov    $0x0,%eax
c000395b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    result = result || print_testresult(test_multitasking(), "Multitasking unit tests");
c000395e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0003962:	75 1a                	jne    c000397e <kernel_main+0x151>
c0003964:	e8 6c fe ff ff       	call   c00037d5 <test_multitasking>
c0003969:	83 ec 08             	sub    $0x8,%esp
c000396c:	68 2e 58 00 c0       	push   $0xc000582e
c0003971:	50                   	push   %eax
c0003972:	e8 e4 f5 ff ff       	call   c0002f5b <print_testresult>
c0003977:	83 c4 10             	add    $0x10,%esp
c000397a:	85 c0                	test   %eax,%eax
c000397c:	74 07                	je     c0003985 <kernel_main+0x158>
c000397e:	b8 01 00 00 00       	mov    $0x1,%eax
c0003983:	eb 05                	jmp    c000398a <kernel_main+0x15d>
c0003985:	b8 00 00 00 00       	mov    $0x0,%eax
c000398a:	89 45 f4             	mov    %eax,-0xc(%ebp)

    print_testresult(result, "Startup successful");
c000398d:	83 ec 08             	sub    $0x8,%esp
c0003990:	68 46 58 00 c0       	push   $0xc0005846
c0003995:	ff 75 f4             	pushl  -0xc(%ebp)
c0003998:	e8 be f5 ff ff       	call   c0002f5b <print_testresult>
c000399d:	83 c4 10             	add    $0x10,%esp

	while(1);
c00039a0:	eb fe                	jmp    c00039a0 <kernel_main+0x173>

c00039a2 <populate_gdt_entry>:
   uint16_t iomap_base;
} tss_entry_t;


static inline void populate_gdt_entry(gdt_entry_t* sd, uint32_t base, uint32_t limit, uint8_t access, uint8_t flags)
{
c00039a2:	55                   	push   %ebp
c00039a3:	89 e5                	mov    %esp,%ebp
c00039a5:	53                   	push   %ebx
c00039a6:	83 ec 08             	sub    $0x8,%esp
c00039a9:	8b 55 14             	mov    0x14(%ebp),%edx
c00039ac:	8b 45 18             	mov    0x18(%ebp),%eax
c00039af:	88 55 f8             	mov    %dl,-0x8(%ebp)
c00039b2:	88 45 f4             	mov    %al,-0xc(%ebp)
    sd->limit_low = limit & SEGMENT_LIMIT_LOW_MASK;
c00039b5:	8b 45 10             	mov    0x10(%ebp),%eax
c00039b8:	89 c2                	mov    %eax,%edx
c00039ba:	8b 45 08             	mov    0x8(%ebp),%eax
c00039bd:	0f b7 ca             	movzwl %dx,%ecx
c00039c0:	0f b6 d9             	movzbl %cl,%ebx
c00039c3:	0f b6 08             	movzbl (%eax),%ecx
c00039c6:	83 e1 00             	and    $0x0,%ecx
c00039c9:	09 d9                	or     %ebx,%ecx
c00039cb:	88 08                	mov    %cl,(%eax)
c00039cd:	66 c1 ea 08          	shr    $0x8,%dx
c00039d1:	0f b7 ca             	movzwl %dx,%ecx
c00039d4:	0f b6 50 01          	movzbl 0x1(%eax),%edx
c00039d8:	83 e2 00             	and    $0x0,%edx
c00039db:	09 ca                	or     %ecx,%edx
c00039dd:	88 50 01             	mov    %dl,0x1(%eax)
    sd->limit_high = (limit & SEGMENT_LIMIT_HIGH_MASK) >> 16;
c00039e0:	8b 45 10             	mov    0x10(%ebp),%eax
c00039e3:	c1 e8 10             	shr    $0x10,%eax
c00039e6:	83 e0 0f             	and    $0xf,%eax
c00039e9:	8b 55 08             	mov    0x8(%ebp),%edx
c00039ec:	83 e0 0f             	and    $0xf,%eax
c00039ef:	89 c1                	mov    %eax,%ecx
c00039f1:	0f b6 42 06          	movzbl 0x6(%edx),%eax
c00039f5:	83 e0 f0             	and    $0xfffffff0,%eax
c00039f8:	09 c8                	or     %ecx,%eax
c00039fa:	88 42 06             	mov    %al,0x6(%edx)
    sd->base_low = base & SEGMENT_BASE_LOW_MASK;
c00039fd:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003a00:	89 c2                	mov    %eax,%edx
c0003a02:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a05:	0f b7 ca             	movzwl %dx,%ecx
c0003a08:	0f b6 d9             	movzbl %cl,%ebx
c0003a0b:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
c0003a0f:	83 e1 00             	and    $0x0,%ecx
c0003a12:	09 d9                	or     %ebx,%ecx
c0003a14:	88 48 02             	mov    %cl,0x2(%eax)
c0003a17:	66 c1 ea 08          	shr    $0x8,%dx
c0003a1b:	0f b7 ca             	movzwl %dx,%ecx
c0003a1e:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c0003a22:	83 e2 00             	and    $0x0,%edx
c0003a25:	09 ca                	or     %ecx,%edx
c0003a27:	88 50 03             	mov    %dl,0x3(%eax)
    sd->base_mid = (base & SEGMENT_BASE_MID_MASK) >> 16;
c0003a2a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003a2d:	c1 e8 10             	shr    $0x10,%eax
c0003a30:	89 c2                	mov    %eax,%edx
c0003a32:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a35:	88 50 04             	mov    %dl,0x4(%eax)
    sd->base_high = (base & SEGMENT_BASE_HIGH_MASK) >> 24;
c0003a38:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003a3b:	c1 e8 18             	shr    $0x18,%eax
c0003a3e:	89 c2                	mov    %eax,%edx
c0003a40:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a43:	88 50 07             	mov    %dl,0x7(%eax)
    sd->access = access;
c0003a46:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a49:	0f b6 55 f8          	movzbl -0x8(%ebp),%edx
c0003a4d:	88 50 05             	mov    %dl,0x5(%eax)
    sd->flags = flags;
c0003a50:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0003a54:	83 e0 0f             	and    $0xf,%eax
c0003a57:	89 c2                	mov    %eax,%edx
c0003a59:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a5c:	89 d1                	mov    %edx,%ecx
c0003a5e:	c1 e1 04             	shl    $0x4,%ecx
c0003a61:	0f b6 50 06          	movzbl 0x6(%eax),%edx
c0003a65:	83 e2 0f             	and    $0xf,%edx
c0003a68:	09 ca                	or     %ecx,%edx
c0003a6a:	88 50 06             	mov    %dl,0x6(%eax)
}
c0003a6d:	90                   	nop
c0003a6e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0003a71:	c9                   	leave  
c0003a72:	c3                   	ret    

c0003a73 <init_gdt>:
gdt_description_t __aligned  gdtd;

tss_entry_t tss = {0};

int init_gdt()
{
c0003a73:	55                   	push   %ebp
c0003a74:	89 e5                	mov    %esp,%ebp
c0003a76:	83 ec 08             	sub    $0x8,%esp
    // gdt[0] unused
    populate_gdt_entry(&gdt[1], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(0) | SEG_DESCTYPE(1) | SEG_CODE_EXRD, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // priv code, seg 0x008
c0003a79:	6a 0c                	push   $0xc
c0003a7b:	68 9a 00 00 00       	push   $0x9a
c0003a80:	6a ff                	push   $0xffffffff
c0003a82:	6a 00                	push   $0x0
c0003a84:	68 c8 78 00 c0       	push   $0xc00078c8
c0003a89:	e8 14 ff ff ff       	call   c00039a2 <populate_gdt_entry>
c0003a8e:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[2], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(0) | SEG_DESCTYPE(1) | SEG_DATA_RDWR, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // priv data, seg 0x010
c0003a91:	6a 0c                	push   $0xc
c0003a93:	68 92 00 00 00       	push   $0x92
c0003a98:	6a ff                	push   $0xffffffff
c0003a9a:	6a 00                	push   $0x0
c0003a9c:	68 d0 78 00 c0       	push   $0xc00078d0
c0003aa1:	e8 fc fe ff ff       	call   c00039a2 <populate_gdt_entry>
c0003aa6:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[3], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(3) | SEG_DESCTYPE(1) | SEG_CODE_EXRD, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // user code, seg 0x018
c0003aa9:	6a 0c                	push   $0xc
c0003aab:	68 fa 00 00 00       	push   $0xfa
c0003ab0:	6a ff                	push   $0xffffffff
c0003ab2:	6a 00                	push   $0x0
c0003ab4:	68 d8 78 00 c0       	push   $0xc00078d8
c0003ab9:	e8 e4 fe ff ff       	call   c00039a2 <populate_gdt_entry>
c0003abe:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[4], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(3) | SEG_DESCTYPE(1) | SEG_DATA_RDWR, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // user data  seg 0x020
c0003ac1:	6a 0c                	push   $0xc
c0003ac3:	68 f2 00 00 00       	push   $0xf2
c0003ac8:	6a ff                	push   $0xffffffff
c0003aca:	6a 00                	push   $0x0
c0003acc:	68 e0 78 00 c0       	push   $0xc00078e0
c0003ad1:	e8 cc fe ff ff       	call   c00039a2 <populate_gdt_entry>
c0003ad6:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[5], (uint32_t) &tss, sizeof(tss_entry_t), SEG_TSS, SEG_FLAG_TSS); // tss, seg 0x028
c0003ad9:	b8 20 79 00 c0       	mov    $0xc0007920,%eax
c0003ade:	6a 04                	push   $0x4
c0003ae0:	68 89 00 00 00       	push   $0x89
c0003ae5:	6a 68                	push   $0x68
c0003ae7:	50                   	push   %eax
c0003ae8:	68 e8 78 00 c0       	push   $0xc00078e8
c0003aed:	e8 b0 fe ff ff       	call   c00039a2 <populate_gdt_entry>
c0003af2:	83 c4 14             	add    $0x14,%esp

    //tss.esp0 = XXXXX
    tss.ss0 = KERNEL_DATA_SEGMENT; //kernel data segment    
c0003af5:	c7 05 28 79 00 c0 10 	movl   $0x10,0xc0007928
c0003afc:	00 00 00 
    tss.iomap_base = sizeof(tss_entry_t);
c0003aff:	66 c7 05 86 79 00 c0 	movw   $0x68,0xc0007986
c0003b06:	68 00 
    // before we can actually switch tasks, we must first set the kernel stack pointer, with update_tss()

    gdtd.addr = (uint32_t) gdt;
c0003b08:	b8 c0 78 00 c0       	mov    $0xc00078c0,%eax
c0003b0d:	a3 02 79 00 c0       	mov    %eax,0xc0007902
    gdtd.size = sizeof(gdt);    
c0003b12:	66 c7 05 00 79 00 c0 	movw   $0x30,0xc0007900
c0003b19:	30 00 
    load_gdt(&gdtd);
c0003b1b:	83 ec 0c             	sub    $0xc,%esp
c0003b1e:	68 00 79 00 c0       	push   $0xc0007900
c0003b23:	e8 20 00 00 00       	call   c0003b48 <load_gdt>
c0003b28:	83 c4 10             	add    $0x10,%esp
    return 0;
c0003b2b:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0003b30:	c9                   	leave  
c0003b31:	c3                   	ret    

c0003b32 <update_kstack>:

void update_kstack(void* kernel_stack_ptr)
{
c0003b32:	55                   	push   %ebp
c0003b33:	89 e5                	mov    %esp,%ebp
c0003b35:	83 ec 08             	sub    $0x8,%esp
    tss.esp0 = (uint32_t) kernel_stack_ptr; //kernel stack ptr
c0003b38:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b3b:	a3 24 79 00 c0       	mov    %eax,0xc0007924
    load_tss();
c0003b40:	e8 23 00 00 00       	call   c0003b68 <load_tss>
}
c0003b45:	90                   	nop
c0003b46:	c9                   	leave  
c0003b47:	c3                   	ret    

c0003b48 <load_gdt>:
c0003b48:	0f 01 15 00 79 00 c0 	lgdtl  0xc0007900
c0003b4f:	ea 56 3b 00 c0 08 00 	ljmp   $0x8,$0xc0003b56

c0003b56 <complete_flush>:
c0003b56:	66 b8 10 00          	mov    $0x10,%ax
c0003b5a:	8e d8                	mov    %eax,%ds
c0003b5c:	8e c0                	mov    %eax,%es
c0003b5e:	8e e0                	mov    %eax,%fs
c0003b60:	8e e8                	mov    %eax,%gs
c0003b62:	8e d0                	mov    %eax,%ss
c0003b64:	c3                   	ret    
c0003b65:	8d 76 00             	lea    0x0(%esi),%esi

c0003b68 <load_tss>:
c0003b68:	66 b8 28 00          	mov    $0x28,%ax
c0003b6c:	66 83 c8 03          	or     $0x3,%ax
c0003b70:	0f 00 d8             	ltr    %ax
c0003b73:	c3                   	ret    

c0003b74 <getregs>:
c0003b74:	55                   	push   %ebp
c0003b75:	89 e5                	mov    %esp,%ebp
c0003b77:	53                   	push   %ebx
c0003b78:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0003b7b:	89 03                	mov    %eax,(%ebx)
c0003b7d:	8b 04 24             	mov    (%esp),%eax
c0003b80:	89 43 04             	mov    %eax,0x4(%ebx)
c0003b83:	89 4b 08             	mov    %ecx,0x8(%ebx)
c0003b86:	89 53 0c             	mov    %edx,0xc(%ebx)
c0003b89:	89 73 10             	mov    %esi,0x10(%ebx)
c0003b8c:	89 7b 14             	mov    %edi,0x14(%ebx)
c0003b8f:	89 e8                	mov    %ebp,%eax
c0003b91:	83 c0 0c             	add    $0xc,%eax
c0003b94:	89 43 18             	mov    %eax,0x18(%ebx)
c0003b97:	8b 45 00             	mov    0x0(%ebp),%eax
c0003b9a:	89 43 1c             	mov    %eax,0x1c(%ebx)
c0003b9d:	8b 45 04             	mov    0x4(%ebp),%eax
c0003ba0:	89 43 20             	mov    %eax,0x20(%ebx)
c0003ba3:	b8 00 00 00 00       	mov    $0x0,%eax
c0003ba8:	9f                   	lahf   
c0003ba9:	89 43 24             	mov    %eax,0x24(%ebx)
c0003bac:	0f 20 c0             	mov    %cr0,%eax
c0003baf:	89 43 28             	mov    %eax,0x28(%ebx)
c0003bb2:	0f 20 d0             	mov    %cr2,%eax
c0003bb5:	89 43 2c             	mov    %eax,0x2c(%ebx)
c0003bb8:	0f 20 d8             	mov    %cr3,%eax
c0003bbb:	89 43 30             	mov    %eax,0x30(%ebx)
c0003bbe:	0f 20 e0             	mov    %cr4,%eax
c0003bc1:	89 43 34             	mov    %eax,0x34(%ebx)
c0003bc4:	5b                   	pop    %ebx
c0003bc5:	5d                   	pop    %ebp
c0003bc6:	c3                   	ret    
c0003bc7:	90                   	nop

c0003bc8 <load_idt>:
c0003bc8:	0f 01 1d 20 78 00 c0 	lidtl  0xc0007820
c0003bcf:	fb                   	sti    
c0003bd0:	c3                   	ret    
c0003bd1:	8d 76 00             	lea    0x0(%esi),%esi

c0003bd4 <pf_addr>:
c0003bd4:	0f 20 d0             	mov    %cr2,%eax
c0003bd7:	c3                   	ret    

c0003bd8 <except_0>:
c0003bd8:	55                   	push   %ebp
c0003bd9:	89 e5                	mov    %esp,%ebp
c0003bdb:	60                   	pusha  
c0003bdc:	8b 45 04             	mov    0x4(%ebp),%eax
c0003bdf:	50                   	push   %eax
c0003be0:	b8 00 00 00 00       	mov    $0x0,%eax
c0003be5:	50                   	push   %eax
c0003be6:	b8 00 00 00 00       	mov    $0x0,%eax
c0003beb:	50                   	push   %eax
c0003bec:	e8 62 e8 ff ff       	call   c0002453 <exception_handler>
c0003bf1:	83 c4 0c             	add    $0xc,%esp
c0003bf4:	61                   	popa   
c0003bf5:	5d                   	pop    %ebp
c0003bf6:	cf                   	iret   
c0003bf7:	90                   	nop

c0003bf8 <except_1>:
c0003bf8:	55                   	push   %ebp
c0003bf9:	89 e5                	mov    %esp,%ebp
c0003bfb:	60                   	pusha  
c0003bfc:	8b 45 04             	mov    0x4(%ebp),%eax
c0003bff:	50                   	push   %eax
c0003c00:	b8 00 00 00 00       	mov    $0x0,%eax
c0003c05:	50                   	push   %eax
c0003c06:	b8 01 00 00 00       	mov    $0x1,%eax
c0003c0b:	50                   	push   %eax
c0003c0c:	e8 42 e8 ff ff       	call   c0002453 <exception_handler>
c0003c11:	83 c4 0c             	add    $0xc,%esp
c0003c14:	61                   	popa   
c0003c15:	5d                   	pop    %ebp
c0003c16:	cf                   	iret   
c0003c17:	90                   	nop

c0003c18 <except_2>:
c0003c18:	55                   	push   %ebp
c0003c19:	89 e5                	mov    %esp,%ebp
c0003c1b:	60                   	pusha  
c0003c1c:	8b 45 04             	mov    0x4(%ebp),%eax
c0003c1f:	50                   	push   %eax
c0003c20:	b8 00 00 00 00       	mov    $0x0,%eax
c0003c25:	50                   	push   %eax
c0003c26:	b8 02 00 00 00       	mov    $0x2,%eax
c0003c2b:	50                   	push   %eax
c0003c2c:	e8 22 e8 ff ff       	call   c0002453 <exception_handler>
c0003c31:	83 c4 0c             	add    $0xc,%esp
c0003c34:	61                   	popa   
c0003c35:	5d                   	pop    %ebp
c0003c36:	cf                   	iret   
c0003c37:	90                   	nop

c0003c38 <except_3>:
c0003c38:	55                   	push   %ebp
c0003c39:	89 e5                	mov    %esp,%ebp
c0003c3b:	60                   	pusha  
c0003c3c:	8b 45 04             	mov    0x4(%ebp),%eax
c0003c3f:	50                   	push   %eax
c0003c40:	b8 00 00 00 00       	mov    $0x0,%eax
c0003c45:	50                   	push   %eax
c0003c46:	b8 03 00 00 00       	mov    $0x3,%eax
c0003c4b:	50                   	push   %eax
c0003c4c:	e8 02 e8 ff ff       	call   c0002453 <exception_handler>
c0003c51:	83 c4 0c             	add    $0xc,%esp
c0003c54:	61                   	popa   
c0003c55:	5d                   	pop    %ebp
c0003c56:	cf                   	iret   
c0003c57:	90                   	nop

c0003c58 <except_4>:
c0003c58:	55                   	push   %ebp
c0003c59:	89 e5                	mov    %esp,%ebp
c0003c5b:	60                   	pusha  
c0003c5c:	8b 45 04             	mov    0x4(%ebp),%eax
c0003c5f:	50                   	push   %eax
c0003c60:	b8 00 00 00 00       	mov    $0x0,%eax
c0003c65:	50                   	push   %eax
c0003c66:	b8 04 00 00 00       	mov    $0x4,%eax
c0003c6b:	50                   	push   %eax
c0003c6c:	e8 e2 e7 ff ff       	call   c0002453 <exception_handler>
c0003c71:	83 c4 0c             	add    $0xc,%esp
c0003c74:	61                   	popa   
c0003c75:	5d                   	pop    %ebp
c0003c76:	cf                   	iret   
c0003c77:	90                   	nop

c0003c78 <except_5>:
c0003c78:	55                   	push   %ebp
c0003c79:	89 e5                	mov    %esp,%ebp
c0003c7b:	60                   	pusha  
c0003c7c:	8b 45 04             	mov    0x4(%ebp),%eax
c0003c7f:	50                   	push   %eax
c0003c80:	b8 00 00 00 00       	mov    $0x0,%eax
c0003c85:	50                   	push   %eax
c0003c86:	b8 05 00 00 00       	mov    $0x5,%eax
c0003c8b:	50                   	push   %eax
c0003c8c:	e8 c2 e7 ff ff       	call   c0002453 <exception_handler>
c0003c91:	83 c4 0c             	add    $0xc,%esp
c0003c94:	61                   	popa   
c0003c95:	5d                   	pop    %ebp
c0003c96:	cf                   	iret   
c0003c97:	90                   	nop

c0003c98 <except_6>:
c0003c98:	55                   	push   %ebp
c0003c99:	89 e5                	mov    %esp,%ebp
c0003c9b:	60                   	pusha  
c0003c9c:	8b 45 04             	mov    0x4(%ebp),%eax
c0003c9f:	50                   	push   %eax
c0003ca0:	b8 00 00 00 00       	mov    $0x0,%eax
c0003ca5:	50                   	push   %eax
c0003ca6:	b8 06 00 00 00       	mov    $0x6,%eax
c0003cab:	50                   	push   %eax
c0003cac:	e8 a2 e7 ff ff       	call   c0002453 <exception_handler>
c0003cb1:	83 c4 0c             	add    $0xc,%esp
c0003cb4:	61                   	popa   
c0003cb5:	5d                   	pop    %ebp
c0003cb6:	cf                   	iret   
c0003cb7:	90                   	nop

c0003cb8 <except_7>:
c0003cb8:	55                   	push   %ebp
c0003cb9:	89 e5                	mov    %esp,%ebp
c0003cbb:	60                   	pusha  
c0003cbc:	8b 45 04             	mov    0x4(%ebp),%eax
c0003cbf:	50                   	push   %eax
c0003cc0:	b8 00 00 00 00       	mov    $0x0,%eax
c0003cc5:	50                   	push   %eax
c0003cc6:	b8 07 00 00 00       	mov    $0x7,%eax
c0003ccb:	50                   	push   %eax
c0003ccc:	e8 82 e7 ff ff       	call   c0002453 <exception_handler>
c0003cd1:	83 c4 0c             	add    $0xc,%esp
c0003cd4:	61                   	popa   
c0003cd5:	5d                   	pop    %ebp
c0003cd6:	cf                   	iret   
c0003cd7:	90                   	nop

c0003cd8 <except_8>:
c0003cd8:	55                   	push   %ebp
c0003cd9:	89 e5                	mov    %esp,%ebp
c0003cdb:	60                   	pusha  
c0003cdc:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cdf:	50                   	push   %eax
c0003ce0:	8b 45 04             	mov    0x4(%ebp),%eax
c0003ce3:	50                   	push   %eax
c0003ce4:	b8 08 00 00 00       	mov    $0x8,%eax
c0003ce9:	50                   	push   %eax
c0003cea:	e8 64 e7 ff ff       	call   c0002453 <exception_handler>
c0003cef:	83 c4 0c             	add    $0xc,%esp
c0003cf2:	61                   	popa   
c0003cf3:	5d                   	pop    %ebp
c0003cf4:	83 c4 04             	add    $0x4,%esp
c0003cf7:	cf                   	iret   

c0003cf8 <except_10>:
c0003cf8:	55                   	push   %ebp
c0003cf9:	89 e5                	mov    %esp,%ebp
c0003cfb:	60                   	pusha  
c0003cfc:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cff:	50                   	push   %eax
c0003d00:	8b 45 04             	mov    0x4(%ebp),%eax
c0003d03:	50                   	push   %eax
c0003d04:	b8 0a 00 00 00       	mov    $0xa,%eax
c0003d09:	50                   	push   %eax
c0003d0a:	e8 44 e7 ff ff       	call   c0002453 <exception_handler>
c0003d0f:	83 c4 0c             	add    $0xc,%esp
c0003d12:	61                   	popa   
c0003d13:	5d                   	pop    %ebp
c0003d14:	83 c4 04             	add    $0x4,%esp
c0003d17:	cf                   	iret   

c0003d18 <except_11>:
c0003d18:	55                   	push   %ebp
c0003d19:	89 e5                	mov    %esp,%ebp
c0003d1b:	60                   	pusha  
c0003d1c:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d1f:	50                   	push   %eax
c0003d20:	8b 45 04             	mov    0x4(%ebp),%eax
c0003d23:	50                   	push   %eax
c0003d24:	b8 0b 00 00 00       	mov    $0xb,%eax
c0003d29:	50                   	push   %eax
c0003d2a:	e8 24 e7 ff ff       	call   c0002453 <exception_handler>
c0003d2f:	83 c4 0c             	add    $0xc,%esp
c0003d32:	61                   	popa   
c0003d33:	5d                   	pop    %ebp
c0003d34:	83 c4 04             	add    $0x4,%esp
c0003d37:	cf                   	iret   

c0003d38 <except_12>:
c0003d38:	55                   	push   %ebp
c0003d39:	89 e5                	mov    %esp,%ebp
c0003d3b:	60                   	pusha  
c0003d3c:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d3f:	50                   	push   %eax
c0003d40:	8b 45 04             	mov    0x4(%ebp),%eax
c0003d43:	50                   	push   %eax
c0003d44:	b8 0c 00 00 00       	mov    $0xc,%eax
c0003d49:	50                   	push   %eax
c0003d4a:	e8 04 e7 ff ff       	call   c0002453 <exception_handler>
c0003d4f:	83 c4 0c             	add    $0xc,%esp
c0003d52:	61                   	popa   
c0003d53:	5d                   	pop    %ebp
c0003d54:	83 c4 04             	add    $0x4,%esp
c0003d57:	cf                   	iret   

c0003d58 <except_13>:
c0003d58:	55                   	push   %ebp
c0003d59:	89 e5                	mov    %esp,%ebp
c0003d5b:	60                   	pusha  
c0003d5c:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d5f:	50                   	push   %eax
c0003d60:	8b 45 04             	mov    0x4(%ebp),%eax
c0003d63:	50                   	push   %eax
c0003d64:	b8 0d 00 00 00       	mov    $0xd,%eax
c0003d69:	50                   	push   %eax
c0003d6a:	e8 e4 e6 ff ff       	call   c0002453 <exception_handler>
c0003d6f:	83 c4 0c             	add    $0xc,%esp
c0003d72:	61                   	popa   
c0003d73:	5d                   	pop    %ebp
c0003d74:	83 c4 04             	add    $0x4,%esp
c0003d77:	cf                   	iret   

c0003d78 <except_14>:
c0003d78:	55                   	push   %ebp
c0003d79:	89 e5                	mov    %esp,%ebp
c0003d7b:	60                   	pusha  
c0003d7c:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d7f:	50                   	push   %eax
c0003d80:	8b 45 04             	mov    0x4(%ebp),%eax
c0003d83:	50                   	push   %eax
c0003d84:	b8 0e 00 00 00       	mov    $0xe,%eax
c0003d89:	50                   	push   %eax
c0003d8a:	e8 c4 e6 ff ff       	call   c0002453 <exception_handler>
c0003d8f:	83 c4 0c             	add    $0xc,%esp
c0003d92:	61                   	popa   
c0003d93:	5d                   	pop    %ebp
c0003d94:	83 c4 04             	add    $0x4,%esp
c0003d97:	cf                   	iret   

c0003d98 <except_16>:
c0003d98:	55                   	push   %ebp
c0003d99:	89 e5                	mov    %esp,%ebp
c0003d9b:	60                   	pusha  
c0003d9c:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d9f:	50                   	push   %eax
c0003da0:	8b 45 04             	mov    0x4(%ebp),%eax
c0003da3:	50                   	push   %eax
c0003da4:	b8 10 00 00 00       	mov    $0x10,%eax
c0003da9:	50                   	push   %eax
c0003daa:	e8 a4 e6 ff ff       	call   c0002453 <exception_handler>
c0003daf:	83 c4 0c             	add    $0xc,%esp
c0003db2:	61                   	popa   
c0003db3:	5d                   	pop    %ebp
c0003db4:	83 c4 04             	add    $0x4,%esp
c0003db7:	cf                   	iret   

c0003db8 <except_17>:
c0003db8:	55                   	push   %ebp
c0003db9:	89 e5                	mov    %esp,%ebp
c0003dbb:	60                   	pusha  
c0003dbc:	8b 45 08             	mov    0x8(%ebp),%eax
c0003dbf:	50                   	push   %eax
c0003dc0:	8b 45 04             	mov    0x4(%ebp),%eax
c0003dc3:	50                   	push   %eax
c0003dc4:	b8 11 00 00 00       	mov    $0x11,%eax
c0003dc9:	50                   	push   %eax
c0003dca:	e8 84 e6 ff ff       	call   c0002453 <exception_handler>
c0003dcf:	83 c4 0c             	add    $0xc,%esp
c0003dd2:	61                   	popa   
c0003dd3:	5d                   	pop    %ebp
c0003dd4:	83 c4 04             	add    $0x4,%esp
c0003dd7:	cf                   	iret   

c0003dd8 <except_18>:
c0003dd8:	55                   	push   %ebp
c0003dd9:	89 e5                	mov    %esp,%ebp
c0003ddb:	60                   	pusha  
c0003ddc:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ddf:	50                   	push   %eax
c0003de0:	8b 45 04             	mov    0x4(%ebp),%eax
c0003de3:	50                   	push   %eax
c0003de4:	b8 12 00 00 00       	mov    $0x12,%eax
c0003de9:	50                   	push   %eax
c0003dea:	e8 64 e6 ff ff       	call   c0002453 <exception_handler>
c0003def:	83 c4 0c             	add    $0xc,%esp
c0003df2:	61                   	popa   
c0003df3:	5d                   	pop    %ebp
c0003df4:	83 c4 04             	add    $0x4,%esp
c0003df7:	cf                   	iret   

c0003df8 <except_19>:
c0003df8:	55                   	push   %ebp
c0003df9:	89 e5                	mov    %esp,%ebp
c0003dfb:	60                   	pusha  
c0003dfc:	8b 45 08             	mov    0x8(%ebp),%eax
c0003dff:	50                   	push   %eax
c0003e00:	8b 45 04             	mov    0x4(%ebp),%eax
c0003e03:	50                   	push   %eax
c0003e04:	b8 13 00 00 00       	mov    $0x13,%eax
c0003e09:	50                   	push   %eax
c0003e0a:	e8 44 e6 ff ff       	call   c0002453 <exception_handler>
c0003e0f:	83 c4 0c             	add    $0xc,%esp
c0003e12:	61                   	popa   
c0003e13:	5d                   	pop    %ebp
c0003e14:	83 c4 04             	add    $0x4,%esp
c0003e17:	cf                   	iret   

c0003e18 <except_20>:
c0003e18:	55                   	push   %ebp
c0003e19:	89 e5                	mov    %esp,%ebp
c0003e1b:	60                   	pusha  
c0003e1c:	8b 45 08             	mov    0x8(%ebp),%eax
c0003e1f:	50                   	push   %eax
c0003e20:	8b 45 04             	mov    0x4(%ebp),%eax
c0003e23:	50                   	push   %eax
c0003e24:	b8 14 00 00 00       	mov    $0x14,%eax
c0003e29:	50                   	push   %eax
c0003e2a:	e8 24 e6 ff ff       	call   c0002453 <exception_handler>
c0003e2f:	83 c4 0c             	add    $0xc,%esp
c0003e32:	61                   	popa   
c0003e33:	5d                   	pop    %ebp
c0003e34:	83 c4 04             	add    $0x4,%esp
c0003e37:	cf                   	iret   

c0003e38 <except_30>:
c0003e38:	55                   	push   %ebp
c0003e39:	89 e5                	mov    %esp,%ebp
c0003e3b:	60                   	pusha  
c0003e3c:	8b 45 08             	mov    0x8(%ebp),%eax
c0003e3f:	50                   	push   %eax
c0003e40:	8b 45 04             	mov    0x4(%ebp),%eax
c0003e43:	50                   	push   %eax
c0003e44:	b8 1e 00 00 00       	mov    $0x1e,%eax
c0003e49:	50                   	push   %eax
c0003e4a:	e8 04 e6 ff ff       	call   c0002453 <exception_handler>
c0003e4f:	83 c4 0c             	add    $0xc,%esp
c0003e52:	61                   	popa   
c0003e53:	5d                   	pop    %ebp
c0003e54:	83 c4 04             	add    $0x4,%esp
c0003e57:	cf                   	iret   

c0003e58 <irq_0>:
c0003e58:	60                   	pusha  
c0003e59:	b8 00 00 00 00       	mov    $0x0,%eax
c0003e5e:	50                   	push   %eax
c0003e5f:	e8 26 e6 ff ff       	call   c000248a <irq_handler>
c0003e64:	83 c4 04             	add    $0x4,%esp
c0003e67:	61                   	popa   
c0003e68:	cf                   	iret   
c0003e69:	8d 76 00             	lea    0x0(%esi),%esi

c0003e6c <irq_1>:
c0003e6c:	60                   	pusha  
c0003e6d:	b8 01 00 00 00       	mov    $0x1,%eax
c0003e72:	50                   	push   %eax
c0003e73:	e8 12 e6 ff ff       	call   c000248a <irq_handler>
c0003e78:	83 c4 04             	add    $0x4,%esp
c0003e7b:	61                   	popa   
c0003e7c:	cf                   	iret   
c0003e7d:	8d 76 00             	lea    0x0(%esi),%esi

c0003e80 <irq_2>:
c0003e80:	60                   	pusha  
c0003e81:	b8 02 00 00 00       	mov    $0x2,%eax
c0003e86:	50                   	push   %eax
c0003e87:	e8 fe e5 ff ff       	call   c000248a <irq_handler>
c0003e8c:	83 c4 04             	add    $0x4,%esp
c0003e8f:	61                   	popa   
c0003e90:	cf                   	iret   
c0003e91:	8d 76 00             	lea    0x0(%esi),%esi

c0003e94 <irq_3>:
c0003e94:	60                   	pusha  
c0003e95:	b8 03 00 00 00       	mov    $0x3,%eax
c0003e9a:	50                   	push   %eax
c0003e9b:	e8 ea e5 ff ff       	call   c000248a <irq_handler>
c0003ea0:	83 c4 04             	add    $0x4,%esp
c0003ea3:	61                   	popa   
c0003ea4:	cf                   	iret   
c0003ea5:	8d 76 00             	lea    0x0(%esi),%esi

c0003ea8 <irq_4>:
c0003ea8:	60                   	pusha  
c0003ea9:	b8 04 00 00 00       	mov    $0x4,%eax
c0003eae:	50                   	push   %eax
c0003eaf:	e8 d6 e5 ff ff       	call   c000248a <irq_handler>
c0003eb4:	83 c4 04             	add    $0x4,%esp
c0003eb7:	61                   	popa   
c0003eb8:	cf                   	iret   
c0003eb9:	8d 76 00             	lea    0x0(%esi),%esi

c0003ebc <irq_5>:
c0003ebc:	60                   	pusha  
c0003ebd:	b8 05 00 00 00       	mov    $0x5,%eax
c0003ec2:	50                   	push   %eax
c0003ec3:	e8 c2 e5 ff ff       	call   c000248a <irq_handler>
c0003ec8:	83 c4 04             	add    $0x4,%esp
c0003ecb:	61                   	popa   
c0003ecc:	cf                   	iret   
c0003ecd:	8d 76 00             	lea    0x0(%esi),%esi

c0003ed0 <irq_6>:
c0003ed0:	60                   	pusha  
c0003ed1:	b8 06 00 00 00       	mov    $0x6,%eax
c0003ed6:	50                   	push   %eax
c0003ed7:	e8 ae e5 ff ff       	call   c000248a <irq_handler>
c0003edc:	83 c4 04             	add    $0x4,%esp
c0003edf:	61                   	popa   
c0003ee0:	cf                   	iret   
c0003ee1:	8d 76 00             	lea    0x0(%esi),%esi

c0003ee4 <irq_7>:
c0003ee4:	60                   	pusha  
c0003ee5:	b8 07 00 00 00       	mov    $0x7,%eax
c0003eea:	50                   	push   %eax
c0003eeb:	e8 9a e5 ff ff       	call   c000248a <irq_handler>
c0003ef0:	83 c4 04             	add    $0x4,%esp
c0003ef3:	61                   	popa   
c0003ef4:	cf                   	iret   
c0003ef5:	8d 76 00             	lea    0x0(%esi),%esi

c0003ef8 <irq_8>:
c0003ef8:	60                   	pusha  
c0003ef9:	b8 08 00 00 00       	mov    $0x8,%eax
c0003efe:	50                   	push   %eax
c0003eff:	e8 86 e5 ff ff       	call   c000248a <irq_handler>
c0003f04:	83 c4 04             	add    $0x4,%esp
c0003f07:	61                   	popa   
c0003f08:	cf                   	iret   
c0003f09:	8d 76 00             	lea    0x0(%esi),%esi

c0003f0c <irq_9>:
c0003f0c:	60                   	pusha  
c0003f0d:	b8 09 00 00 00       	mov    $0x9,%eax
c0003f12:	50                   	push   %eax
c0003f13:	e8 72 e5 ff ff       	call   c000248a <irq_handler>
c0003f18:	83 c4 04             	add    $0x4,%esp
c0003f1b:	61                   	popa   
c0003f1c:	cf                   	iret   
c0003f1d:	8d 76 00             	lea    0x0(%esi),%esi

c0003f20 <irq_10>:
c0003f20:	60                   	pusha  
c0003f21:	b8 0a 00 00 00       	mov    $0xa,%eax
c0003f26:	50                   	push   %eax
c0003f27:	e8 5e e5 ff ff       	call   c000248a <irq_handler>
c0003f2c:	83 c4 04             	add    $0x4,%esp
c0003f2f:	61                   	popa   
c0003f30:	cf                   	iret   
c0003f31:	8d 76 00             	lea    0x0(%esi),%esi

c0003f34 <irq_11>:
c0003f34:	60                   	pusha  
c0003f35:	b8 0b 00 00 00       	mov    $0xb,%eax
c0003f3a:	50                   	push   %eax
c0003f3b:	e8 4a e5 ff ff       	call   c000248a <irq_handler>
c0003f40:	83 c4 04             	add    $0x4,%esp
c0003f43:	61                   	popa   
c0003f44:	cf                   	iret   
c0003f45:	8d 76 00             	lea    0x0(%esi),%esi

c0003f48 <irq_12>:
c0003f48:	60                   	pusha  
c0003f49:	b8 0c 00 00 00       	mov    $0xc,%eax
c0003f4e:	50                   	push   %eax
c0003f4f:	e8 36 e5 ff ff       	call   c000248a <irq_handler>
c0003f54:	83 c4 04             	add    $0x4,%esp
c0003f57:	61                   	popa   
c0003f58:	cf                   	iret   
c0003f59:	8d 76 00             	lea    0x0(%esi),%esi

c0003f5c <irq_13>:
c0003f5c:	60                   	pusha  
c0003f5d:	b8 0d 00 00 00       	mov    $0xd,%eax
c0003f62:	50                   	push   %eax
c0003f63:	e8 22 e5 ff ff       	call   c000248a <irq_handler>
c0003f68:	83 c4 04             	add    $0x4,%esp
c0003f6b:	61                   	popa   
c0003f6c:	cf                   	iret   
c0003f6d:	8d 76 00             	lea    0x0(%esi),%esi

c0003f70 <irq_14>:
c0003f70:	60                   	pusha  
c0003f71:	b8 0e 00 00 00       	mov    $0xe,%eax
c0003f76:	50                   	push   %eax
c0003f77:	e8 0e e5 ff ff       	call   c000248a <irq_handler>
c0003f7c:	83 c4 04             	add    $0x4,%esp
c0003f7f:	61                   	popa   
c0003f80:	cf                   	iret   
c0003f81:	8d 76 00             	lea    0x0(%esi),%esi

c0003f84 <irq_15>:
c0003f84:	60                   	pusha  
c0003f85:	b8 0f 00 00 00       	mov    $0xf,%eax
c0003f8a:	50                   	push   %eax
c0003f8b:	e8 fa e4 ff ff       	call   c000248a <irq_handler>
c0003f90:	83 c4 04             	add    $0x4,%esp
c0003f93:	61                   	popa   
c0003f94:	cf                   	iret   
c0003f95:	66 90                	xchg   %ax,%ax
c0003f97:	90                   	nop

c0003f98 <switch_to_task>:
c0003f98:	53                   	push   %ebx
c0003f99:	56                   	push   %esi
c0003f9a:	57                   	push   %edi
c0003f9b:	55                   	push   %ebp
c0003f9c:	8b 3d 40 78 00 c0    	mov    0xc0007840,%edi
c0003fa2:	89 67 08             	mov    %esp,0x8(%edi)
c0003fa5:	8b 74 24 14          	mov    0x14(%esp),%esi
c0003fa9:	89 35 40 78 00 c0    	mov    %esi,0xc0007840
c0003faf:	8b 66 08             	mov    0x8(%esi),%esp
c0003fb2:	8b 5e 0c             	mov    0xc(%esi),%ebx
c0003fb5:	8b 46 10             	mov    0x10(%esi),%eax
c0003fb8:	89 1d 24 79 00 c0    	mov    %ebx,0xc0007924
c0003fbe:	0f 20 d9             	mov    %cr3,%ecx
c0003fc1:	39 c8                	cmp    %ecx,%eax
c0003fc3:	74 03                	je     c0003fc8 <.done>
c0003fc5:	0f 22 d8             	mov    %eax,%cr3

c0003fc8 <.done>:
c0003fc8:	5d                   	pop    %ebp
c0003fc9:	5f                   	pop    %edi
c0003fca:	5e                   	pop    %esi
c0003fcb:	5b                   	pop    %ebx
c0003fcc:	c3                   	ret    

c0003fcd <terminate_task>:
c0003fcd:	8d 35 60 78 00 c0    	lea    0xc0007860,%esi
c0003fd3:	89 35 40 78 00 c0    	mov    %esi,0xc0007840
c0003fd9:	8b 66 08             	mov    0x8(%esi),%esp
c0003fdc:	8b 5e 0c             	mov    0xc(%esi),%ebx
c0003fdf:	8b 46 10             	mov    0x10(%esi),%eax
c0003fe2:	89 1d 24 79 00 c0    	mov    %ebx,0xc0007924
c0003fe8:	0f 20 d9             	mov    %cr3,%ecx
c0003feb:	39 c8                	cmp    %ecx,%eax
c0003fed:	74 d9                	je     c0003fc8 <.done>
c0003fef:	0f 22 d8             	mov    %eax,%cr3

c0003ff2 <.done2>:
c0003ff2:	5d                   	pop    %ebp
c0003ff3:	5f                   	pop    %edi
c0003ff4:	5e                   	pop    %esi
c0003ff5:	5b                   	pop    %ebx
c0003ff6:	c3                   	ret    
c0003ff7:	90                   	nop

c0003ff8 <enable_paging>:
c0003ff8:	55                   	push   %ebp
c0003ff9:	89 e5                	mov    %esp,%ebp
c0003ffb:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ffe:	0f 22 d8             	mov    %eax,%cr3
c0004001:	0f 20 c0             	mov    %cr0,%eax
c0004004:	0d 01 00 00 80       	or     $0x80000001,%eax
c0004009:	0f 22 c0             	mov    %eax,%cr0
c000400c:	89 ec                	mov    %ebp,%esp
c000400e:	5d                   	pop    %ebp
c000400f:	c3                   	ret    

c0004010 <set_page_dir>:
c0004010:	8b 44 24 04          	mov    0x4(%esp),%eax
c0004014:	0f 22 d8             	mov    %eax,%cr3
c0004017:	c3                   	ret    

c0004018 <get_page_dir>:
c0004018:	0f 20 d8             	mov    %cr3,%eax
c000401b:	c3                   	ret    

c000401c <refresh_tlb>:
c000401c:	0f 20 d8             	mov    %cr3,%eax
c000401f:	0f 22 d8             	mov    %eax,%cr3
c0004022:	c3                   	ret    
c0004023:	90                   	nop

c0004024 <refresh_page>:
c0004024:	8b 44 24 04          	mov    0x4(%esp),%eax
c0004028:	0f 01 38             	invlpg (%eax)
c000402b:	c3                   	ret    
