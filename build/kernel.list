
build/kernel:     file format elf32-i386


Disassembly of section .text.boot:

00100000 <_start-0xc>:
  100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fb                   	sti    
  100009:	4f                   	dec    %edi
  10000a:	52                   	push   %edx
  10000b:	e4                   	.byte 0xe4

0010000c <_start>:
  10000c:	fa                   	cli    
  10000d:	3d 02 b0 ad 2b       	cmp    $0x2badb002,%eax
  100012:	0f 85 c1 00 00 00    	jne    1000d9 <kpanic>
  100018:	8d 25 00 f0 10 00    	lea    0x10f000,%esp
  10001e:	53                   	push   %ebx
  10001f:	8d 3d 00 f0 10 00    	lea    0x10f000,%edi
  100025:	b8 83 00 00 00       	mov    $0x83,%eax
  10002a:	89 07                	mov    %eax,(%edi)
  10002c:	0f 20 e0             	mov    %cr4,%eax
  10002f:	83 c8 10             	or     $0x10,%eax
  100032:	0f 22 e0             	mov    %eax,%cr4
  100035:	8d 35 00 00 11 00    	lea    0x110000,%esi
  10003b:	83 ce 03             	or     $0x3,%esi
  10003e:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  100044:	c1 e8 16             	shr    $0x16,%eax
  100047:	bb 04 00 00 00       	mov    $0x4,%ebx
  10004c:	f7 e3                	mul    %ebx
  10004e:	8d 3d 00 f0 10 00    	lea    0x10f000,%edi
  100054:	01 c7                	add    %eax,%edi
  100056:	89 37                	mov    %esi,(%edi)
  100058:	8d 1d 00 00 00 c0    	lea    0xc0000000,%ebx
  10005e:	c1 eb 0c             	shr    $0xc,%ebx
  100061:	8d 0d 68 09 01 c0    	lea    0xc0010968,%ecx
  100067:	81 c1 ff 0f 00 00    	add    $0xfff,%ecx
  10006d:	c1 e9 0c             	shr    $0xc,%ecx
  100070:	29 d9                	sub    %ebx,%ecx
  100072:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  100078:	25 00 f0 3f 00       	and    $0x3ff000,%eax
  10007d:	c1 e8 0c             	shr    $0xc,%eax
  100080:	bb 04 00 00 00       	mov    $0x4,%ebx
  100085:	f7 e3                	mul    %ebx
  100087:	8d 3d 00 00 11 00    	lea    0x110000,%edi
  10008d:	01 c7                	add    %eax,%edi
  10008f:	8d 05 00 10 10 00    	lea    0x101000,%eax
  100095:	83 c8 03             	or     $0x3,%eax
  100098:	fc                   	cld    

00100099 <.nextpte>:
  100099:	ab                   	stos   %eax,%es:(%edi)
  10009a:	05 00 10 00 00       	add    $0x1000,%eax
  10009f:	e2 f8                	loop   100099 <.nextpte>
  1000a1:	8d 35 00 f0 10 00    	lea    0x10f000,%esi
  1000a7:	89 f7                	mov    %esi,%edi
  1000a9:	81 c7 fc 0f 00 00    	add    $0xffc,%edi
  1000af:	83 ce 03             	or     $0x3,%esi
  1000b2:	89 37                	mov    %esi,(%edi)
  1000b4:	5b                   	pop    %ebx

001000b5 <_enable_paging>:
  1000b5:	8d 05 00 f0 10 00    	lea    0x10f000,%eax
  1000bb:	0f 22 d8             	mov    %eax,%cr3
  1000be:	0f 20 c0             	mov    %cr0,%eax
  1000c1:	0d 00 00 01 80       	or     $0x80010000,%eax
  1000c6:	0f 22 c0             	mov    %eax,%cr0
  1000c9:	8d 25 00 e0 00 c0    	lea    0xc000e000,%esp
  1000cf:	50                   	push   %eax
  1000d0:	50                   	push   %eax
  1000d1:	50                   	push   %eax
  1000d2:	53                   	push   %ebx
  1000d3:	e8 98 2b f0 bf       	call   c0002c70 <kernel_main>
  1000d8:	fa                   	cli    

001000d9 <kpanic>:
  1000d9:	f4                   	hlt    
  1000da:	eb fd                	jmp    1000d9 <kpanic>

Disassembly of section .text:

c0000000 <syscall>:
#include "terminal.h"
#include "kprintf.h"

void syscall()
{
c0000000:	55                   	push   %ebp
c0000001:	89 e5                	mov    %esp,%ebp
}
c0000003:	90                   	nop
c0000004:	5d                   	pop    %ebp
c0000005:	c3                   	ret    

c0000006 <vga_entry_color>:
	VGA_COLOR_LIGHT_BROWN = 14,
	VGA_COLOR_WHITE = 15,
};
 
static inline uint8_t vga_entry_color(enum vga_color fg, enum vga_color bg) 
{
c0000006:	55                   	push   %ebp
c0000007:	89 e5                	mov    %esp,%ebp
	return fg | bg << 4;
c0000009:	8b 45 0c             	mov    0xc(%ebp),%eax
c000000c:	c1 e0 04             	shl    $0x4,%eax
c000000f:	89 c2                	mov    %eax,%edx
c0000011:	8b 45 08             	mov    0x8(%ebp),%eax
c0000014:	09 d0                	or     %edx,%eax
}
c0000016:	5d                   	pop    %ebp
c0000017:	c3                   	ret    

c0000018 <vga_entry>:
 
static inline uint16_t vga_entry(unsigned char uc, uint8_t color) 
{
c0000018:	55                   	push   %ebp
c0000019:	89 e5                	mov    %esp,%ebp
c000001b:	83 ec 08             	sub    $0x8,%esp
c000001e:	8b 55 08             	mov    0x8(%ebp),%edx
c0000021:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000024:	88 55 fc             	mov    %dl,-0x4(%ebp)
c0000027:	88 45 f8             	mov    %al,-0x8(%ebp)
	return (uint16_t) uc | (uint16_t) color << 8;
c000002a:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c000002e:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0000032:	c1 e0 08             	shl    $0x8,%eax
c0000035:	09 d0                	or     %edx,%eax
}
c0000037:	c9                   	leave  
c0000038:	c3                   	ret    

c0000039 <outb>:
  return _v;
}

static inline void
outb (unsigned char __value, unsigned short int __port)
{
c0000039:	55                   	push   %ebp
c000003a:	89 e5                	mov    %esp,%ebp
c000003c:	83 ec 08             	sub    $0x8,%esp
c000003f:	8b 55 08             	mov    0x8(%ebp),%edx
c0000042:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000045:	88 55 fc             	mov    %dl,-0x4(%ebp)
c0000048:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
c000004c:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0000050:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
c0000054:	ee                   	out    %al,(%dx)
}
c0000055:	90                   	nop
c0000056:	c9                   	leave  
c0000057:	c3                   	ret    

c0000058 <terminal_init>:
#include "io.h"

struct terminal stdout;

void terminal_init(struct terminal* term) 
{
c0000058:	55                   	push   %ebp
c0000059:	89 e5                	mov    %esp,%ebp
c000005b:	53                   	push   %ebx
c000005c:	83 ec 10             	sub    $0x10,%esp
	term->row = 0;
c000005f:	8b 45 08             	mov    0x8(%ebp),%eax
c0000062:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	term->column = 0;
c0000068:	8b 45 08             	mov    0x8(%ebp),%eax
c000006b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	term->color = vga_entry_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
c0000072:	6a 00                	push   $0x0
c0000074:	6a 07                	push   $0x7
c0000076:	e8 8b ff ff ff       	call   c0000006 <vga_entry_color>
c000007b:	83 c4 08             	add    $0x8,%esp
c000007e:	8b 55 08             	mov    0x8(%ebp),%edx
c0000081:	88 42 08             	mov    %al,0x8(%edx)
	term->buffer = (uint16_t*) VGA_BUFFER;
c0000084:	8b 45 08             	mov    0x8(%ebp),%eax
c0000087:	c7 40 0c 00 80 0b 00 	movl   $0xb8000,0xc(%eax)
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
c000008e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0000095:	eb 54                	jmp    c00000eb <terminal_init+0x93>
		for (size_t x = 0; x < VGA_WIDTH; x++) {
c0000097:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000009e:	eb 41                	jmp    c00000e1 <terminal_init+0x89>
			const size_t index = y * VGA_WIDTH + x;
c00000a0:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00000a3:	89 d0                	mov    %edx,%eax
c00000a5:	c1 e0 02             	shl    $0x2,%eax
c00000a8:	01 d0                	add    %edx,%eax
c00000aa:	c1 e0 04             	shl    $0x4,%eax
c00000ad:	89 c2                	mov    %eax,%edx
c00000af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00000b2:	01 d0                	add    %edx,%eax
c00000b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
			term->buffer[index] = vga_entry(' ', term->color);
c00000b7:	8b 45 08             	mov    0x8(%ebp),%eax
c00000ba:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c00000be:	0f b6 c0             	movzbl %al,%eax
c00000c1:	8b 55 08             	mov    0x8(%ebp),%edx
c00000c4:	8b 4a 0c             	mov    0xc(%edx),%ecx
c00000c7:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00000ca:	01 d2                	add    %edx,%edx
c00000cc:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
c00000cf:	50                   	push   %eax
c00000d0:	6a 20                	push   $0x20
c00000d2:	e8 41 ff ff ff       	call   c0000018 <vga_entry>
c00000d7:	83 c4 08             	add    $0x8,%esp
c00000da:	66 89 03             	mov    %ax,(%ebx)
		for (size_t x = 0; x < VGA_WIDTH; x++) {
c00000dd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00000e1:	83 7d f4 4f          	cmpl   $0x4f,-0xc(%ebp)
c00000e5:	76 b9                	jbe    c00000a0 <terminal_init+0x48>
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
c00000e7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c00000eb:	83 7d f8 18          	cmpl   $0x18,-0x8(%ebp)
c00000ef:	76 a6                	jbe    c0000097 <terminal_init+0x3f>
		}
	}

	//disable cursor
	outb(0x0A, 0x3D4);
c00000f1:	68 d4 03 00 00       	push   $0x3d4
c00000f6:	6a 0a                	push   $0xa
c00000f8:	e8 3c ff ff ff       	call   c0000039 <outb>
c00000fd:	83 c4 08             	add    $0x8,%esp
	outb(0x20, 0x3D5);
c0000100:	68 d5 03 00 00       	push   $0x3d5
c0000105:	6a 20                	push   $0x20
c0000107:	e8 2d ff ff ff       	call   c0000039 <outb>
c000010c:	83 c4 08             	add    $0x8,%esp
	// outb(0x0A, 0x3D4);
	// outb((inb(0x3D5) & 0xC0) | cursor_start, 0x3D5);
 
	// outb(0x0B, 0x3D4);
	// outb((inb(0x3D5) & 0xE0) | cursor_end, 0x3D5);
}
c000010f:	90                   	nop
c0000110:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0000113:	c9                   	leave  
c0000114:	c3                   	ret    

c0000115 <terminal_setcolor>:
 
void terminal_setcolor(struct terminal* term, uint8_t color) 
{
c0000115:	55                   	push   %ebp
c0000116:	89 e5                	mov    %esp,%ebp
c0000118:	83 ec 04             	sub    $0x4,%esp
c000011b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000011e:	88 45 fc             	mov    %al,-0x4(%ebp)
	term->color = color;
c0000121:	8b 45 08             	mov    0x8(%ebp),%eax
c0000124:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c0000128:	88 50 08             	mov    %dl,0x8(%eax)
}
c000012b:	90                   	nop
c000012c:	c9                   	leave  
c000012d:	c3                   	ret    

c000012e <terminal_putentryat>:
 
void terminal_putentryat(struct terminal* term, char c, uint8_t color, size_t x, size_t y) 
{
c000012e:	55                   	push   %ebp
c000012f:	89 e5                	mov    %esp,%ebp
c0000131:	53                   	push   %ebx
c0000132:	83 ec 18             	sub    $0x18,%esp
c0000135:	8b 55 0c             	mov    0xc(%ebp),%edx
c0000138:	8b 45 10             	mov    0x10(%ebp),%eax
c000013b:	88 55 e8             	mov    %dl,-0x18(%ebp)
c000013e:	88 45 e4             	mov    %al,-0x1c(%ebp)
	const size_t index = y * VGA_WIDTH + x;
c0000141:	8b 55 18             	mov    0x18(%ebp),%edx
c0000144:	89 d0                	mov    %edx,%eax
c0000146:	c1 e0 02             	shl    $0x2,%eax
c0000149:	01 d0                	add    %edx,%eax
c000014b:	c1 e0 04             	shl    $0x4,%eax
c000014e:	89 c2                	mov    %eax,%edx
c0000150:	8b 45 14             	mov    0x14(%ebp),%eax
c0000153:	01 d0                	add    %edx,%eax
c0000155:	89 45 f8             	mov    %eax,-0x8(%ebp)
	term->buffer[index] = vga_entry(c, color);
c0000158:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c000015c:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0000160:	0f b6 c0             	movzbl %al,%eax
c0000163:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0000166:	8b 59 0c             	mov    0xc(%ecx),%ebx
c0000169:	8b 4d f8             	mov    -0x8(%ebp),%ecx
c000016c:	01 c9                	add    %ecx,%ecx
c000016e:	01 cb                	add    %ecx,%ebx
c0000170:	52                   	push   %edx
c0000171:	50                   	push   %eax
c0000172:	e8 a1 fe ff ff       	call   c0000018 <vga_entry>
c0000177:	83 c4 08             	add    $0x8,%esp
c000017a:	66 89 03             	mov    %ax,(%ebx)
	// terminal_movecursor(term, x, y);
}
c000017d:	90                   	nop
c000017e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0000181:	c9                   	leave  
c0000182:	c3                   	ret    

c0000183 <terminal_movecursor>:

void terminal_movecursor(struct terminal* term, size_t x, size_t y)
{
c0000183:	55                   	push   %ebp
c0000184:	89 e5                	mov    %esp,%ebp
c0000186:	83 ec 10             	sub    $0x10,%esp
	(void) term; //we are directly manipulating curser, so were arean't using the term struct

	uint16_t pos = y * VGA_WIDTH + x;
c0000189:	8b 45 10             	mov    0x10(%ebp),%eax
c000018c:	89 c2                	mov    %eax,%edx
c000018e:	89 d0                	mov    %edx,%eax
c0000190:	c1 e0 02             	shl    $0x2,%eax
c0000193:	01 d0                	add    %edx,%eax
c0000195:	c1 e0 04             	shl    $0x4,%eax
c0000198:	89 c2                	mov    %eax,%edx
c000019a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000019d:	01 d0                	add    %edx,%eax
c000019f:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

	outb(0x0F, 0x3D4);
c00001a3:	68 d4 03 00 00       	push   $0x3d4
c00001a8:	6a 0f                	push   $0xf
c00001aa:	e8 8a fe ff ff       	call   c0000039 <outb>
c00001af:	83 c4 08             	add    $0x8,%esp
	outb((uint8_t) (pos & 0xFF), 0x3D5);
c00001b2:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c00001b6:	0f b6 c0             	movzbl %al,%eax
c00001b9:	68 d5 03 00 00       	push   $0x3d5
c00001be:	50                   	push   %eax
c00001bf:	e8 75 fe ff ff       	call   c0000039 <outb>
c00001c4:	83 c4 08             	add    $0x8,%esp
	outb(0x0E, 0x3D4);
c00001c7:	68 d4 03 00 00       	push   $0x3d4
c00001cc:	6a 0e                	push   $0xe
c00001ce:	e8 66 fe ff ff       	call   c0000039 <outb>
c00001d3:	83 c4 08             	add    $0x8,%esp
	outb((uint8_t) ((pos >> 8) & 0xFF), 0x3D5);
c00001d6:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c00001da:	66 c1 e8 08          	shr    $0x8,%ax
c00001de:	0f b6 c0             	movzbl %al,%eax
c00001e1:	68 d5 03 00 00       	push   $0x3d5
c00001e6:	50                   	push   %eax
c00001e7:	e8 4d fe ff ff       	call   c0000039 <outb>
c00001ec:	83 c4 08             	add    $0x8,%esp
}
c00001ef:	90                   	nop
c00001f0:	c9                   	leave  
c00001f1:	c3                   	ret    

c00001f2 <terminal_putchar>:

 
void terminal_putchar(struct terminal* term, char c) 
{
c00001f2:	55                   	push   %ebp
c00001f3:	89 e5                	mov    %esp,%ebp
c00001f5:	53                   	push   %ebx
c00001f6:	83 ec 14             	sub    $0x14,%esp
c00001f9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00001fc:	88 45 f4             	mov    %al,-0xc(%ebp)
	if(c == '\n')
c00001ff:	80 7d f4 0a          	cmpb   $0xa,-0xc(%ebp)
c0000203:	75 10                	jne    c0000215 <terminal_putchar+0x23>
	{
		terminal_newline(term);
c0000205:	83 ec 0c             	sub    $0xc,%esp
c0000208:	ff 75 08             	pushl  0x8(%ebp)
c000020b:	e8 95 00 00 00       	call   c00002a5 <terminal_newline>
c0000210:	83 c4 10             	add    $0x10,%esp
		return;
c0000213:	eb 53                	jmp    c0000268 <terminal_putchar+0x76>
	}

	terminal_putentryat(term, c, term->color, term->column, term->row);
c0000215:	8b 45 08             	mov    0x8(%ebp),%eax
c0000218:	8b 18                	mov    (%eax),%ebx
c000021a:	8b 45 08             	mov    0x8(%ebp),%eax
c000021d:	8b 48 04             	mov    0x4(%eax),%ecx
c0000220:	8b 45 08             	mov    0x8(%ebp),%eax
c0000223:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c0000227:	0f b6 d0             	movzbl %al,%edx
c000022a:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c000022e:	83 ec 0c             	sub    $0xc,%esp
c0000231:	53                   	push   %ebx
c0000232:	51                   	push   %ecx
c0000233:	52                   	push   %edx
c0000234:	50                   	push   %eax
c0000235:	ff 75 08             	pushl  0x8(%ebp)
c0000238:	e8 f1 fe ff ff       	call   c000012e <terminal_putentryat>
c000023d:	83 c4 20             	add    $0x20,%esp
	if (++term->column == VGA_WIDTH)
c0000240:	8b 45 08             	mov    0x8(%ebp),%eax
c0000243:	8b 40 04             	mov    0x4(%eax),%eax
c0000246:	8d 50 01             	lea    0x1(%eax),%edx
c0000249:	8b 45 08             	mov    0x8(%ebp),%eax
c000024c:	89 50 04             	mov    %edx,0x4(%eax)
c000024f:	8b 45 08             	mov    0x8(%ebp),%eax
c0000252:	8b 40 04             	mov    0x4(%eax),%eax
c0000255:	83 f8 50             	cmp    $0x50,%eax
c0000258:	75 0e                	jne    c0000268 <terminal_putchar+0x76>
		terminal_newline(term);
c000025a:	83 ec 0c             	sub    $0xc,%esp
c000025d:	ff 75 08             	pushl  0x8(%ebp)
c0000260:	e8 40 00 00 00       	call   c00002a5 <terminal_newline>
c0000265:	83 c4 10             	add    $0x10,%esp
}
c0000268:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000026b:	c9                   	leave  
c000026c:	c3                   	ret    

c000026d <terminal_putcharn>:

void terminal_putcharn(struct terminal* term, char c, size_t repeat) 
{
c000026d:	55                   	push   %ebp
c000026e:	89 e5                	mov    %esp,%ebp
c0000270:	83 ec 28             	sub    $0x28,%esp
c0000273:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000276:	88 45 e4             	mov    %al,-0x1c(%ebp)
	for (size_t i = 0; i < repeat; i++)
c0000279:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0000280:	eb 17                	jmp    c0000299 <terminal_putcharn+0x2c>
		terminal_putchar(term, c);
c0000282:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
c0000286:	83 ec 08             	sub    $0x8,%esp
c0000289:	50                   	push   %eax
c000028a:	ff 75 08             	pushl  0x8(%ebp)
c000028d:	e8 60 ff ff ff       	call   c00001f2 <terminal_putchar>
c0000292:	83 c4 10             	add    $0x10,%esp
	for (size_t i = 0; i < repeat; i++)
c0000295:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0000299:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000029c:	3b 45 10             	cmp    0x10(%ebp),%eax
c000029f:	72 e1                	jb     c0000282 <terminal_putcharn+0x15>
}
c00002a1:	90                   	nop
c00002a2:	90                   	nop
c00002a3:	c9                   	leave  
c00002a4:	c3                   	ret    

c00002a5 <terminal_newline>:

void terminal_newline(struct terminal* term)
{
c00002a5:	55                   	push   %ebp
c00002a6:	89 e5                	mov    %esp,%ebp
c00002a8:	83 ec 08             	sub    $0x8,%esp
    term->column = 0;
c00002ab:	8b 45 08             	mov    0x8(%ebp),%eax
c00002ae:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if (++term->row == VGA_HEIGHT)
c00002b5:	8b 45 08             	mov    0x8(%ebp),%eax
c00002b8:	8b 00                	mov    (%eax),%eax
c00002ba:	8d 50 01             	lea    0x1(%eax),%edx
c00002bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00002c0:	89 10                	mov    %edx,(%eax)
c00002c2:	8b 45 08             	mov    0x8(%ebp),%eax
c00002c5:	8b 00                	mov    (%eax),%eax
c00002c7:	83 f8 19             	cmp    $0x19,%eax
c00002ca:	75 0e                	jne    c00002da <terminal_newline+0x35>
        terminal_scrollline(term);
c00002cc:	83 ec 0c             	sub    $0xc,%esp
c00002cf:	ff 75 08             	pushl  0x8(%ebp)
c00002d2:	e8 06 00 00 00       	call   c00002dd <terminal_scrollline>
c00002d7:	83 c4 10             	add    $0x10,%esp
}
c00002da:	90                   	nop
c00002db:	c9                   	leave  
c00002dc:	c3                   	ret    

c00002dd <terminal_scrollline>:

void terminal_scrollline(struct terminal* term)
{
c00002dd:	55                   	push   %ebp
c00002de:	89 e5                	mov    %esp,%ebp
c00002e0:	83 ec 08             	sub    $0x8,%esp
	// copy rows 2 though N to rows 1 through N-1
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c00002e3:	8b 45 08             	mov    0x8(%ebp),%eax
c00002e6:	8b 40 0c             	mov    0xc(%eax),%eax
c00002e9:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c00002ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00002f2:	8b 40 0c             	mov    0xc(%eax),%eax
c00002f5:	83 ec 04             	sub    $0x4,%esp
c00002f8:	68 00 0f 00 00       	push   $0xf00
c00002fd:	52                   	push   %edx
c00002fe:	50                   	push   %eax
c00002ff:	e8 d5 0f 00 00       	call   c00012d9 <memcpy>
c0000304:	83 c4 10             	add    $0x10,%esp
	// clear last row
	term->row = VGA_HEIGHT-1;
c0000307:	8b 45 08             	mov    0x8(%ebp),%eax
c000030a:	c7 00 18 00 00 00    	movl   $0x18,(%eax)
	terminal_clearline(term);
c0000310:	83 ec 0c             	sub    $0xc,%esp
c0000313:	ff 75 08             	pushl  0x8(%ebp)
c0000316:	e8 06 00 00 00       	call   c0000321 <terminal_clearline>
c000031b:	83 c4 10             	add    $0x10,%esp
}
c000031e:	90                   	nop
c000031f:	c9                   	leave  
c0000320:	c3                   	ret    

c0000321 <terminal_clearline>:

void terminal_clearline(struct terminal* term)
{
c0000321:	55                   	push   %ebp
c0000322:	89 e5                	mov    %esp,%ebp
c0000324:	53                   	push   %ebx
c0000325:	83 ec 10             	sub    $0x10,%esp
	size_t row_start = term->row * VGA_WIDTH;
c0000328:	8b 45 08             	mov    0x8(%ebp),%eax
c000032b:	8b 10                	mov    (%eax),%edx
c000032d:	89 d0                	mov    %edx,%eax
c000032f:	c1 e0 02             	shl    $0x2,%eax
c0000332:	01 d0                	add    %edx,%eax
c0000334:	c1 e0 04             	shl    $0x4,%eax
c0000337:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c000033a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0000341:	eb 2f                	jmp    c0000372 <terminal_clearline+0x51>
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0000343:	8b 45 08             	mov    0x8(%ebp),%eax
c0000346:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c000034a:	0f b6 c0             	movzbl %al,%eax
c000034d:	8b 55 08             	mov    0x8(%ebp),%edx
c0000350:	8b 4a 0c             	mov    0xc(%edx),%ecx
c0000353:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c0000356:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0000359:	01 da                	add    %ebx,%edx
c000035b:	01 d2                	add    %edx,%edx
c000035d:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
c0000360:	50                   	push   %eax
c0000361:	6a 20                	push   $0x20
c0000363:	e8 b0 fc ff ff       	call   c0000018 <vga_entry>
c0000368:	83 c4 08             	add    $0x8,%esp
c000036b:	66 89 03             	mov    %ax,(%ebx)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c000036e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0000372:	83 7d f8 4f          	cmpl   $0x4f,-0x8(%ebp)
c0000376:	76 cb                	jbe    c0000343 <terminal_clearline+0x22>

}
c0000378:	90                   	nop
c0000379:	90                   	nop
c000037a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000037d:	c9                   	leave  
c000037e:	c3                   	ret    

c000037f <terminal_write>:


void terminal_write(struct terminal* term, const char* data, size_t size) 
{
c000037f:	55                   	push   %ebp
c0000380:	89 e5                	mov    %esp,%ebp
c0000382:	83 ec 18             	sub    $0x18,%esp
	for (size_t i = 0; i < size; i++)
c0000385:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000038c:	eb 21                	jmp    c00003af <terminal_write+0x30>
		terminal_putchar(term, data[i]);
c000038e:	8b 55 0c             	mov    0xc(%ebp),%edx
c0000391:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000394:	01 d0                	add    %edx,%eax
c0000396:	0f b6 00             	movzbl (%eax),%eax
c0000399:	0f be c0             	movsbl %al,%eax
c000039c:	83 ec 08             	sub    $0x8,%esp
c000039f:	50                   	push   %eax
c00003a0:	ff 75 08             	pushl  0x8(%ebp)
c00003a3:	e8 4a fe ff ff       	call   c00001f2 <terminal_putchar>
c00003a8:	83 c4 10             	add    $0x10,%esp
	for (size_t i = 0; i < size; i++)
c00003ab:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00003af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00003b2:	3b 45 10             	cmp    0x10(%ebp),%eax
c00003b5:	72 d7                	jb     c000038e <terminal_write+0xf>
}
c00003b7:	90                   	nop
c00003b8:	90                   	nop
c00003b9:	c9                   	leave  
c00003ba:	c3                   	ret    

c00003bb <terminal_writestring>:
 
void terminal_writestring(struct terminal* term, const char* data) 
{
c00003bb:	55                   	push   %ebp
c00003bc:	89 e5                	mov    %esp,%ebp
c00003be:	83 ec 08             	sub    $0x8,%esp
	terminal_write(term, data, strlen(data));
c00003c1:	83 ec 0c             	sub    $0xc,%esp
c00003c4:	ff 75 0c             	pushl  0xc(%ebp)
c00003c7:	e8 e6 0e 00 00       	call   c00012b2 <strlen>
c00003cc:	83 c4 10             	add    $0x10,%esp
c00003cf:	83 ec 04             	sub    $0x4,%esp
c00003d2:	50                   	push   %eax
c00003d3:	ff 75 0c             	pushl  0xc(%ebp)
c00003d6:	ff 75 08             	pushl  0x8(%ebp)
c00003d9:	e8 a1 ff ff ff       	call   c000037f <terminal_write>
c00003de:	83 c4 10             	add    $0x10,%esp
}
c00003e1:	90                   	nop
c00003e2:	c9                   	leave  
c00003e3:	c3                   	ret    

c00003e4 <kprint>:
unsigned int numdigits_uint(unsigned int value, unsigned int base);

int format_uint(unsigned int value, char* str, unsigned int base, int precision, int cap);

int kprint(const char* str)
{
c00003e4:	55                   	push   %ebp
c00003e5:	89 e5                	mov    %esp,%ebp
c00003e7:	83 ec 08             	sub    $0x8,%esp
    terminal_writestring(&stdout, str);
c00003ea:	83 ec 08             	sub    $0x8,%esp
c00003ed:	ff 75 08             	pushl  0x8(%ebp)
c00003f0:	68 00 00 01 c0       	push   $0xc0010000
c00003f5:	e8 c1 ff ff ff       	call   c00003bb <terminal_writestring>
c00003fa:	83 c4 10             	add    $0x10,%esp
    return strlen(str);
c00003fd:	83 ec 0c             	sub    $0xc,%esp
c0000400:	ff 75 08             	pushl  0x8(%ebp)
c0000403:	e8 aa 0e 00 00       	call   c00012b2 <strlen>
c0000408:	83 c4 10             	add    $0x10,%esp
}
c000040b:	c9                   	leave  
c000040c:	c3                   	ret    

c000040d <kprintn>:

int kprintn(const char* str, size_t len)
{
c000040d:	55                   	push   %ebp
c000040e:	89 e5                	mov    %esp,%ebp
c0000410:	83 ec 08             	sub    $0x8,%esp
    terminal_write(&stdout, str, len);
c0000413:	83 ec 04             	sub    $0x4,%esp
c0000416:	ff 75 0c             	pushl  0xc(%ebp)
c0000419:	ff 75 08             	pushl  0x8(%ebp)
c000041c:	68 00 00 01 c0       	push   $0xc0010000
c0000421:	e8 59 ff ff ff       	call   c000037f <terminal_write>
c0000426:	83 c4 10             	add    $0x10,%esp
    return len;
c0000429:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c000042c:	c9                   	leave  
c000042d:	c3                   	ret    

c000042e <kprint_char>:

int kprint_char(char c)
{
c000042e:	55                   	push   %ebp
c000042f:	89 e5                	mov    %esp,%ebp
c0000431:	83 ec 18             	sub    $0x18,%esp
c0000434:	8b 45 08             	mov    0x8(%ebp),%eax
c0000437:	88 45 f4             	mov    %al,-0xc(%ebp)
    terminal_putchar(&stdout, c); 
c000043a:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c000043e:	83 ec 08             	sub    $0x8,%esp
c0000441:	50                   	push   %eax
c0000442:	68 00 00 01 c0       	push   $0xc0010000
c0000447:	e8 a6 fd ff ff       	call   c00001f2 <terminal_putchar>
c000044c:	83 c4 10             	add    $0x10,%esp
    return 1;
c000044f:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0000454:	c9                   	leave  
c0000455:	c3                   	ret    

c0000456 <kprintn_char>:

int kprintn_char(char c, size_t rpt)
{
c0000456:	55                   	push   %ebp
c0000457:	89 e5                	mov    %esp,%ebp
c0000459:	83 ec 18             	sub    $0x18,%esp
c000045c:	8b 45 08             	mov    0x8(%ebp),%eax
c000045f:	88 45 f4             	mov    %al,-0xc(%ebp)
    terminal_putcharn(&stdout, c, rpt); 
c0000462:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c0000466:	83 ec 04             	sub    $0x4,%esp
c0000469:	ff 75 0c             	pushl  0xc(%ebp)
c000046c:	50                   	push   %eax
c000046d:	68 00 00 01 c0       	push   $0xc0010000
c0000472:	e8 f6 fd ff ff       	call   c000026d <terminal_putcharn>
c0000477:	83 c4 10             	add    $0x10,%esp
    return rpt;
c000047a:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c000047d:	c9                   	leave  
c000047e:	c3                   	ret    

c000047f <kprintf>:


int kprintf(const char* format, ...)
{
c000047f:	55                   	push   %ebp
c0000480:	89 e5                	mov    %esp,%ebp
c0000482:	81 ec a8 02 00 00    	sub    $0x2a8,%esp
    /* initialize valist for num number of arguments */
    va_list valist;
    va_start(valist, format);
c0000488:	8d 45 0c             	lea    0xc(%ebp),%eax
c000048b:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)

    // parse format into str
    const char* f = format;
c0000491:	8b 45 08             	mov    0x8(%ebp),%eax
c0000494:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int nchar = 0;
c0000497:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    while(f[0] != 0)
c000049e:	e9 9e 0a 00 00       	jmp    c0000f41 <kprintf+0xac2>
    {
        if(f[0] == '\\' && f[1] == '%')
c00004a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00004a6:	0f b6 00             	movzbl (%eax),%eax
c00004a9:	3c 5c                	cmp    $0x5c,%al
c00004ab:	75 22                	jne    c00004cf <kprintf+0x50>
c00004ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00004b0:	83 c0 01             	add    $0x1,%eax
c00004b3:	0f b6 00             	movzbl (%eax),%eax
c00004b6:	3c 25                	cmp    $0x25,%al
c00004b8:	75 15                	jne    c00004cf <kprintf+0x50>
        {
            //write escaped "%%" as '%'
            kprint_char('%');
c00004ba:	83 ec 0c             	sub    $0xc,%esp
c00004bd:	6a 25                	push   $0x25
c00004bf:	e8 6a ff ff ff       	call   c000042e <kprint_char>
c00004c4:	83 c4 10             	add    $0x10,%esp
            nchar++;
c00004c7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
            f += 2;
c00004cb:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
        }

        if(f[0] == '%')
c00004cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00004d2:	0f b6 00             	movzbl (%eax),%eax
c00004d5:	3c 25                	cmp    $0x25,%al
c00004d7:	0f 85 45 0a 00 00    	jne    c0000f22 <kprintf+0xaa3>
        {
            // found new field

            // parse flags
            struct format_flags flags = {0};
c00004dd:	c7 85 77 ff ff ff 00 	movl   $0x0,-0x89(%ebp)
c00004e4:	00 00 00 
c00004e7:	c6 85 7b ff ff ff 00 	movb   $0x0,-0x85(%ebp)
            int check_flags = 1;
c00004ee:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
            while(check_flags)
c00004f5:	e9 ee 00 00 00       	jmp    c00005e8 <kprintf+0x169>
            {
                switch(*(++f))
c00004fa:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00004fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000501:	0f b6 00             	movzbl (%eax),%eax
c0000504:	0f be c0             	movsbl %al,%eax
c0000507:	85 c0                	test   %eax,%eax
c0000509:	0f 84 c8 00 00 00    	je     c00005d7 <kprintf+0x158>
c000050f:	85 c0                	test   %eax,%eax
c0000511:	0f 88 ca 00 00 00    	js     c00005e1 <kprintf+0x162>
c0000517:	83 f8 30             	cmp    $0x30,%eax
c000051a:	0f 8f c1 00 00 00    	jg     c00005e1 <kprintf+0x162>
c0000520:	83 f8 20             	cmp    $0x20,%eax
c0000523:	0f 8c b8 00 00 00    	jl     c00005e1 <kprintf+0x162>
c0000529:	83 e8 20             	sub    $0x20,%eax
c000052c:	83 f8 10             	cmp    $0x10,%eax
c000052f:	0f 87 ac 00 00 00    	ja     c00005e1 <kprintf+0x162>
c0000535:	8b 04 85 00 40 00 c0 	mov    -0x3fffc000(,%eax,4),%eax
c000053c:	ff e0                	jmp    *%eax
                {
                    case '#':
                        if(flags.alt) return 0;
c000053e:	0f b6 85 77 ff ff ff 	movzbl -0x89(%ebp),%eax
c0000545:	84 c0                	test   %al,%al
c0000547:	74 0a                	je     c0000553 <kprintf+0xd4>
c0000549:	b8 00 00 00 00       	mov    $0x0,%eax
c000054e:	e9 ff 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        flags.alt = 1;
c0000553:	c6 85 77 ff ff ff 01 	movb   $0x1,-0x89(%ebp)
                        break;
c000055a:	e9 89 00 00 00       	jmp    c00005e8 <kprintf+0x169>
                    case '0':
                        if(flags.zero) return 0;
c000055f:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000566:	84 c0                	test   %al,%al
c0000568:	74 0a                	je     c0000574 <kprintf+0xf5>
c000056a:	b8 00 00 00 00       	mov    $0x0,%eax
c000056f:	e9 de 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        flags.zero = 1;
c0000574:	c6 85 78 ff ff ff 01 	movb   $0x1,-0x88(%ebp)
                        break;
c000057b:	eb 6b                	jmp    c00005e8 <kprintf+0x169>
                    case '-':
                        if(flags.left) return 0;
c000057d:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000584:	84 c0                	test   %al,%al
c0000586:	74 0a                	je     c0000592 <kprintf+0x113>
c0000588:	b8 00 00 00 00       	mov    $0x0,%eax
c000058d:	e9 c0 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        flags.left = 1;
c0000592:	c6 85 79 ff ff ff 01 	movb   $0x1,-0x87(%ebp)
                        break;
c0000599:	eb 4d                	jmp    c00005e8 <kprintf+0x169>
                    case ' ':
                        if(flags.space) return 0;
c000059b:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c00005a2:	84 c0                	test   %al,%al
c00005a4:	74 0a                	je     c00005b0 <kprintf+0x131>
c00005a6:	b8 00 00 00 00       	mov    $0x0,%eax
c00005ab:	e9 a2 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        flags.space = 1;
c00005b0:	c6 85 7a ff ff ff 01 	movb   $0x1,-0x86(%ebp)
                        break;
c00005b7:	eb 2f                	jmp    c00005e8 <kprintf+0x169>
                    case '+':
                        if(flags.sign) return 0;
c00005b9:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c00005c0:	84 c0                	test   %al,%al
c00005c2:	74 0a                	je     c00005ce <kprintf+0x14f>
c00005c4:	b8 00 00 00 00       	mov    $0x0,%eax
c00005c9:	e9 84 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        flags.sign = 1;
c00005ce:	c6 85 7b ff ff ff 01 	movb   $0x1,-0x85(%ebp)
                        break;
c00005d5:	eb 11                	jmp    c00005e8 <kprintf+0x169>
                    case '\0':
                        //unexpected string termination
                        return -1;
c00005d7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00005dc:	e9 71 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        break;
                    default:
                        //no more flags
                        check_flags = 0;
c00005e1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
            while(check_flags)
c00005e8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c00005ec:	0f 85 08 ff ff ff    	jne    c00004fa <kprintf+0x7b>
                }
            }

            if(flags.left) flags.zero = 0; //If the 0 and - flags both appear, the 0 flag is ignored
c00005f2:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c00005f9:	84 c0                	test   %al,%al
c00005fb:	74 07                	je     c0000604 <kprintf+0x185>
c00005fd:	c6 85 78 ff ff ff 00 	movb   $0x0,-0x88(%ebp)

            // parse field width
            int field_width=0;
c0000604:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
            int nn=0;
c000060b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
            while(f[nn] >= '0' && f[nn] <= '9')
c0000612:	eb 04                	jmp    c0000618 <kprintf+0x199>
                nn++;            
c0000614:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
            while(f[nn] >= '0' && f[nn] <= '9')
c0000618:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c000061b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000061e:	01 d0                	add    %edx,%eax
c0000620:	0f b6 00             	movzbl (%eax),%eax
c0000623:	3c 2f                	cmp    $0x2f,%al
c0000625:	7e 0f                	jle    c0000636 <kprintf+0x1b7>
c0000627:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c000062a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000062d:	01 d0                	add    %edx,%eax
c000062f:	0f b6 00             	movzbl (%eax),%eax
c0000632:	3c 39                	cmp    $0x39,%al
c0000634:	7e de                	jle    c0000614 <kprintf+0x195>
            if(nn>0)
c0000636:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c000063a:	7e 17                	jle    c0000653 <kprintf+0x1d4>
            {
                field_width = atoi(f);
c000063c:	83 ec 0c             	sub    $0xc,%esp
c000063f:	ff 75 f4             	pushl  -0xc(%ebp)
c0000642:	e8 37 0d 00 00       	call   c000137e <atoi>
c0000647:	83 c4 10             	add    $0x10,%esp
c000064a:	89 45 e8             	mov    %eax,-0x18(%ebp)
                f += nn;
c000064d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0000650:	01 45 f4             	add    %eax,-0xc(%ebp)
            }

            // parse field precision
            int field_prec=-1; //default is -1
c0000653:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
            if(f[0] == '.')
c000065a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000065d:	0f b6 00             	movzbl (%eax),%eax
c0000660:	3c 2e                	cmp    $0x2e,%al
c0000662:	75 59                	jne    c00006bd <kprintf+0x23e>
            {
                f++;
c0000664:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                nn=0;
c0000668:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
                while(f[nn] >= '0' && f[nn] <= '9')
c000066f:	eb 04                	jmp    c0000675 <kprintf+0x1f6>
                    nn++;            
c0000671:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                while(f[nn] >= '0' && f[nn] <= '9')
c0000675:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000678:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000067b:	01 d0                	add    %edx,%eax
c000067d:	0f b6 00             	movzbl (%eax),%eax
c0000680:	3c 2f                	cmp    $0x2f,%al
c0000682:	7e 0f                	jle    c0000693 <kprintf+0x214>
c0000684:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000687:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000068a:	01 d0                	add    %edx,%eax
c000068c:	0f b6 00             	movzbl (%eax),%eax
c000068f:	3c 39                	cmp    $0x39,%al
c0000691:	7e de                	jle    c0000671 <kprintf+0x1f2>
                if(nn>0)
c0000693:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0000697:	7e 24                	jle    c00006bd <kprintf+0x23e>
                {
                    field_prec = atoi(f);
c0000699:	83 ec 0c             	sub    $0xc,%esp
c000069c:	ff 75 f4             	pushl  -0xc(%ebp)
c000069f:	e8 da 0c 00 00       	call   c000137e <atoi>
c00006a4:	83 c4 10             	add    $0x10,%esp
c00006a7:	89 45 e0             	mov    %eax,-0x20(%ebp)
                    if(field_prec<0) field_prec = 0;
c00006aa:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c00006ae:	79 07                	jns    c00006b7 <kprintf+0x238>
c00006b0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
                    f += nn;
c00006b7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00006ba:	01 45 f4             	add    %eax,-0xc(%ebp)

            //parse type
            enum length_mod_t {DEFAULT, CHARINT, SHORTINT, LONGINT, LONGLONGINT,
                            LONGDOUBLE, INTMAX, SIZE, PTRDIFF} length_mod;

            switch(*(f++))
c00006bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00006c0:	8d 50 01             	lea    0x1(%eax),%edx
c00006c3:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00006c6:	0f b6 00             	movzbl (%eax),%eax
c00006c9:	0f be c0             	movsbl %al,%eax
c00006cc:	83 e8 4c             	sub    $0x4c,%eax
c00006cf:	83 f8 2e             	cmp    $0x2e,%eax
c00006d2:	77 6d                	ja     c0000741 <kprintf+0x2c2>
c00006d4:	8b 04 85 44 40 00 c0 	mov    -0x3fffbfbc(,%eax,4),%eax
c00006db:	ff e0                	jmp    *%eax
            {
                case 'h':
                    if(*f == 'h')
c00006dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00006e0:	0f b6 00             	movzbl (%eax),%eax
c00006e3:	3c 68                	cmp    $0x68,%al
c00006e5:	75 0d                	jne    c00006f4 <kprintf+0x275>
                    {
                        f++;
c00006e7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                        length_mod = CHARINT;
c00006eb:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
                    }
                    else
                        length_mod = SHORTINT;
                    break;
c00006f2:	eb 58                	jmp    c000074c <kprintf+0x2cd>
                        length_mod = SHORTINT;
c00006f4:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
                    break;
c00006fb:	eb 4f                	jmp    c000074c <kprintf+0x2cd>
                case 'l':
                    if(*f == 'l')
c00006fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000700:	0f b6 00             	movzbl (%eax),%eax
c0000703:	3c 6c                	cmp    $0x6c,%al
c0000705:	75 0d                	jne    c0000714 <kprintf+0x295>
                    {
                        f++;
c0000707:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                        length_mod = LONGLONGINT;
c000070b:	c7 45 dc 04 00 00 00 	movl   $0x4,-0x24(%ebp)
                    }
                    else
                        length_mod = LONGINT;
                    break;
c0000712:	eb 38                	jmp    c000074c <kprintf+0x2cd>
                        length_mod = LONGINT;
c0000714:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
                    break;
c000071b:	eb 2f                	jmp    c000074c <kprintf+0x2cd>
                case 'q':
                case 'L':
                    length_mod = LONGDOUBLE;
c000071d:	c7 45 dc 05 00 00 00 	movl   $0x5,-0x24(%ebp)
                    break;
c0000724:	eb 26                	jmp    c000074c <kprintf+0x2cd>
                case 'j':
                    length_mod = INTMAX;
c0000726:	c7 45 dc 06 00 00 00 	movl   $0x6,-0x24(%ebp)
                    break;
c000072d:	eb 1d                	jmp    c000074c <kprintf+0x2cd>
                case 'Z':
                case 'z':
                    length_mod = SIZE;
c000072f:	c7 45 dc 07 00 00 00 	movl   $0x7,-0x24(%ebp)
                    break;
c0000736:	eb 14                	jmp    c000074c <kprintf+0x2cd>
                case 't':
                    length_mod = PTRDIFF;
c0000738:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
                    break;
c000073f:	eb 0b                	jmp    c000074c <kprintf+0x2cd>
                default:
                    f--; //no length mod, back up a char...
c0000741:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
                    length_mod = DEFAULT;
c0000745:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
            }

            //parse field
            char val_buf[512]; //assuming here that numberical values cannot exceed 512 chars 
            if(field_width>511)
c000074c:	81 7d e8 ff 01 00 00 	cmpl   $0x1ff,-0x18(%ebp)
c0000753:	7e 0a                	jle    c000075f <kprintf+0x2e0>
                return -1;
c0000755:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000075a:	e9 f3 07 00 00       	jmp    c0000f52 <kprintf+0xad3>

            switch(*f)
c000075f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000762:	0f b6 00             	movzbl (%eax),%eax
c0000765:	0f be c0             	movsbl %al,%eax
c0000768:	83 e8 45             	sub    $0x45,%eax
c000076b:	83 f8 33             	cmp    $0x33,%eax
c000076e:	0f 87 97 07 00 00    	ja     c0000f0b <kprintf+0xa8c>
c0000774:	8b 04 85 00 41 00 c0 	mov    -0x3fffbf00(,%eax,4),%eax
c000077b:	ff e0                	jmp    *%eax
c000077d:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000781:	0f 87 67 01 00 00    	ja     c00008ee <kprintf+0x46f>
                        case(LONGINT):
                        case(LONGLONGINT):
                        case(DEFAULT):
                            {
                                int i_value;
                                if(length_mod == LONGLONGINT)
c0000787:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c000078b:	75 19                	jne    c00007a6 <kprintf+0x327>
                                    i_value = (int) va_arg(valist, long long int); //TODO: implement actual longlong handling
c000078d:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000793:	8d 50 08             	lea    0x8(%eax),%edx
c0000796:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c000079c:	8b 50 04             	mov    0x4(%eax),%edx
c000079f:	8b 00                	mov    (%eax),%eax
c00007a1:	89 45 d8             	mov    %eax,-0x28(%ebp)
c00007a4:	eb 14                	jmp    c00007ba <kprintf+0x33b>
                                else
                                    i_value = va_arg(valist, int);
c00007a6:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c00007ac:	8d 50 04             	lea    0x4(%eax),%edx
c00007af:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c00007b5:	8b 00                	mov    (%eax),%eax
c00007b7:	89 45 d8             	mov    %eax,-0x28(%ebp)

                                char sign_char = 0; //sign character or 0 if none
c00007ba:	c6 45 d7 00          	movb   $0x0,-0x29(%ebp)
                                unsigned int ui_value; //unsigned value (abs value)
                                if(i_value<0)
c00007be:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c00007c2:	79 0e                	jns    c00007d2 <kprintf+0x353>
                                {
                                    ui_value = -i_value;
c00007c4:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00007c7:	f7 d8                	neg    %eax
c00007c9:	89 45 d0             	mov    %eax,-0x30(%ebp)
                                    sign_char = '-';
c00007cc:	c6 45 d7 2d          	movb   $0x2d,-0x29(%ebp)
c00007d0:	eb 26                	jmp    c00007f8 <kprintf+0x379>
                                }
                                else
                                {
                                    ui_value = i_value;
c00007d2:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00007d5:	89 45 d0             	mov    %eax,-0x30(%ebp)
                                    if(flags.sign)
c00007d8:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c00007df:	84 c0                	test   %al,%al
c00007e1:	74 06                	je     c00007e9 <kprintf+0x36a>
                                        sign_char = '+';
c00007e3:	c6 45 d7 2b          	movb   $0x2b,-0x29(%ebp)
c00007e7:	eb 0f                	jmp    c00007f8 <kprintf+0x379>
                                    else if(flags.space)
c00007e9:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c00007f0:	84 c0                	test   %al,%al
c00007f2:	74 04                	je     c00007f8 <kprintf+0x379>
                                        sign_char = ' ';
c00007f4:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
                                    
                                    //else positive number has no sign character
                                }

                                //convert value into string
                                int len = format_uint(ui_value, val_buf, 10, field_prec, 0);
c00007f8:	83 ec 0c             	sub    $0xc,%esp
c00007fb:	6a 00                	push   $0x0
c00007fd:	ff 75 e0             	pushl  -0x20(%ebp)
c0000800:	6a 0a                	push   $0xa
c0000802:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000808:	50                   	push   %eax
c0000809:	ff 75 d0             	pushl  -0x30(%ebp)
c000080c:	e8 43 07 00 00       	call   c0000f54 <format_uint>
c0000811:	83 c4 20             	add    $0x20,%esp
c0000814:	89 45 9c             	mov    %eax,-0x64(%ebp)
                                //amount of padding required to meet requested width
                                int lenpad = field_width - len; 
c0000817:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000081a:	2b 45 9c             	sub    -0x64(%ebp),%eax
c000081d:	89 45 cc             	mov    %eax,-0x34(%ebp)

                                if(sign_char)
c0000820:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
c0000824:	74 22                	je     c0000848 <kprintf+0x3c9>
                                {
                                    lenpad--; //remove one char of padding to account for sign
c0000826:	83 6d cc 01          	subl   $0x1,-0x34(%ebp)
                                    if(flags.zero)
c000082a:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000831:	84 c0                	test   %al,%al
c0000833:	74 13                	je     c0000848 <kprintf+0x3c9>
                                        nchar += kprint_char(sign_char); //if zero padding, sign is at beginning
c0000835:	0f be 45 d7          	movsbl -0x29(%ebp),%eax
c0000839:	83 ec 0c             	sub    $0xc,%esp
c000083c:	50                   	push   %eax
c000083d:	e8 ec fb ff ff       	call   c000042e <kprint_char>
c0000842:	83 c4 10             	add    $0x10,%esp
c0000845:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                if(!flags.left && lenpad>0)
c0000848:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c000084f:	84 c0                	test   %al,%al
c0000851:	75 3b                	jne    c000088e <kprintf+0x40f>
c0000853:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
c0000857:	7e 35                	jle    c000088e <kprintf+0x40f>
                                {
                                    if(flags.zero)
c0000859:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000860:	84 c0                	test   %al,%al
c0000862:	74 16                	je     c000087a <kprintf+0x3fb>
                                        nchar += kprintn_char('0', lenpad);
c0000864:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0000867:	83 ec 08             	sub    $0x8,%esp
c000086a:	50                   	push   %eax
c000086b:	6a 30                	push   $0x30
c000086d:	e8 e4 fb ff ff       	call   c0000456 <kprintn_char>
c0000872:	83 c4 10             	add    $0x10,%esp
c0000875:	01 45 f0             	add    %eax,-0x10(%ebp)
c0000878:	eb 14                	jmp    c000088e <kprintf+0x40f>
                                    else
                                        nchar += kprintn_char(' ', lenpad);
c000087a:	8b 45 cc             	mov    -0x34(%ebp),%eax
c000087d:	83 ec 08             	sub    $0x8,%esp
c0000880:	50                   	push   %eax
c0000881:	6a 20                	push   $0x20
c0000883:	e8 ce fb ff ff       	call   c0000456 <kprintn_char>
c0000888:	83 c4 10             	add    $0x10,%esp
c000088b:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                if(!flags.zero && sign_char)
c000088e:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000895:	84 c0                	test   %al,%al
c0000897:	75 19                	jne    c00008b2 <kprintf+0x433>
c0000899:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
c000089d:	74 13                	je     c00008b2 <kprintf+0x433>
                                    nchar += kprint_char(sign_char); //if not zero padding, write sign here
c000089f:	0f be 45 d7          	movsbl -0x29(%ebp),%eax
c00008a3:	83 ec 0c             	sub    $0xc,%esp
c00008a6:	50                   	push   %eax
c00008a7:	e8 82 fb ff ff       	call   c000042e <kprint_char>
c00008ac:	83 c4 10             	add    $0x10,%esp
c00008af:	01 45 f0             	add    %eax,-0x10(%ebp)

                                nchar += kprint(val_buf);
c00008b2:	83 ec 0c             	sub    $0xc,%esp
c00008b5:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c00008bb:	50                   	push   %eax
c00008bc:	e8 23 fb ff ff       	call   c00003e4 <kprint>
c00008c1:	83 c4 10             	add    $0x10,%esp
c00008c4:	01 45 f0             	add    %eax,-0x10(%ebp)

                                if(flags.left && lenpad>0)
c00008c7:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c00008ce:	84 c0                	test   %al,%al
c00008d0:	74 26                	je     c00008f8 <kprintf+0x479>
c00008d2:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
c00008d6:	7e 20                	jle    c00008f8 <kprintf+0x479>
                                    nchar += kprintn_char(' ', lenpad);
c00008d8:	8b 45 cc             	mov    -0x34(%ebp),%eax
c00008db:	83 ec 08             	sub    $0x8,%esp
c00008de:	50                   	push   %eax
c00008df:	6a 20                	push   $0x20
c00008e1:	e8 70 fb ff ff       	call   c0000456 <kprintn_char>
c00008e6:	83 c4 10             	add    $0x10,%esp
c00008e9:	01 45 f0             	add    %eax,-0x10(%ebp)


                            }
                            break;
c00008ec:	eb 0a                	jmp    c00008f8 <kprintf+0x479>
                        default:
                            return -1; //invalid length mod
c00008ee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00008f3:	e9 5a 06 00 00       	jmp    c0000f52 <kprintf+0xad3>
                            break;
c00008f8:	90                   	nop
                    }
                    break;
c00008f9:	e9 1e 06 00 00       	jmp    c0000f1c <kprintf+0xa9d>
c00008fe:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000902:	0f 87 03 02 00 00    	ja     c0000b0b <kprintf+0x68c>
                        case(SHORTINT):
                        case(LONGINT):
                        case(LONGLONGINT):
                        case(DEFAULT):
                            {
                                unsigned int base = 10;
c0000908:	c7 45 c8 0a 00 00 00 	movl   $0xa,-0x38(%ebp)
                                unsigned int ui_value;
                                if(length_mod == LONGLONGINT)
c000090f:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000913:	75 19                	jne    c000092e <kprintf+0x4af>
                                    ui_value = (unsigned int) va_arg(valist, long long unsigned int); //TODO: implement actual longlong handling
c0000915:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c000091b:	8d 50 08             	lea    0x8(%eax),%edx
c000091e:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000924:	8b 50 04             	mov    0x4(%eax),%edx
c0000927:	8b 00                	mov    (%eax),%eax
c0000929:	89 45 c4             	mov    %eax,-0x3c(%ebp)
c000092c:	eb 14                	jmp    c0000942 <kprintf+0x4c3>
                                else
                                    ui_value = va_arg(valist, unsigned int);
c000092e:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000934:	8d 50 04             	lea    0x4(%eax),%edx
c0000937:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c000093d:	8b 00                	mov    (%eax),%eax
c000093f:	89 45 c4             	mov    %eax,-0x3c(%ebp)

                                if(*f == 'o')
c0000942:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000945:	0f b6 00             	movzbl (%eax),%eax
c0000948:	3c 6f                	cmp    $0x6f,%al
c000094a:	75 09                	jne    c0000955 <kprintf+0x4d6>
                                    base = 8;
c000094c:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
c0000953:	eb 3e                	jmp    c0000993 <kprintf+0x514>
                                else if(*f == 'x' || *f == 'X')
c0000955:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000958:	0f b6 00             	movzbl (%eax),%eax
c000095b:	3c 78                	cmp    $0x78,%al
c000095d:	74 0a                	je     c0000969 <kprintf+0x4ea>
c000095f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000962:	0f b6 00             	movzbl (%eax),%eax
c0000965:	3c 58                	cmp    $0x58,%al
c0000967:	75 09                	jne    c0000972 <kprintf+0x4f3>
                                    base = 16;
c0000969:	c7 45 c8 10 00 00 00 	movl   $0x10,-0x38(%ebp)
c0000970:	eb 21                	jmp    c0000993 <kprintf+0x514>
                                else if(*f == 'p')
c0000972:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000975:	0f b6 00             	movzbl (%eax),%eax
c0000978:	3c 70                	cmp    $0x70,%al
c000097a:	75 10                	jne    c000098c <kprintf+0x50d>
                                {
                                    //print as hex with 0x prefix
                                    base = 16;
c000097c:	c7 45 c8 10 00 00 00 	movl   $0x10,-0x38(%ebp)
                                    flags.alt = 1; 
c0000983:	c6 85 77 ff ff ff 01 	movb   $0x1,-0x89(%ebp)
c000098a:	eb 07                	jmp    c0000993 <kprintf+0x514>
                                }
                                else
                                    flags.alt = 0;
c000098c:	c6 85 77 ff ff ff 00 	movb   $0x0,-0x89(%ebp)
                                
                                int cap = (*f == 'X') ? 1 : 0;
c0000993:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000996:	0f b6 00             	movzbl (%eax),%eax
c0000999:	3c 58                	cmp    $0x58,%al
c000099b:	0f 94 c0             	sete   %al
c000099e:	0f b6 c0             	movzbl %al,%eax
c00009a1:	89 45 94             	mov    %eax,-0x6c(%ebp)

                                //convert value into string
                                int len = format_uint(ui_value, val_buf, base, field_prec, cap);
c00009a4:	83 ec 0c             	sub    $0xc,%esp
c00009a7:	ff 75 94             	pushl  -0x6c(%ebp)
c00009aa:	ff 75 e0             	pushl  -0x20(%ebp)
c00009ad:	ff 75 c8             	pushl  -0x38(%ebp)
c00009b0:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c00009b6:	50                   	push   %eax
c00009b7:	ff 75 c4             	pushl  -0x3c(%ebp)
c00009ba:	e8 95 05 00 00       	call   c0000f54 <format_uint>
c00009bf:	83 c4 20             	add    $0x20,%esp
c00009c2:	89 45 90             	mov    %eax,-0x70(%ebp)
                                //amount of padding required to meet requested width
                                int lenpad = field_width - len; 
c00009c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00009c8:	2b 45 90             	sub    -0x70(%ebp),%eax
c00009cb:	89 45 c0             	mov    %eax,-0x40(%ebp)


                                //format radix prefix for oct and hex with alt flag
                                char radix[3]="";
c00009ce:	66 c7 85 74 ff ff ff 	movw   $0x0,-0x8c(%ebp)
c00009d5:	00 00 
c00009d7:	c6 85 76 ff ff ff 00 	movb   $0x0,-0x8a(%ebp)
                                if(flags.alt)
c00009de:	0f b6 85 77 ff ff ff 	movzbl -0x89(%ebp),%eax
c00009e5:	84 c0                	test   %al,%al
c00009e7:	74 75                	je     c0000a5e <kprintf+0x5df>
                                {
                                    if(base==16)
c00009e9:	83 7d c8 10          	cmpl   $0x10,-0x38(%ebp)
c00009ed:	75 2c                	jne    c0000a1b <kprintf+0x59c>
                                    {
                                        lenpad -= 2;
c00009ef:	83 6d c0 02          	subl   $0x2,-0x40(%ebp)
                                        radix[0] = '0';
c00009f3:	c6 85 74 ff ff ff 30 	movb   $0x30,-0x8c(%ebp)
                                        radix[1] = cap ? 'X' : 'x';
c00009fa:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
c00009fe:	74 07                	je     c0000a07 <kprintf+0x588>
c0000a00:	b8 58 00 00 00       	mov    $0x58,%eax
c0000a05:	eb 05                	jmp    c0000a0c <kprintf+0x58d>
c0000a07:	b8 78 00 00 00       	mov    $0x78,%eax
c0000a0c:	88 85 75 ff ff ff    	mov    %al,-0x8b(%ebp)
                                        radix[2] = 0;
c0000a12:	c6 85 76 ff ff ff 00 	movb   $0x0,-0x8a(%ebp)
c0000a19:	eb 23                	jmp    c0000a3e <kprintf+0x5bf>
                                    }
                                    else if(base==8 && val_buf[0] != '0')
c0000a1b:	83 7d c8 08          	cmpl   $0x8,-0x38(%ebp)
c0000a1f:	75 1d                	jne    c0000a3e <kprintf+0x5bf>
c0000a21:	0f b6 85 74 fd ff ff 	movzbl -0x28c(%ebp),%eax
c0000a28:	3c 30                	cmp    $0x30,%al
c0000a2a:	74 12                	je     c0000a3e <kprintf+0x5bf>
                                    {
                                        lenpad -= 1;
c0000a2c:	83 6d c0 01          	subl   $0x1,-0x40(%ebp)
                                        radix[0] = '0';
c0000a30:	c6 85 74 ff ff ff 30 	movb   $0x30,-0x8c(%ebp)
                                        radix[1] = 0;
c0000a37:	c6 85 75 ff ff ff 00 	movb   $0x0,-0x8b(%ebp)
                                    }

                                    //if zero padding, radix is printed first
                                    if(flags.zero)
c0000a3e:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000a45:	84 c0                	test   %al,%al
c0000a47:	74 15                	je     c0000a5e <kprintf+0x5df>
                                        nchar += kprint(radix);
c0000a49:	83 ec 0c             	sub    $0xc,%esp
c0000a4c:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
c0000a52:	50                   	push   %eax
c0000a53:	e8 8c f9 ff ff       	call   c00003e4 <kprint>
c0000a58:	83 c4 10             	add    $0x10,%esp
c0000a5b:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }


                                //print leading padding, if any
                                if(!flags.left && lenpad>0)
c0000a5e:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000a65:	84 c0                	test   %al,%al
c0000a67:	75 3b                	jne    c0000aa4 <kprintf+0x625>
c0000a69:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
c0000a6d:	7e 35                	jle    c0000aa4 <kprintf+0x625>
                                {
                                    if(flags.zero)
c0000a6f:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000a76:	84 c0                	test   %al,%al
c0000a78:	74 16                	je     c0000a90 <kprintf+0x611>
                                        nchar += kprintn_char('0', lenpad);
c0000a7a:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000a7d:	83 ec 08             	sub    $0x8,%esp
c0000a80:	50                   	push   %eax
c0000a81:	6a 30                	push   $0x30
c0000a83:	e8 ce f9 ff ff       	call   c0000456 <kprintn_char>
c0000a88:	83 c4 10             	add    $0x10,%esp
c0000a8b:	01 45 f0             	add    %eax,-0x10(%ebp)
c0000a8e:	eb 14                	jmp    c0000aa4 <kprintf+0x625>
                                    else
                                        nchar += kprintn_char(' ', lenpad);
c0000a90:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000a93:	83 ec 08             	sub    $0x8,%esp
c0000a96:	50                   	push   %eax
c0000a97:	6a 20                	push   $0x20
c0000a99:	e8 b8 f9 ff ff       	call   c0000456 <kprintn_char>
c0000a9e:	83 c4 10             	add    $0x10,%esp
c0000aa1:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                //print radix prefix if valid and not leading zeros
                                if(!flags.zero && radix[0])
c0000aa4:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000aab:	84 c0                	test   %al,%al
c0000aad:	75 20                	jne    c0000acf <kprintf+0x650>
c0000aaf:	0f b6 85 74 ff ff ff 	movzbl -0x8c(%ebp),%eax
c0000ab6:	84 c0                	test   %al,%al
c0000ab8:	74 15                	je     c0000acf <kprintf+0x650>
                                    nchar += kprint(radix);
c0000aba:	83 ec 0c             	sub    $0xc,%esp
c0000abd:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
c0000ac3:	50                   	push   %eax
c0000ac4:	e8 1b f9 ff ff       	call   c00003e4 <kprint>
c0000ac9:	83 c4 10             	add    $0x10,%esp
c0000acc:	01 45 f0             	add    %eax,-0x10(%ebp)

                                //print number itself
                                nchar += kprint(val_buf);
c0000acf:	83 ec 0c             	sub    $0xc,%esp
c0000ad2:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000ad8:	50                   	push   %eax
c0000ad9:	e8 06 f9 ff ff       	call   c00003e4 <kprint>
c0000ade:	83 c4 10             	add    $0x10,%esp
c0000ae1:	01 45 f0             	add    %eax,-0x10(%ebp)

                                //print trailing padding if left justified
                                if(flags.left && lenpad>0)
c0000ae4:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000aeb:	84 c0                	test   %al,%al
c0000aed:	74 26                	je     c0000b15 <kprintf+0x696>
c0000aef:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
c0000af3:	7e 20                	jle    c0000b15 <kprintf+0x696>
                                    nchar += kprintn_char(' ', lenpad);
c0000af5:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000af8:	83 ec 08             	sub    $0x8,%esp
c0000afb:	50                   	push   %eax
c0000afc:	6a 20                	push   $0x20
c0000afe:	e8 53 f9 ff ff       	call   c0000456 <kprintn_char>
c0000b03:	83 c4 10             	add    $0x10,%esp
c0000b06:	01 45 f0             	add    %eax,-0x10(%ebp)

                            }
                            break;
c0000b09:	eb 0a                	jmp    c0000b15 <kprintf+0x696>
                        default:
                            return -1; //invalid length mod
c0000b0b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000b10:	e9 3d 04 00 00       	jmp    c0000f52 <kprintf+0xad3>
                            break;
c0000b15:	90                   	nop
                    }

                    break;
c0000b16:	e9 01 04 00 00       	jmp    c0000f1c <kprintf+0xa9d>

                case 'f':
                case 'F':
                    {
                        float f_value = (float) va_arg(valist, double);
c0000b1b:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000b21:	8d 50 08             	lea    0x8(%eax),%edx
c0000b24:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000b2a:	dd 00                	fldl   (%eax)
c0000b2c:	d9 5d 8c             	fstps  -0x74(%ebp)

                        //When 0 is printed with an explicit precision 0, the output is empty.
                        if(f_value==0 && field_prec==0)
c0000b2f:	d9 45 8c             	flds   -0x74(%ebp)
c0000b32:	d9 ee                	fldz   
c0000b34:	df e9                	fucomip %st(1),%st
c0000b36:	dd d8                	fstp   %st(0)
c0000b38:	7a 15                	jp     c0000b4f <kprintf+0x6d0>
c0000b3a:	d9 45 8c             	flds   -0x74(%ebp)
c0000b3d:	d9 ee                	fldz   
c0000b3f:	df e9                	fucomip %st(1),%st
c0000b41:	dd d8                	fstp   %st(0)
c0000b43:	75 0a                	jne    c0000b4f <kprintf+0x6d0>
c0000b45:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000b49:	0f 84 c3 03 00 00    	je     c0000f12 <kprintf+0xa93>
                            break;
                        if(field_prec<0) field_prec = 6;  //default is prec = 6
c0000b4f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000b53:	79 07                	jns    c0000b5c <kprintf+0x6dd>
c0000b55:	c7 45 e0 06 00 00 00 	movl   $0x6,-0x20(%ebp)

                        unsigned int ui_part;
                        char sign_char = 0;
c0000b5c:	c6 45 bb 00          	movb   $0x0,-0x45(%ebp)
                        if(f_value<0)
c0000b60:	d9 45 8c             	flds   -0x74(%ebp)
c0000b63:	d9 ee                	fldz   
c0000b65:	df f1                	fcomip %st(1),%st
c0000b67:	dd d8                	fstp   %st(0)
c0000b69:	76 3d                	jbe    c0000ba8 <kprintf+0x729>
                        {
                            ui_part = (unsigned int) -f_value;
c0000b6b:	d9 45 8c             	flds   -0x74(%ebp)
c0000b6e:	d9 e0                	fchs   
c0000b70:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c0000b76:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c0000b7d:	80 cc 0c             	or     $0xc,%ah
c0000b80:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c0000b87:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c0000b8d:	df bd 58 fd ff ff    	fistpll -0x2a8(%ebp)
c0000b93:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
c0000b99:	8b 85 58 fd ff ff    	mov    -0x2a8(%ebp),%eax
c0000b9f:	89 45 bc             	mov    %eax,-0x44(%ebp)
                            sign_char = '-';
c0000ba2:	c6 45 bb 2d          	movb   $0x2d,-0x45(%ebp)
c0000ba6:	eb 55                	jmp    c0000bfd <kprintf+0x77e>
                        }
                        else
                        {
                            ui_part = (unsigned int) f_value;
c0000ba8:	d9 45 8c             	flds   -0x74(%ebp)
c0000bab:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c0000bb1:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c0000bb8:	80 cc 0c             	or     $0xc,%ah
c0000bbb:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c0000bc2:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c0000bc8:	df bd 58 fd ff ff    	fistpll -0x2a8(%ebp)
c0000bce:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
c0000bd4:	8b 85 58 fd ff ff    	mov    -0x2a8(%ebp),%eax
c0000bda:	89 45 bc             	mov    %eax,-0x44(%ebp)
                            if(flags.sign)
c0000bdd:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c0000be4:	84 c0                	test   %al,%al
c0000be6:	74 06                	je     c0000bee <kprintf+0x76f>
                                sign_char = '+';
c0000be8:	c6 45 bb 2b          	movb   $0x2b,-0x45(%ebp)
c0000bec:	eb 0f                	jmp    c0000bfd <kprintf+0x77e>
                            else if(flags.space)
c0000bee:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c0000bf5:	84 c0                	test   %al,%al
c0000bf7:	74 04                	je     c0000bfd <kprintf+0x77e>
                                sign_char = ' ';
c0000bf9:	c6 45 bb 20          	movb   $0x20,-0x45(%ebp)
                            
                            //else positive number has no sign character
                        }

                        int int_len = format_uint(ui_part,val_buf,10,-1,0);
c0000bfd:	83 ec 0c             	sub    $0xc,%esp
c0000c00:	6a 00                	push   $0x0
c0000c02:	6a ff                	push   $0xffffffff
c0000c04:	6a 0a                	push   $0xa
c0000c06:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000c0c:	50                   	push   %eax
c0000c0d:	ff 75 bc             	pushl  -0x44(%ebp)
c0000c10:	e8 3f 03 00 00       	call   c0000f54 <format_uint>
c0000c15:	83 c4 20             	add    $0x20,%esp
c0000c18:	89 45 88             	mov    %eax,-0x78(%ebp)

                        int f_len = int_len + 1 + field_prec;
c0000c1b:	8b 45 88             	mov    -0x78(%ebp),%eax
c0000c1e:	8d 50 01             	lea    0x1(%eax),%edx
c0000c21:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0000c24:	01 d0                	add    %edx,%eax
c0000c26:	89 45 84             	mov    %eax,-0x7c(%ebp)

                        //amount of padding required to meet requested width
                        int lenpad = field_width - f_len; 
c0000c29:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000c2c:	2b 45 84             	sub    -0x7c(%ebp),%eax
c0000c2f:	89 45 b4             	mov    %eax,-0x4c(%ebp)

                        if(sign_char)
c0000c32:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
c0000c36:	74 22                	je     c0000c5a <kprintf+0x7db>
                        {
                            lenpad--; //remove one char of padding to account for sign
c0000c38:	83 6d b4 01          	subl   $0x1,-0x4c(%ebp)
                            if(flags.zero)
c0000c3c:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000c43:	84 c0                	test   %al,%al
c0000c45:	74 13                	je     c0000c5a <kprintf+0x7db>
                                nchar += kprint_char(sign_char); //if zero padding, sign is at beginning
c0000c47:	0f be 45 bb          	movsbl -0x45(%ebp),%eax
c0000c4b:	83 ec 0c             	sub    $0xc,%esp
c0000c4e:	50                   	push   %eax
c0000c4f:	e8 da f7 ff ff       	call   c000042e <kprint_char>
c0000c54:	83 c4 10             	add    $0x10,%esp
c0000c57:	01 45 f0             	add    %eax,-0x10(%ebp)
                        }

                        if(!flags.left && lenpad>0)
c0000c5a:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000c61:	84 c0                	test   %al,%al
c0000c63:	75 3b                	jne    c0000ca0 <kprintf+0x821>
c0000c65:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
c0000c69:	7e 35                	jle    c0000ca0 <kprintf+0x821>
                        {
                            if(flags.zero)
c0000c6b:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000c72:	84 c0                	test   %al,%al
c0000c74:	74 16                	je     c0000c8c <kprintf+0x80d>
                                nchar += kprintn_char('0', lenpad);
c0000c76:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c0000c79:	83 ec 08             	sub    $0x8,%esp
c0000c7c:	50                   	push   %eax
c0000c7d:	6a 30                	push   $0x30
c0000c7f:	e8 d2 f7 ff ff       	call   c0000456 <kprintn_char>
c0000c84:	83 c4 10             	add    $0x10,%esp
c0000c87:	01 45 f0             	add    %eax,-0x10(%ebp)
c0000c8a:	eb 14                	jmp    c0000ca0 <kprintf+0x821>
                            else
                                nchar += kprintn_char(' ', lenpad);
c0000c8c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c0000c8f:	83 ec 08             	sub    $0x8,%esp
c0000c92:	50                   	push   %eax
c0000c93:	6a 20                	push   $0x20
c0000c95:	e8 bc f7 ff ff       	call   c0000456 <kprintn_char>
c0000c9a:	83 c4 10             	add    $0x10,%esp
c0000c9d:	01 45 f0             	add    %eax,-0x10(%ebp)
                        }

                        if(!flags.zero && sign_char)
c0000ca0:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000ca7:	84 c0                	test   %al,%al
c0000ca9:	75 19                	jne    c0000cc4 <kprintf+0x845>
c0000cab:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
c0000caf:	74 13                	je     c0000cc4 <kprintf+0x845>
                            nchar += kprint_char(sign_char); //if not zero padding, write sign here
c0000cb1:	0f be 45 bb          	movsbl -0x45(%ebp),%eax
c0000cb5:	83 ec 0c             	sub    $0xc,%esp
c0000cb8:	50                   	push   %eax
c0000cb9:	e8 70 f7 ff ff       	call   c000042e <kprint_char>
c0000cbe:	83 c4 10             	add    $0x10,%esp
c0000cc1:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprint(val_buf);
c0000cc4:	83 ec 0c             	sub    $0xc,%esp
c0000cc7:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000ccd:	50                   	push   %eax
c0000cce:	e8 11 f7 ff ff       	call   c00003e4 <kprint>
c0000cd3:	83 c4 10             	add    $0x10,%esp
c0000cd6:	01 45 f0             	add    %eax,-0x10(%ebp)
                        nchar += kprint_char('.');
c0000cd9:	83 ec 0c             	sub    $0xc,%esp
c0000cdc:	6a 2e                	push   $0x2e
c0000cde:	e8 4b f7 ff ff       	call   c000042e <kprint_char>
c0000ce3:	83 c4 10             	add    $0x10,%esp
c0000ce6:	01 45 f0             	add    %eax,-0x10(%ebp)

                        //compute fractional digits.
                        float frac = f_value<0 ? -f_value - ui_part : f_value - ui_part;
c0000ce9:	d9 45 8c             	flds   -0x74(%ebp)
c0000cec:	d9 ee                	fldz   
c0000cee:	df f1                	fcomip %st(1),%st
c0000cf0:	dd d8                	fstp   %st(0)
c0000cf2:	76 23                	jbe    c0000d17 <kprintf+0x898>
c0000cf4:	d9 45 8c             	flds   -0x74(%ebp)
c0000cf7:	d9 e0                	fchs   
c0000cf9:	8b 45 bc             	mov    -0x44(%ebp),%eax
c0000cfc:	ba 00 00 00 00       	mov    $0x0,%edx
c0000d01:	89 85 58 fd ff ff    	mov    %eax,-0x2a8(%ebp)
c0000d07:	89 95 5c fd ff ff    	mov    %edx,-0x2a4(%ebp)
c0000d0d:	df ad 58 fd ff ff    	fildll -0x2a8(%ebp)
c0000d13:	de e9                	fsubrp %st,%st(1)
c0000d15:	eb 1f                	jmp    c0000d36 <kprintf+0x8b7>
c0000d17:	8b 45 bc             	mov    -0x44(%ebp),%eax
c0000d1a:	ba 00 00 00 00       	mov    $0x0,%edx
c0000d1f:	89 85 58 fd ff ff    	mov    %eax,-0x2a8(%ebp)
c0000d25:	89 95 5c fd ff ff    	mov    %edx,-0x2a4(%ebp)
c0000d2b:	df ad 58 fd ff ff    	fildll -0x2a8(%ebp)
c0000d31:	d9 45 8c             	flds   -0x74(%ebp)
c0000d34:	de e1                	fsubp  %st,%st(1)
c0000d36:	d9 5d b0             	fstps  -0x50(%ebp)
                        int d;
                        for(int nn=0;nn<field_prec; nn++)
c0000d39:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
c0000d40:	eb 5e                	jmp    c0000da0 <kprintf+0x921>
                        {
                            frac *= 10.;
c0000d42:	d9 45 b0             	flds   -0x50(%ebp)
c0000d45:	d9 05 1c 44 00 c0    	flds   0xc000441c
c0000d4b:	de c9                	fmulp  %st,%st(1)
c0000d4d:	d9 5d b0             	fstps  -0x50(%ebp)
                            d = (int) frac;
c0000d50:	d9 45 b0             	flds   -0x50(%ebp)
c0000d53:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c0000d59:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c0000d60:	80 cc 0c             	or     $0xc,%ah
c0000d63:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c0000d6a:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c0000d70:	db 5d 80             	fistpl -0x80(%ebp)
c0000d73:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
                            frac -= d;
c0000d79:	db 45 80             	fildl  -0x80(%ebp)
c0000d7c:	d9 45 b0             	flds   -0x50(%ebp)
c0000d7f:	de e1                	fsubp  %st,%st(1)
c0000d81:	d9 5d b0             	fstps  -0x50(%ebp)
                            nchar += kprint_char('0' + d);
c0000d84:	8b 45 80             	mov    -0x80(%ebp),%eax
c0000d87:	83 c0 30             	add    $0x30,%eax
c0000d8a:	0f be c0             	movsbl %al,%eax
c0000d8d:	83 ec 0c             	sub    $0xc,%esp
c0000d90:	50                   	push   %eax
c0000d91:	e8 98 f6 ff ff       	call   c000042e <kprint_char>
c0000d96:	83 c4 10             	add    $0x10,%esp
c0000d99:	01 45 f0             	add    %eax,-0x10(%ebp)
                        for(int nn=0;nn<field_prec; nn++)
c0000d9c:	83 45 ac 01          	addl   $0x1,-0x54(%ebp)
c0000da0:	8b 45 ac             	mov    -0x54(%ebp),%eax
c0000da3:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c0000da6:	7c 9a                	jl     c0000d42 <kprintf+0x8c3>
                        }

                        if(flags.left && lenpad>0)
c0000da8:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000daf:	84 c0                	test   %al,%al
c0000db1:	0f 84 5e 01 00 00    	je     c0000f15 <kprintf+0xa96>
c0000db7:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
c0000dbb:	0f 8e 54 01 00 00    	jle    c0000f15 <kprintf+0xa96>
                            nchar += kprintn_char(' ', lenpad);
c0000dc1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c0000dc4:	83 ec 08             	sub    $0x8,%esp
c0000dc7:	50                   	push   %eax
c0000dc8:	6a 20                	push   $0x20
c0000dca:	e8 87 f6 ff ff       	call   c0000456 <kprintn_char>
c0000dcf:	83 c4 10             	add    $0x10,%esp
c0000dd2:	01 45 f0             	add    %eax,-0x10(%ebp)

                    }
                    break;
c0000dd5:	e9 3b 01 00 00       	jmp    c0000f15 <kprintf+0xa96>
                case 'e':
                case 'E':
                case 'g':
                case 'G':
                    return -1; // not yet implemented
c0000dda:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000ddf:	e9 6e 01 00 00       	jmp    c0000f52 <kprintf+0xad3>
                case 'c':
                    {
                        char c = (char) va_arg(valist, int);
c0000de4:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000dea:	8d 50 04             	lea    0x4(%eax),%edx
c0000ded:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000df3:	8b 00                	mov    (%eax),%eax
c0000df5:	88 45 9b             	mov    %al,-0x65(%ebp)

                        if(field_width>1 && !flags.left)    
c0000df8:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
c0000dfc:	7e 22                	jle    c0000e20 <kprintf+0x9a1>
c0000dfe:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000e05:	84 c0                	test   %al,%al
c0000e07:	75 17                	jne    c0000e20 <kprintf+0x9a1>
                            nchar += kprintn_char(' ', field_width-1);
c0000e09:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000e0c:	83 e8 01             	sub    $0x1,%eax
c0000e0f:	83 ec 08             	sub    $0x8,%esp
c0000e12:	50                   	push   %eax
c0000e13:	6a 20                	push   $0x20
c0000e15:	e8 3c f6 ff ff       	call   c0000456 <kprintn_char>
c0000e1a:	83 c4 10             	add    $0x10,%esp
c0000e1d:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprint_char(c);
c0000e20:	0f be 45 9b          	movsbl -0x65(%ebp),%eax
c0000e24:	83 ec 0c             	sub    $0xc,%esp
c0000e27:	50                   	push   %eax
c0000e28:	e8 01 f6 ff ff       	call   c000042e <kprint_char>
c0000e2d:	83 c4 10             	add    $0x10,%esp
c0000e30:	01 45 f0             	add    %eax,-0x10(%ebp)

                        if(field_width>1 && flags.left)    
c0000e33:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
c0000e37:	0f 8e db 00 00 00    	jle    c0000f18 <kprintf+0xa99>
c0000e3d:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000e44:	84 c0                	test   %al,%al
c0000e46:	0f 84 cc 00 00 00    	je     c0000f18 <kprintf+0xa99>
                            nchar += kprintn_char(' ', field_width-1);
c0000e4c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000e4f:	83 e8 01             	sub    $0x1,%eax
c0000e52:	83 ec 08             	sub    $0x8,%esp
c0000e55:	50                   	push   %eax
c0000e56:	6a 20                	push   $0x20
c0000e58:	e8 f9 f5 ff ff       	call   c0000456 <kprintn_char>
c0000e5d:	83 c4 10             	add    $0x10,%esp
c0000e60:	01 45 f0             	add    %eax,-0x10(%ebp)
                    }                    
                    break;
c0000e63:	e9 b0 00 00 00       	jmp    c0000f18 <kprintf+0xa99>

                case 's':
                    {
                        char* str = va_arg(valist, char*);
c0000e68:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000e6e:	8d 50 04             	lea    0x4(%eax),%edx
c0000e71:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000e77:	8b 00                	mov    (%eax),%eax
c0000e79:	89 45 a4             	mov    %eax,-0x5c(%ebp)
                        int len = strlen(str);
c0000e7c:	83 ec 0c             	sub    $0xc,%esp
c0000e7f:	ff 75 a4             	pushl  -0x5c(%ebp)
c0000e82:	e8 2b 04 00 00       	call   c00012b2 <strlen>
c0000e87:	83 c4 10             	add    $0x10,%esp
c0000e8a:	89 45 a8             	mov    %eax,-0x58(%ebp)
                        if(field_prec > 0 && field_prec < len)
c0000e8d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000e91:	7e 0e                	jle    c0000ea1 <kprintf+0xa22>
c0000e93:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0000e96:	3b 45 a8             	cmp    -0x58(%ebp),%eax
c0000e99:	7d 06                	jge    c0000ea1 <kprintf+0xa22>
                            len = field_prec;
c0000e9b:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0000e9e:	89 45 a8             	mov    %eax,-0x58(%ebp)

                        int lenpad = field_width - len; 
c0000ea1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000ea4:	2b 45 a8             	sub    -0x58(%ebp),%eax
c0000ea7:	89 45 a0             	mov    %eax,-0x60(%ebp)

                        if(lenpad>0 && !flags.left)    
c0000eaa:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
c0000eae:	7e 1f                	jle    c0000ecf <kprintf+0xa50>
c0000eb0:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000eb7:	84 c0                	test   %al,%al
c0000eb9:	75 14                	jne    c0000ecf <kprintf+0xa50>
                            nchar += kprintn_char(' ', lenpad);
c0000ebb:	8b 45 a0             	mov    -0x60(%ebp),%eax
c0000ebe:	83 ec 08             	sub    $0x8,%esp
c0000ec1:	50                   	push   %eax
c0000ec2:	6a 20                	push   $0x20
c0000ec4:	e8 8d f5 ff ff       	call   c0000456 <kprintn_char>
c0000ec9:	83 c4 10             	add    $0x10,%esp
c0000ecc:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprintn(str,len);
c0000ecf:	8b 45 a8             	mov    -0x58(%ebp),%eax
c0000ed2:	83 ec 08             	sub    $0x8,%esp
c0000ed5:	50                   	push   %eax
c0000ed6:	ff 75 a4             	pushl  -0x5c(%ebp)
c0000ed9:	e8 2f f5 ff ff       	call   c000040d <kprintn>
c0000ede:	83 c4 10             	add    $0x10,%esp
c0000ee1:	01 45 f0             	add    %eax,-0x10(%ebp)

                        if(lenpad>0 && flags.left)
c0000ee4:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
c0000ee8:	7e 31                	jle    c0000f1b <kprintf+0xa9c>
c0000eea:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000ef1:	84 c0                	test   %al,%al
c0000ef3:	74 26                	je     c0000f1b <kprintf+0xa9c>
                            nchar += kprintn_char(' ', lenpad);
c0000ef5:	8b 45 a0             	mov    -0x60(%ebp),%eax
c0000ef8:	83 ec 08             	sub    $0x8,%esp
c0000efb:	50                   	push   %eax
c0000efc:	6a 20                	push   $0x20
c0000efe:	e8 53 f5 ff ff       	call   c0000456 <kprintn_char>
c0000f03:	83 c4 10             	add    $0x10,%esp
c0000f06:	01 45 f0             	add    %eax,-0x10(%ebp)
                        
                    }
                    break;
c0000f09:	eb 10                	jmp    c0000f1b <kprintf+0xa9c>
                default:
                    //unsupported type
                    return -1;
c0000f0b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000f10:	eb 40                	jmp    c0000f52 <kprintf+0xad3>
                            break;
c0000f12:	90                   	nop
c0000f13:	eb 07                	jmp    c0000f1c <kprintf+0xa9d>
                    break;
c0000f15:	90                   	nop
c0000f16:	eb 04                	jmp    c0000f1c <kprintf+0xa9d>
                    break;
c0000f18:	90                   	nop
c0000f19:	eb 01                	jmp    c0000f1c <kprintf+0xa9d>
                    break;
c0000f1b:	90                   	nop
                
            }
            f++;
c0000f1c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0000f20:	eb 1f                	jmp    c0000f41 <kprintf+0xac2>
        }
        else
        {
            //this isnt part of a format code, just copy char to string and increment pointers
            kprint_char(*(f++));
c0000f22:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000f25:	8d 50 01             	lea    0x1(%eax),%edx
c0000f28:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0000f2b:	0f b6 00             	movzbl (%eax),%eax
c0000f2e:	0f be c0             	movsbl %al,%eax
c0000f31:	83 ec 0c             	sub    $0xc,%esp
c0000f34:	50                   	push   %eax
c0000f35:	e8 f4 f4 ff ff       	call   c000042e <kprint_char>
c0000f3a:	83 c4 10             	add    $0x10,%esp
            nchar++;
c0000f3d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    while(f[0] != 0)
c0000f41:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000f44:	0f b6 00             	movzbl (%eax),%eax
c0000f47:	84 c0                	test   %al,%al
c0000f49:	0f 85 54 f5 ff ff    	jne    c00004a3 <kprintf+0x24>
    }

   /* clean memory reserved for valist */
   va_end(valist);

   return nchar; //number of characters copied to str
c0000f4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0000f52:	c9                   	leave  
c0000f53:	c3                   	ret    

c0000f54 <format_uint>:
// base may be 2-32
// precision is per printf format, precision<0 represents default (unspecified) 
// cap = 0, alpha-numbers are capitalized [base>10 only]
// returns length of string (not counting null termination)
int format_uint(unsigned int value, char* str, unsigned int base, int precision, int cap)
{
c0000f54:	55                   	push   %ebp
c0000f55:	89 e5                	mov    %esp,%ebp
c0000f57:	83 ec 18             	sub    $0x18,%esp
    if(base < 2 || base > 32)
c0000f5a:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c0000f5e:	76 06                	jbe    c0000f66 <format_uint+0x12>
c0000f60:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
c0000f64:	76 0a                	jbe    c0000f70 <format_uint+0x1c>
        return -1;
c0000f66:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000f6b:	e9 d1 00 00 00       	jmp    c0001041 <format_uint+0xed>

    //When 0 is printed with an explicit precision 0, the output is empty.
    if(value==0 && precision==0)
c0000f70:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0000f74:	75 16                	jne    c0000f8c <format_uint+0x38>
c0000f76:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c0000f7a:	75 10                	jne    c0000f8c <format_uint+0x38>
    {
        str[0] = 0;
c0000f7c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000f7f:	c6 00 00             	movb   $0x0,(%eax)
        return 0;
c0000f82:	b8 00 00 00 00       	mov    $0x0,%eax
c0000f87:	e9 b5 00 00 00       	jmp    c0001041 <format_uint+0xed>
    }

    // find number of digits
    int num_digits = numdigits_uint(value, base);
c0000f8c:	83 ec 08             	sub    $0x8,%esp
c0000f8f:	ff 75 10             	pushl  0x10(%ebp)
c0000f92:	ff 75 08             	pushl  0x8(%ebp)
c0000f95:	e8 a9 00 00 00       	call   c0001043 <numdigits_uint>
c0000f9a:	83 c4 10             	add    $0x10,%esp
c0000f9d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    num_digits = num_digits>precision ? num_digits : precision;
c0000fa0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0000fa3:	39 45 14             	cmp    %eax,0x14(%ebp)
c0000fa6:	0f 4d 45 14          	cmovge 0x14(%ebp),%eax
c0000faa:	89 45 ec             	mov    %eax,-0x14(%ebp)

    //write formatted number out in reverse order
    char* s = str + num_digits;
c0000fad:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0000fb0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000fb3:	01 d0                	add    %edx,%eax
c0000fb5:	89 45 f4             	mov    %eax,-0xc(%ebp)

    *(s--) = '\0'; //null termination
c0000fb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000fbb:	8d 50 ff             	lea    -0x1(%eax),%edx
c0000fbe:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0000fc1:	c6 00 00             	movb   $0x0,(%eax)

    //compute each digit from lowest to highest.
    unsigned int d;
    for(int nn=0;nn<num_digits; nn++)
c0000fc4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0000fcb:	eb 69                	jmp    c0001036 <format_uint+0xe2>
    {
        d = value % base;
c0000fcd:	8b 45 08             	mov    0x8(%ebp),%eax
c0000fd0:	ba 00 00 00 00       	mov    $0x0,%edx
c0000fd5:	f7 75 10             	divl   0x10(%ebp)
c0000fd8:	89 55 e8             	mov    %edx,-0x18(%ebp)
        value /= base;
c0000fdb:	8b 45 08             	mov    0x8(%ebp),%eax
c0000fde:	ba 00 00 00 00       	mov    $0x0,%edx
c0000fe3:	f7 75 10             	divl   0x10(%ebp)
c0000fe6:	89 45 08             	mov    %eax,0x8(%ebp)

        //write digit into string and decrement pointer
        if(d < 10)
c0000fe9:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
c0000fed:	77 15                	ja     c0001004 <format_uint+0xb0>
            *(s--) = d + '0';
c0000fef:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000ff2:	8d 48 30             	lea    0x30(%eax),%ecx
c0000ff5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000ff8:	8d 50 ff             	lea    -0x1(%eax),%edx
c0000ffb:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0000ffe:	89 ca                	mov    %ecx,%edx
c0001000:	88 10                	mov    %dl,(%eax)
c0001002:	eb 2e                	jmp    c0001032 <format_uint+0xde>
        else if(cap == 0)
c0001004:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
c0001008:	75 15                	jne    c000101f <format_uint+0xcb>
            *(s--) = d - 10 + 'a';
c000100a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000100d:	8d 48 57             	lea    0x57(%eax),%ecx
c0001010:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001013:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001016:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0001019:	89 ca                	mov    %ecx,%edx
c000101b:	88 10                	mov    %dl,(%eax)
c000101d:	eb 13                	jmp    c0001032 <format_uint+0xde>
        else
            *(s--) = d - 10 + 'A';
c000101f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001022:	8d 48 37             	lea    0x37(%eax),%ecx
c0001025:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001028:	8d 50 ff             	lea    -0x1(%eax),%edx
c000102b:	89 55 f4             	mov    %edx,-0xc(%ebp)
c000102e:	89 ca                	mov    %ecx,%edx
c0001030:	88 10                	mov    %dl,(%eax)
    for(int nn=0;nn<num_digits; nn++)
c0001032:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0001036:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001039:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c000103c:	7c 8f                	jl     c0000fcd <format_uint+0x79>
    }

    return num_digits;
c000103e:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c0001041:	c9                   	leave  
c0001042:	c3                   	ret    

c0001043 <numdigits_uint>:


//returns number of digits of unsigned int represented in given base
//num_digits is always >= 1
unsigned int numdigits_uint(unsigned int value, unsigned int base)
{
c0001043:	55                   	push   %ebp
c0001044:	89 e5                	mov    %esp,%ebp
c0001046:	83 ec 10             	sub    $0x10,%esp
    unsigned int num_digits = 1;
c0001049:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
    while(value >= base)
c0001050:	eb 12                	jmp    c0001064 <numdigits_uint+0x21>
    {
        num_digits++;
c0001052:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        value /= base;
c0001056:	8b 45 08             	mov    0x8(%ebp),%eax
c0001059:	ba 00 00 00 00       	mov    $0x0,%edx
c000105e:	f7 75 0c             	divl   0xc(%ebp)
c0001061:	89 45 08             	mov    %eax,0x8(%ebp)
    while(value >= base)
c0001064:	8b 45 08             	mov    0x8(%ebp),%eax
c0001067:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000106a:	73 e6                	jae    c0001052 <numdigits_uint+0xf>
    }
    return num_digits;
c000106c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c000106f:	c9                   	leave  
c0001070:	c3                   	ret    

c0001071 <kprintf_test>:



void kprintf_test()
{
c0001071:	55                   	push   %ebp
c0001072:	89 e5                	mov    %esp,%ebp
c0001074:	83 ec 18             	sub    $0x18,%esp
    int num = 12345678;    
c0001077:	c7 45 f4 4e 61 bc 00 	movl   $0xbc614e,-0xc(%ebp)
    kprintf("\nkprintf() tests...\n", num);
c000107e:	83 ec 08             	sub    $0x8,%esp
c0001081:	ff 75 f4             	pushl  -0xc(%ebp)
c0001084:	68 d0 41 00 c0       	push   $0xc00041d0
c0001089:	e8 f1 f3 ff ff       	call   c000047f <kprintf>
c000108e:	83 c4 10             	add    $0x10,%esp
    kprintf("Fixed width, right justify:\n");
c0001091:	83 ec 0c             	sub    $0xc,%esp
c0001094:	68 e5 41 00 c0       	push   $0xc00041e5
c0001099:	e8 e1 f3 ff ff       	call   c000047f <kprintf>
c000109e:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%15d]\n", num);
c00010a1:	83 ec 08             	sub    $0x8,%esp
c00010a4:	ff 75 f4             	pushl  -0xc(%ebp)
c00010a7:	68 02 42 00 c0       	push   $0xc0004202
c00010ac:	e8 ce f3 ff ff       	call   c000047f <kprintf>
c00010b1:	83 c4 10             	add    $0x10,%esp
    kprintf("Hex:     [%#15x]\n", num);
c00010b4:	83 ec 08             	sub    $0x8,%esp
c00010b7:	ff 75 f4             	pushl  -0xc(%ebp)
c00010ba:	68 13 42 00 c0       	push   $0xc0004213
c00010bf:	e8 bb f3 ff ff       	call   c000047f <kprintf>
c00010c4:	83 c4 10             	add    $0x10,%esp
    kprintf("Oct:     [%#15o]\n", num);
c00010c7:	83 ec 08             	sub    $0x8,%esp
c00010ca:	ff 75 f4             	pushl  -0xc(%ebp)
c00010cd:	68 25 42 00 c0       	push   $0xc0004225
c00010d2:	e8 a8 f3 ff ff       	call   c000047f <kprintf>
c00010d7:	83 c4 10             	add    $0x10,%esp
    kprintf("String:  [%15s]\n", "Hello World!");
c00010da:	83 ec 08             	sub    $0x8,%esp
c00010dd:	68 37 42 00 c0       	push   $0xc0004237
c00010e2:	68 44 42 00 c0       	push   $0xc0004244
c00010e7:	e8 93 f3 ff ff       	call   c000047f <kprintf>
c00010ec:	83 c4 10             	add    $0x10,%esp
    kprintf("Char:    [%15c]\n", '!');
c00010ef:	83 ec 08             	sub    $0x8,%esp
c00010f2:	6a 21                	push   $0x21
c00010f4:	68 55 42 00 c0       	push   $0xc0004255
c00010f9:	e8 81 f3 ff ff       	call   c000047f <kprintf>
c00010fe:	83 c4 10             	add    $0x10,%esp

    kprintf("\nFixed width, left justify:\n");
c0001101:	83 ec 0c             	sub    $0xc,%esp
c0001104:	68 66 42 00 c0       	push   $0xc0004266
c0001109:	e8 71 f3 ff ff       	call   c000047f <kprintf>
c000110e:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%-15d]\n", num);
c0001111:	83 ec 08             	sub    $0x8,%esp
c0001114:	ff 75 f4             	pushl  -0xc(%ebp)
c0001117:	68 83 42 00 c0       	push   $0xc0004283
c000111c:	e8 5e f3 ff ff       	call   c000047f <kprintf>
c0001121:	83 c4 10             	add    $0x10,%esp
    kprintf("Hex:     [%-#15x]\n", num);
c0001124:	83 ec 08             	sub    $0x8,%esp
c0001127:	ff 75 f4             	pushl  -0xc(%ebp)
c000112a:	68 95 42 00 c0       	push   $0xc0004295
c000112f:	e8 4b f3 ff ff       	call   c000047f <kprintf>
c0001134:	83 c4 10             	add    $0x10,%esp
    kprintf("String:  [%-15s]\n", "Hello World!");
c0001137:	83 ec 08             	sub    $0x8,%esp
c000113a:	68 37 42 00 c0       	push   $0xc0004237
c000113f:	68 a8 42 00 c0       	push   $0xc00042a8
c0001144:	e8 36 f3 ff ff       	call   c000047f <kprintf>
c0001149:	83 c4 10             	add    $0x10,%esp

    kprintf("\nFixed Precision:\n");
c000114c:	83 ec 0c             	sub    $0xc,%esp
c000114f:	68 ba 42 00 c0       	push   $0xc00042ba
c0001154:	e8 26 f3 ff ff       	call   c000047f <kprintf>
c0001159:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%15.10d]\nHex:     [%#15.10x]\nOct:     [%#15.10o]\nString:  [%15.10s]\n", 
c000115c:	83 ec 0c             	sub    $0xc,%esp
c000115f:	68 37 42 00 c0       	push   $0xc0004237
c0001164:	ff 75 f4             	pushl  -0xc(%ebp)
c0001167:	ff 75 f4             	pushl  -0xc(%ebp)
c000116a:	ff 75 f4             	pushl  -0xc(%ebp)
c000116d:	68 d0 42 00 c0       	push   $0xc00042d0
c0001172:	e8 08 f3 ff ff       	call   c000047f <kprintf>
c0001177:	83 c4 20             	add    $0x20,%esp
        num, num, num, "Hello World!");

    kprintf("\nLeading Zeros:\n");
c000117a:	83 ec 0c             	sub    $0xc,%esp
c000117d:	68 1f 43 00 c0       	push   $0xc000431f
c0001182:	e8 f8 f2 ff ff       	call   c000047f <kprintf>
c0001187:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%015.10d]\nHex:     [%#015.10x]\nOct:     [%#015.10o]\n",num, num, num);
c000118a:	ff 75 f4             	pushl  -0xc(%ebp)
c000118d:	ff 75 f4             	pushl  -0xc(%ebp)
c0001190:	ff 75 f4             	pushl  -0xc(%ebp)
c0001193:	68 30 43 00 c0       	push   $0xc0004330
c0001198:	e8 e2 f2 ff ff       	call   c000047f <kprintf>
c000119d:	83 c4 10             	add    $0x10,%esp

    kprintf("Signed (none):  [%d], [%d]\n",num, -num);
c00011a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00011a3:	f7 d8                	neg    %eax
c00011a5:	83 ec 04             	sub    $0x4,%esp
c00011a8:	50                   	push   %eax
c00011a9:	ff 75 f4             	pushl  -0xc(%ebp)
c00011ac:	68 6f 43 00 c0       	push   $0xc000436f
c00011b1:	e8 c9 f2 ff ff       	call   c000047f <kprintf>
c00011b6:	83 c4 10             	add    $0x10,%esp
    kprintf("Signed (space): [% d], [% d]\n",num, -num);
c00011b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00011bc:	f7 d8                	neg    %eax
c00011be:	83 ec 04             	sub    $0x4,%esp
c00011c1:	50                   	push   %eax
c00011c2:	ff 75 f4             	pushl  -0xc(%ebp)
c00011c5:	68 8b 43 00 c0       	push   $0xc000438b
c00011ca:	e8 b0 f2 ff ff       	call   c000047f <kprintf>
c00011cf:	83 c4 10             	add    $0x10,%esp
    kprintf("Signed (+):     [%+d], [%+d]\n",num, -num);
c00011d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00011d5:	f7 d8                	neg    %eax
c00011d7:	83 ec 04             	sub    $0x4,%esp
c00011da:	50                   	push   %eax
c00011db:	ff 75 f4             	pushl  -0xc(%ebp)
c00011de:	68 a9 43 00 c0       	push   $0xc00043a9
c00011e3:	e8 97 f2 ff ff       	call   c000047f <kprintf>
c00011e8:	83 c4 10             	add    $0x10,%esp

    float f = 1.23456789;
c00011eb:	d9 05 20 44 00 c0    	flds   0xc0004420
c00011f1:	d9 5d f0             	fstps  -0x10(%ebp)
    kprintf("\nfloat:     [%15.f]\n",f);
c00011f4:	d9 45 f0             	flds   -0x10(%ebp)
c00011f7:	83 ec 04             	sub    $0x4,%esp
c00011fa:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c00011fe:	dd 1c 24             	fstpl  (%esp)
c0001201:	68 c7 43 00 c0       	push   $0xc00043c7
c0001206:	e8 74 f2 ff ff       	call   c000047f <kprintf>
c000120b:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.3f]\n",f);
c000120e:	d9 45 f0             	flds   -0x10(%ebp)
c0001211:	83 ec 04             	sub    $0x4,%esp
c0001214:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001218:	dd 1c 24             	fstpl  (%esp)
c000121b:	68 dc 43 00 c0       	push   $0xc00043dc
c0001220:	e8 5a f2 ff ff       	call   c000047f <kprintf>
c0001225:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.10f]\n",f);
c0001228:	d9 45 f0             	flds   -0x10(%ebp)
c000122b:	83 ec 04             	sub    $0x4,%esp
c000122e:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001232:	dd 1c 24             	fstpl  (%esp)
c0001235:	68 f1 43 00 c0       	push   $0xc00043f1
c000123a:	e8 40 f2 ff ff       	call   c000047f <kprintf>
c000123f:	83 c4 10             	add    $0x10,%esp

    f = -12345.6789;
c0001242:	d9 05 24 44 00 c0    	flds   0xc0004424
c0001248:	d9 5d f0             	fstps  -0x10(%ebp)
    kprintf("float:     [%15f]\n",f);
c000124b:	d9 45 f0             	flds   -0x10(%ebp)
c000124e:	83 ec 04             	sub    $0x4,%esp
c0001251:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001255:	dd 1c 24             	fstpl  (%esp)
c0001258:	68 07 44 00 c0       	push   $0xc0004407
c000125d:	e8 1d f2 ff ff       	call   c000047f <kprintf>
c0001262:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.3f]\n",f);
c0001265:	d9 45 f0             	flds   -0x10(%ebp)
c0001268:	83 ec 04             	sub    $0x4,%esp
c000126b:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c000126f:	dd 1c 24             	fstpl  (%esp)
c0001272:	68 dc 43 00 c0       	push   $0xc00043dc
c0001277:	e8 03 f2 ff ff       	call   c000047f <kprintf>
c000127c:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.10f]\n",f);
c000127f:	d9 45 f0             	flds   -0x10(%ebp)
c0001282:	83 ec 04             	sub    $0x4,%esp
c0001285:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001289:	dd 1c 24             	fstpl  (%esp)
c000128c:	68 f1 43 00 c0       	push   $0xc00043f1
c0001291:	e8 e9 f1 ff ff       	call   c000047f <kprintf>
c0001296:	83 c4 10             	add    $0x10,%esp
}
c0001299:	90                   	nop
c000129a:	c9                   	leave  
c000129b:	c3                   	ret    

c000129c <panic>:
#include "common.h"
#include "kprintf.h"

void panic(char* str)
{
c000129c:	55                   	push   %ebp
c000129d:	89 e5                	mov    %esp,%ebp
c000129f:	83 ec 08             	sub    $0x8,%esp
    kprintf(str);
c00012a2:	83 ec 0c             	sub    $0xc,%esp
c00012a5:	ff 75 08             	pushl  0x8(%ebp)
c00012a8:	e8 d2 f1 ff ff       	call   c000047f <kprintf>
c00012ad:	83 c4 10             	add    $0x10,%esp
    while(1);
c00012b0:	eb fe                	jmp    c00012b0 <panic+0x14>

c00012b2 <strlen>:
}

size_t strlen(const char* str) 
{
c00012b2:	55                   	push   %ebp
c00012b3:	89 e5                	mov    %esp,%ebp
c00012b5:	83 ec 10             	sub    $0x10,%esp
	size_t len = 0;
c00012b8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while (str[len])
c00012bf:	eb 04                	jmp    c00012c5 <strlen+0x13>
		len++;
c00012c1:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
	while (str[len])
c00012c5:	8b 55 08             	mov    0x8(%ebp),%edx
c00012c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00012cb:	01 d0                	add    %edx,%eax
c00012cd:	0f b6 00             	movzbl (%eax),%eax
c00012d0:	84 c0                	test   %al,%al
c00012d2:	75 ed                	jne    c00012c1 <strlen+0xf>
	return len;
c00012d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00012d7:	c9                   	leave  
c00012d8:	c3                   	ret    

c00012d9 <memcpy>:

// copy n bytes from src to dest
void *memcpy(void *dest, const void *src, size_t n)
{
c00012d9:	55                   	push   %ebp
c00012da:	89 e5                	mov    %esp,%ebp
c00012dc:	83 ec 20             	sub    $0x20,%esp
    //system wordsize is equal to length of size_t
    size_t n_words = n/sizeof(size_t);
c00012df:	8b 45 10             	mov    0x10(%ebp),%eax
c00012e2:	c1 e8 02             	shr    $0x2,%eax
c00012e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t* dest_word = (size_t *) dest;
c00012e8:	8b 45 08             	mov    0x8(%ebp),%eax
c00012eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    size_t* src_word = (size_t *) src;
c00012ee:	8b 45 0c             	mov    0xc(%ebp),%eax
c00012f1:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for(size_t nn=0; nn<n_words; nn++)
c00012f4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00012fb:	eb 26                	jmp    c0001323 <memcpy+0x4a>
        dest_word[nn]=src_word[nn];
c00012fd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001300:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0001307:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000130a:	01 d0                	add    %edx,%eax
c000130c:	8b 55 fc             	mov    -0x4(%ebp),%edx
c000130f:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
c0001316:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001319:	01 ca                	add    %ecx,%edx
c000131b:	8b 00                	mov    (%eax),%eax
c000131d:	89 02                	mov    %eax,(%edx)
    for(size_t nn=0; nn<n_words; nn++)
c000131f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0001323:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001326:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0001329:	72 d2                	jb     c00012fd <memcpy+0x24>
    
    //copy remaining bytes
    size_t n_bytes = n - n_words*sizeof(size_t);
c000132b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000132e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0001335:	8b 45 10             	mov    0x10(%ebp),%eax
c0001338:	29 d0                	sub    %edx,%eax
c000133a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(n_bytes > 0)
c000133d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0001341:	74 36                	je     c0001379 <memcpy+0xa0>
    {
        char* dest_byte = (char *) dest;
c0001343:	8b 45 08             	mov    0x8(%ebp),%eax
c0001346:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        char* src_byte = (char *) src;
c0001349:	8b 45 0c             	mov    0xc(%ebp),%eax
c000134c:	89 45 e0             	mov    %eax,-0x20(%ebp)
        for(size_t nn=0; nn<n_bytes; nn++)
c000134f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0001356:	eb 19                	jmp    c0001371 <memcpy+0x98>
            dest_byte[nn]=src_byte[nn];
c0001358:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000135b:	8b 45 f8             	mov    -0x8(%ebp),%eax
c000135e:	01 d0                	add    %edx,%eax
c0001360:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c0001363:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0001366:	01 ca                	add    %ecx,%edx
c0001368:	0f b6 00             	movzbl (%eax),%eax
c000136b:	88 02                	mov    %al,(%edx)
        for(size_t nn=0; nn<n_bytes; nn++)
c000136d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0001371:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0001374:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0001377:	72 df                	jb     c0001358 <memcpy+0x7f>
    }

    return dest;
c0001379:	8b 45 08             	mov    0x8(%ebp),%eax
}
c000137c:	c9                   	leave  
c000137d:	c3                   	ret    

c000137e <atoi>:

int atoi(const char* str)
{
c000137e:	55                   	push   %ebp
c000137f:	89 e5                	mov    %esp,%ebp
c0001381:	83 ec 20             	sub    $0x20,%esp
    int p = 0;
c0001384:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    int neg = 0;
c000138b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    //find start of number string, ignore whitespace
    while(str[p] == '-' || str[p] == ' ' || (str[p] >= 9 && str[p] <= 13))
c0001392:	eb 41                	jmp    c00013d5 <atoi+0x57>
    {
        if(str[p++] == '-')
c0001394:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001397:	8d 50 01             	lea    0x1(%eax),%edx
c000139a:	89 55 fc             	mov    %edx,-0x4(%ebp)
c000139d:	89 c2                	mov    %eax,%edx
c000139f:	8b 45 08             	mov    0x8(%ebp),%eax
c00013a2:	01 d0                	add    %edx,%eax
c00013a4:	0f b6 00             	movzbl (%eax),%eax
c00013a7:	3c 2d                	cmp    $0x2d,%al
c00013a9:	75 09                	jne    c00013b4 <atoi+0x36>
        {
            neg=1;
c00013ab:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
            break;
c00013b2:	eb 5d                	jmp    c0001411 <atoi+0x93>
        }
        if(str[p++] == '\0')
c00013b4:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00013b7:	8d 50 01             	lea    0x1(%eax),%edx
c00013ba:	89 55 fc             	mov    %edx,-0x4(%ebp)
c00013bd:	89 c2                	mov    %eax,%edx
c00013bf:	8b 45 08             	mov    0x8(%ebp),%eax
c00013c2:	01 d0                	add    %edx,%eax
c00013c4:	0f b6 00             	movzbl (%eax),%eax
c00013c7:	84 c0                	test   %al,%al
c00013c9:	75 0a                	jne    c00013d5 <atoi+0x57>
            return 0; //invalid string (only whitespace found)
c00013cb:	b8 00 00 00 00       	mov    $0x0,%eax
c00013d0:	e9 ee 00 00 00       	jmp    c00014c3 <atoi+0x145>
    while(str[p] == '-' || str[p] == ' ' || (str[p] >= 9 && str[p] <= 13))
c00013d5:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00013d8:	8b 45 08             	mov    0x8(%ebp),%eax
c00013db:	01 d0                	add    %edx,%eax
c00013dd:	0f b6 00             	movzbl (%eax),%eax
c00013e0:	3c 2d                	cmp    $0x2d,%al
c00013e2:	74 b0                	je     c0001394 <atoi+0x16>
c00013e4:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00013e7:	8b 45 08             	mov    0x8(%ebp),%eax
c00013ea:	01 d0                	add    %edx,%eax
c00013ec:	0f b6 00             	movzbl (%eax),%eax
c00013ef:	3c 20                	cmp    $0x20,%al
c00013f1:	74 a1                	je     c0001394 <atoi+0x16>
c00013f3:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00013f6:	8b 45 08             	mov    0x8(%ebp),%eax
c00013f9:	01 d0                	add    %edx,%eax
c00013fb:	0f b6 00             	movzbl (%eax),%eax
c00013fe:	3c 08                	cmp    $0x8,%al
c0001400:	7e 0f                	jle    c0001411 <atoi+0x93>
c0001402:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0001405:	8b 45 08             	mov    0x8(%ebp),%eax
c0001408:	01 d0                	add    %edx,%eax
c000140a:	0f b6 00             	movzbl (%eax),%eax
c000140d:	3c 0d                	cmp    $0xd,%al
c000140f:	7e 83                	jle    c0001394 <atoi+0x16>
    }

    int num_start = p;
c0001411:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001414:	89 45 e8             	mov    %eax,-0x18(%ebp)

    //find end of integer string (ints only, no decimal point)
    while(str[p] >= '0' && str[p] <= '9')
c0001417:	eb 21                	jmp    c000143a <atoi+0xbc>
    {
        if(str[p++] == '\0')
c0001419:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000141c:	8d 50 01             	lea    0x1(%eax),%edx
c000141f:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001422:	89 c2                	mov    %eax,%edx
c0001424:	8b 45 08             	mov    0x8(%ebp),%eax
c0001427:	01 d0                	add    %edx,%eax
c0001429:	0f b6 00             	movzbl (%eax),%eax
c000142c:	84 c0                	test   %al,%al
c000142e:	75 0a                	jne    c000143a <atoi+0xbc>
            return 0; //invalid string (only whitespace found)
c0001430:	b8 00 00 00 00       	mov    $0x0,%eax
c0001435:	e9 89 00 00 00       	jmp    c00014c3 <atoi+0x145>
    while(str[p] >= '0' && str[p] <= '9')
c000143a:	8b 55 fc             	mov    -0x4(%ebp),%edx
c000143d:	8b 45 08             	mov    0x8(%ebp),%eax
c0001440:	01 d0                	add    %edx,%eax
c0001442:	0f b6 00             	movzbl (%eax),%eax
c0001445:	3c 2f                	cmp    $0x2f,%al
c0001447:	7e 0f                	jle    c0001458 <atoi+0xda>
c0001449:	8b 55 fc             	mov    -0x4(%ebp),%edx
c000144c:	8b 45 08             	mov    0x8(%ebp),%eax
c000144f:	01 d0                	add    %edx,%eax
c0001451:	0f b6 00             	movzbl (%eax),%eax
c0001454:	3c 39                	cmp    $0x39,%al
c0001456:	7e c1                	jle    c0001419 <atoi+0x9b>
    }

    if(num_start == p) return 0; //length 0 string
c0001458:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000145b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c000145e:	75 07                	jne    c0001467 <atoi+0xe9>
c0001460:	b8 00 00 00 00       	mov    $0x0,%eax
c0001465:	eb 5c                	jmp    c00014c3 <atoi+0x145>

    int number = 0;
c0001467:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    int place = 1;
c000146e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    //iterate backwards through number to add each digit
    for(int digit = p-1; digit >= num_start; digit--)
c0001475:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001478:	83 e8 01             	sub    $0x1,%eax
c000147b:	89 45 ec             	mov    %eax,-0x14(%ebp)
c000147e:	eb 2b                	jmp    c00014ab <atoi+0x12d>
    {
        number += (int) (str[digit] - '0') * place;
c0001480:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0001483:	8b 45 08             	mov    0x8(%ebp),%eax
c0001486:	01 d0                	add    %edx,%eax
c0001488:	0f b6 00             	movzbl (%eax),%eax
c000148b:	0f be c0             	movsbl %al,%eax
c000148e:	83 e8 30             	sub    $0x30,%eax
c0001491:	0f af 45 f0          	imul   -0x10(%ebp),%eax
c0001495:	01 45 f4             	add    %eax,-0xc(%ebp)
        place *= 10;
c0001498:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000149b:	89 d0                	mov    %edx,%eax
c000149d:	c1 e0 02             	shl    $0x2,%eax
c00014a0:	01 d0                	add    %edx,%eax
c00014a2:	01 c0                	add    %eax,%eax
c00014a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for(int digit = p-1; digit >= num_start; digit--)
c00014a7:	83 6d ec 01          	subl   $0x1,-0x14(%ebp)
c00014ab:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00014ae:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c00014b1:	7d cd                	jge    c0001480 <atoi+0x102>
    }

    if(neg)
c00014b3:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c00014b7:	74 07                	je     c00014c0 <atoi+0x142>
        return -1*number;
c00014b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00014bc:	f7 d8                	neg    %eax
c00014be:	eb 03                	jmp    c00014c3 <atoi+0x145>
    else
        return number;
c00014c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00014c3:	c9                   	leave  
c00014c4:	c3                   	ret    

c00014c5 <itoa>:

char* itoa( int value, char* str, int base)
{
c00014c5:	55                   	push   %ebp
c00014c6:	89 e5                	mov    %esp,%ebp
c00014c8:	83 ec 20             	sub    $0x20,%esp
    if(base < 2 || base > 32)
c00014cb:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c00014cf:	7e 06                	jle    c00014d7 <itoa+0x12>
c00014d1:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
c00014d5:	7e 0a                	jle    c00014e1 <itoa+0x1c>
        return NULL;
c00014d7:	b8 00 00 00 00       	mov    $0x0,%eax
c00014dc:	e9 df 00 00 00       	jmp    c00015c0 <itoa+0xfb>

    //handle zero as special case 
    if(value == 0)
c00014e1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00014e5:	75 17                	jne    c00014fe <itoa+0x39>
    {
        str[0] = '0';
c00014e7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00014ea:	c6 00 30             	movb   $0x30,(%eax)
        str[1] = '\0';
c00014ed:	8b 45 0c             	mov    0xc(%ebp),%eax
c00014f0:	83 c0 01             	add    $0x1,%eax
c00014f3:	c6 00 00             	movb   $0x0,(%eax)
        return str;
c00014f6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00014f9:	e9 c2 00 00 00       	jmp    c00015c0 <itoa+0xfb>
    }

    char* s = str;
c00014fe:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001501:	89 45 fc             	mov    %eax,-0x4(%ebp)
    unsigned int residual; //holds the unsigned value still to be parsed
    if(base == 10 && value < 0)
c0001504:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
c0001508:	75 1c                	jne    c0001526 <itoa+0x61>
c000150a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c000150e:	79 16                	jns    c0001526 <itoa+0x61>
    {
        residual = -value;
c0001510:	8b 45 08             	mov    0x8(%ebp),%eax
c0001513:	f7 d8                	neg    %eax
c0001515:	89 45 f8             	mov    %eax,-0x8(%ebp)
        *(s++) = '-';
c0001518:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000151b:	8d 50 01             	lea    0x1(%eax),%edx
c000151e:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001521:	c6 00 2d             	movb   $0x2d,(%eax)
c0001524:	eb 06                	jmp    c000152c <itoa+0x67>
    }
    else
    {
        //all non-decimal numbers are treated as unsigned
        residual = (unsigned int) value;
c0001526:	8b 45 08             	mov    0x8(%ebp),%eax
c0001529:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    
    // find number of digits so that we can parse number
    // directly into string from lowest to highest digit    
    unsigned int num_digits = 0;
c000152c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    unsigned int temp = residual;
c0001533:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0001536:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(temp>0)
c0001539:	eb 14                	jmp    c000154f <itoa+0x8a>
    {
        num_digits++;
c000153b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
        temp /= base;
c000153f:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0001542:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001545:	ba 00 00 00 00       	mov    $0x0,%edx
c000154a:	f7 f1                	div    %ecx
c000154c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(temp>0)
c000154f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0001553:	75 e6                	jne    c000153b <itoa+0x76>
    }

    //point at end of string
    s += num_digits;
c0001555:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001558:	01 45 fc             	add    %eax,-0x4(%ebp)
    *(s--) = '\0'; //null termination
c000155b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000155e:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001561:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001564:	c6 00 00             	movb   $0x0,(%eax)

    //compute each digit from lowest to highest.
    unsigned int digit;
    while(residual>0)
c0001567:	eb 4e                	jmp    c00015b7 <itoa+0xf2>
    {
        digit = residual % base;
c0001569:	8b 4d 10             	mov    0x10(%ebp),%ecx
c000156c:	8b 45 f8             	mov    -0x8(%ebp),%eax
c000156f:	ba 00 00 00 00       	mov    $0x0,%edx
c0001574:	f7 f1                	div    %ecx
c0001576:	89 55 ec             	mov    %edx,-0x14(%ebp)
        residual /= base;
c0001579:	8b 4d 10             	mov    0x10(%ebp),%ecx
c000157c:	8b 45 f8             	mov    -0x8(%ebp),%eax
c000157f:	ba 00 00 00 00       	mov    $0x0,%edx
c0001584:	f7 f1                	div    %ecx
c0001586:	89 45 f8             	mov    %eax,-0x8(%ebp)

        //write digit into string and decrement pointer
        if(digit < 10)
c0001589:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
c000158d:	77 15                	ja     c00015a4 <itoa+0xdf>
            *(s--) = digit + '0';
c000158f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001592:	8d 48 30             	lea    0x30(%eax),%ecx
c0001595:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001598:	8d 50 ff             	lea    -0x1(%eax),%edx
c000159b:	89 55 fc             	mov    %edx,-0x4(%ebp)
c000159e:	89 ca                	mov    %ecx,%edx
c00015a0:	88 10                	mov    %dl,(%eax)
c00015a2:	eb 13                	jmp    c00015b7 <itoa+0xf2>
        else
            *(s--) = digit - 10 + 'A';        
c00015a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00015a7:	8d 48 37             	lea    0x37(%eax),%ecx
c00015aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00015ad:	8d 50 ff             	lea    -0x1(%eax),%edx
c00015b0:	89 55 fc             	mov    %edx,-0x4(%ebp)
c00015b3:	89 ca                	mov    %ecx,%edx
c00015b5:	88 10                	mov    %dl,(%eax)
    while(residual>0)
c00015b7:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c00015bb:	75 ac                	jne    c0001569 <itoa+0xa4>
    }

    return str;
c00015bd:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c00015c0:	c9                   	leave  
c00015c1:	c3                   	ret    

c00015c2 <printregs>:
#include "regs.h"
#include "kprintf.h"

void printregs(const reg_t* regs)
{
c00015c2:	55                   	push   %ebp
c00015c3:	89 e5                	mov    %esp,%ebp
c00015c5:	57                   	push   %edi
c00015c6:	56                   	push   %esi
c00015c7:	53                   	push   %ebx
c00015c8:	83 ec 0c             	sub    $0xc,%esp
    kprintf("Registers:\n");
c00015cb:	83 ec 0c             	sub    $0xc,%esp
c00015ce:	68 28 44 00 c0       	push   $0xc0004428
c00015d3:	e8 a7 ee ff ff       	call   c000047f <kprintf>
c00015d8:	83 c4 10             	add    $0x10,%esp
    kprintf("eax: 0x%x\n", regs->eax);
c00015db:	8b 45 08             	mov    0x8(%ebp),%eax
c00015de:	8b 00                	mov    (%eax),%eax
c00015e0:	83 ec 08             	sub    $0x8,%esp
c00015e3:	50                   	push   %eax
c00015e4:	68 34 44 00 c0       	push   $0xc0004434
c00015e9:	e8 91 ee ff ff       	call   c000047f <kprintf>
c00015ee:	83 c4 10             	add    $0x10,%esp
    kprintf("ebx: 0x%x\n", regs->ebx);
c00015f1:	8b 45 08             	mov    0x8(%ebp),%eax
c00015f4:	8b 40 04             	mov    0x4(%eax),%eax
c00015f7:	83 ec 08             	sub    $0x8,%esp
c00015fa:	50                   	push   %eax
c00015fb:	68 3f 44 00 c0       	push   $0xc000443f
c0001600:	e8 7a ee ff ff       	call   c000047f <kprintf>
c0001605:	83 c4 10             	add    $0x10,%esp
    kprintf("ecx: 0x%x\n", regs->ecx);
c0001608:	8b 45 08             	mov    0x8(%ebp),%eax
c000160b:	8b 40 08             	mov    0x8(%eax),%eax
c000160e:	83 ec 08             	sub    $0x8,%esp
c0001611:	50                   	push   %eax
c0001612:	68 4a 44 00 c0       	push   $0xc000444a
c0001617:	e8 63 ee ff ff       	call   c000047f <kprintf>
c000161c:	83 c4 10             	add    $0x10,%esp
    kprintf("edx: 0x%x\n", regs->edx);
c000161f:	8b 45 08             	mov    0x8(%ebp),%eax
c0001622:	8b 40 0c             	mov    0xc(%eax),%eax
c0001625:	83 ec 08             	sub    $0x8,%esp
c0001628:	50                   	push   %eax
c0001629:	68 55 44 00 c0       	push   $0xc0004455
c000162e:	e8 4c ee ff ff       	call   c000047f <kprintf>
c0001633:	83 c4 10             	add    $0x10,%esp
    kprintf("esi: 0x%x\n", regs->esi);
c0001636:	8b 45 08             	mov    0x8(%ebp),%eax
c0001639:	8b 40 10             	mov    0x10(%eax),%eax
c000163c:	83 ec 08             	sub    $0x8,%esp
c000163f:	50                   	push   %eax
c0001640:	68 60 44 00 c0       	push   $0xc0004460
c0001645:	e8 35 ee ff ff       	call   c000047f <kprintf>
c000164a:	83 c4 10             	add    $0x10,%esp
    kprintf("edi: 0x%x\n", regs->edi);
c000164d:	8b 45 08             	mov    0x8(%ebp),%eax
c0001650:	8b 40 14             	mov    0x14(%eax),%eax
c0001653:	83 ec 08             	sub    $0x8,%esp
c0001656:	50                   	push   %eax
c0001657:	68 6b 44 00 c0       	push   $0xc000446b
c000165c:	e8 1e ee ff ff       	call   c000047f <kprintf>
c0001661:	83 c4 10             	add    $0x10,%esp
    kprintf("ebp: 0x%x\n", regs->ebp);
c0001664:	8b 45 08             	mov    0x8(%ebp),%eax
c0001667:	8b 40 1c             	mov    0x1c(%eax),%eax
c000166a:	83 ec 08             	sub    $0x8,%esp
c000166d:	50                   	push   %eax
c000166e:	68 76 44 00 c0       	push   $0xc0004476
c0001673:	e8 07 ee ff ff       	call   c000047f <kprintf>
c0001678:	83 c4 10             	add    $0x10,%esp
    kprintf("esp: 0x%x\n", regs->esp);
c000167b:	8b 45 08             	mov    0x8(%ebp),%eax
c000167e:	8b 40 18             	mov    0x18(%eax),%eax
c0001681:	83 ec 08             	sub    $0x8,%esp
c0001684:	50                   	push   %eax
c0001685:	68 81 44 00 c0       	push   $0xc0004481
c000168a:	e8 f0 ed ff ff       	call   c000047f <kprintf>
c000168f:	83 c4 10             	add    $0x10,%esp
    kprintf("eip: 0x%x\n", regs->eip);
c0001692:	8b 45 08             	mov    0x8(%ebp),%eax
c0001695:	8b 40 20             	mov    0x20(%eax),%eax
c0001698:	83 ec 08             	sub    $0x8,%esp
c000169b:	50                   	push   %eax
c000169c:	68 8c 44 00 c0       	push   $0xc000448c
c00016a1:	e8 d9 ed ff ff       	call   c000047f <kprintf>
c00016a6:	83 c4 10             	add    $0x10,%esp
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
                                                            (regs->eflags&EFLAGS_PF) == EFLAGS_PF,
                                                            (regs->eflags&EFLAGS_AF) == EFLAGS_AF,
                                                            (regs->eflags&EFLAGS_ZF) == EFLAGS_ZF,
                                                            (regs->eflags&EFLAGS_SF) == EFLAGS_SF,
                                                            (regs->eflags&EFLAGS_TF) == EFLAGS_TF);
c00016a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00016ac:	8b 40 24             	mov    0x24(%eax),%eax
c00016af:	25 00 01 00 00       	and    $0x100,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c00016b4:	85 c0                	test   %eax,%eax
c00016b6:	0f 95 c0             	setne  %al
c00016b9:	0f b6 f8             	movzbl %al,%edi
                                                            (regs->eflags&EFLAGS_SF) == EFLAGS_SF,
c00016bc:	8b 45 08             	mov    0x8(%ebp),%eax
c00016bf:	8b 40 24             	mov    0x24(%eax),%eax
c00016c2:	25 80 00 00 00       	and    $0x80,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c00016c7:	85 c0                	test   %eax,%eax
c00016c9:	0f 95 c0             	setne  %al
c00016cc:	0f b6 f0             	movzbl %al,%esi
                                                            (regs->eflags&EFLAGS_ZF) == EFLAGS_ZF,
c00016cf:	8b 45 08             	mov    0x8(%ebp),%eax
c00016d2:	8b 40 24             	mov    0x24(%eax),%eax
c00016d5:	83 e0 40             	and    $0x40,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c00016d8:	85 c0                	test   %eax,%eax
c00016da:	0f 95 c0             	setne  %al
c00016dd:	0f b6 d8             	movzbl %al,%ebx
                                                            (regs->eflags&EFLAGS_AF) == EFLAGS_AF,
c00016e0:	8b 45 08             	mov    0x8(%ebp),%eax
c00016e3:	8b 40 24             	mov    0x24(%eax),%eax
c00016e6:	83 e0 10             	and    $0x10,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c00016e9:	85 c0                	test   %eax,%eax
c00016eb:	0f 95 c0             	setne  %al
c00016ee:	0f b6 c8             	movzbl %al,%ecx
                                                            (regs->eflags&EFLAGS_PF) == EFLAGS_PF,
c00016f1:	8b 45 08             	mov    0x8(%ebp),%eax
c00016f4:	8b 40 24             	mov    0x24(%eax),%eax
c00016f7:	83 e0 04             	and    $0x4,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c00016fa:	85 c0                	test   %eax,%eax
c00016fc:	0f 95 c0             	setne  %al
c00016ff:	0f b6 d0             	movzbl %al,%edx
c0001702:	8b 45 08             	mov    0x8(%ebp),%eax
c0001705:	8b 40 24             	mov    0x24(%eax),%eax
c0001708:	83 e0 01             	and    $0x1,%eax
c000170b:	85 c0                	test   %eax,%eax
c000170d:	0f 95 c0             	setne  %al
c0001710:	0f b6 c0             	movzbl %al,%eax
c0001713:	83 ec 04             	sub    $0x4,%esp
c0001716:	57                   	push   %edi
c0001717:	56                   	push   %esi
c0001718:	53                   	push   %ebx
c0001719:	51                   	push   %ecx
c000171a:	52                   	push   %edx
c000171b:	50                   	push   %eax
c000171c:	68 98 44 00 c0       	push   $0xc0004498
c0001721:	e8 59 ed ff ff       	call   c000047f <kprintf>
c0001726:	83 c4 20             	add    $0x20,%esp
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
                                                            (regs->eflags&EFLAGS_DF) == EFLAGS_DF,
                                                            (regs->eflags&EFLAGS_OF) == EFLAGS_OF,
                                                            (regs->eflags&EFLAGS_IOPL) >> 12,
                                                            (regs->eflags&EFLAGS_NT) == EFLAGS_NT,
                                                            (regs->eflags&EFLAGS_RF) == EFLAGS_RF);
c0001729:	8b 45 08             	mov    0x8(%ebp),%eax
c000172c:	8b 40 24             	mov    0x24(%eax),%eax
c000172f:	25 00 00 01 00       	and    $0x10000,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001734:	85 c0                	test   %eax,%eax
c0001736:	0f 95 c0             	setne  %al
c0001739:	0f b6 f0             	movzbl %al,%esi
                                                            (regs->eflags&EFLAGS_NT) == EFLAGS_NT,
c000173c:	8b 45 08             	mov    0x8(%ebp),%eax
c000173f:	8b 40 24             	mov    0x24(%eax),%eax
c0001742:	25 00 40 00 00       	and    $0x4000,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001747:	85 c0                	test   %eax,%eax
c0001749:	0f 95 c0             	setne  %al
c000174c:	0f b6 d8             	movzbl %al,%ebx
                                                            (regs->eflags&EFLAGS_IOPL) >> 12,
c000174f:	8b 45 08             	mov    0x8(%ebp),%eax
c0001752:	8b 40 24             	mov    0x24(%eax),%eax
c0001755:	c1 e8 0c             	shr    $0xc,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001758:	83 e0 03             	and    $0x3,%eax
c000175b:	89 c7                	mov    %eax,%edi
                                                            (regs->eflags&EFLAGS_OF) == EFLAGS_OF,
c000175d:	8b 45 08             	mov    0x8(%ebp),%eax
c0001760:	8b 40 24             	mov    0x24(%eax),%eax
c0001763:	25 00 08 00 00       	and    $0x800,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001768:	85 c0                	test   %eax,%eax
c000176a:	0f 95 c0             	setne  %al
c000176d:	0f b6 c8             	movzbl %al,%ecx
                                                            (regs->eflags&EFLAGS_DF) == EFLAGS_DF,
c0001770:	8b 45 08             	mov    0x8(%ebp),%eax
c0001773:	8b 40 24             	mov    0x24(%eax),%eax
c0001776:	25 00 04 00 00       	and    $0x400,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c000177b:	85 c0                	test   %eax,%eax
c000177d:	0f 95 c0             	setne  %al
c0001780:	0f b6 d0             	movzbl %al,%edx
c0001783:	8b 45 08             	mov    0x8(%ebp),%eax
c0001786:	8b 40 24             	mov    0x24(%eax),%eax
c0001789:	25 00 02 00 00       	and    $0x200,%eax
c000178e:	85 c0                	test   %eax,%eax
c0001790:	0f 95 c0             	setne  %al
c0001793:	0f b6 c0             	movzbl %al,%eax
c0001796:	83 ec 04             	sub    $0x4,%esp
c0001799:	56                   	push   %esi
c000179a:	53                   	push   %ebx
c000179b:	57                   	push   %edi
c000179c:	51                   	push   %ecx
c000179d:	52                   	push   %edx
c000179e:	50                   	push   %eax
c000179f:	68 c8 44 00 c0       	push   $0xc00044c8
c00017a4:	e8 d6 ec ff ff       	call   c000047f <kprintf>
c00017a9:	83 c4 20             	add    $0x20,%esp
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
                                                            (regs->eflags&EFLAGS_AC) == EFLAGS_AC,
                                                            (regs->eflags&EFLAGS_VIF) == EFLAGS_VIF,
                                                            (regs->eflags&EFLAGS_VIP) == EFLAGS_VIP,
                                                            (regs->eflags&EFLAGS_ID) == EFLAGS_ID);
c00017ac:	8b 45 08             	mov    0x8(%ebp),%eax
c00017af:	8b 40 24             	mov    0x24(%eax),%eax
c00017b2:	25 00 00 20 00       	and    $0x200000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c00017b7:	85 c0                	test   %eax,%eax
c00017b9:	0f 95 c0             	setne  %al
c00017bc:	0f b6 f0             	movzbl %al,%esi
                                                            (regs->eflags&EFLAGS_VIP) == EFLAGS_VIP,
c00017bf:	8b 45 08             	mov    0x8(%ebp),%eax
c00017c2:	8b 40 24             	mov    0x24(%eax),%eax
c00017c5:	25 00 00 10 00       	and    $0x100000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c00017ca:	85 c0                	test   %eax,%eax
c00017cc:	0f 95 c0             	setne  %al
c00017cf:	0f b6 d8             	movzbl %al,%ebx
                                                            (regs->eflags&EFLAGS_VIF) == EFLAGS_VIF,
c00017d2:	8b 45 08             	mov    0x8(%ebp),%eax
c00017d5:	8b 40 24             	mov    0x24(%eax),%eax
c00017d8:	25 00 00 08 00       	and    $0x80000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c00017dd:	85 c0                	test   %eax,%eax
c00017df:	0f 95 c0             	setne  %al
c00017e2:	0f b6 c8             	movzbl %al,%ecx
                                                            (regs->eflags&EFLAGS_AC) == EFLAGS_AC,
c00017e5:	8b 45 08             	mov    0x8(%ebp),%eax
c00017e8:	8b 40 24             	mov    0x24(%eax),%eax
c00017eb:	25 00 00 04 00       	and    $0x40000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c00017f0:	85 c0                	test   %eax,%eax
c00017f2:	0f 95 c0             	setne  %al
c00017f5:	0f b6 d0             	movzbl %al,%edx
c00017f8:	8b 45 08             	mov    0x8(%ebp),%eax
c00017fb:	8b 40 24             	mov    0x24(%eax),%eax
c00017fe:	25 00 00 02 00       	and    $0x20000,%eax
c0001803:	85 c0                	test   %eax,%eax
c0001805:	0f 95 c0             	setne  %al
c0001808:	0f b6 c0             	movzbl %al,%eax
c000180b:	83 ec 08             	sub    $0x8,%esp
c000180e:	56                   	push   %esi
c000180f:	53                   	push   %ebx
c0001810:	51                   	push   %ecx
c0001811:	52                   	push   %edx
c0001812:	50                   	push   %eax
c0001813:	68 f8 44 00 c0       	push   $0xc00044f8
c0001818:	e8 62 ec ff ff       	call   c000047f <kprintf>
c000181d:	83 c4 20             	add    $0x20,%esp
    kprintf("cr0: 0x%x\n", regs->cr0);
c0001820:	8b 45 08             	mov    0x8(%ebp),%eax
c0001823:	8b 40 28             	mov    0x28(%eax),%eax
c0001826:	83 ec 08             	sub    $0x8,%esp
c0001829:	50                   	push   %eax
c000182a:	68 21 45 00 c0       	push   $0xc0004521
c000182f:	e8 4b ec ff ff       	call   c000047f <kprintf>
c0001834:	83 c4 10             	add    $0x10,%esp
    kprintf("cr2: 0x%x\n", regs->cr2);
c0001837:	8b 45 08             	mov    0x8(%ebp),%eax
c000183a:	8b 40 2c             	mov    0x2c(%eax),%eax
c000183d:	83 ec 08             	sub    $0x8,%esp
c0001840:	50                   	push   %eax
c0001841:	68 2c 45 00 c0       	push   $0xc000452c
c0001846:	e8 34 ec ff ff       	call   c000047f <kprintf>
c000184b:	83 c4 10             	add    $0x10,%esp
    kprintf("cr3: 0x%x\n", regs->cr3);
c000184e:	8b 45 08             	mov    0x8(%ebp),%eax
c0001851:	8b 40 30             	mov    0x30(%eax),%eax
c0001854:	83 ec 08             	sub    $0x8,%esp
c0001857:	50                   	push   %eax
c0001858:	68 37 45 00 c0       	push   $0xc0004537
c000185d:	e8 1d ec ff ff       	call   c000047f <kprintf>
c0001862:	83 c4 10             	add    $0x10,%esp
    kprintf("cr4: 0x%x\n", regs->cr4);
c0001865:	8b 45 08             	mov    0x8(%ebp),%eax
c0001868:	8b 40 34             	mov    0x34(%eax),%eax
c000186b:	83 ec 08             	sub    $0x8,%esp
c000186e:	50                   	push   %eax
c000186f:	68 42 45 00 c0       	push   $0xc0004542
c0001874:	e8 06 ec ff ff       	call   c000047f <kprintf>
c0001879:	83 c4 10             	add    $0x10,%esp
}
c000187c:	90                   	nop
c000187d:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0001880:	5b                   	pop    %ebx
c0001881:	5e                   	pop    %esi
c0001882:	5f                   	pop    %edi
c0001883:	5d                   	pop    %ebp
c0001884:	c3                   	ret    

c0001885 <memory_table>:
#include "multiboot.h"
#include "kprintf.h"

size_t memory_table(multiboot_info_t* mbd)
{
c0001885:	55                   	push   %ebp
c0001886:	89 e5                	mov    %esp,%ebp
c0001888:	56                   	push   %esi
c0001889:	53                   	push   %ebx
c000188a:	83 ec 10             	sub    $0x10,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c000188d:	8b 45 08             	mov    0x8(%ebp),%eax
c0001890:	8b 40 30             	mov    0x30(%eax),%eax
c0001893:	89 45 ec             	mov    %eax,-0x14(%ebp)
    size_t available_mem = 0;
c0001896:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c000189d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00018a4:	e9 83 00 00 00       	jmp    c000192c <memory_table+0xa7>
	{
		if(mmap_table[nn].len>0 && mmap_table[nn].size>0)
c00018a9:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00018ac:	89 d0                	mov    %edx,%eax
c00018ae:	01 c0                	add    %eax,%eax
c00018b0:	01 d0                	add    %edx,%eax
c00018b2:	c1 e0 03             	shl    $0x3,%eax
c00018b5:	89 c2                	mov    %eax,%edx
c00018b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00018ba:	01 d0                	add    %edx,%eax
c00018bc:	8b 50 10             	mov    0x10(%eax),%edx
c00018bf:	8b 40 0c             	mov    0xc(%eax),%eax
c00018c2:	89 c6                	mov    %eax,%esi
c00018c4:	83 f6 00             	xor    $0x0,%esi
c00018c7:	89 f1                	mov    %esi,%ecx
c00018c9:	89 d0                	mov    %edx,%eax
c00018cb:	80 f4 00             	xor    $0x0,%ah
c00018ce:	89 c3                	mov    %eax,%ebx
c00018d0:	89 d8                	mov    %ebx,%eax
c00018d2:	09 c8                	or     %ecx,%eax
c00018d4:	85 c0                	test   %eax,%eax
c00018d6:	74 50                	je     c0001928 <memory_table+0xa3>
c00018d8:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00018db:	89 d0                	mov    %edx,%eax
c00018dd:	01 c0                	add    %eax,%eax
c00018df:	01 d0                	add    %edx,%eax
c00018e1:	c1 e0 03             	shl    $0x3,%eax
c00018e4:	89 c2                	mov    %eax,%edx
c00018e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00018e9:	01 d0                	add    %edx,%eax
c00018eb:	8b 00                	mov    (%eax),%eax
c00018ed:	85 c0                	test   %eax,%eax
c00018ef:	74 37                	je     c0001928 <memory_table+0xa3>
        {
            if(mmap_table[nn].type == 1)
c00018f1:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00018f4:	89 d0                	mov    %edx,%eax
c00018f6:	01 c0                	add    %eax,%eax
c00018f8:	01 d0                	add    %edx,%eax
c00018fa:	c1 e0 03             	shl    $0x3,%eax
c00018fd:	89 c2                	mov    %eax,%edx
c00018ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001902:	01 d0                	add    %edx,%eax
c0001904:	8b 40 14             	mov    0x14(%eax),%eax
c0001907:	83 f8 01             	cmp    $0x1,%eax
c000190a:	75 1c                	jne    c0001928 <memory_table+0xa3>
            available_mem += mmap_table[nn].len;
c000190c:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000190f:	89 d0                	mov    %edx,%eax
c0001911:	01 c0                	add    %eax,%eax
c0001913:	01 d0                	add    %edx,%eax
c0001915:	c1 e0 03             	shl    $0x3,%eax
c0001918:	89 c2                	mov    %eax,%edx
c000191a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000191d:	01 d0                	add    %edx,%eax
c000191f:	8b 50 10             	mov    0x10(%eax),%edx
c0001922:	8b 40 0c             	mov    0xc(%eax),%eax
c0001925:	01 45 f4             	add    %eax,-0xc(%ebp)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001928:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c000192c:	8b 45 08             	mov    0x8(%ebp),%eax
c000192f:	8b 40 2c             	mov    0x2c(%eax),%eax
c0001932:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0001935:	0f 82 6e ff ff ff    	jb     c00018a9 <memory_table+0x24>
        }
		
	}

    return available_mem;
c000193b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c000193e:	83 c4 10             	add    $0x10,%esp
c0001941:	5b                   	pop    %ebx
c0001942:	5e                   	pop    %esi
c0001943:	5d                   	pop    %ebp
c0001944:	c3                   	ret    

c0001945 <print_memory_table>:

int print_memory_table(multiboot_info_t* mbd)
{
c0001945:	55                   	push   %ebp
c0001946:	89 e5                	mov    %esp,%ebp
c0001948:	57                   	push   %edi
c0001949:	56                   	push   %esi
c000194a:	53                   	push   %ebx
c000194b:	83 ec 2c             	sub    $0x2c,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c000194e:	8b 45 08             	mov    0x8(%ebp),%eax
c0001951:	8b 40 30             	mov    0x30(%eax),%eax
c0001954:	89 45 e0             	mov    %eax,-0x20(%ebp)
	kprintf("Memory Table:\n");
c0001957:	83 ec 0c             	sub    $0xc,%esp
c000195a:	68 50 45 00 c0       	push   $0xc0004550
c000195f:	e8 1b eb ff ff       	call   c000047f <kprintf>
c0001964:	83 c4 10             	add    $0x10,%esp
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001967:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c000196e:	e9 a6 01 00 00       	jmp    c0001b19 <print_memory_table+0x1d4>
	{
        if(mmap_table[nn].size == 0)
c0001973:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001976:	89 d0                	mov    %edx,%eax
c0001978:	01 c0                	add    %eax,%eax
c000197a:	01 d0                	add    %edx,%eax
c000197c:	c1 e0 03             	shl    $0x3,%eax
c000197f:	89 c2                	mov    %eax,%edx
c0001981:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001984:	01 d0                	add    %edx,%eax
c0001986:	8b 00                	mov    (%eax),%eax
c0001988:	85 c0                	test   %eax,%eax
c000198a:	0f 84 9a 01 00 00    	je     c0001b2a <print_memory_table+0x1e5>
            break;

		if(mmap_table[nn].len>0)
c0001990:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001993:	89 d0                	mov    %edx,%eax
c0001995:	01 c0                	add    %eax,%eax
c0001997:	01 d0                	add    %edx,%eax
c0001999:	c1 e0 03             	shl    $0x3,%eax
c000199c:	89 c2                	mov    %eax,%edx
c000199e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00019a1:	01 d0                	add    %edx,%eax
c00019a3:	8b 50 10             	mov    0x10(%eax),%edx
c00019a6:	8b 40 0c             	mov    0xc(%eax),%eax
c00019a9:	89 c7                	mov    %eax,%edi
c00019ab:	83 f7 00             	xor    $0x0,%edi
c00019ae:	89 7d d0             	mov    %edi,-0x30(%ebp)
c00019b1:	89 d0                	mov    %edx,%eax
c00019b3:	80 f4 00             	xor    $0x0,%ah
c00019b6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
c00019b9:	8b 5d d0             	mov    -0x30(%ebp),%ebx
c00019bc:	8b 75 d4             	mov    -0x2c(%ebp),%esi
c00019bf:	89 f0                	mov    %esi,%eax
c00019c1:	09 d8                	or     %ebx,%eax
c00019c3:	85 c0                	test   %eax,%eax
c00019c5:	0f 84 4a 01 00 00    	je     c0001b15 <print_memory_table+0x1d0>
		{
			if(mmap_table[nn].type == MULTIBOOT_MEMORY_AVAILABLE)
c00019cb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00019ce:	89 d0                	mov    %edx,%eax
c00019d0:	01 c0                	add    %eax,%eax
c00019d2:	01 d0                	add    %edx,%eax
c00019d4:	c1 e0 03             	shl    $0x3,%eax
c00019d7:	89 c2                	mov    %eax,%edx
c00019d9:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00019dc:	01 d0                	add    %edx,%eax
c00019de:	8b 40 14             	mov    0x14(%eax),%eax
c00019e1:	83 f8 01             	cmp    $0x1,%eax
c00019e4:	0f 85 98 00 00 00    	jne    c0001a82 <print_memory_table+0x13d>
				kprintf("%.8llp - %.8llp [AVAILABLE] (%6llu kiB)\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c00019ea:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00019ed:	89 d0                	mov    %edx,%eax
c00019ef:	01 c0                	add    %eax,%eax
c00019f1:	01 d0                	add    %edx,%eax
c00019f3:	c1 e0 03             	shl    $0x3,%eax
c00019f6:	89 c2                	mov    %eax,%edx
c00019f8:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00019fb:	01 d0                	add    %edx,%eax
c00019fd:	8b 50 10             	mov    0x10(%eax),%edx
c0001a00:	8b 40 0c             	mov    0xc(%eax),%eax
c0001a03:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c0001a07:	c1 ea 0a             	shr    $0xa,%edx
c0001a0a:	89 c6                	mov    %eax,%esi
c0001a0c:	89 d7                	mov    %edx,%edi
c0001a0e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001a11:	89 d0                	mov    %edx,%eax
c0001a13:	01 c0                	add    %eax,%eax
c0001a15:	01 d0                	add    %edx,%eax
c0001a17:	c1 e0 03             	shl    $0x3,%eax
c0001a1a:	89 c2                	mov    %eax,%edx
c0001a1c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001a1f:	01 d0                	add    %edx,%eax
c0001a21:	8b 48 04             	mov    0x4(%eax),%ecx
c0001a24:	8b 58 08             	mov    0x8(%eax),%ebx
c0001a27:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001a2a:	89 d0                	mov    %edx,%eax
c0001a2c:	01 c0                	add    %eax,%eax
c0001a2e:	01 d0                	add    %edx,%eax
c0001a30:	c1 e0 03             	shl    $0x3,%eax
c0001a33:	89 c2                	mov    %eax,%edx
c0001a35:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001a38:	01 d0                	add    %edx,%eax
c0001a3a:	8b 50 10             	mov    0x10(%eax),%edx
c0001a3d:	8b 40 0c             	mov    0xc(%eax),%eax
c0001a40:	01 c8                	add    %ecx,%eax
c0001a42:	11 da                	adc    %ebx,%edx
c0001a44:	83 c0 ff             	add    $0xffffffff,%eax
c0001a47:	83 d2 ff             	adc    $0xffffffff,%edx
c0001a4a:	89 c1                	mov    %eax,%ecx
c0001a4c:	89 d3                	mov    %edx,%ebx
c0001a4e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001a51:	89 d0                	mov    %edx,%eax
c0001a53:	01 c0                	add    %eax,%eax
c0001a55:	01 d0                	add    %edx,%eax
c0001a57:	c1 e0 03             	shl    $0x3,%eax
c0001a5a:	89 c2                	mov    %eax,%edx
c0001a5c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001a5f:	01 d0                	add    %edx,%eax
c0001a61:	8b 50 08             	mov    0x8(%eax),%edx
c0001a64:	8b 40 04             	mov    0x4(%eax),%eax
c0001a67:	83 ec 04             	sub    $0x4,%esp
c0001a6a:	57                   	push   %edi
c0001a6b:	56                   	push   %esi
c0001a6c:	53                   	push   %ebx
c0001a6d:	51                   	push   %ecx
c0001a6e:	52                   	push   %edx
c0001a6f:	50                   	push   %eax
c0001a70:	68 60 45 00 c0       	push   $0xc0004560
c0001a75:	e8 05 ea ff ff       	call   c000047f <kprintf>
c0001a7a:	83 c4 20             	add    $0x20,%esp
c0001a7d:	e9 93 00 00 00       	jmp    c0001b15 <print_memory_table+0x1d0>
			else
				kprintf("%.8llp - %.8llp [RESERVED]\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c0001a82:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001a85:	89 d0                	mov    %edx,%eax
c0001a87:	01 c0                	add    %eax,%eax
c0001a89:	01 d0                	add    %edx,%eax
c0001a8b:	c1 e0 03             	shl    $0x3,%eax
c0001a8e:	89 c2                	mov    %eax,%edx
c0001a90:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001a93:	01 d0                	add    %edx,%eax
c0001a95:	8b 50 10             	mov    0x10(%eax),%edx
c0001a98:	8b 40 0c             	mov    0xc(%eax),%eax
c0001a9b:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c0001a9f:	c1 ea 0a             	shr    $0xa,%edx
c0001aa2:	89 c6                	mov    %eax,%esi
c0001aa4:	89 d7                	mov    %edx,%edi
c0001aa6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001aa9:	89 d0                	mov    %edx,%eax
c0001aab:	01 c0                	add    %eax,%eax
c0001aad:	01 d0                	add    %edx,%eax
c0001aaf:	c1 e0 03             	shl    $0x3,%eax
c0001ab2:	89 c2                	mov    %eax,%edx
c0001ab4:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001ab7:	01 d0                	add    %edx,%eax
c0001ab9:	8b 48 04             	mov    0x4(%eax),%ecx
c0001abc:	8b 58 08             	mov    0x8(%eax),%ebx
c0001abf:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001ac2:	89 d0                	mov    %edx,%eax
c0001ac4:	01 c0                	add    %eax,%eax
c0001ac6:	01 d0                	add    %edx,%eax
c0001ac8:	c1 e0 03             	shl    $0x3,%eax
c0001acb:	89 c2                	mov    %eax,%edx
c0001acd:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001ad0:	01 d0                	add    %edx,%eax
c0001ad2:	8b 50 10             	mov    0x10(%eax),%edx
c0001ad5:	8b 40 0c             	mov    0xc(%eax),%eax
c0001ad8:	01 c8                	add    %ecx,%eax
c0001ada:	11 da                	adc    %ebx,%edx
c0001adc:	83 c0 ff             	add    $0xffffffff,%eax
c0001adf:	83 d2 ff             	adc    $0xffffffff,%edx
c0001ae2:	89 c1                	mov    %eax,%ecx
c0001ae4:	89 d3                	mov    %edx,%ebx
c0001ae6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001ae9:	89 d0                	mov    %edx,%eax
c0001aeb:	01 c0                	add    %eax,%eax
c0001aed:	01 d0                	add    %edx,%eax
c0001aef:	c1 e0 03             	shl    $0x3,%eax
c0001af2:	89 c2                	mov    %eax,%edx
c0001af4:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001af7:	01 d0                	add    %edx,%eax
c0001af9:	8b 50 08             	mov    0x8(%eax),%edx
c0001afc:	8b 40 04             	mov    0x4(%eax),%eax
c0001aff:	83 ec 04             	sub    $0x4,%esp
c0001b02:	57                   	push   %edi
c0001b03:	56                   	push   %esi
c0001b04:	53                   	push   %ebx
c0001b05:	51                   	push   %ecx
c0001b06:	52                   	push   %edx
c0001b07:	50                   	push   %eax
c0001b08:	68 89 45 00 c0       	push   $0xc0004589
c0001b0d:	e8 6d e9 ff ff       	call   c000047f <kprintf>
c0001b12:	83 c4 20             	add    $0x20,%esp
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001b15:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c0001b19:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b1c:	8b 40 2c             	mov    0x2c(%eax),%eax
c0001b1f:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c0001b22:	0f 82 4b fe ff ff    	jb     c0001973 <print_memory_table+0x2e>
c0001b28:	eb 01                	jmp    c0001b2b <print_memory_table+0x1e6>
            break;
c0001b2a:	90                   	nop
    //         kprintf("[%3u] %p (%#x)\n", nn, addr, flags);		
	// }

    // print_crs();

    return 0;
c0001b2b:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0001b30:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0001b33:	5b                   	pop    %ebx
c0001b34:	5e                   	pop    %esi
c0001b35:	5f                   	pop    %edi
c0001b36:	5d                   	pop    %ebp
c0001b37:	c3                   	ret    

c0001b38 <inb>:
{
c0001b38:	55                   	push   %ebp
c0001b39:	89 e5                	mov    %esp,%ebp
c0001b3b:	83 ec 14             	sub    $0x14,%esp
c0001b3e:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b41:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  __asm__ __volatile__ ("inb %w1,%0":"=a" (_v):"Nd" (__port));
c0001b45:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0001b49:	89 c2                	mov    %eax,%edx
c0001b4b:	ec                   	in     (%dx),%al
c0001b4c:	88 45 ff             	mov    %al,-0x1(%ebp)
  return _v;
c0001b4f:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0001b53:	c9                   	leave  
c0001b54:	c3                   	ret    

c0001b55 <outb>:
{
c0001b55:	55                   	push   %ebp
c0001b56:	89 e5                	mov    %esp,%ebp
c0001b58:	83 ec 08             	sub    $0x8,%esp
c0001b5b:	8b 55 08             	mov    0x8(%ebp),%edx
c0001b5e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001b61:	88 55 fc             	mov    %dl,-0x4(%ebp)
c0001b64:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
c0001b68:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0001b6c:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
c0001b70:	ee                   	out    %al,(%dx)
}
c0001b71:	90                   	nop
c0001b72:	c9                   	leave  
c0001b73:	c3                   	ret    

c0001b74 <init_interrupts>:

idt_entry_t __aligned idt[NUM_INTERRUPT_HANDLERS] = {0};
idt_descriptor_t __aligned idtd;

void init_interrupts()
{
c0001b74:	55                   	push   %ebp
c0001b75:	89 e5                	mov    %esp,%ebp
c0001b77:	83 ec 08             	sub    $0x8,%esp
    /* init the PIC */
	outb(PIC_INIT, PIC1_CMD);  // init PIC 1
c0001b7a:	6a 20                	push   $0x20
c0001b7c:	6a 11                	push   $0x11
c0001b7e:	e8 d2 ff ff ff       	call   c0001b55 <outb>
c0001b83:	83 c4 08             	add    $0x8,%esp
    outb(PIC_INIT, PIC2_CMD);  // init PIC 2
c0001b86:	68 a0 00 00 00       	push   $0xa0
c0001b8b:	6a 11                	push   $0x11
c0001b8d:	e8 c3 ff ff ff       	call   c0001b55 <outb>
c0001b92:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_OFFSET, PIC1_DATA); // map irq 0x0-0x7 to int 0x20-0x27
c0001b95:	6a 21                	push   $0x21
c0001b97:	6a 20                	push   $0x20
c0001b99:	e8 b7 ff ff ff       	call   c0001b55 <outb>
c0001b9e:	83 c4 08             	add    $0x8,%esp
    outb(PIC2_OFFSET, PIC2_DATA); // map irq 0x8-0xf to int 0x28-0x2f
c0001ba1:	68 a1 00 00 00       	push   $0xa1
c0001ba6:	6a 28                	push   $0x28
c0001ba8:	e8 a8 ff ff ff       	call   c0001b55 <outb>
c0001bad:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_MS, PIC1_DATA);     // pic1 is master, with slave at irq 2
c0001bb0:	6a 21                	push   $0x21
c0001bb2:	6a 04                	push   $0x4
c0001bb4:	e8 9c ff ff ff       	call   c0001b55 <outb>
c0001bb9:	83 c4 08             	add    $0x8,%esp
    outb(PIC2_MS, PIC2_DATA);     // pic2 is slave with id 2
c0001bbc:	68 a1 00 00 00       	push   $0xa1
c0001bc1:	6a 02                	push   $0x2
c0001bc3:	e8 8d ff ff ff       	call   c0001b55 <outb>
c0001bc8:	83 c4 08             	add    $0x8,%esp
    outb(PIC_8086MODE, PIC1_DATA); //enable 8086 mode
c0001bcb:	6a 21                	push   $0x21
c0001bcd:	6a 01                	push   $0x1
c0001bcf:	e8 81 ff ff ff       	call   c0001b55 <outb>
c0001bd4:	83 c4 08             	add    $0x8,%esp
    outb(PIC_8086MODE, PIC2_DATA); //enable 8086 mode
c0001bd7:	68 a1 00 00 00       	push   $0xa1
c0001bdc:	6a 01                	push   $0x1
c0001bde:	e8 72 ff ff ff       	call   c0001b55 <outb>
c0001be3:	83 c4 08             	add    $0x8,%esp
    // interrupt mask
    outb( ~(1<<1) , PIC1_DATA); //enable irq1 (keyboard)
c0001be6:	6a 21                	push   $0x21
c0001be8:	68 fd 00 00 00       	push   $0xfd
c0001bed:	e8 63 ff ff ff       	call   c0001b55 <outb>
c0001bf2:	83 c4 08             	add    $0x8,%esp
    outb(0xff, PIC2_DATA); //disable interrupts from slave
c0001bf5:	68 a1 00 00 00       	push   $0xa1
c0001bfa:	68 ff 00 00 00       	push   $0xff
c0001bff:	e8 51 ff ff ff       	call   c0001b55 <outb>
c0001c04:	83 c4 08             	add    $0x8,%esp


    // individual handler routines defined in interrupt.S
    // these call back to exception_handler() and irq_handler()
    set_interrupt_handler(0,except_0);
c0001c07:	83 ec 08             	sub    $0x8,%esp
c0001c0a:	68 0c 2f 00 c0       	push   $0xc0002f0c
c0001c0f:	6a 00                	push   $0x0
c0001c11:	e8 94 02 00 00       	call   c0001eaa <set_interrupt_handler>
c0001c16:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(1,except_1);
c0001c19:	83 ec 08             	sub    $0x8,%esp
c0001c1c:	68 2c 2f 00 c0       	push   $0xc0002f2c
c0001c21:	6a 01                	push   $0x1
c0001c23:	e8 82 02 00 00       	call   c0001eaa <set_interrupt_handler>
c0001c28:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(2,except_2);
c0001c2b:	83 ec 08             	sub    $0x8,%esp
c0001c2e:	68 4c 2f 00 c0       	push   $0xc0002f4c
c0001c33:	6a 02                	push   $0x2
c0001c35:	e8 70 02 00 00       	call   c0001eaa <set_interrupt_handler>
c0001c3a:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(3,except_3);
c0001c3d:	83 ec 08             	sub    $0x8,%esp
c0001c40:	68 6c 2f 00 c0       	push   $0xc0002f6c
c0001c45:	6a 03                	push   $0x3
c0001c47:	e8 5e 02 00 00       	call   c0001eaa <set_interrupt_handler>
c0001c4c:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(4,except_4);
c0001c4f:	83 ec 08             	sub    $0x8,%esp
c0001c52:	68 8c 2f 00 c0       	push   $0xc0002f8c
c0001c57:	6a 04                	push   $0x4
c0001c59:	e8 4c 02 00 00       	call   c0001eaa <set_interrupt_handler>
c0001c5e:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(5,except_5);
c0001c61:	83 ec 08             	sub    $0x8,%esp
c0001c64:	68 ac 2f 00 c0       	push   $0xc0002fac
c0001c69:	6a 05                	push   $0x5
c0001c6b:	e8 3a 02 00 00       	call   c0001eaa <set_interrupt_handler>
c0001c70:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(6,except_6);
c0001c73:	83 ec 08             	sub    $0x8,%esp
c0001c76:	68 cc 2f 00 c0       	push   $0xc0002fcc
c0001c7b:	6a 06                	push   $0x6
c0001c7d:	e8 28 02 00 00       	call   c0001eaa <set_interrupt_handler>
c0001c82:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(7,except_7);
c0001c85:	83 ec 08             	sub    $0x8,%esp
c0001c88:	68 ec 2f 00 c0       	push   $0xc0002fec
c0001c8d:	6a 07                	push   $0x7
c0001c8f:	e8 16 02 00 00       	call   c0001eaa <set_interrupt_handler>
c0001c94:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(8,except_8);
c0001c97:	83 ec 08             	sub    $0x8,%esp
c0001c9a:	68 0c 30 00 c0       	push   $0xc000300c
c0001c9f:	6a 08                	push   $0x8
c0001ca1:	e8 04 02 00 00       	call   c0001eaa <set_interrupt_handler>
c0001ca6:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(10,except_10);
c0001ca9:	83 ec 08             	sub    $0x8,%esp
c0001cac:	68 2c 30 00 c0       	push   $0xc000302c
c0001cb1:	6a 0a                	push   $0xa
c0001cb3:	e8 f2 01 00 00       	call   c0001eaa <set_interrupt_handler>
c0001cb8:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(11,except_11);
c0001cbb:	83 ec 08             	sub    $0x8,%esp
c0001cbe:	68 4c 30 00 c0       	push   $0xc000304c
c0001cc3:	6a 0b                	push   $0xb
c0001cc5:	e8 e0 01 00 00       	call   c0001eaa <set_interrupt_handler>
c0001cca:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(12,except_12);
c0001ccd:	83 ec 08             	sub    $0x8,%esp
c0001cd0:	68 6c 30 00 c0       	push   $0xc000306c
c0001cd5:	6a 0c                	push   $0xc
c0001cd7:	e8 ce 01 00 00       	call   c0001eaa <set_interrupt_handler>
c0001cdc:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(13,except_13);
c0001cdf:	83 ec 08             	sub    $0x8,%esp
c0001ce2:	68 8c 30 00 c0       	push   $0xc000308c
c0001ce7:	6a 0d                	push   $0xd
c0001ce9:	e8 bc 01 00 00       	call   c0001eaa <set_interrupt_handler>
c0001cee:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(14,except_14);
c0001cf1:	83 ec 08             	sub    $0x8,%esp
c0001cf4:	68 ac 30 00 c0       	push   $0xc00030ac
c0001cf9:	6a 0e                	push   $0xe
c0001cfb:	e8 aa 01 00 00       	call   c0001eaa <set_interrupt_handler>
c0001d00:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(16,except_16);
c0001d03:	83 ec 08             	sub    $0x8,%esp
c0001d06:	68 cc 30 00 c0       	push   $0xc00030cc
c0001d0b:	6a 10                	push   $0x10
c0001d0d:	e8 98 01 00 00       	call   c0001eaa <set_interrupt_handler>
c0001d12:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(17,except_17);
c0001d15:	83 ec 08             	sub    $0x8,%esp
c0001d18:	68 ec 30 00 c0       	push   $0xc00030ec
c0001d1d:	6a 11                	push   $0x11
c0001d1f:	e8 86 01 00 00       	call   c0001eaa <set_interrupt_handler>
c0001d24:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(18,except_18);
c0001d27:	83 ec 08             	sub    $0x8,%esp
c0001d2a:	68 0c 31 00 c0       	push   $0xc000310c
c0001d2f:	6a 12                	push   $0x12
c0001d31:	e8 74 01 00 00       	call   c0001eaa <set_interrupt_handler>
c0001d36:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(19,except_19);
c0001d39:	83 ec 08             	sub    $0x8,%esp
c0001d3c:	68 2c 31 00 c0       	push   $0xc000312c
c0001d41:	6a 13                	push   $0x13
c0001d43:	e8 62 01 00 00       	call   c0001eaa <set_interrupt_handler>
c0001d48:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(20,except_20);
c0001d4b:	83 ec 08             	sub    $0x8,%esp
c0001d4e:	68 4c 31 00 c0       	push   $0xc000314c
c0001d53:	6a 14                	push   $0x14
c0001d55:	e8 50 01 00 00       	call   c0001eaa <set_interrupt_handler>
c0001d5a:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(30,except_30);
c0001d5d:	83 ec 08             	sub    $0x8,%esp
c0001d60:	68 6c 31 00 c0       	push   $0xc000316c
c0001d65:	6a 1e                	push   $0x1e
c0001d67:	e8 3e 01 00 00       	call   c0001eaa <set_interrupt_handler>
c0001d6c:	83 c4 10             	add    $0x10,%esp

    set_interrupt_handler(32,irq_0);
c0001d6f:	83 ec 08             	sub    $0x8,%esp
c0001d72:	68 8c 31 00 c0       	push   $0xc000318c
c0001d77:	6a 20                	push   $0x20
c0001d79:	e8 2c 01 00 00       	call   c0001eaa <set_interrupt_handler>
c0001d7e:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(33,irq_1);
c0001d81:	83 ec 08             	sub    $0x8,%esp
c0001d84:	68 a0 31 00 c0       	push   $0xc00031a0
c0001d89:	6a 21                	push   $0x21
c0001d8b:	e8 1a 01 00 00       	call   c0001eaa <set_interrupt_handler>
c0001d90:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(34,irq_2);
c0001d93:	83 ec 08             	sub    $0x8,%esp
c0001d96:	68 b4 31 00 c0       	push   $0xc00031b4
c0001d9b:	6a 22                	push   $0x22
c0001d9d:	e8 08 01 00 00       	call   c0001eaa <set_interrupt_handler>
c0001da2:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(35,irq_3);
c0001da5:	83 ec 08             	sub    $0x8,%esp
c0001da8:	68 c8 31 00 c0       	push   $0xc00031c8
c0001dad:	6a 23                	push   $0x23
c0001daf:	e8 f6 00 00 00       	call   c0001eaa <set_interrupt_handler>
c0001db4:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(36,irq_4);
c0001db7:	83 ec 08             	sub    $0x8,%esp
c0001dba:	68 dc 31 00 c0       	push   $0xc00031dc
c0001dbf:	6a 24                	push   $0x24
c0001dc1:	e8 e4 00 00 00       	call   c0001eaa <set_interrupt_handler>
c0001dc6:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(37,irq_5);
c0001dc9:	83 ec 08             	sub    $0x8,%esp
c0001dcc:	68 f0 31 00 c0       	push   $0xc00031f0
c0001dd1:	6a 25                	push   $0x25
c0001dd3:	e8 d2 00 00 00       	call   c0001eaa <set_interrupt_handler>
c0001dd8:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(38,irq_6);
c0001ddb:	83 ec 08             	sub    $0x8,%esp
c0001dde:	68 04 32 00 c0       	push   $0xc0003204
c0001de3:	6a 26                	push   $0x26
c0001de5:	e8 c0 00 00 00       	call   c0001eaa <set_interrupt_handler>
c0001dea:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(39,irq_7);
c0001ded:	83 ec 08             	sub    $0x8,%esp
c0001df0:	68 18 32 00 c0       	push   $0xc0003218
c0001df5:	6a 27                	push   $0x27
c0001df7:	e8 ae 00 00 00       	call   c0001eaa <set_interrupt_handler>
c0001dfc:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(40,irq_8);
c0001dff:	83 ec 08             	sub    $0x8,%esp
c0001e02:	68 2c 32 00 c0       	push   $0xc000322c
c0001e07:	6a 28                	push   $0x28
c0001e09:	e8 9c 00 00 00       	call   c0001eaa <set_interrupt_handler>
c0001e0e:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(41,irq_9);
c0001e11:	83 ec 08             	sub    $0x8,%esp
c0001e14:	68 40 32 00 c0       	push   $0xc0003240
c0001e19:	6a 29                	push   $0x29
c0001e1b:	e8 8a 00 00 00       	call   c0001eaa <set_interrupt_handler>
c0001e20:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(42,irq_10);
c0001e23:	83 ec 08             	sub    $0x8,%esp
c0001e26:	68 54 32 00 c0       	push   $0xc0003254
c0001e2b:	6a 2a                	push   $0x2a
c0001e2d:	e8 78 00 00 00       	call   c0001eaa <set_interrupt_handler>
c0001e32:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(43,irq_11);
c0001e35:	83 ec 08             	sub    $0x8,%esp
c0001e38:	68 68 32 00 c0       	push   $0xc0003268
c0001e3d:	6a 2b                	push   $0x2b
c0001e3f:	e8 66 00 00 00       	call   c0001eaa <set_interrupt_handler>
c0001e44:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(44,irq_12);
c0001e47:	83 ec 08             	sub    $0x8,%esp
c0001e4a:	68 7c 32 00 c0       	push   $0xc000327c
c0001e4f:	6a 2c                	push   $0x2c
c0001e51:	e8 54 00 00 00       	call   c0001eaa <set_interrupt_handler>
c0001e56:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(45,irq_13);
c0001e59:	83 ec 08             	sub    $0x8,%esp
c0001e5c:	68 90 32 00 c0       	push   $0xc0003290
c0001e61:	6a 2d                	push   $0x2d
c0001e63:	e8 42 00 00 00       	call   c0001eaa <set_interrupt_handler>
c0001e68:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(46,irq_14);
c0001e6b:	83 ec 08             	sub    $0x8,%esp
c0001e6e:	68 a4 32 00 c0       	push   $0xc00032a4
c0001e73:	6a 2e                	push   $0x2e
c0001e75:	e8 30 00 00 00       	call   c0001eaa <set_interrupt_handler>
c0001e7a:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(47,irq_15);
c0001e7d:	83 ec 08             	sub    $0x8,%esp
c0001e80:	68 b8 32 00 c0       	push   $0xc00032b8
c0001e85:	6a 2f                	push   $0x2f
c0001e87:	e8 1e 00 00 00       	call   c0001eaa <set_interrupt_handler>
c0001e8c:	83 c4 10             	add    $0x10,%esp



    idtd.base = (uint32_t) idt;
c0001e8f:	b8 20 00 01 c0       	mov    $0xc0010020,%eax
c0001e94:	a3 22 08 01 c0       	mov    %eax,0xc0010822
    idtd.limit = sizeof(idt_entry_t) * NUM_INTERRUPT_HANDLERS - 1;
c0001e99:	66 c7 05 20 08 01 c0 	movw   $0x7ff,0xc0010820
c0001ea0:	ff 07 
    load_idt();
c0001ea2:	e8 55 10 00 00       	call   c0002efc <load_idt>
}
c0001ea7:	90                   	nop
c0001ea8:	c9                   	leave  
c0001ea9:	c3                   	ret    

c0001eaa <set_interrupt_handler>:

void set_interrupt_handler(int int_num, void* handler)
{
c0001eaa:	55                   	push   %ebp
c0001eab:	89 e5                	mov    %esp,%ebp
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c0001ead:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001eb0:	89 c2                	mov    %eax,%edx
c0001eb2:	8b 45 08             	mov    0x8(%ebp),%eax
c0001eb5:	66 89 14 c5 20 00 01 	mov    %dx,-0x3ffeffe0(,%eax,8)
c0001ebc:	c0 
	idt[int_num].segment = KERNEL_CODE_SEGMENT;
c0001ebd:	8b 45 08             	mov    0x8(%ebp),%eax
c0001ec0:	66 c7 04 c5 22 00 01 	movw   $0x8,-0x3ffeffde(,%eax,8)
c0001ec7:	c0 08 00 
	idt[int_num].zero = 0;
c0001eca:	8b 45 08             	mov    0x8(%ebp),%eax
c0001ecd:	c6 04 c5 24 00 01 c0 	movb   $0x0,-0x3ffeffdc(,%eax,8)
c0001ed4:	00 
	idt[int_num].type = 0x8e; /* INTERRUPT_GATE */
c0001ed5:	8b 45 08             	mov    0x8(%ebp),%eax
c0001ed8:	c6 04 c5 25 00 01 c0 	movb   $0x8e,-0x3ffeffdb(,%eax,8)
c0001edf:	8e 
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c0001ee0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001ee3:	c1 e8 10             	shr    $0x10,%eax
c0001ee6:	89 c2                	mov    %eax,%edx
c0001ee8:	8b 45 08             	mov    0x8(%ebp),%eax
c0001eeb:	66 89 14 c5 26 00 01 	mov    %dx,-0x3ffeffda(,%eax,8)
c0001ef2:	c0 
}
c0001ef3:	90                   	nop
c0001ef4:	5d                   	pop    %ebp
c0001ef5:	c3                   	ret    

c0001ef6 <page_fault_handler>:

void page_fault_handler(uint32_t code, void* fault_ip)
{
c0001ef6:	55                   	push   %ebp
c0001ef7:	89 e5                	mov    %esp,%ebp
c0001ef9:	83 ec 08             	sub    $0x8,%esp

    if(code & PF_CODE_WRITE)
c0001efc:	8b 45 08             	mov    0x8(%ebp),%eax
c0001eff:	83 e0 02             	and    $0x2,%eax
c0001f02:	85 c0                	test   %eax,%eax
c0001f04:	74 1b                	je     c0001f21 <page_fault_handler+0x2b>
        kprintf("\n\nPage Fault writing to 0x%x (instruction 0x%x)\n", pf_addr(), fault_ip);
c0001f06:	e8 fd 0f 00 00       	call   c0002f08 <pf_addr>
c0001f0b:	83 ec 04             	sub    $0x4,%esp
c0001f0e:	ff 75 0c             	pushl  0xc(%ebp)
c0001f11:	50                   	push   %eax
c0001f12:	68 a8 45 00 c0       	push   $0xc00045a8
c0001f17:	e8 63 e5 ff ff       	call   c000047f <kprintf>
c0001f1c:	83 c4 10             	add    $0x10,%esp
c0001f1f:	eb 19                	jmp    c0001f3a <page_fault_handler+0x44>
    else        
        kprintf("\n\nPage Fault reading from 0x%x (instruction 0x%x)\n", pf_addr(), fault_ip);
c0001f21:	e8 e2 0f 00 00       	call   c0002f08 <pf_addr>
c0001f26:	83 ec 04             	sub    $0x4,%esp
c0001f29:	ff 75 0c             	pushl  0xc(%ebp)
c0001f2c:	50                   	push   %eax
c0001f2d:	68 dc 45 00 c0       	push   $0xc00045dc
c0001f32:	e8 48 e5 ff ff       	call   c000047f <kprintf>
c0001f37:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_PGPROT)
c0001f3a:	8b 45 08             	mov    0x8(%ebp),%eax
c0001f3d:	83 e0 01             	and    $0x1,%eax
c0001f40:	85 c0                	test   %eax,%eax
c0001f42:	74 12                	je     c0001f56 <page_fault_handler+0x60>
        kprintf("Page protection violation\n");
c0001f44:	83 ec 0c             	sub    $0xc,%esp
c0001f47:	68 0f 46 00 c0       	push   $0xc000460f
c0001f4c:	e8 2e e5 ff ff       	call   c000047f <kprintf>
c0001f51:	83 c4 10             	add    $0x10,%esp
c0001f54:	eb 10                	jmp    c0001f66 <page_fault_handler+0x70>
    else
        kprintf("Page not present\n");
c0001f56:	83 ec 0c             	sub    $0xc,%esp
c0001f59:	68 2a 46 00 c0       	push   $0xc000462a
c0001f5e:	e8 1c e5 ff ff       	call   c000047f <kprintf>
c0001f63:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_USER)
c0001f66:	8b 45 08             	mov    0x8(%ebp),%eax
c0001f69:	83 e0 04             	and    $0x4,%eax
c0001f6c:	85 c0                	test   %eax,%eax
c0001f6e:	74 10                	je     c0001f80 <page_fault_handler+0x8a>
        kprintf("\n\nFault caused by user code\n");
c0001f70:	83 ec 0c             	sub    $0xc,%esp
c0001f73:	68 3c 46 00 c0       	push   $0xc000463c
c0001f78:	e8 02 e5 ff ff       	call   c000047f <kprintf>
c0001f7d:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_RES)
c0001f80:	8b 45 08             	mov    0x8(%ebp),%eax
c0001f83:	83 e0 08             	and    $0x8,%eax
c0001f86:	85 c0                	test   %eax,%eax
c0001f88:	74 10                	je     c0001f9a <page_fault_handler+0xa4>
        kprintf("Page reserved bit set\n");
c0001f8a:	83 ec 0c             	sub    $0xc,%esp
c0001f8d:	68 59 46 00 c0       	push   $0xc0004659
c0001f92:	e8 e8 e4 ff ff       	call   c000047f <kprintf>
c0001f97:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_IF)
c0001f9a:	8b 45 08             	mov    0x8(%ebp),%eax
c0001f9d:	83 e0 10             	and    $0x10,%eax
c0001fa0:	85 c0                	test   %eax,%eax
c0001fa2:	74 10                	je     c0001fb4 <page_fault_handler+0xbe>
        kprintf("Fault caused by instruction fetch\n");
c0001fa4:	83 ec 0c             	sub    $0xc,%esp
c0001fa7:	68 70 46 00 c0       	push   $0xc0004670
c0001fac:	e8 ce e4 ff ff       	call   c000047f <kprintf>
c0001fb1:	83 c4 10             	add    $0x10,%esp

    while(1);
c0001fb4:	eb fe                	jmp    c0001fb4 <page_fault_handler+0xbe>

c0001fb6 <exception_handler>:
}


void exception_handler(uint32_t exception_num, uint32_t code, void* fault_ip)
{
c0001fb6:	55                   	push   %ebp
c0001fb7:	89 e5                	mov    %esp,%ebp
c0001fb9:	83 ec 08             	sub    $0x8,%esp
    if(exception_num==14)
c0001fbc:	83 7d 08 0e          	cmpl   $0xe,0x8(%ebp)
c0001fc0:	75 13                	jne    c0001fd5 <exception_handler+0x1f>
        page_fault_handler(code, fault_ip);
c0001fc2:	83 ec 08             	sub    $0x8,%esp
c0001fc5:	ff 75 10             	pushl  0x10(%ebp)
c0001fc8:	ff 75 0c             	pushl  0xc(%ebp)
c0001fcb:	e8 26 ff ff ff       	call   c0001ef6 <page_fault_handler>
c0001fd0:	83 c4 10             	add    $0x10,%esp
c0001fd3:	eb 16                	jmp    c0001feb <exception_handler+0x35>
    else
        kprintf("\n\nException %u with code 0x%x at instruction 0x%x\n", exception_num, code, fault_ip);
c0001fd5:	ff 75 10             	pushl  0x10(%ebp)
c0001fd8:	ff 75 0c             	pushl  0xc(%ebp)
c0001fdb:	ff 75 08             	pushl  0x8(%ebp)
c0001fde:	68 94 46 00 c0       	push   $0xc0004694
c0001fe3:	e8 97 e4 ff ff       	call   c000047f <kprintf>
c0001fe8:	83 c4 10             	add    $0x10,%esp
    while(1);
c0001feb:	eb fe                	jmp    c0001feb <exception_handler+0x35>

c0001fed <irq_handler>:
}

void irq_handler(uint32_t irq_num)
{
c0001fed:	55                   	push   %ebp
c0001fee:	89 e5                	mov    %esp,%ebp
c0001ff0:	83 ec 18             	sub    $0x18,%esp
    if(irq_num == 1)
c0001ff3:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0001ff7:	75 36                	jne    c000202f <irq_handler+0x42>
    {
        unsigned char scan_code = inb(0x60);
c0001ff9:	6a 60                	push   $0x60
c0001ffb:	e8 38 fb ff ff       	call   c0001b38 <inb>
c0002000:	83 c4 04             	add    $0x4,%esp
c0002003:	88 45 f7             	mov    %al,-0x9(%ebp)
        char key_ascii = scancode_to_ascii(scan_code);
c0002006:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000200a:	83 ec 0c             	sub    $0xc,%esp
c000200d:	50                   	push   %eax
c000200e:	e8 86 0b 00 00       	call   c0002b99 <scancode_to_ascii>
c0002013:	83 c4 10             	add    $0x10,%esp
c0002016:	88 45 f6             	mov    %al,-0xa(%ebp)
        // kprintf("code: 0x%x, ascii:%c\n", scan_code, key_ascii);
        if(key_ascii>0)
c0002019:	80 7d f6 00          	cmpb   $0x0,-0xa(%ebp)
c000201d:	7e 10                	jle    c000202f <irq_handler+0x42>
            kprint_char(key_ascii);
c000201f:	0f be 45 f6          	movsbl -0xa(%ebp),%eax
c0002023:	83 ec 0c             	sub    $0xc,%esp
c0002026:	50                   	push   %eax
c0002027:	e8 02 e4 ff ff       	call   c000042e <kprint_char>
c000202c:	83 c4 10             	add    $0x10,%esp
    
    }

    // notify PIC that interrupt handling is complete
    if(irq_num >= 8)
c000202f:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
c0002033:	76 12                	jbe    c0002047 <irq_handler+0x5a>
        outb(PIC_EOI, PIC2_CMD);
c0002035:	83 ec 08             	sub    $0x8,%esp
c0002038:	68 a0 00 00 00       	push   $0xa0
c000203d:	6a 20                	push   $0x20
c000203f:	e8 11 fb ff ff       	call   c0001b55 <outb>
c0002044:	83 c4 10             	add    $0x10,%esp

    outb(PIC_EOI, PIC1_CMD);
c0002047:	83 ec 08             	sub    $0x8,%esp
c000204a:	6a 20                	push   $0x20
c000204c:	6a 20                	push   $0x20
c000204e:	e8 02 fb ff ff       	call   c0001b55 <outb>
c0002053:	83 c4 10             	add    $0x10,%esp

    return;
c0002056:	90                   	nop
}
c0002057:	c9                   	leave  
c0002058:	c3                   	ret    

c0002059 <initialize_multitasking>:
task_control_block_t kernel_main_task;

uint32_t pid_counter;

void initialize_multitasking()
{    
c0002059:	55                   	push   %ebp
c000205a:	89 e5                	mov    %esp,%ebp
c000205c:	83 ec 08             	sub    $0x8,%esp
    // initialize current task as initial task
    kernel_main_task.pid = pid_counter = 0;
c000205f:	c7 05 80 08 01 c0 00 	movl   $0x0,0xc0010880
c0002066:	00 00 00 
c0002069:	a1 80 08 01 c0       	mov    0xc0010880,%eax
c000206e:	a3 60 08 01 c0       	mov    %eax,0xc0010860
    kernel_main_task.state = RUNNING;
c0002073:	c7 05 64 08 01 c0 00 	movl   $0x0,0xc0010864
c000207a:	00 00 00 
    kernel_main_task.esp = NULL; //this is initialized only on task switch
c000207d:	c7 05 68 08 01 c0 00 	movl   $0x0,0xc0010868
c0002084:	00 00 00 
    kernel_main_task.pd = get_page_dir();
c0002087:	e8 c0 12 00 00       	call   c000334c <get_page_dir>
c000208c:	a3 70 08 01 c0       	mov    %eax,0xc0010870

    // this is the only task so far
    //as we add tasks this becomes circular linked list
    kernel_main_task.next_task = &kernel_main_task;
c0002091:	c7 05 74 08 01 c0 60 	movl   $0xc0010860,0xc0010874
c0002098:	08 01 c0 
    current_task = &kernel_main_task;
c000209b:	c7 05 40 08 01 c0 60 	movl   $0xc0010860,0xc0010840
c00020a2:	08 01 c0 
}
c00020a5:	90                   	nop
c00020a6:	c9                   	leave  
c00020a7:	c3                   	ret    

c00020a8 <new_kernel_task>:

task_control_block_t* new_kernel_task(int32_t (*task_entry) (void))
{
c00020a8:	55                   	push   %ebp
c00020a9:	89 e5                	mov    %esp,%ebp
c00020ab:	83 ec 18             	sub    $0x18,%esp
    task_control_block_t* new_task = kmalloc(sizeof(task_control_block_t));
c00020ae:	83 ec 0c             	sub    $0xc,%esp
c00020b1:	6a 20                	push   $0x20
c00020b3:	e8 61 0a 00 00       	call   c0002b19 <kmalloc>
c00020b8:	83 c4 10             	add    $0x10,%esp
c00020bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void* new_stack = kmalloc(KERNEL_STACK_SIZE);
c00020be:	83 ec 0c             	sub    $0xc,%esp
c00020c1:	68 00 80 00 00       	push   $0x8000
c00020c6:	e8 4e 0a 00 00       	call   c0002b19 <kmalloc>
c00020cb:	83 c4 10             	add    $0x10,%esp
c00020ce:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint32_t* esp0 = (uint32_t*) (new_stack + KERNEL_STACK_SIZE);
c00020d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00020d4:	05 00 80 00 00       	add    $0x8000,%eax
c00020d9:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // init new stack with valid context to launch new task
    *(--esp0) = (uint32_t) new_task; //argument to launch_task
c00020dc:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c00020e0:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00020e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00020e6:	89 10                	mov    %edx,(%eax)
    *(--esp0) = (uint32_t) terminate_task; // launch_task() returns to here, to close out task
c00020e8:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c00020ec:	ba 01 33 00 c0       	mov    $0xc0003301,%edx
c00020f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00020f4:	89 10                	mov    %edx,(%eax)
    *(--esp0) = (uint32_t) launch_task; //common entry function for new tasks
c00020f6:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c00020fa:	ba 65 22 00 c0       	mov    $0xc0002265,%edx
c00020ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002102:	89 10                	mov    %edx,(%eax)
    *(--esp0) = 0; //push ebx
c0002104:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c0002108:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000210b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp0) = 0; //push esi
c0002111:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c0002115:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002118:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp0) = 0; //push edi
c000211e:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c0002122:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002125:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp0) = 0; //push ebp
c000212b:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c000212f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002132:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    update_kstack(esp0); //update tss with esp0
c0002138:	83 ec 0c             	sub    $0xc,%esp
c000213b:	ff 75 ec             	pushl  -0x14(%ebp)
c000213e:	e8 21 0d 00 00       	call   c0002e64 <update_kstack>
c0002143:	83 c4 10             	add    $0x10,%esp

    //create copy of kernel page_dir
    void* new_pd = kmalloc_aligned(PAGE_SIZE, PAGE_SIZE);
c0002146:	83 ec 08             	sub    $0x8,%esp
c0002149:	68 00 10 00 00       	push   $0x1000
c000214e:	68 00 10 00 00       	push   $0x1000
c0002153:	e8 f8 08 00 00       	call   c0002a50 <kmalloc_aligned>
c0002158:	83 c4 10             	add    $0x10,%esp
c000215b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    memcpy(new_pd, (void*) &pd->dir,PAGE_SIZE);
c000215e:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c0002163:	05 00 f0 3f 00       	add    $0x3ff000,%eax
c0002168:	83 ec 04             	sub    $0x4,%esp
c000216b:	68 00 10 00 00       	push   $0x1000
c0002170:	50                   	push   %eax
c0002171:	ff 75 e8             	pushl  -0x18(%ebp)
c0002174:	e8 60 f1 ff ff       	call   c00012d9 <memcpy>
c0002179:	83 c4 10             	add    $0x10,%esp
    new_task->pd = get_physaddr(new_pd); //page dir is physical address.
c000217c:	83 ec 0c             	sub    $0xc,%esp
c000217f:	ff 75 e8             	pushl  -0x18(%ebp)
c0002182:	e8 0a 02 00 00       	call   c0002391 <get_physaddr>
c0002187:	83 c4 10             	add    $0x10,%esp
c000218a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000218d:	89 42 10             	mov    %eax,0x10(%edx)


    new_task->pid = ++pid_counter;
c0002190:	a1 80 08 01 c0       	mov    0xc0010880,%eax
c0002195:	83 c0 01             	add    $0x1,%eax
c0002198:	a3 80 08 01 c0       	mov    %eax,0xc0010880
c000219d:	8b 15 80 08 01 c0    	mov    0xc0010880,%edx
c00021a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00021a6:	89 10                	mov    %edx,(%eax)
    new_task->state = WAITING;
c00021a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00021ab:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
    new_task->esp = esp0;
c00021b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00021b5:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00021b8:	89 50 08             	mov    %edx,0x8(%eax)
    new_task->task_entry = task_entry;
c00021bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00021be:	8b 55 08             	mov    0x8(%ebp),%edx
c00021c1:	89 50 18             	mov    %edx,0x18(%eax)
    new_task->return_val = -1;
c00021c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00021c7:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%eax)

    //insert task into the ll
    new_task->next_task = current_task->next_task;
c00021ce:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c00021d3:	8b 50 14             	mov    0x14(%eax),%edx
c00021d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00021d9:	89 50 14             	mov    %edx,0x14(%eax)
    current_task->next_task = new_task;
c00021dc:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c00021e1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00021e4:	89 50 14             	mov    %edx,0x14(%eax)

    return new_task;
c00021e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00021ea:	c9                   	leave  
c00021eb:	c3                   	ret    

c00021ec <yield>:

void yield(void)
{
c00021ec:	55                   	push   %ebp
c00021ed:	89 e5                	mov    %esp,%ebp
c00021ef:	83 ec 08             	sub    $0x8,%esp
    current_task->state = WAITING;
c00021f2:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c00021f7:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
    current_task->next_task->state = RUNNING;    
c00021fe:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c0002203:	8b 40 14             	mov    0x14(%eax),%eax
c0002206:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    switch_to_task(current_task->next_task);
c000220d:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c0002212:	8b 40 14             	mov    0x14(%eax),%eax
c0002215:	83 ec 0c             	sub    $0xc,%esp
c0002218:	50                   	push   %eax
c0002219:	e8 ae 10 00 00       	call   c00032cc <switch_to_task>
c000221e:	83 c4 10             	add    $0x10,%esp
}
c0002221:	90                   	nop
c0002222:	c9                   	leave  
c0002223:	c3                   	ret    

c0002224 <join>:

int32_t join(task_control_block_t* task)
{
c0002224:	55                   	push   %ebp
c0002225:	89 e5                	mov    %esp,%ebp
c0002227:	83 ec 08             	sub    $0x8,%esp
    // make sure we are not trying to join the current task or the main kernel task
    if(task == current_task || task == &kernel_main_task)
c000222a:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c000222f:	39 45 08             	cmp    %eax,0x8(%ebp)
c0002232:	74 09                	je     c000223d <join+0x19>
c0002234:	81 7d 08 60 08 01 c0 	cmpl   $0xc0010860,0x8(%ebp)
c000223b:	75 0c                	jne    c0002249 <join+0x25>
        return -1; 
c000223d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002242:	eb 1f                	jmp    c0002263 <join+0x3f>

    while(task->state == WAITING || task->state == RUNNING)
        yield();
c0002244:	e8 a3 ff ff ff       	call   c00021ec <yield>
    while(task->state == WAITING || task->state == RUNNING)
c0002249:	8b 45 08             	mov    0x8(%ebp),%eax
c000224c:	8b 40 04             	mov    0x4(%eax),%eax
c000224f:	83 f8 02             	cmp    $0x2,%eax
c0002252:	74 f0                	je     c0002244 <join+0x20>
c0002254:	8b 45 08             	mov    0x8(%ebp),%eax
c0002257:	8b 40 04             	mov    0x4(%eax),%eax
c000225a:	85 c0                	test   %eax,%eax
c000225c:	74 e6                	je     c0002244 <join+0x20>

    // free task memory: stack, heap and paging structures
    // free tcb? << what should lifetime be?  Want to interrogate after process completes, but dont want it to live forever...
    // before I can do any of this, I need to actually implement free() :)

    return 0;
c000225e:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002263:	c9                   	leave  
c0002264:	c3                   	ret    

c0002265 <launch_task>:


void launch_task(task_control_block_t* task)
{
c0002265:	55                   	push   %ebp
c0002266:	89 e5                	mov    %esp,%ebp
c0002268:	83 ec 18             	sub    $0x18,%esp
    task->state = RUNNING;
c000226b:	8b 45 08             	mov    0x8(%ebp),%eax
c000226e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

   // call task main function
    task->return_val = (*task->task_entry)();
c0002275:	8b 45 08             	mov    0x8(%ebp),%eax
c0002278:	8b 40 18             	mov    0x18(%eax),%eax
c000227b:	ff d0                	call   *%eax
c000227d:	8b 55 08             	mov    0x8(%ebp),%edx
c0002280:	89 42 1c             	mov    %eax,0x1c(%edx)

    //remove this task from active task list
    task_control_block_t* t = task->next_task;
c0002283:	8b 45 08             	mov    0x8(%ebp),%eax
c0002286:	8b 40 14             	mov    0x14(%eax),%eax
c0002289:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while( t->next_task != task)
c000228c:	eb 09                	jmp    c0002297 <launch_task+0x32>
        t = t->next_task;
c000228e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002291:	8b 40 14             	mov    0x14(%eax),%eax
c0002294:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while( t->next_task != task)
c0002297:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000229a:	8b 40 14             	mov    0x14(%eax),%eax
c000229d:	39 45 08             	cmp    %eax,0x8(%ebp)
c00022a0:	75 ec                	jne    c000228e <launch_task+0x29>
    t->next_task = t->next_task->next_task;
c00022a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00022a5:	8b 40 14             	mov    0x14(%eax),%eax
c00022a8:	8b 50 14             	mov    0x14(%eax),%edx
c00022ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00022ae:	89 50 14             	mov    %edx,0x14(%eax)

    task->state = COMPLETE;
c00022b1:	8b 45 08             	mov    0x8(%ebp),%eax
c00022b4:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)

    // this will "return" to terminite_task 
}
c00022bb:	90                   	nop
c00022bc:	c9                   	leave  
c00022bd:	c3                   	ret    

c00022be <num_tasks>:

int num_tasks()
{
c00022be:	55                   	push   %ebp
c00022bf:	89 e5                	mov    %esp,%ebp
c00022c1:	83 ec 10             	sub    $0x10,%esp
    task_control_block_t* t = current_task;
c00022c4:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c00022c9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int nn = 1;
c00022cc:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    while( t->next_task != current_task)
c00022d3:	eb 0d                	jmp    c00022e2 <num_tasks+0x24>
    {
        t = t->next_task;
c00022d5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00022d8:	8b 40 14             	mov    0x14(%eax),%eax
c00022db:	89 45 fc             	mov    %eax,-0x4(%ebp)
        nn++;
c00022de:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while( t->next_task != current_task)
c00022e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00022e5:	8b 50 14             	mov    0x14(%eax),%edx
c00022e8:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c00022ed:	39 c2                	cmp    %eax,%edx
c00022ef:	75 e4                	jne    c00022d5 <num_tasks+0x17>
    }
    return nn;
c00022f1:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c00022f4:	c9                   	leave  
c00022f5:	c3                   	ret    

c00022f6 <user_test>:
int user_test()
{
c00022f6:	55                   	push   %ebp
c00022f7:	89 e5                	mov    %esp,%ebp
c00022f9:	83 ec 10             	sub    $0x10,%esp
    int a = 1;
c00022fc:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
    int b = 2;
c0002303:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
    int c = b/a;
c000230a:	8b 45 f8             	mov    -0x8(%ebp),%eax
c000230d:	99                   	cltd   
c000230e:	f7 7d fc             	idivl  -0x4(%ebp)
c0002311:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return c;
c0002314:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002317:	c9                   	leave  
c0002318:	c3                   	ret    

c0002319 <get_ptindex>:
//global pointer to page directory
extern page_directory_virt_t* pd;   //initialized in paging_asm.S

// return page table index for virtual address
static inline uint32_t get_ptindex(void* addr)
{
c0002319:	55                   	push   %ebp
c000231a:	89 e5                	mov    %esp,%ebp
    return (((uint32_t) addr) & PAGE_PTE_MASK ) >> 12;
c000231c:	8b 45 08             	mov    0x8(%ebp),%eax
c000231f:	c1 e8 0c             	shr    $0xc,%eax
c0002322:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c0002327:	5d                   	pop    %ebp
c0002328:	c3                   	ret    

c0002329 <get_pdindex>:

// return page directory index for virtual address
static inline uint32_t get_pdindex(void* addr)
{
c0002329:	55                   	push   %ebp
c000232a:	89 e5                	mov    %esp,%ebp
    return ((uint32_t) addr) >> 22;
c000232c:	8b 45 08             	mov    0x8(%ebp),%eax
c000232f:	c1 e8 16             	shr    $0x16,%eax
}
c0002332:	5d                   	pop    %ebp
c0002333:	c3                   	ret    

c0002334 <get_page_offset>:

// return offset into page
static inline uint32_t get_page_offset(void* addr)
{
c0002334:	55                   	push   %ebp
c0002335:	89 e5                	mov    %esp,%ebp
    return ((uint32_t) addr) & ~PAGE_ADDRMASK;
c0002337:	8b 45 08             	mov    0x8(%ebp),%eax
c000233a:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c000233f:	5d                   	pop    %ebp
c0002340:	c3                   	ret    

c0002341 <get_table>:

page_directory_virt_t* pd = (page_directory_virt_t*) PD_ADDR;

// return page directory index for virtual address
page_table_t* get_table(void* addr)
{
c0002341:	55                   	push   %ebp
c0002342:	89 e5                	mov    %esp,%ebp
c0002344:	53                   	push   %ebx
c0002345:	83 ec 10             	sub    $0x10,%esp
    uint32_t idx = get_pdindex(addr);
c0002348:	ff 75 08             	pushl  0x8(%ebp)
c000234b:	e8 d9 ff ff ff       	call   c0002329 <get_pdindex>
c0002350:	83 c4 04             	add    $0x4,%esp
c0002353:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(pd->dir.pde[idx] & PAGE_FLAG_PRESENT)
c0002356:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c000235b:	8b 55 f8             	mov    -0x8(%ebp),%edx
c000235e:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c0002364:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0002367:	83 e0 01             	and    $0x1,%eax
c000236a:	85 c0                	test   %eax,%eax
c000236c:	74 19                	je     c0002387 <get_table+0x46>
        return pd->tables + get_pdindex(addr);
c000236e:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c0002373:	89 c3                	mov    %eax,%ebx
c0002375:	ff 75 08             	pushl  0x8(%ebp)
c0002378:	e8 ac ff ff ff       	call   c0002329 <get_pdindex>
c000237d:	83 c4 04             	add    $0x4,%esp
c0002380:	c1 e0 0c             	shl    $0xc,%eax
c0002383:	01 d8                	add    %ebx,%eax
c0002385:	eb 05                	jmp    c000238c <get_table+0x4b>
    else 
        return NULL;
c0002387:	b8 00 00 00 00       	mov    $0x0,%eax
}
c000238c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000238f:	c9                   	leave  
c0002390:	c3                   	ret    

c0002391 <get_physaddr>:

// return physical addr from virt addr
void* get_physaddr(void* addr)
{
c0002391:	55                   	push   %ebp
c0002392:	89 e5                	mov    %esp,%ebp
c0002394:	53                   	push   %ebx
c0002395:	83 ec 10             	sub    $0x10,%esp
    //check pd entry is present
    uint32_t pdi = get_pdindex(addr);
c0002398:	ff 75 08             	pushl  0x8(%ebp)
c000239b:	e8 89 ff ff ff       	call   c0002329 <get_pdindex>
c00023a0:	83 c4 04             	add    $0x4,%esp
c00023a3:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(! pd->dir.pde[pdi] & PAGE_FLAG_PRESENT)
c00023a6:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c00023ab:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00023ae:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c00023b4:	8b 04 90             	mov    (%eax,%edx,4),%eax
c00023b7:	85 c0                	test   %eax,%eax
c00023b9:	75 07                	jne    c00023c2 <get_physaddr+0x31>
        return NULL;
c00023bb:	b8 00 00 00 00       	mov    $0x0,%eax
c00023c0:	eb 45                	jmp    c0002407 <get_physaddr+0x76>

    //check pt entry is present
    uint32_t pte = pd->tables[pdi].pte[get_ptindex(addr)];
c00023c2:	8b 1d 00 50 00 c0    	mov    0xc0005000,%ebx
c00023c8:	ff 75 08             	pushl  0x8(%ebp)
c00023cb:	e8 49 ff ff ff       	call   c0002319 <get_ptindex>
c00023d0:	83 c4 04             	add    $0x4,%esp
c00023d3:	89 c2                	mov    %eax,%edx
c00023d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00023d8:	c1 e0 0a             	shl    $0xa,%eax
c00023db:	01 d0                	add    %edx,%eax
c00023dd:	8b 04 83             	mov    (%ebx,%eax,4),%eax
c00023e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(! pte & PAGE_FLAG_PRESENT)
c00023e3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00023e7:	75 07                	jne    c00023f0 <get_physaddr+0x5f>
        return NULL;
c00023e9:	b8 00 00 00 00       	mov    $0x0,%eax
c00023ee:	eb 17                	jmp    c0002407 <get_physaddr+0x76>

    return (void*) ((pte & PAGE_ADDRMASK) +  get_page_offset(addr) );
c00023f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00023f3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00023f8:	89 c3                	mov    %eax,%ebx
c00023fa:	ff 75 08             	pushl  0x8(%ebp)
c00023fd:	e8 32 ff ff ff       	call   c0002334 <get_page_offset>
c0002402:	83 c4 04             	add    $0x4,%esp
c0002405:	01 d8                	add    %ebx,%eax
}
c0002407:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000240a:	c9                   	leave  
c000240b:	c3                   	ret    

c000240c <get_ptindex>:
{
c000240c:	55                   	push   %ebp
c000240d:	89 e5                	mov    %esp,%ebp
    return (((uint32_t) addr) & PAGE_PTE_MASK ) >> 12;
c000240f:	8b 45 08             	mov    0x8(%ebp),%eax
c0002412:	c1 e8 0c             	shr    $0xc,%eax
c0002415:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c000241a:	5d                   	pop    %ebp
c000241b:	c3                   	ret    

c000241c <get_pdindex>:
{
c000241c:	55                   	push   %ebp
c000241d:	89 e5                	mov    %esp,%ebp
    return ((uint32_t) addr) >> 22;
c000241f:	8b 45 08             	mov    0x8(%ebp),%eax
c0002422:	c1 e8 16             	shr    $0x16,%eax
}
c0002425:	5d                   	pop    %ebp
c0002426:	c3                   	ret    

c0002427 <align_addr>:
void* kmalloc(size_t sz);
void* kmalloc_aligned(size_t sz, size_t alignment);
void* memset(void* addr, int val, size_t cnt);

static inline void* align_addr(void* addr, uint32_t alignment)
{
c0002427:	55                   	push   %ebp
c0002428:	89 e5                	mov    %esp,%ebp
c000242a:	83 ec 10             	sub    $0x10,%esp
    uint32_t am = alignment - 1;
c000242d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002430:	83 e8 01             	sub    $0x1,%eax
c0002433:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (char*) (((uint32_t)addr + am) & ~am);
c0002436:	8b 55 08             	mov    0x8(%ebp),%edx
c0002439:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000243c:	01 c2                	add    %eax,%edx
c000243e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002441:	f7 d0                	not    %eax
c0002443:	21 d0                	and    %edx,%eax
}
c0002445:	c9                   	leave  
c0002446:	c3                   	ret    

c0002447 <is_pow_of_two>:

static inline int is_pow_of_two(uint32_t x)
{
c0002447:	55                   	push   %ebp
c0002448:	89 e5                	mov    %esp,%ebp
    return (x != 0) && ((x & (x - 1)) == 0);
c000244a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c000244e:	74 14                	je     c0002464 <is_pow_of_two+0x1d>
c0002450:	8b 45 08             	mov    0x8(%ebp),%eax
c0002453:	83 e8 01             	sub    $0x1,%eax
c0002456:	23 45 08             	and    0x8(%ebp),%eax
c0002459:	85 c0                	test   %eax,%eax
c000245b:	75 07                	jne    c0002464 <is_pow_of_two+0x1d>
c000245d:	b8 01 00 00 00       	mov    $0x1,%eax
c0002462:	eb 05                	jmp    c0002469 <is_pow_of_two+0x22>
c0002464:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002469:	5d                   	pop    %ebp
c000246a:	c3                   	ret    

c000246b <pop_free_page>:
page_t** free_stack_base;   //end of stack data
page_t*  free_stack_break;   //end of allocated memory for stack

// allocate a physical page from the stack
page_t* pop_free_page()
{
c000246b:	55                   	push   %ebp
c000246c:	89 e5                	mov    %esp,%ebp
c000246e:	83 ec 10             	sub    $0x10,%esp
    page_t* free_page = *(free_stack_top++);
c0002471:	a1 94 08 01 c0       	mov    0xc0010894,%eax
c0002476:	8d 50 04             	lea    0x4(%eax),%edx
c0002479:	89 15 94 08 01 c0    	mov    %edx,0xc0010894
c000247f:	8b 00                	mov    (%eax),%eax
c0002481:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(free_stack_top<free_stack_base)
c0002484:	8b 15 94 08 01 c0    	mov    0xc0010894,%edx
c000248a:	a1 98 08 01 c0       	mov    0xc0010898,%eax
c000248f:	39 c2                	cmp    %eax,%edx
c0002491:	73 05                	jae    c0002498 <pop_free_page+0x2d>
        return free_page;
c0002493:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002496:	eb 05                	jmp    c000249d <pop_free_page+0x32>
    else
        return NULL; //out of memory!    
c0002498:	b8 00 00 00 00       	mov    $0x0,%eax
}
c000249d:	c9                   	leave  
c000249e:	c3                   	ret    

c000249f <push_free_page>:

// free a physical page back to the stack
int push_free_page(page_t* free_page)
{
c000249f:	55                   	push   %ebp
c00024a0:	89 e5                	mov    %esp,%ebp
    if(free_stack_top<=free_stack_start)
c00024a2:	8b 15 94 08 01 c0    	mov    0xc0010894,%edx
c00024a8:	a1 90 08 01 c0       	mov    0xc0010890,%eax
c00024ad:	39 c2                	cmp    %eax,%edx
c00024af:	77 07                	ja     c00024b8 <push_free_page+0x19>
        return -1;
c00024b1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00024b6:	eb 18                	jmp    c00024d0 <push_free_page+0x31>

    *(free_stack_top--) = free_page;
c00024b8:	a1 94 08 01 c0       	mov    0xc0010894,%eax
c00024bd:	8d 50 fc             	lea    -0x4(%eax),%edx
c00024c0:	89 15 94 08 01 c0    	mov    %edx,0xc0010894
c00024c6:	8b 55 08             	mov    0x8(%ebp),%edx
c00024c9:	89 10                	mov    %edx,(%eax)
    return 0;
c00024cb:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00024d0:	5d                   	pop    %ebp
c00024d1:	c3                   	ret    

c00024d2 <init_page_stack>:


// set up a stack will all free pages of physical memory
void init_page_stack(multiboot_info_t* mbd)
{
c00024d2:	55                   	push   %ebp
c00024d3:	89 e5                	mov    %esp,%ebp
c00024d5:	57                   	push   %edi
c00024d6:	56                   	push   %esi
c00024d7:	83 ec 30             	sub    $0x30,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c00024da:	8b 45 08             	mov    0x8(%ebp),%eax
c00024dd:	8b 40 30             	mov    0x30(%eax),%eax
c00024e0:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // We will start looking for free physical memory just above the kernel
    page_t* first_free_page = align_addr( &_kernel_end_phys, PAGE_SIZE); //physical address of first free page after the kernel
c00024e3:	68 00 10 00 00       	push   $0x1000
c00024e8:	68 68 19 11 00       	push   $0x111968
c00024ed:	e8 35 ff ff ff       	call   c0002427 <align_addr>
c00024f2:	83 c4 08             	add    $0x8,%esp
c00024f5:	89 45 e8             	mov    %eax,-0x18(%ebp)

    // Map the stack just past the end of the kernel in virtual mem

    // stack_break points to the end of the allocated region for the stack  
    free_stack_break = align_addr( &_kernel_end, PAGE_SIZE);
c00024f8:	68 00 10 00 00       	push   $0x1000
c00024fd:	68 68 09 01 c0       	push   $0xc0010968
c0002502:	e8 20 ff ff ff       	call   c0002427 <align_addr>
c0002507:	83 c4 08             	add    $0x8,%esp
c000250a:	a3 9c 08 01 c0       	mov    %eax,0xc001089c

    // initialize stack pointers
    // we will initialize the stack by adding new pages to the base
    // first pages (in low mem) will be at top of the stack
    free_stack_start = (page_t**) free_stack_break;
c000250f:	a1 9c 08 01 c0       	mov    0xc001089c,%eax
c0002514:	a3 90 08 01 c0       	mov    %eax,0xc0010890
    free_stack_top = free_stack_start;
c0002519:	a1 90 08 01 c0       	mov    0xc0010890,%eax
c000251e:	a3 94 08 01 c0       	mov    %eax,0xc0010894
    free_stack_base = free_stack_top;
c0002523:	a1 94 08 01 c0       	mov    0xc0010894,%eax
c0002528:	a3 98 08 01 c0       	mov    %eax,0xc0010898

    // allocate one page for the stack, incrementing the stack_break and first_free_page pointers
    // We will allocate more pages for the stack as we go as needed
    if(!map_page_at(free_stack_break++, first_free_page++, PAGE_FLAG_WRITE))
c000252d:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0002530:	8d 82 00 10 00 00    	lea    0x1000(%edx),%eax
c0002536:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0002539:	a1 9c 08 01 c0       	mov    0xc001089c,%eax
c000253e:	8d 88 00 10 00 00    	lea    0x1000(%eax),%ecx
c0002544:	89 0d 9c 08 01 c0    	mov    %ecx,0xc001089c
c000254a:	83 ec 04             	sub    $0x4,%esp
c000254d:	6a 02                	push   $0x2
c000254f:	52                   	push   %edx
c0002550:	50                   	push   %eax
c0002551:	e8 a6 03 00 00       	call   c00028fc <map_page_at>
c0002556:	83 c4 10             	add    $0x10,%esp
c0002559:	85 c0                	test   %eax,%eax
c000255b:	75 10                	jne    c000256d <init_page_stack+0x9b>
        panic("Error reserving memory for physical page allocation!");
c000255d:	83 ec 0c             	sub    $0xc,%esp
c0002560:	68 c8 46 00 c0       	push   $0xc00046c8
c0002565:	e8 32 ed ff ff       	call   c000129c <panic>
c000256a:	83 c4 10             	add    $0x10,%esp

    // loop through each block of memory defined in the multiboot record
    // for each block of memory, add free pages to stack
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c000256d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0002574:	e9 50 01 00 00       	jmp    c00026c9 <init_page_stack+0x1f7>
	{
        if(mmap_table[nn].size == 0) // end of table
c0002579:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000257c:	89 d0                	mov    %edx,%eax
c000257e:	01 c0                	add    %eax,%eax
c0002580:	01 d0                	add    %edx,%eax
c0002582:	c1 e0 03             	shl    $0x3,%eax
c0002585:	89 c2                	mov    %eax,%edx
c0002587:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000258a:	01 d0                	add    %edx,%eax
c000258c:	8b 00                	mov    (%eax),%eax
c000258e:	85 c0                	test   %eax,%eax
c0002590:	0f 84 44 01 00 00    	je     c00026da <init_page_stack+0x208>
            break;

        if(mmap_table[nn].addr >> 32) // ignore anything above 32bits
c0002596:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002599:	89 d0                	mov    %edx,%eax
c000259b:	01 c0                	add    %eax,%eax
c000259d:	01 d0                	add    %edx,%eax
c000259f:	c1 e0 03             	shl    $0x3,%eax
c00025a2:	89 c2                	mov    %eax,%edx
c00025a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00025a7:	01 d0                	add    %edx,%eax
c00025a9:	8b 50 08             	mov    0x8(%eax),%edx
c00025ac:	8b 40 04             	mov    0x4(%eax),%eax
c00025af:	89 d0                	mov    %edx,%eax
c00025b1:	31 d2                	xor    %edx,%edx
c00025b3:	89 c1                	mov    %eax,%ecx
c00025b5:	80 f5 00             	xor    $0x0,%ch
c00025b8:	89 ce                	mov    %ecx,%esi
c00025ba:	89 d0                	mov    %edx,%eax
c00025bc:	80 f4 00             	xor    $0x0,%ah
c00025bf:	89 c7                	mov    %eax,%edi
c00025c1:	89 f8                	mov    %edi,%eax
c00025c3:	09 f0                	or     %esi,%eax
c00025c5:	85 c0                	test   %eax,%eax
c00025c7:	0f 85 f7 00 00 00    	jne    c00026c4 <init_page_stack+0x1f2>
            continue;

		if(mmap_table[nn].type == MULTIBOOT_MEMORY_AVAILABLE)
c00025cd:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00025d0:	89 d0                	mov    %edx,%eax
c00025d2:	01 c0                	add    %eax,%eax
c00025d4:	01 d0                	add    %edx,%eax
c00025d6:	c1 e0 03             	shl    $0x3,%eax
c00025d9:	89 c2                	mov    %eax,%edx
c00025db:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00025de:	01 d0                	add    %edx,%eax
c00025e0:	8b 40 14             	mov    0x14(%eax),%eax
c00025e3:	83 f8 01             	cmp    $0x1,%eax
c00025e6:	0f 85 d9 00 00 00    	jne    c00026c5 <init_page_stack+0x1f3>
        {
            //pointers to the first and last page in this memory block 
            size_t block_addr = mmap_table[nn].addr;
c00025ec:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00025ef:	89 d0                	mov    %edx,%eax
c00025f1:	01 c0                	add    %eax,%eax
c00025f3:	01 d0                	add    %edx,%eax
c00025f5:	c1 e0 03             	shl    $0x3,%eax
c00025f8:	89 c2                	mov    %eax,%edx
c00025fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00025fd:	01 d0                	add    %edx,%eax
c00025ff:	8b 50 08             	mov    0x8(%eax),%edx
c0002602:	8b 40 04             	mov    0x4(%eax),%eax
c0002605:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            size_t block_len = mmap_table[nn].len;
c0002608:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000260b:	89 d0                	mov    %edx,%eax
c000260d:	01 c0                	add    %eax,%eax
c000260f:	01 d0                	add    %edx,%eax
c0002611:	c1 e0 03             	shl    $0x3,%eax
c0002614:	89 c2                	mov    %eax,%edx
c0002616:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002619:	01 d0                	add    %edx,%eax
c000261b:	8b 50 10             	mov    0x10(%eax),%edx
c000261e:	8b 40 0c             	mov    0xc(%eax),%eax
c0002621:	89 45 e0             	mov    %eax,-0x20(%ebp)
            page_t* pg = align_addr( (char*) block_addr, PAGE_SIZE); // first whole page in block
c0002624:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0002627:	83 ec 08             	sub    $0x8,%esp
c000262a:	68 00 10 00 00       	push   $0x1000
c000262f:	50                   	push   %eax
c0002630:	e8 f2 fd ff ff       	call   c0002427 <align_addr>
c0002635:	83 c4 10             	add    $0x10,%esp
c0002638:	89 45 f0             	mov    %eax,-0x10(%ebp)
            page_t* pg_end = (page_t*) ((block_addr+block_len) & PAGE_ADDRMASK); // first page *after* last whole page in block
c000263b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c000263e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0002641:	01 d0                	add    %edx,%eax
c0002643:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002648:	89 45 dc             	mov    %eax,-0x24(%ebp)

            //don't map any memory before end of the kernel
            pg = pg<first_free_page ? first_free_page : pg; 
c000264b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000264e:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0002651:	0f 43 45 f0          	cmovae -0x10(%ebp),%eax
c0002655:	89 45 f0             	mov    %eax,-0x10(%ebp)

            //fill stack with pointers to each page in the block
            for(; pg<pg_end; pg++)
c0002658:	eb 60                	jmp    c00026ba <init_page_stack+0x1e8>
            {
                // extend end of stack and make sure we have allocated enough memory
                if( (void*) ++free_stack_base >= (void*) free_stack_break)
c000265a:	a1 98 08 01 c0       	mov    0xc0010898,%eax
c000265f:	83 c0 04             	add    $0x4,%eax
c0002662:	a3 98 08 01 c0       	mov    %eax,0xc0010898
c0002667:	8b 15 98 08 01 c0    	mov    0xc0010898,%edx
c000266d:	a1 9c 08 01 c0       	mov    0xc001089c,%eax
c0002672:	39 c2                	cmp    %eax,%edx
c0002674:	72 33                	jb     c00026a9 <init_page_stack+0x1d7>
                {
                    // map a new page at the end of the stack
                    // note that this will pop a free page off the top of the stack
                    if(!map_page(free_stack_break++, PAGE_FLAG_WRITE))
c0002676:	a1 9c 08 01 c0       	mov    0xc001089c,%eax
c000267b:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c0002681:	89 15 9c 08 01 c0    	mov    %edx,0xc001089c
c0002687:	83 ec 08             	sub    $0x8,%esp
c000268a:	6a 02                	push   $0x2
c000268c:	50                   	push   %eax
c000268d:	e8 fa 02 00 00       	call   c000298c <map_page>
c0002692:	83 c4 10             	add    $0x10,%esp
c0002695:	85 c0                	test   %eax,%eax
c0002697:	75 10                	jne    c00026a9 <init_page_stack+0x1d7>
                        panic("Error reserving memory for physical page allocation!");
c0002699:	83 ec 0c             	sub    $0xc,%esp
c000269c:	68 c8 46 00 c0       	push   $0xc00046c8
c00026a1:	e8 f6 eb ff ff       	call   c000129c <panic>
c00026a6:	83 c4 10             	add    $0x10,%esp
                }

                //record physical page at end stack
                *free_stack_base = pg;
c00026a9:	a1 98 08 01 c0       	mov    0xc0010898,%eax
c00026ae:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00026b1:	89 10                	mov    %edx,(%eax)
            for(; pg<pg_end; pg++)
c00026b3:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
c00026ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00026bd:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c00026c0:	72 98                	jb     c000265a <init_page_stack+0x188>
c00026c2:	eb 01                	jmp    c00026c5 <init_page_stack+0x1f3>
            continue;
c00026c4:	90                   	nop
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c00026c5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00026c9:	8b 45 08             	mov    0x8(%ebp),%eax
c00026cc:	8b 40 2c             	mov    0x2c(%eax),%eax
c00026cf:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c00026d2:	0f 82 a1 fe ff ff    	jb     c0002579 <init_page_stack+0xa7>
c00026d8:	eb 01                	jmp    c00026db <init_page_stack+0x209>
            break;
c00026da:	90                   	nop
            }
        }
	}

    size_t free_pages = free_stack_base-free_stack_top;
c00026db:	a1 98 08 01 c0       	mov    0xc0010898,%eax
c00026e0:	8b 15 94 08 01 c0    	mov    0xc0010894,%edx
c00026e6:	29 d0                	sub    %edx,%eax
c00026e8:	c1 f8 02             	sar    $0x2,%eax
c00026eb:	89 45 d8             	mov    %eax,-0x28(%ebp)
	kprintf("\nFound %d pages (%f MB)\n", free_pages, free_pages*PAGE_SIZE/1e6);
c00026ee:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00026f1:	c1 e0 0c             	shl    $0xc,%eax
c00026f4:	89 45 d0             	mov    %eax,-0x30(%ebp)
c00026f7:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
c00026fe:	df 6d d0             	fildll -0x30(%ebp)
c0002701:	dd 05 48 47 00 c0    	fldl   0xc0004748
c0002707:	de f9                	fdivrp %st,%st(1)
c0002709:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c000270d:	dd 1c 24             	fstpl  (%esp)
c0002710:	ff 75 d8             	pushl  -0x28(%ebp)
c0002713:	68 fd 46 00 c0       	push   $0xc00046fd
c0002718:	e8 62 dd ff ff       	call   c000047f <kprintf>
c000271d:	83 c4 10             	add    $0x10,%esp

}
c0002720:	90                   	nop
c0002721:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0002724:	5e                   	pop    %esi
c0002725:	5f                   	pop    %edi
c0002726:	5d                   	pop    %ebp
c0002727:	c3                   	ret    

c0002728 <memory_init>:

int memory_init(multiboot_info_t* mbd)
{
c0002728:	55                   	push   %ebp
c0002729:	89 e5                	mov    %esp,%ebp
c000272b:	83 ec 08             	sub    $0x8,%esp
    init_page_stack(mbd);
c000272e:	83 ec 0c             	sub    $0xc,%esp
c0002731:	ff 75 08             	pushl  0x8(%ebp)
c0002734:	e8 99 fd ff ff       	call   c00024d2 <init_page_stack>
c0002739:	83 c4 10             	add    $0x10,%esp

	if(! heap_init() )
c000273c:	e8 38 01 00 00       	call   c0002879 <heap_init>
c0002741:	85 c0                	test   %eax,%eax
c0002743:	75 07                	jne    c000274c <memory_init+0x24>
        return -1;
c0002745:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000274a:	eb 25                	jmp    c0002771 <memory_init+0x49>

	if( unmap_lowmem() )
c000274c:	e8 22 00 00 00       	call   c0002773 <unmap_lowmem>
c0002751:	85 c0                	test   %eax,%eax
c0002753:	74 07                	je     c000275c <memory_init+0x34>
        return -1;
c0002755:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000275a:	eb 15                	jmp    c0002771 <memory_init+0x49>

	// if(! map_multiboot() )
    //     return -1;

	if(! map_vga() )
c000275c:	e8 33 00 00 00       	call   c0002794 <map_vga>
c0002761:	85 c0                	test   %eax,%eax
c0002763:	75 07                	jne    c000276c <memory_init+0x44>
        return -1;
c0002765:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000276a:	eb 05                	jmp    c0002771 <memory_init+0x49>

    return 0;
c000276c:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002771:	c9                   	leave  
c0002772:	c3                   	ret    

c0002773 <unmap_lowmem>:

int unmap_lowmem()
{
c0002773:	55                   	push   %ebp
c0002774:	89 e5                	mov    %esp,%ebp
c0002776:	83 ec 08             	sub    $0x8,%esp
    pd->dir.pde[0] = PAGE_FLAG_EMPTY;
c0002779:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c000277e:	c7 80 00 f0 3f 00 00 	movl   $0x0,0x3ff000(%eax)
c0002785:	00 00 00 
    refresh_tlb();
c0002788:	e8 c3 0b 00 00       	call   c0003350 <refresh_tlb>
    return 0;
c000278d:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002792:	c9                   	leave  
c0002793:	c3                   	ret    

c0002794 <map_vga>:
// {

// }

char* map_vga()
{
c0002794:	55                   	push   %ebp
c0002795:	89 e5                	mov    %esp,%ebp
c0002797:	83 ec 18             	sub    $0x18,%esp
    page_t* vga_buf = (page_t*) VGA_BUFFER;
c000279a:	c7 45 f4 00 80 0b 00 	movl   $0xb8000,-0xc(%ebp)

    //map 6 pages of vga memory    
    map_page_at(vga_buf,vga_buf, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c00027a1:	83 ec 04             	sub    $0x4,%esp
c00027a4:	6a 06                	push   $0x6
c00027a6:	ff 75 f4             	pushl  -0xc(%ebp)
c00027a9:	ff 75 f4             	pushl  -0xc(%ebp)
c00027ac:	e8 4b 01 00 00       	call   c00028fc <map_page_at>
c00027b1:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+1,vga_buf+1, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c00027b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00027b7:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c00027bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00027c0:	05 00 10 00 00       	add    $0x1000,%eax
c00027c5:	83 ec 04             	sub    $0x4,%esp
c00027c8:	6a 06                	push   $0x6
c00027ca:	52                   	push   %edx
c00027cb:	50                   	push   %eax
c00027cc:	e8 2b 01 00 00       	call   c00028fc <map_page_at>
c00027d1:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+2,vga_buf+2, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c00027d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00027d7:	8d 90 00 20 00 00    	lea    0x2000(%eax),%edx
c00027dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00027e0:	05 00 20 00 00       	add    $0x2000,%eax
c00027e5:	83 ec 04             	sub    $0x4,%esp
c00027e8:	6a 06                	push   $0x6
c00027ea:	52                   	push   %edx
c00027eb:	50                   	push   %eax
c00027ec:	e8 0b 01 00 00       	call   c00028fc <map_page_at>
c00027f1:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+3,vga_buf+3, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c00027f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00027f7:	8d 90 00 30 00 00    	lea    0x3000(%eax),%edx
c00027fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002800:	05 00 30 00 00       	add    $0x3000,%eax
c0002805:	83 ec 04             	sub    $0x4,%esp
c0002808:	6a 06                	push   $0x6
c000280a:	52                   	push   %edx
c000280b:	50                   	push   %eax
c000280c:	e8 eb 00 00 00       	call   c00028fc <map_page_at>
c0002811:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+4,vga_buf+4, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c0002814:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002817:	8d 90 00 40 00 00    	lea    0x4000(%eax),%edx
c000281d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002820:	05 00 40 00 00       	add    $0x4000,%eax
c0002825:	83 ec 04             	sub    $0x4,%esp
c0002828:	6a 06                	push   $0x6
c000282a:	52                   	push   %edx
c000282b:	50                   	push   %eax
c000282c:	e8 cb 00 00 00       	call   c00028fc <map_page_at>
c0002831:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+5,vga_buf+5, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c0002834:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002837:	8d 90 00 50 00 00    	lea    0x5000(%eax),%edx
c000283d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002840:	05 00 50 00 00       	add    $0x5000,%eax
c0002845:	83 ec 04             	sub    $0x4,%esp
c0002848:	6a 06                	push   $0x6
c000284a:	52                   	push   %edx
c000284b:	50                   	push   %eax
c000284c:	e8 ab 00 00 00       	call   c00028fc <map_page_at>
c0002851:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+6,vga_buf+6, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c0002854:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002857:	8d 90 00 60 00 00    	lea    0x6000(%eax),%edx
c000285d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002860:	05 00 60 00 00       	add    $0x6000,%eax
c0002865:	83 ec 04             	sub    $0x4,%esp
c0002868:	6a 06                	push   $0x6
c000286a:	52                   	push   %edx
c000286b:	50                   	push   %eax
c000286c:	e8 8b 00 00 00       	call   c00028fc <map_page_at>
c0002871:	83 c4 10             	add    $0x10,%esp

    return (char*) vga_buf;
c0002874:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0002877:	c9                   	leave  
c0002878:	c3                   	ret    

c0002879 <heap_init>:

char* heap_init()
{
c0002879:	55                   	push   %ebp
c000287a:	89 e5                	mov    %esp,%ebp
c000287c:	83 ec 08             	sub    $0x8,%esp
    //start new allocations here in virtual memory
    heap_page = (page_t*) align_addr((void*) KERNEL_HEAP, PAGE_SIZE);
c000287f:	68 00 10 00 00       	push   $0x1000
c0002884:	68 00 00 00 c5       	push   $0xc5000000
c0002889:	e8 99 fb ff ff       	call   c0002427 <align_addr>
c000288e:	83 c4 08             	add    $0x8,%esp
c0002891:	a3 84 08 01 c0       	mov    %eax,0xc0010884
    heap = (char*) heap_page;
c0002896:	a1 84 08 01 c0       	mov    0xc0010884,%eax
c000289b:	a3 88 08 01 c0       	mov    %eax,0xc0010888
    heap_end = (char*) KERNEL_HEAP_END;
c00028a0:	c7 05 8c 08 01 c0 00 	movl   $0xf0000000,0xc001088c
c00028a7:	00 00 f0 

	kprintf("Setting up heap: 0x%.8x - 0x%.8x (%u MiB)\n\n", heap, heap_end,  (uint32_t) (heap_end-heap) >> 20);
c00028aa:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
c00028af:	8b 15 88 08 01 c0    	mov    0xc0010888,%edx
c00028b5:	29 d0                	sub    %edx,%eax
c00028b7:	c1 e8 14             	shr    $0x14,%eax
c00028ba:	89 c1                	mov    %eax,%ecx
c00028bc:	8b 15 8c 08 01 c0    	mov    0xc001088c,%edx
c00028c2:	a1 88 08 01 c0       	mov    0xc0010888,%eax
c00028c7:	51                   	push   %ecx
c00028c8:	52                   	push   %edx
c00028c9:	50                   	push   %eax
c00028ca:	68 18 47 00 c0       	push   $0xc0004718
c00028cf:	e8 ab db ff ff       	call   c000047f <kprintf>
c00028d4:	83 c4 10             	add    $0x10,%esp

    //map the first page on the heap
    if(!map_page(heap_page, PAGE_FLAG_WRITE))
c00028d7:	a1 84 08 01 c0       	mov    0xc0010884,%eax
c00028dc:	83 ec 08             	sub    $0x8,%esp
c00028df:	6a 02                	push   $0x2
c00028e1:	50                   	push   %eax
c00028e2:	e8 a5 00 00 00       	call   c000298c <map_page>
c00028e7:	83 c4 10             	add    $0x10,%esp
c00028ea:	85 c0                	test   %eax,%eax
c00028ec:	75 07                	jne    c00028f5 <heap_init+0x7c>
        return NULL;
c00028ee:	b8 00 00 00 00       	mov    $0x0,%eax
c00028f3:	eb 05                	jmp    c00028fa <heap_init+0x81>

    return heap;
c00028f5:	a1 88 08 01 c0       	mov    0xc0010888,%eax
}
c00028fa:	c9                   	leave  
c00028fb:	c3                   	ret    

c00028fc <map_page_at>:


page_t* map_page_at(page_t* page_virt, page_t* page_phys, uint32_t flags)
{
c00028fc:	55                   	push   %ebp
c00028fd:	89 e5                	mov    %esp,%ebp
c00028ff:	53                   	push   %ebx
c0002900:	83 ec 14             	sub    $0x14,%esp
    page_table_t* pt = get_table(page_virt);
c0002903:	83 ec 0c             	sub    $0xc,%esp
c0002906:	ff 75 08             	pushl  0x8(%ebp)
c0002909:	e8 33 fa ff ff       	call   c0002341 <get_table>
c000290e:	83 c4 10             	add    $0x10,%esp
c0002911:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(!pt)
c0002914:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002918:	75 14                	jne    c000292e <map_page_at+0x32>
        pt = new_page_table(page_virt, flags); // page table is not present, allocate a new one
c000291a:	83 ec 08             	sub    $0x8,%esp
c000291d:	ff 75 10             	pushl  0x10(%ebp)
c0002920:	ff 75 08             	pushl  0x8(%ebp)
c0002923:	e8 83 00 00 00       	call   c00029ab <new_page_table>
c0002928:	83 c4 10             	add    $0x10,%esp
c000292b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    
    if(pt->pte[get_ptindex(page_virt)] & PAGE_FLAG_PRESENT)
c000292e:	83 ec 0c             	sub    $0xc,%esp
c0002931:	ff 75 08             	pushl  0x8(%ebp)
c0002934:	e8 d3 fa ff ff       	call   c000240c <get_ptindex>
c0002939:	83 c4 10             	add    $0x10,%esp
c000293c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000293f:	8b 04 82             	mov    (%edx,%eax,4),%eax
c0002942:	83 e0 01             	and    $0x1,%eax
c0002945:	85 c0                	test   %eax,%eax
c0002947:	74 07                	je     c0002950 <map_page_at+0x54>
        return NULL; //page already mapped
c0002949:	b8 00 00 00 00       	mov    $0x0,%eax
c000294e:	eb 37                	jmp    c0002987 <map_page_at+0x8b>

    // map page
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0002950:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002953:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002958:	0b 45 10             	or     0x10(%ebp),%eax
c000295b:	89 c3                	mov    %eax,%ebx
c000295d:	83 ec 0c             	sub    $0xc,%esp
c0002960:	ff 75 08             	pushl  0x8(%ebp)
c0002963:	e8 a4 fa ff ff       	call   c000240c <get_ptindex>
c0002968:	83 c4 10             	add    $0x10,%esp
c000296b:	89 d9                	mov    %ebx,%ecx
c000296d:	83 c9 01             	or     $0x1,%ecx
c0002970:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002973:	89 0c 82             	mov    %ecx,(%edx,%eax,4)

    refresh_page(page_virt);
c0002976:	83 ec 0c             	sub    $0xc,%esp
c0002979:	ff 75 08             	pushl  0x8(%ebp)
c000297c:	e8 d7 09 00 00       	call   c0003358 <refresh_page>
c0002981:	83 c4 10             	add    $0x10,%esp
    return page_virt;
c0002984:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0002987:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000298a:	c9                   	leave  
c000298b:	c3                   	ret    

c000298c <map_page>:

page_t* map_page(page_t* page_virt, uint32_t flags)
{
c000298c:	55                   	push   %ebp
c000298d:	89 e5                	mov    %esp,%ebp
c000298f:	83 ec 08             	sub    $0x8,%esp
    return map_page_at(page_virt, pop_free_page(), flags);
c0002992:	e8 d4 fa ff ff       	call   c000246b <pop_free_page>
c0002997:	83 ec 04             	sub    $0x4,%esp
c000299a:	ff 75 0c             	pushl  0xc(%ebp)
c000299d:	50                   	push   %eax
c000299e:	ff 75 08             	pushl  0x8(%ebp)
c00029a1:	e8 56 ff ff ff       	call   c00028fc <map_page_at>
c00029a6:	83 c4 10             	add    $0x10,%esp
}
c00029a9:	c9                   	leave  
c00029aa:	c3                   	ret    

c00029ab <new_page_table>:


page_table_t* new_page_table(void* addr, uint32_t flags)
{
c00029ab:	55                   	push   %ebp
c00029ac:	89 e5                	mov    %esp,%ebp
c00029ae:	83 ec 18             	sub    $0x18,%esp
    uint32_t pdindex = get_pdindex(addr);      // index into page dir (which table does this address point to)
c00029b1:	ff 75 08             	pushl  0x8(%ebp)
c00029b4:	e8 63 fa ff ff       	call   c000241c <get_pdindex>
c00029b9:	83 c4 04             	add    $0x4,%esp
c00029bc:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // is this table already mapped?
    if(pd->dir.pde[pdindex] & PAGE_FLAG_PRESENT)
c00029bf:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c00029c4:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00029c7:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c00029cd:	8b 04 90             	mov    (%eax,%edx,4),%eax
c00029d0:	83 e0 01             	and    $0x1,%eax
c00029d3:	85 c0                	test   %eax,%eax
c00029d5:	74 07                	je     c00029de <new_page_table+0x33>
        return NULL;
c00029d7:	b8 00 00 00 00       	mov    $0x0,%eax
c00029dc:	eb 70                	jmp    c0002a4e <new_page_table+0xa3>

    page_t* pp = pop_free_page();         // find a free page in physical mem for page table
c00029de:	e8 88 fa ff ff       	call   c000246b <pop_free_page>
c00029e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!pp) return NULL; // OOM
c00029e6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00029ea:	75 07                	jne    c00029f3 <new_page_table+0x48>
c00029ec:	b8 00 00 00 00       	mov    $0x0,%eax
c00029f1:	eb 5b                	jmp    c0002a4e <new_page_table+0xa3>

    // we don't need to allocate virtual memory space, since table lives in our paging structure
    page_table_t* pv = pd->tables + pdindex;        // pointer to table (virtual)
c00029f3:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c00029f8:	89 c2                	mov    %eax,%edx
c00029fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00029fd:	c1 e0 0c             	shl    $0xc,%eax
c0002a00:	01 d0                	add    %edx,%eax
c0002a02:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // map table: point the pd entry at the physical page we just reserved, and set flags
    pd->dir.pde[pdindex] = (((uint32_t) pp) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0002a05:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002a08:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002a0d:	0b 45 0c             	or     0xc(%ebp),%eax
c0002a10:	89 c2                	mov    %eax,%edx
c0002a12:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c0002a17:	89 d1                	mov    %edx,%ecx
c0002a19:	83 c9 01             	or     $0x1,%ecx
c0002a1c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002a1f:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c0002a25:	89 0c 90             	mov    %ecx,(%eax,%edx,4)

    // flush the tlb
    refresh_page(pv);
c0002a28:	83 ec 0c             	sub    $0xc,%esp
c0002a2b:	ff 75 ec             	pushl  -0x14(%ebp)
c0002a2e:	e8 25 09 00 00       	call   c0003358 <refresh_page>
c0002a33:	83 c4 10             	add    $0x10,%esp

    //clear table
    memset((char*) pv, 0, PAGE_SIZE);     
c0002a36:	83 ec 04             	sub    $0x4,%esp
c0002a39:	68 00 10 00 00       	push   $0x1000
c0002a3e:	6a 00                	push   $0x0
c0002a40:	ff 75 ec             	pushl  -0x14(%ebp)
c0002a43:	e8 e9 00 00 00       	call   c0002b31 <memset>
c0002a48:	83 c4 10             	add    $0x10,%esp

    // return pointer to table (virtual)
    return pv;
c0002a4b:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c0002a4e:	c9                   	leave  
c0002a4f:	c3                   	ret    

c0002a50 <kmalloc_aligned>:

void* kmalloc_aligned(size_t sz, size_t alignment)
{
c0002a50:	55                   	push   %ebp
c0002a51:	89 e5                	mov    %esp,%ebp
c0002a53:	83 ec 28             	sub    $0x28,%esp
    if( sz == 0 || !is_pow_of_two(alignment) ) return NULL;
c0002a56:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002a5a:	74 0f                	je     c0002a6b <kmalloc_aligned+0x1b>
c0002a5c:	ff 75 0c             	pushl  0xc(%ebp)
c0002a5f:	e8 e3 f9 ff ff       	call   c0002447 <is_pow_of_two>
c0002a64:	83 c4 04             	add    $0x4,%esp
c0002a67:	85 c0                	test   %eax,%eax
c0002a69:	75 0a                	jne    c0002a75 <kmalloc_aligned+0x25>
c0002a6b:	b8 00 00 00 00       	mov    $0x0,%eax
c0002a70:	e9 a2 00 00 00       	jmp    c0002b17 <kmalloc_aligned+0xc7>

    char* mem = align_addr(heap, alignment); //start of allocated region
c0002a75:	a1 88 08 01 c0       	mov    0xc0010888,%eax
c0002a7a:	ff 75 0c             	pushl  0xc(%ebp)
c0002a7d:	50                   	push   %eax
c0002a7e:	e8 a4 f9 ff ff       	call   c0002427 <align_addr>
c0002a83:	83 c4 08             	add    $0x8,%esp
c0002a86:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char* mem_end = align_addr(mem+sz, alignment); //first byte past end of allocated region
c0002a89:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002a8c:	8b 45 08             	mov    0x8(%ebp),%eax
c0002a8f:	01 d0                	add    %edx,%eax
c0002a91:	ff 75 0c             	pushl  0xc(%ebp)
c0002a94:	50                   	push   %eax
c0002a95:	e8 8d f9 ff ff       	call   c0002427 <align_addr>
c0002a9a:	83 c4 08             	add    $0x8,%esp
c0002a9d:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if(mem_end > heap_end)
c0002aa0:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
c0002aa5:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0002aa8:	76 07                	jbe    c0002ab1 <kmalloc_aligned+0x61>
    {
        // out of memory!
        return NULL;
c0002aaa:	b8 00 00 00 00       	mov    $0x0,%eax
c0002aaf:	eb 66                	jmp    c0002b17 <kmalloc_aligned+0xc7>
    }

    //map new pages
    page_t* page_end = (page_t*) (((uint32_t) mem_end - 1) & PAGE_ADDRMASK);
c0002ab1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002ab4:	83 e8 01             	sub    $0x1,%eax
c0002ab7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002abc:	89 45 ec             	mov    %eax,-0x14(%ebp)
    while(page_end > heap_page)
c0002abf:	eb 41                	jmp    c0002b02 <kmalloc_aligned+0xb2>
    {
        page_t* pp = pop_free_page();    // find a free page in physical mem
c0002ac1:	e8 a5 f9 ff ff       	call   c000246b <pop_free_page>
c0002ac6:	89 45 e8             	mov    %eax,-0x18(%ebp)
        page_t* pv = get_next_heap_page();         // find a free page in virtual mem
c0002ac9:	e8 96 00 00 00       	call   c0002b64 <get_next_heap_page>
c0002ace:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        if(!pp || !pv)
c0002ad1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0002ad5:	74 06                	je     c0002add <kmalloc_aligned+0x8d>
c0002ad7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0002adb:	75 07                	jne    c0002ae4 <kmalloc_aligned+0x94>
            return NULL; //OOM
c0002add:	b8 00 00 00 00       	mov    $0x0,%eax
c0002ae2:	eb 33                	jmp    c0002b17 <kmalloc_aligned+0xc7>

        if(!map_page_at(pv, pp, PAGE_FLAG_WRITE))
c0002ae4:	83 ec 04             	sub    $0x4,%esp
c0002ae7:	6a 02                	push   $0x2
c0002ae9:	ff 75 e8             	pushl  -0x18(%ebp)
c0002aec:	ff 75 e4             	pushl  -0x1c(%ebp)
c0002aef:	e8 08 fe ff ff       	call   c00028fc <map_page_at>
c0002af4:	83 c4 10             	add    $0x10,%esp
c0002af7:	85 c0                	test   %eax,%eax
c0002af9:	75 07                	jne    c0002b02 <kmalloc_aligned+0xb2>
            return NULL;
c0002afb:	b8 00 00 00 00       	mov    $0x0,%eax
c0002b00:	eb 15                	jmp    c0002b17 <kmalloc_aligned+0xc7>
    while(page_end > heap_page)
c0002b02:	a1 84 08 01 c0       	mov    0xc0010884,%eax
c0002b07:	39 45 ec             	cmp    %eax,-0x14(%ebp)
c0002b0a:	77 b5                	ja     c0002ac1 <kmalloc_aligned+0x71>
    }

    heap = mem_end;     //update pointer to end of used heap
c0002b0c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002b0f:	a3 88 08 01 c0       	mov    %eax,0xc0010888
    return (void*) mem;
c0002b14:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0002b17:	c9                   	leave  
c0002b18:	c3                   	ret    

c0002b19 <kmalloc>:


void* kmalloc(size_t sz)
{
c0002b19:	55                   	push   %ebp
c0002b1a:	89 e5                	mov    %esp,%ebp
c0002b1c:	83 ec 08             	sub    $0x8,%esp
    return kmalloc_aligned(sz, 4);
c0002b1f:	83 ec 08             	sub    $0x8,%esp
c0002b22:	6a 04                	push   $0x4
c0002b24:	ff 75 08             	pushl  0x8(%ebp)
c0002b27:	e8 24 ff ff ff       	call   c0002a50 <kmalloc_aligned>
c0002b2c:	83 c4 10             	add    $0x10,%esp
}
c0002b2f:	c9                   	leave  
c0002b30:	c3                   	ret    

c0002b31 <memset>:

void* memset(void* addr, int val, size_t cnt)
{
c0002b31:	55                   	push   %ebp
c0002b32:	89 e5                	mov    %esp,%ebp
c0002b34:	83 ec 10             	sub    $0x10,%esp
    char* m = (char*) addr;
c0002b37:	8b 45 08             	mov    0x8(%ebp),%eax
c0002b3a:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for(size_t nn=0;nn<cnt; nn++)
c0002b3d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0002b44:	eb 11                	jmp    c0002b57 <memset+0x26>
        m[nn] = val;
c0002b46:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0002b49:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002b4c:	01 d0                	add    %edx,%eax
c0002b4e:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002b51:	88 10                	mov    %dl,(%eax)
    for(size_t nn=0;nn<cnt; nn++)
c0002b53:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0002b57:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002b5a:	3b 45 10             	cmp    0x10(%ebp),%eax
c0002b5d:	72 e7                	jb     c0002b46 <memset+0x15>

    return addr;
c0002b5f:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0002b62:	c9                   	leave  
c0002b63:	c3                   	ret    

c0002b64 <get_next_heap_page>:

// returns next available virtual page from the heap and updates the heap_page_phys pointer
// this does *not* update the heap pointer
// returns NULL on OOM
page_t* get_next_heap_page()
{
c0002b64:	55                   	push   %ebp
c0002b65:	89 e5                	mov    %esp,%ebp
    if( (uint32_t) (heap_page+1) > (uint32_t) heap_end)
c0002b67:	a1 84 08 01 c0       	mov    0xc0010884,%eax
c0002b6c:	05 00 10 00 00       	add    $0x1000,%eax
c0002b71:	89 c2                	mov    %eax,%edx
c0002b73:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
c0002b78:	39 c2                	cmp    %eax,%edx
c0002b7a:	76 07                	jbe    c0002b83 <get_next_heap_page+0x1f>
    {
        //out of memory
        return NULL;
c0002b7c:	b8 00 00 00 00       	mov    $0x0,%eax
c0002b81:	eb 14                	jmp    c0002b97 <get_next_heap_page+0x33>
    }
    return ++heap_page;
c0002b83:	a1 84 08 01 c0       	mov    0xc0010884,%eax
c0002b88:	05 00 10 00 00       	add    $0x1000,%eax
c0002b8d:	a3 84 08 01 c0       	mov    %eax,0xc0010884
c0002b92:	a1 84 08 01 c0       	mov    0xc0010884,%eax
}
c0002b97:	5d                   	pop    %ebp
c0002b98:	c3                   	ret    

c0002b99 <scancode_to_ascii>:
    0,  /* F12 Key */
    0,  /* All other keys are undefined */
};

char scancode_to_ascii(uint8_t scancode)
{
c0002b99:	55                   	push   %ebp
c0002b9a:	89 e5                	mov    %esp,%ebp
c0002b9c:	83 ec 04             	sub    $0x4,%esp
c0002b9f:	8b 45 08             	mov    0x8(%ebp),%eax
c0002ba2:	88 45 fc             	mov    %al,-0x4(%ebp)
    return kbd_US[scancode];
c0002ba5:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0002ba9:	0f b6 80 20 50 00 c0 	movzbl -0x3fffafe0(%eax),%eax
}
c0002bb0:	c9                   	leave  
c0002bb1:	c3                   	ret    

c0002bb2 <test_multitasking2>:
#if defined(__linux__)  || !defined(__i386__)
#error "This kernel requires ix86-elf cross compiler"
#endif

int32_t test_multitasking2()
{
c0002bb2:	55                   	push   %ebp
c0002bb3:	89 e5                	mov    %esp,%ebp
c0002bb5:	83 ec 18             	sub    $0x18,%esp
	int nn;
	for(nn=0;nn<5;nn++)
c0002bb8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0002bbf:	eb 22                	jmp    c0002be3 <test_multitasking2+0x31>
	{
		kprintf("task 2, count %d, [%d active tasks]\n", nn, num_tasks());
c0002bc1:	e8 f8 f6 ff ff       	call   c00022be <num_tasks>
c0002bc6:	83 ec 04             	sub    $0x4,%esp
c0002bc9:	50                   	push   %eax
c0002bca:	ff 75 f4             	pushl  -0xc(%ebp)
c0002bcd:	68 50 47 00 c0       	push   $0xc0004750
c0002bd2:	e8 a8 d8 ff ff       	call   c000047f <kprintf>
c0002bd7:	83 c4 10             	add    $0x10,%esp
		yield();
c0002bda:	e8 0d f6 ff ff       	call   c00021ec <yield>
	for(nn=0;nn<5;nn++)
c0002bdf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0002be3:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
c0002be7:	7e d8                	jle    c0002bc1 <test_multitasking2+0xf>
	}
	return nn;
c0002be9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0002bec:	c9                   	leave  
c0002bed:	c3                   	ret    

c0002bee <test_multitasking1>:

void test_multitasking1()
{
c0002bee:	55                   	push   %ebp
c0002bef:	89 e5                	mov    %esp,%ebp
c0002bf1:	83 ec 18             	sub    $0x18,%esp
	task_control_block_t* task2 = new_kernel_task( &test_multitasking2 );
c0002bf4:	83 ec 0c             	sub    $0xc,%esp
c0002bf7:	68 b2 2b 00 c0       	push   $0xc0002bb2
c0002bfc:	e8 a7 f4 ff ff       	call   c00020a8 <new_kernel_task>
c0002c01:	83 c4 10             	add    $0x10,%esp
c0002c04:	89 45 f0             	mov    %eax,-0x10(%ebp)

	int nn;
	for(nn=0;nn<10;nn++)
c0002c07:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0002c0e:	eb 22                	jmp    c0002c32 <test_multitasking1+0x44>
	{
		kprintf("task 1, count %d  [%d active tasks]\n", nn, num_tasks());
c0002c10:	e8 a9 f6 ff ff       	call   c00022be <num_tasks>
c0002c15:	83 ec 04             	sub    $0x4,%esp
c0002c18:	50                   	push   %eax
c0002c19:	ff 75 f4             	pushl  -0xc(%ebp)
c0002c1c:	68 78 47 00 c0       	push   $0xc0004778
c0002c21:	e8 59 d8 ff ff       	call   c000047f <kprintf>
c0002c26:	83 c4 10             	add    $0x10,%esp
		yield();
c0002c29:	e8 be f5 ff ff       	call   c00021ec <yield>
	for(nn=0;nn<10;nn++)
c0002c2e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0002c32:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c0002c36:	7e d8                	jle    c0002c10 <test_multitasking1+0x22>
	}	

	kprintf("Waiting for task 2...\n");	
c0002c38:	83 ec 0c             	sub    $0xc,%esp
c0002c3b:	68 9d 47 00 c0       	push   $0xc000479d
c0002c40:	e8 3a d8 ff ff       	call   c000047f <kprintf>
c0002c45:	83 c4 10             	add    $0x10,%esp
	join(task2);
c0002c48:	83 ec 0c             	sub    $0xc,%esp
c0002c4b:	ff 75 f0             	pushl  -0x10(%ebp)
c0002c4e:	e8 d1 f5 ff ff       	call   c0002224 <join>
c0002c53:	83 c4 10             	add    $0x10,%esp
	kprintf("Task 2 complete, ran %dx\n", task2->return_val);
c0002c56:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002c59:	8b 40 1c             	mov    0x1c(%eax),%eax
c0002c5c:	83 ec 08             	sub    $0x8,%esp
c0002c5f:	50                   	push   %eax
c0002c60:	68 b4 47 00 c0       	push   $0xc00047b4
c0002c65:	e8 15 d8 ff ff       	call   c000047f <kprintf>
c0002c6a:	83 c4 10             	add    $0x10,%esp
}
c0002c6d:	90                   	nop
c0002c6e:	c9                   	leave  
c0002c6f:	c3                   	ret    

c0002c70 <kernel_main>:

void kernel_main(multiboot_info_t* mbd)
{
c0002c70:	55                   	push   %ebp
c0002c71:	89 e5                	mov    %esp,%ebp
c0002c73:	83 ec 08             	sub    $0x8,%esp
	init_gdt();
c0002c76:	e8 2e 01 00 00       	call   c0002da9 <init_gdt>
	init_interrupts();
c0002c7b:	e8 f4 ee ff ff       	call   c0001b74 <init_interrupts>

	terminal_init(&stdout);
c0002c80:	83 ec 0c             	sub    $0xc,%esp
c0002c83:	68 00 00 01 c0       	push   $0xc0010000
c0002c88:	e8 cb d3 ff ff       	call   c0000058 <terminal_init>
c0002c8d:	83 c4 10             	add    $0x10,%esp

    // terminal_setcolor(&stdout, VGA_COLOR_WHITE);
	kprintf("Let's learn about Operating Systems!\n");
c0002c90:	83 ec 0c             	sub    $0xc,%esp
c0002c93:	68 d0 47 00 c0       	push   $0xc00047d0
c0002c98:	e8 e2 d7 ff ff       	call   c000047f <kprintf>
c0002c9d:	83 c4 10             	add    $0x10,%esp
	kprintf("Jon Doane, 2020\n\n");
c0002ca0:	83 ec 0c             	sub    $0xc,%esp
c0002ca3:	68 f6 47 00 c0       	push   $0xc00047f6
c0002ca8:	e8 d2 d7 ff ff       	call   c000047f <kprintf>
c0002cad:	83 c4 10             	add    $0x10,%esp

	print_memory_table(mbd);
c0002cb0:	83 ec 0c             	sub    $0xc,%esp
c0002cb3:	ff 75 08             	pushl  0x8(%ebp)
c0002cb6:	e8 8a ec ff ff       	call   c0001945 <print_memory_table>
c0002cbb:	83 c4 10             	add    $0x10,%esp
	memory_init(mbd);	//after this the multiboot structure is unmapped
c0002cbe:	83 ec 0c             	sub    $0xc,%esp
c0002cc1:	ff 75 08             	pushl  0x8(%ebp)
c0002cc4:	e8 5f fa ff ff       	call   c0002728 <memory_init>
c0002cc9:	83 c4 10             	add    $0x10,%esp
	initialize_multitasking();
c0002ccc:	e8 88 f3 ff ff       	call   c0002059 <initialize_multitasking>
    // reg_t regs;
    // getregs(&regs);
	// printregs(&regs);


	test_multitasking1();
c0002cd1:	e8 18 ff ff ff       	call   c0002bee <test_multitasking1>

	while(1);
c0002cd6:	eb fe                	jmp    c0002cd6 <kernel_main+0x66>

c0002cd8 <populate_gdt_entry>:
   uint16_t iomap_base;
} tss_entry_t;


static inline void populate_gdt_entry(gdt_entry_t* sd, uint32_t base, uint32_t limit, uint8_t access, uint8_t flags)
{
c0002cd8:	55                   	push   %ebp
c0002cd9:	89 e5                	mov    %esp,%ebp
c0002cdb:	53                   	push   %ebx
c0002cdc:	83 ec 08             	sub    $0x8,%esp
c0002cdf:	8b 55 14             	mov    0x14(%ebp),%edx
c0002ce2:	8b 45 18             	mov    0x18(%ebp),%eax
c0002ce5:	88 55 f8             	mov    %dl,-0x8(%ebp)
c0002ce8:	88 45 f4             	mov    %al,-0xc(%ebp)
    sd->limit_low = limit & SEGMENT_LIMIT_LOW_MASK;
c0002ceb:	8b 45 10             	mov    0x10(%ebp),%eax
c0002cee:	89 c2                	mov    %eax,%edx
c0002cf0:	8b 45 08             	mov    0x8(%ebp),%eax
c0002cf3:	0f b7 ca             	movzwl %dx,%ecx
c0002cf6:	0f b6 d9             	movzbl %cl,%ebx
c0002cf9:	0f b6 08             	movzbl (%eax),%ecx
c0002cfc:	83 e1 00             	and    $0x0,%ecx
c0002cff:	09 d9                	or     %ebx,%ecx
c0002d01:	88 08                	mov    %cl,(%eax)
c0002d03:	66 c1 ea 08          	shr    $0x8,%dx
c0002d07:	0f b7 ca             	movzwl %dx,%ecx
c0002d0a:	0f b6 50 01          	movzbl 0x1(%eax),%edx
c0002d0e:	83 e2 00             	and    $0x0,%edx
c0002d11:	09 ca                	or     %ecx,%edx
c0002d13:	88 50 01             	mov    %dl,0x1(%eax)
    sd->limit_high = (limit & SEGMENT_LIMIT_HIGH_MASK) >> 16;
c0002d16:	8b 45 10             	mov    0x10(%ebp),%eax
c0002d19:	c1 e8 10             	shr    $0x10,%eax
c0002d1c:	83 e0 0f             	and    $0xf,%eax
c0002d1f:	8b 55 08             	mov    0x8(%ebp),%edx
c0002d22:	83 e0 0f             	and    $0xf,%eax
c0002d25:	89 c1                	mov    %eax,%ecx
c0002d27:	0f b6 42 06          	movzbl 0x6(%edx),%eax
c0002d2b:	83 e0 f0             	and    $0xfffffff0,%eax
c0002d2e:	09 c8                	or     %ecx,%eax
c0002d30:	88 42 06             	mov    %al,0x6(%edx)
    sd->base_low = base & SEGMENT_BASE_LOW_MASK;
c0002d33:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002d36:	89 c2                	mov    %eax,%edx
c0002d38:	8b 45 08             	mov    0x8(%ebp),%eax
c0002d3b:	0f b7 ca             	movzwl %dx,%ecx
c0002d3e:	0f b6 d9             	movzbl %cl,%ebx
c0002d41:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
c0002d45:	83 e1 00             	and    $0x0,%ecx
c0002d48:	09 d9                	or     %ebx,%ecx
c0002d4a:	88 48 02             	mov    %cl,0x2(%eax)
c0002d4d:	66 c1 ea 08          	shr    $0x8,%dx
c0002d51:	0f b7 ca             	movzwl %dx,%ecx
c0002d54:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c0002d58:	83 e2 00             	and    $0x0,%edx
c0002d5b:	09 ca                	or     %ecx,%edx
c0002d5d:	88 50 03             	mov    %dl,0x3(%eax)
    sd->base_mid = (base & SEGMENT_BASE_MID_MASK) >> 16;
c0002d60:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002d63:	c1 e8 10             	shr    $0x10,%eax
c0002d66:	89 c2                	mov    %eax,%edx
c0002d68:	8b 45 08             	mov    0x8(%ebp),%eax
c0002d6b:	88 50 04             	mov    %dl,0x4(%eax)
    sd->base_high = (base & SEGMENT_BASE_HIGH_MASK) >> 24;
c0002d6e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002d71:	c1 e8 18             	shr    $0x18,%eax
c0002d74:	89 c2                	mov    %eax,%edx
c0002d76:	8b 45 08             	mov    0x8(%ebp),%eax
c0002d79:	88 50 07             	mov    %dl,0x7(%eax)
    sd->access = access;
c0002d7c:	8b 45 08             	mov    0x8(%ebp),%eax
c0002d7f:	0f b6 55 f8          	movzbl -0x8(%ebp),%edx
c0002d83:	88 50 05             	mov    %dl,0x5(%eax)
    sd->flags = flags;
c0002d86:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0002d8a:	83 e0 0f             	and    $0xf,%eax
c0002d8d:	89 c2                	mov    %eax,%edx
c0002d8f:	8b 45 08             	mov    0x8(%ebp),%eax
c0002d92:	89 d1                	mov    %edx,%ecx
c0002d94:	c1 e1 04             	shl    $0x4,%ecx
c0002d97:	0f b6 50 06          	movzbl 0x6(%eax),%edx
c0002d9b:	83 e2 0f             	and    $0xf,%edx
c0002d9e:	09 ca                	or     %ecx,%edx
c0002da0:	88 50 06             	mov    %dl,0x6(%eax)
}
c0002da3:	90                   	nop
c0002da4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0002da7:	c9                   	leave  
c0002da8:	c3                   	ret    

c0002da9 <init_gdt>:
gdt_description_t __aligned  gdtd;

tss_entry_t tss = {0};

void init_gdt()
{
c0002da9:	55                   	push   %ebp
c0002daa:	89 e5                	mov    %esp,%ebp
c0002dac:	83 ec 08             	sub    $0x8,%esp
    // gdt[0] unused
    populate_gdt_entry(&gdt[1], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(0) | SEG_DESCTYPE(1) | SEG_CODE_EXRD, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // priv code, seg 0x008
c0002daf:	6a 0c                	push   $0xc
c0002db1:	68 9a 00 00 00       	push   $0x9a
c0002db6:	6a ff                	push   $0xffffffff
c0002db8:	6a 00                	push   $0x0
c0002dba:	68 a8 08 01 c0       	push   $0xc00108a8
c0002dbf:	e8 14 ff ff ff       	call   c0002cd8 <populate_gdt_entry>
c0002dc4:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[2], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(0) | SEG_DESCTYPE(1) | SEG_DATA_RDWR, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // priv data, seg 0x010
c0002dc7:	6a 0c                	push   $0xc
c0002dc9:	68 92 00 00 00       	push   $0x92
c0002dce:	6a ff                	push   $0xffffffff
c0002dd0:	6a 00                	push   $0x0
c0002dd2:	68 b0 08 01 c0       	push   $0xc00108b0
c0002dd7:	e8 fc fe ff ff       	call   c0002cd8 <populate_gdt_entry>
c0002ddc:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[3], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(3) | SEG_DESCTYPE(1) | SEG_CODE_EXRD, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // user code, seg 0x018
c0002ddf:	6a 0c                	push   $0xc
c0002de1:	68 fa 00 00 00       	push   $0xfa
c0002de6:	6a ff                	push   $0xffffffff
c0002de8:	6a 00                	push   $0x0
c0002dea:	68 b8 08 01 c0       	push   $0xc00108b8
c0002def:	e8 e4 fe ff ff       	call   c0002cd8 <populate_gdt_entry>
c0002df4:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[4], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(3) | SEG_DESCTYPE(1) | SEG_DATA_RDWR, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // user data  seg 0x020
c0002df7:	6a 0c                	push   $0xc
c0002df9:	68 f2 00 00 00       	push   $0xf2
c0002dfe:	6a ff                	push   $0xffffffff
c0002e00:	6a 00                	push   $0x0
c0002e02:	68 c0 08 01 c0       	push   $0xc00108c0
c0002e07:	e8 cc fe ff ff       	call   c0002cd8 <populate_gdt_entry>
c0002e0c:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[5], (uint32_t) &tss, sizeof(tss_entry_t), SEG_TSS, SEG_FLAG_TSS); // tss, seg 0x028
c0002e0f:	b8 00 09 01 c0       	mov    $0xc0010900,%eax
c0002e14:	6a 04                	push   $0x4
c0002e16:	68 89 00 00 00       	push   $0x89
c0002e1b:	6a 68                	push   $0x68
c0002e1d:	50                   	push   %eax
c0002e1e:	68 c8 08 01 c0       	push   $0xc00108c8
c0002e23:	e8 b0 fe ff ff       	call   c0002cd8 <populate_gdt_entry>
c0002e28:	83 c4 14             	add    $0x14,%esp

    //tss.esp0 = XXXXX
    tss.ss0 = KERNEL_DATA_SEGMENT; //kernel data segment    
c0002e2b:	c7 05 08 09 01 c0 10 	movl   $0x10,0xc0010908
c0002e32:	00 00 00 
    tss.iomap_base = sizeof(tss_entry_t);
c0002e35:	66 c7 05 66 09 01 c0 	movw   $0x68,0xc0010966
c0002e3c:	68 00 
    // before we can actually switch tasks, we must first set the kernel stack pointer, with update_tss()

    gdtd.addr = (uint32_t) gdt;
c0002e3e:	b8 a0 08 01 c0       	mov    $0xc00108a0,%eax
c0002e43:	a3 e2 08 01 c0       	mov    %eax,0xc00108e2
    gdtd.size = sizeof(gdt);    
c0002e48:	66 c7 05 e0 08 01 c0 	movw   $0x30,0xc00108e0
c0002e4f:	30 00 
    load_gdt(&gdtd);
c0002e51:	83 ec 0c             	sub    $0xc,%esp
c0002e54:	68 e0 08 01 c0       	push   $0xc00108e0
c0002e59:	e8 1e 00 00 00       	call   c0002e7c <load_gdt>
c0002e5e:	83 c4 10             	add    $0x10,%esp
}
c0002e61:	90                   	nop
c0002e62:	c9                   	leave  
c0002e63:	c3                   	ret    

c0002e64 <update_kstack>:

void update_kstack(void* kernel_stack_ptr)
{
c0002e64:	55                   	push   %ebp
c0002e65:	89 e5                	mov    %esp,%ebp
c0002e67:	83 ec 08             	sub    $0x8,%esp
    tss.esp0 = (uint32_t) kernel_stack_ptr; //kernel stack ptr
c0002e6a:	8b 45 08             	mov    0x8(%ebp),%eax
c0002e6d:	a3 04 09 01 c0       	mov    %eax,0xc0010904
    load_tss();
c0002e72:	e8 25 00 00 00       	call   c0002e9c <load_tss>
}
c0002e77:	90                   	nop
c0002e78:	c9                   	leave  
c0002e79:	c3                   	ret    
c0002e7a:	66 90                	xchg   %ax,%ax

c0002e7c <load_gdt>:
c0002e7c:	0f 01 15 e0 08 01 c0 	lgdtl  0xc00108e0
c0002e83:	ea 8a 2e 00 c0 08 00 	ljmp   $0x8,$0xc0002e8a

c0002e8a <complete_flush>:
c0002e8a:	66 b8 10 00          	mov    $0x10,%ax
c0002e8e:	8e d8                	mov    %eax,%ds
c0002e90:	8e c0                	mov    %eax,%es
c0002e92:	8e e0                	mov    %eax,%fs
c0002e94:	8e e8                	mov    %eax,%gs
c0002e96:	8e d0                	mov    %eax,%ss
c0002e98:	c3                   	ret    
c0002e99:	8d 76 00             	lea    0x0(%esi),%esi

c0002e9c <load_tss>:
c0002e9c:	66 b8 28 00          	mov    $0x28,%ax
c0002ea0:	66 83 c8 03          	or     $0x3,%ax
c0002ea4:	0f 00 d8             	ltr    %ax
c0002ea7:	c3                   	ret    

c0002ea8 <getregs>:
c0002ea8:	55                   	push   %ebp
c0002ea9:	89 e5                	mov    %esp,%ebp
c0002eab:	53                   	push   %ebx
c0002eac:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0002eaf:	89 03                	mov    %eax,(%ebx)
c0002eb1:	8b 04 24             	mov    (%esp),%eax
c0002eb4:	89 43 04             	mov    %eax,0x4(%ebx)
c0002eb7:	89 4b 08             	mov    %ecx,0x8(%ebx)
c0002eba:	89 53 0c             	mov    %edx,0xc(%ebx)
c0002ebd:	89 73 10             	mov    %esi,0x10(%ebx)
c0002ec0:	89 7b 14             	mov    %edi,0x14(%ebx)
c0002ec3:	89 e8                	mov    %ebp,%eax
c0002ec5:	83 c0 0c             	add    $0xc,%eax
c0002ec8:	89 43 18             	mov    %eax,0x18(%ebx)
c0002ecb:	8b 45 00             	mov    0x0(%ebp),%eax
c0002ece:	89 43 1c             	mov    %eax,0x1c(%ebx)
c0002ed1:	8b 45 04             	mov    0x4(%ebp),%eax
c0002ed4:	89 43 20             	mov    %eax,0x20(%ebx)
c0002ed7:	b8 00 00 00 00       	mov    $0x0,%eax
c0002edc:	9f                   	lahf   
c0002edd:	89 43 24             	mov    %eax,0x24(%ebx)
c0002ee0:	0f 20 c0             	mov    %cr0,%eax
c0002ee3:	89 43 28             	mov    %eax,0x28(%ebx)
c0002ee6:	0f 20 d0             	mov    %cr2,%eax
c0002ee9:	89 43 2c             	mov    %eax,0x2c(%ebx)
c0002eec:	0f 20 d8             	mov    %cr3,%eax
c0002eef:	89 43 30             	mov    %eax,0x30(%ebx)
c0002ef2:	0f 20 e0             	mov    %cr4,%eax
c0002ef5:	89 43 34             	mov    %eax,0x34(%ebx)
c0002ef8:	5b                   	pop    %ebx
c0002ef9:	5d                   	pop    %ebp
c0002efa:	c3                   	ret    
c0002efb:	90                   	nop

c0002efc <load_idt>:
c0002efc:	0f 01 1d 20 08 01 c0 	lidtl  0xc0010820
c0002f03:	fb                   	sti    
c0002f04:	c3                   	ret    
c0002f05:	8d 76 00             	lea    0x0(%esi),%esi

c0002f08 <pf_addr>:
c0002f08:	0f 20 d0             	mov    %cr2,%eax
c0002f0b:	c3                   	ret    

c0002f0c <except_0>:
c0002f0c:	55                   	push   %ebp
c0002f0d:	89 e5                	mov    %esp,%ebp
c0002f0f:	60                   	pusha  
c0002f10:	8b 45 04             	mov    0x4(%ebp),%eax
c0002f13:	50                   	push   %eax
c0002f14:	b8 00 00 00 00       	mov    $0x0,%eax
c0002f19:	50                   	push   %eax
c0002f1a:	b8 00 00 00 00       	mov    $0x0,%eax
c0002f1f:	50                   	push   %eax
c0002f20:	e8 91 f0 ff ff       	call   c0001fb6 <exception_handler>
c0002f25:	83 c4 0c             	add    $0xc,%esp
c0002f28:	61                   	popa   
c0002f29:	5d                   	pop    %ebp
c0002f2a:	cf                   	iret   
c0002f2b:	90                   	nop

c0002f2c <except_1>:
c0002f2c:	55                   	push   %ebp
c0002f2d:	89 e5                	mov    %esp,%ebp
c0002f2f:	60                   	pusha  
c0002f30:	8b 45 04             	mov    0x4(%ebp),%eax
c0002f33:	50                   	push   %eax
c0002f34:	b8 00 00 00 00       	mov    $0x0,%eax
c0002f39:	50                   	push   %eax
c0002f3a:	b8 01 00 00 00       	mov    $0x1,%eax
c0002f3f:	50                   	push   %eax
c0002f40:	e8 71 f0 ff ff       	call   c0001fb6 <exception_handler>
c0002f45:	83 c4 0c             	add    $0xc,%esp
c0002f48:	61                   	popa   
c0002f49:	5d                   	pop    %ebp
c0002f4a:	cf                   	iret   
c0002f4b:	90                   	nop

c0002f4c <except_2>:
c0002f4c:	55                   	push   %ebp
c0002f4d:	89 e5                	mov    %esp,%ebp
c0002f4f:	60                   	pusha  
c0002f50:	8b 45 04             	mov    0x4(%ebp),%eax
c0002f53:	50                   	push   %eax
c0002f54:	b8 00 00 00 00       	mov    $0x0,%eax
c0002f59:	50                   	push   %eax
c0002f5a:	b8 02 00 00 00       	mov    $0x2,%eax
c0002f5f:	50                   	push   %eax
c0002f60:	e8 51 f0 ff ff       	call   c0001fb6 <exception_handler>
c0002f65:	83 c4 0c             	add    $0xc,%esp
c0002f68:	61                   	popa   
c0002f69:	5d                   	pop    %ebp
c0002f6a:	cf                   	iret   
c0002f6b:	90                   	nop

c0002f6c <except_3>:
c0002f6c:	55                   	push   %ebp
c0002f6d:	89 e5                	mov    %esp,%ebp
c0002f6f:	60                   	pusha  
c0002f70:	8b 45 04             	mov    0x4(%ebp),%eax
c0002f73:	50                   	push   %eax
c0002f74:	b8 00 00 00 00       	mov    $0x0,%eax
c0002f79:	50                   	push   %eax
c0002f7a:	b8 03 00 00 00       	mov    $0x3,%eax
c0002f7f:	50                   	push   %eax
c0002f80:	e8 31 f0 ff ff       	call   c0001fb6 <exception_handler>
c0002f85:	83 c4 0c             	add    $0xc,%esp
c0002f88:	61                   	popa   
c0002f89:	5d                   	pop    %ebp
c0002f8a:	cf                   	iret   
c0002f8b:	90                   	nop

c0002f8c <except_4>:
c0002f8c:	55                   	push   %ebp
c0002f8d:	89 e5                	mov    %esp,%ebp
c0002f8f:	60                   	pusha  
c0002f90:	8b 45 04             	mov    0x4(%ebp),%eax
c0002f93:	50                   	push   %eax
c0002f94:	b8 00 00 00 00       	mov    $0x0,%eax
c0002f99:	50                   	push   %eax
c0002f9a:	b8 04 00 00 00       	mov    $0x4,%eax
c0002f9f:	50                   	push   %eax
c0002fa0:	e8 11 f0 ff ff       	call   c0001fb6 <exception_handler>
c0002fa5:	83 c4 0c             	add    $0xc,%esp
c0002fa8:	61                   	popa   
c0002fa9:	5d                   	pop    %ebp
c0002faa:	cf                   	iret   
c0002fab:	90                   	nop

c0002fac <except_5>:
c0002fac:	55                   	push   %ebp
c0002fad:	89 e5                	mov    %esp,%ebp
c0002faf:	60                   	pusha  
c0002fb0:	8b 45 04             	mov    0x4(%ebp),%eax
c0002fb3:	50                   	push   %eax
c0002fb4:	b8 00 00 00 00       	mov    $0x0,%eax
c0002fb9:	50                   	push   %eax
c0002fba:	b8 05 00 00 00       	mov    $0x5,%eax
c0002fbf:	50                   	push   %eax
c0002fc0:	e8 f1 ef ff ff       	call   c0001fb6 <exception_handler>
c0002fc5:	83 c4 0c             	add    $0xc,%esp
c0002fc8:	61                   	popa   
c0002fc9:	5d                   	pop    %ebp
c0002fca:	cf                   	iret   
c0002fcb:	90                   	nop

c0002fcc <except_6>:
c0002fcc:	55                   	push   %ebp
c0002fcd:	89 e5                	mov    %esp,%ebp
c0002fcf:	60                   	pusha  
c0002fd0:	8b 45 04             	mov    0x4(%ebp),%eax
c0002fd3:	50                   	push   %eax
c0002fd4:	b8 00 00 00 00       	mov    $0x0,%eax
c0002fd9:	50                   	push   %eax
c0002fda:	b8 06 00 00 00       	mov    $0x6,%eax
c0002fdf:	50                   	push   %eax
c0002fe0:	e8 d1 ef ff ff       	call   c0001fb6 <exception_handler>
c0002fe5:	83 c4 0c             	add    $0xc,%esp
c0002fe8:	61                   	popa   
c0002fe9:	5d                   	pop    %ebp
c0002fea:	cf                   	iret   
c0002feb:	90                   	nop

c0002fec <except_7>:
c0002fec:	55                   	push   %ebp
c0002fed:	89 e5                	mov    %esp,%ebp
c0002fef:	60                   	pusha  
c0002ff0:	8b 45 04             	mov    0x4(%ebp),%eax
c0002ff3:	50                   	push   %eax
c0002ff4:	b8 00 00 00 00       	mov    $0x0,%eax
c0002ff9:	50                   	push   %eax
c0002ffa:	b8 07 00 00 00       	mov    $0x7,%eax
c0002fff:	50                   	push   %eax
c0003000:	e8 b1 ef ff ff       	call   c0001fb6 <exception_handler>
c0003005:	83 c4 0c             	add    $0xc,%esp
c0003008:	61                   	popa   
c0003009:	5d                   	pop    %ebp
c000300a:	cf                   	iret   
c000300b:	90                   	nop

c000300c <except_8>:
c000300c:	55                   	push   %ebp
c000300d:	89 e5                	mov    %esp,%ebp
c000300f:	60                   	pusha  
c0003010:	8b 45 08             	mov    0x8(%ebp),%eax
c0003013:	50                   	push   %eax
c0003014:	8b 45 04             	mov    0x4(%ebp),%eax
c0003017:	50                   	push   %eax
c0003018:	b8 08 00 00 00       	mov    $0x8,%eax
c000301d:	50                   	push   %eax
c000301e:	e8 93 ef ff ff       	call   c0001fb6 <exception_handler>
c0003023:	83 c4 0c             	add    $0xc,%esp
c0003026:	61                   	popa   
c0003027:	5d                   	pop    %ebp
c0003028:	83 c4 04             	add    $0x4,%esp
c000302b:	cf                   	iret   

c000302c <except_10>:
c000302c:	55                   	push   %ebp
c000302d:	89 e5                	mov    %esp,%ebp
c000302f:	60                   	pusha  
c0003030:	8b 45 08             	mov    0x8(%ebp),%eax
c0003033:	50                   	push   %eax
c0003034:	8b 45 04             	mov    0x4(%ebp),%eax
c0003037:	50                   	push   %eax
c0003038:	b8 0a 00 00 00       	mov    $0xa,%eax
c000303d:	50                   	push   %eax
c000303e:	e8 73 ef ff ff       	call   c0001fb6 <exception_handler>
c0003043:	83 c4 0c             	add    $0xc,%esp
c0003046:	61                   	popa   
c0003047:	5d                   	pop    %ebp
c0003048:	83 c4 04             	add    $0x4,%esp
c000304b:	cf                   	iret   

c000304c <except_11>:
c000304c:	55                   	push   %ebp
c000304d:	89 e5                	mov    %esp,%ebp
c000304f:	60                   	pusha  
c0003050:	8b 45 08             	mov    0x8(%ebp),%eax
c0003053:	50                   	push   %eax
c0003054:	8b 45 04             	mov    0x4(%ebp),%eax
c0003057:	50                   	push   %eax
c0003058:	b8 0b 00 00 00       	mov    $0xb,%eax
c000305d:	50                   	push   %eax
c000305e:	e8 53 ef ff ff       	call   c0001fb6 <exception_handler>
c0003063:	83 c4 0c             	add    $0xc,%esp
c0003066:	61                   	popa   
c0003067:	5d                   	pop    %ebp
c0003068:	83 c4 04             	add    $0x4,%esp
c000306b:	cf                   	iret   

c000306c <except_12>:
c000306c:	55                   	push   %ebp
c000306d:	89 e5                	mov    %esp,%ebp
c000306f:	60                   	pusha  
c0003070:	8b 45 08             	mov    0x8(%ebp),%eax
c0003073:	50                   	push   %eax
c0003074:	8b 45 04             	mov    0x4(%ebp),%eax
c0003077:	50                   	push   %eax
c0003078:	b8 0c 00 00 00       	mov    $0xc,%eax
c000307d:	50                   	push   %eax
c000307e:	e8 33 ef ff ff       	call   c0001fb6 <exception_handler>
c0003083:	83 c4 0c             	add    $0xc,%esp
c0003086:	61                   	popa   
c0003087:	5d                   	pop    %ebp
c0003088:	83 c4 04             	add    $0x4,%esp
c000308b:	cf                   	iret   

c000308c <except_13>:
c000308c:	55                   	push   %ebp
c000308d:	89 e5                	mov    %esp,%ebp
c000308f:	60                   	pusha  
c0003090:	8b 45 08             	mov    0x8(%ebp),%eax
c0003093:	50                   	push   %eax
c0003094:	8b 45 04             	mov    0x4(%ebp),%eax
c0003097:	50                   	push   %eax
c0003098:	b8 0d 00 00 00       	mov    $0xd,%eax
c000309d:	50                   	push   %eax
c000309e:	e8 13 ef ff ff       	call   c0001fb6 <exception_handler>
c00030a3:	83 c4 0c             	add    $0xc,%esp
c00030a6:	61                   	popa   
c00030a7:	5d                   	pop    %ebp
c00030a8:	83 c4 04             	add    $0x4,%esp
c00030ab:	cf                   	iret   

c00030ac <except_14>:
c00030ac:	55                   	push   %ebp
c00030ad:	89 e5                	mov    %esp,%ebp
c00030af:	60                   	pusha  
c00030b0:	8b 45 08             	mov    0x8(%ebp),%eax
c00030b3:	50                   	push   %eax
c00030b4:	8b 45 04             	mov    0x4(%ebp),%eax
c00030b7:	50                   	push   %eax
c00030b8:	b8 0e 00 00 00       	mov    $0xe,%eax
c00030bd:	50                   	push   %eax
c00030be:	e8 f3 ee ff ff       	call   c0001fb6 <exception_handler>
c00030c3:	83 c4 0c             	add    $0xc,%esp
c00030c6:	61                   	popa   
c00030c7:	5d                   	pop    %ebp
c00030c8:	83 c4 04             	add    $0x4,%esp
c00030cb:	cf                   	iret   

c00030cc <except_16>:
c00030cc:	55                   	push   %ebp
c00030cd:	89 e5                	mov    %esp,%ebp
c00030cf:	60                   	pusha  
c00030d0:	8b 45 08             	mov    0x8(%ebp),%eax
c00030d3:	50                   	push   %eax
c00030d4:	8b 45 04             	mov    0x4(%ebp),%eax
c00030d7:	50                   	push   %eax
c00030d8:	b8 10 00 00 00       	mov    $0x10,%eax
c00030dd:	50                   	push   %eax
c00030de:	e8 d3 ee ff ff       	call   c0001fb6 <exception_handler>
c00030e3:	83 c4 0c             	add    $0xc,%esp
c00030e6:	61                   	popa   
c00030e7:	5d                   	pop    %ebp
c00030e8:	83 c4 04             	add    $0x4,%esp
c00030eb:	cf                   	iret   

c00030ec <except_17>:
c00030ec:	55                   	push   %ebp
c00030ed:	89 e5                	mov    %esp,%ebp
c00030ef:	60                   	pusha  
c00030f0:	8b 45 08             	mov    0x8(%ebp),%eax
c00030f3:	50                   	push   %eax
c00030f4:	8b 45 04             	mov    0x4(%ebp),%eax
c00030f7:	50                   	push   %eax
c00030f8:	b8 11 00 00 00       	mov    $0x11,%eax
c00030fd:	50                   	push   %eax
c00030fe:	e8 b3 ee ff ff       	call   c0001fb6 <exception_handler>
c0003103:	83 c4 0c             	add    $0xc,%esp
c0003106:	61                   	popa   
c0003107:	5d                   	pop    %ebp
c0003108:	83 c4 04             	add    $0x4,%esp
c000310b:	cf                   	iret   

c000310c <except_18>:
c000310c:	55                   	push   %ebp
c000310d:	89 e5                	mov    %esp,%ebp
c000310f:	60                   	pusha  
c0003110:	8b 45 08             	mov    0x8(%ebp),%eax
c0003113:	50                   	push   %eax
c0003114:	8b 45 04             	mov    0x4(%ebp),%eax
c0003117:	50                   	push   %eax
c0003118:	b8 12 00 00 00       	mov    $0x12,%eax
c000311d:	50                   	push   %eax
c000311e:	e8 93 ee ff ff       	call   c0001fb6 <exception_handler>
c0003123:	83 c4 0c             	add    $0xc,%esp
c0003126:	61                   	popa   
c0003127:	5d                   	pop    %ebp
c0003128:	83 c4 04             	add    $0x4,%esp
c000312b:	cf                   	iret   

c000312c <except_19>:
c000312c:	55                   	push   %ebp
c000312d:	89 e5                	mov    %esp,%ebp
c000312f:	60                   	pusha  
c0003130:	8b 45 08             	mov    0x8(%ebp),%eax
c0003133:	50                   	push   %eax
c0003134:	8b 45 04             	mov    0x4(%ebp),%eax
c0003137:	50                   	push   %eax
c0003138:	b8 13 00 00 00       	mov    $0x13,%eax
c000313d:	50                   	push   %eax
c000313e:	e8 73 ee ff ff       	call   c0001fb6 <exception_handler>
c0003143:	83 c4 0c             	add    $0xc,%esp
c0003146:	61                   	popa   
c0003147:	5d                   	pop    %ebp
c0003148:	83 c4 04             	add    $0x4,%esp
c000314b:	cf                   	iret   

c000314c <except_20>:
c000314c:	55                   	push   %ebp
c000314d:	89 e5                	mov    %esp,%ebp
c000314f:	60                   	pusha  
c0003150:	8b 45 08             	mov    0x8(%ebp),%eax
c0003153:	50                   	push   %eax
c0003154:	8b 45 04             	mov    0x4(%ebp),%eax
c0003157:	50                   	push   %eax
c0003158:	b8 14 00 00 00       	mov    $0x14,%eax
c000315d:	50                   	push   %eax
c000315e:	e8 53 ee ff ff       	call   c0001fb6 <exception_handler>
c0003163:	83 c4 0c             	add    $0xc,%esp
c0003166:	61                   	popa   
c0003167:	5d                   	pop    %ebp
c0003168:	83 c4 04             	add    $0x4,%esp
c000316b:	cf                   	iret   

c000316c <except_30>:
c000316c:	55                   	push   %ebp
c000316d:	89 e5                	mov    %esp,%ebp
c000316f:	60                   	pusha  
c0003170:	8b 45 08             	mov    0x8(%ebp),%eax
c0003173:	50                   	push   %eax
c0003174:	8b 45 04             	mov    0x4(%ebp),%eax
c0003177:	50                   	push   %eax
c0003178:	b8 1e 00 00 00       	mov    $0x1e,%eax
c000317d:	50                   	push   %eax
c000317e:	e8 33 ee ff ff       	call   c0001fb6 <exception_handler>
c0003183:	83 c4 0c             	add    $0xc,%esp
c0003186:	61                   	popa   
c0003187:	5d                   	pop    %ebp
c0003188:	83 c4 04             	add    $0x4,%esp
c000318b:	cf                   	iret   

c000318c <irq_0>:
c000318c:	60                   	pusha  
c000318d:	b8 00 00 00 00       	mov    $0x0,%eax
c0003192:	50                   	push   %eax
c0003193:	e8 55 ee ff ff       	call   c0001fed <irq_handler>
c0003198:	83 c4 04             	add    $0x4,%esp
c000319b:	61                   	popa   
c000319c:	cf                   	iret   
c000319d:	8d 76 00             	lea    0x0(%esi),%esi

c00031a0 <irq_1>:
c00031a0:	60                   	pusha  
c00031a1:	b8 01 00 00 00       	mov    $0x1,%eax
c00031a6:	50                   	push   %eax
c00031a7:	e8 41 ee ff ff       	call   c0001fed <irq_handler>
c00031ac:	83 c4 04             	add    $0x4,%esp
c00031af:	61                   	popa   
c00031b0:	cf                   	iret   
c00031b1:	8d 76 00             	lea    0x0(%esi),%esi

c00031b4 <irq_2>:
c00031b4:	60                   	pusha  
c00031b5:	b8 02 00 00 00       	mov    $0x2,%eax
c00031ba:	50                   	push   %eax
c00031bb:	e8 2d ee ff ff       	call   c0001fed <irq_handler>
c00031c0:	83 c4 04             	add    $0x4,%esp
c00031c3:	61                   	popa   
c00031c4:	cf                   	iret   
c00031c5:	8d 76 00             	lea    0x0(%esi),%esi

c00031c8 <irq_3>:
c00031c8:	60                   	pusha  
c00031c9:	b8 03 00 00 00       	mov    $0x3,%eax
c00031ce:	50                   	push   %eax
c00031cf:	e8 19 ee ff ff       	call   c0001fed <irq_handler>
c00031d4:	83 c4 04             	add    $0x4,%esp
c00031d7:	61                   	popa   
c00031d8:	cf                   	iret   
c00031d9:	8d 76 00             	lea    0x0(%esi),%esi

c00031dc <irq_4>:
c00031dc:	60                   	pusha  
c00031dd:	b8 04 00 00 00       	mov    $0x4,%eax
c00031e2:	50                   	push   %eax
c00031e3:	e8 05 ee ff ff       	call   c0001fed <irq_handler>
c00031e8:	83 c4 04             	add    $0x4,%esp
c00031eb:	61                   	popa   
c00031ec:	cf                   	iret   
c00031ed:	8d 76 00             	lea    0x0(%esi),%esi

c00031f0 <irq_5>:
c00031f0:	60                   	pusha  
c00031f1:	b8 05 00 00 00       	mov    $0x5,%eax
c00031f6:	50                   	push   %eax
c00031f7:	e8 f1 ed ff ff       	call   c0001fed <irq_handler>
c00031fc:	83 c4 04             	add    $0x4,%esp
c00031ff:	61                   	popa   
c0003200:	cf                   	iret   
c0003201:	8d 76 00             	lea    0x0(%esi),%esi

c0003204 <irq_6>:
c0003204:	60                   	pusha  
c0003205:	b8 06 00 00 00       	mov    $0x6,%eax
c000320a:	50                   	push   %eax
c000320b:	e8 dd ed ff ff       	call   c0001fed <irq_handler>
c0003210:	83 c4 04             	add    $0x4,%esp
c0003213:	61                   	popa   
c0003214:	cf                   	iret   
c0003215:	8d 76 00             	lea    0x0(%esi),%esi

c0003218 <irq_7>:
c0003218:	60                   	pusha  
c0003219:	b8 07 00 00 00       	mov    $0x7,%eax
c000321e:	50                   	push   %eax
c000321f:	e8 c9 ed ff ff       	call   c0001fed <irq_handler>
c0003224:	83 c4 04             	add    $0x4,%esp
c0003227:	61                   	popa   
c0003228:	cf                   	iret   
c0003229:	8d 76 00             	lea    0x0(%esi),%esi

c000322c <irq_8>:
c000322c:	60                   	pusha  
c000322d:	b8 08 00 00 00       	mov    $0x8,%eax
c0003232:	50                   	push   %eax
c0003233:	e8 b5 ed ff ff       	call   c0001fed <irq_handler>
c0003238:	83 c4 04             	add    $0x4,%esp
c000323b:	61                   	popa   
c000323c:	cf                   	iret   
c000323d:	8d 76 00             	lea    0x0(%esi),%esi

c0003240 <irq_9>:
c0003240:	60                   	pusha  
c0003241:	b8 09 00 00 00       	mov    $0x9,%eax
c0003246:	50                   	push   %eax
c0003247:	e8 a1 ed ff ff       	call   c0001fed <irq_handler>
c000324c:	83 c4 04             	add    $0x4,%esp
c000324f:	61                   	popa   
c0003250:	cf                   	iret   
c0003251:	8d 76 00             	lea    0x0(%esi),%esi

c0003254 <irq_10>:
c0003254:	60                   	pusha  
c0003255:	b8 0a 00 00 00       	mov    $0xa,%eax
c000325a:	50                   	push   %eax
c000325b:	e8 8d ed ff ff       	call   c0001fed <irq_handler>
c0003260:	83 c4 04             	add    $0x4,%esp
c0003263:	61                   	popa   
c0003264:	cf                   	iret   
c0003265:	8d 76 00             	lea    0x0(%esi),%esi

c0003268 <irq_11>:
c0003268:	60                   	pusha  
c0003269:	b8 0b 00 00 00       	mov    $0xb,%eax
c000326e:	50                   	push   %eax
c000326f:	e8 79 ed ff ff       	call   c0001fed <irq_handler>
c0003274:	83 c4 04             	add    $0x4,%esp
c0003277:	61                   	popa   
c0003278:	cf                   	iret   
c0003279:	8d 76 00             	lea    0x0(%esi),%esi

c000327c <irq_12>:
c000327c:	60                   	pusha  
c000327d:	b8 0c 00 00 00       	mov    $0xc,%eax
c0003282:	50                   	push   %eax
c0003283:	e8 65 ed ff ff       	call   c0001fed <irq_handler>
c0003288:	83 c4 04             	add    $0x4,%esp
c000328b:	61                   	popa   
c000328c:	cf                   	iret   
c000328d:	8d 76 00             	lea    0x0(%esi),%esi

c0003290 <irq_13>:
c0003290:	60                   	pusha  
c0003291:	b8 0d 00 00 00       	mov    $0xd,%eax
c0003296:	50                   	push   %eax
c0003297:	e8 51 ed ff ff       	call   c0001fed <irq_handler>
c000329c:	83 c4 04             	add    $0x4,%esp
c000329f:	61                   	popa   
c00032a0:	cf                   	iret   
c00032a1:	8d 76 00             	lea    0x0(%esi),%esi

c00032a4 <irq_14>:
c00032a4:	60                   	pusha  
c00032a5:	b8 0e 00 00 00       	mov    $0xe,%eax
c00032aa:	50                   	push   %eax
c00032ab:	e8 3d ed ff ff       	call   c0001fed <irq_handler>
c00032b0:	83 c4 04             	add    $0x4,%esp
c00032b3:	61                   	popa   
c00032b4:	cf                   	iret   
c00032b5:	8d 76 00             	lea    0x0(%esi),%esi

c00032b8 <irq_15>:
c00032b8:	60                   	pusha  
c00032b9:	b8 0f 00 00 00       	mov    $0xf,%eax
c00032be:	50                   	push   %eax
c00032bf:	e8 29 ed ff ff       	call   c0001fed <irq_handler>
c00032c4:	83 c4 04             	add    $0x4,%esp
c00032c7:	61                   	popa   
c00032c8:	cf                   	iret   
c00032c9:	66 90                	xchg   %ax,%ax
c00032cb:	90                   	nop

c00032cc <switch_to_task>:
c00032cc:	53                   	push   %ebx
c00032cd:	56                   	push   %esi
c00032ce:	57                   	push   %edi
c00032cf:	55                   	push   %ebp
c00032d0:	8b 3d 40 08 01 c0    	mov    0xc0010840,%edi
c00032d6:	89 67 08             	mov    %esp,0x8(%edi)
c00032d9:	8b 74 24 14          	mov    0x14(%esp),%esi
c00032dd:	89 35 40 08 01 c0    	mov    %esi,0xc0010840
c00032e3:	8b 66 08             	mov    0x8(%esi),%esp
c00032e6:	8b 5e 0c             	mov    0xc(%esi),%ebx
c00032e9:	8b 46 10             	mov    0x10(%esi),%eax
c00032ec:	89 1d 04 09 01 c0    	mov    %ebx,0xc0010904
c00032f2:	0f 20 d9             	mov    %cr3,%ecx
c00032f5:	39 c8                	cmp    %ecx,%eax
c00032f7:	74 03                	je     c00032fc <.done>
c00032f9:	0f 22 d8             	mov    %eax,%cr3

c00032fc <.done>:
c00032fc:	5d                   	pop    %ebp
c00032fd:	5f                   	pop    %edi
c00032fe:	5e                   	pop    %esi
c00032ff:	5b                   	pop    %ebx
c0003300:	c3                   	ret    

c0003301 <terminate_task>:
c0003301:	8d 35 60 08 01 c0    	lea    0xc0010860,%esi
c0003307:	89 35 40 08 01 c0    	mov    %esi,0xc0010840
c000330d:	8b 66 08             	mov    0x8(%esi),%esp
c0003310:	8b 5e 0c             	mov    0xc(%esi),%ebx
c0003313:	8b 46 10             	mov    0x10(%esi),%eax
c0003316:	89 1d 04 09 01 c0    	mov    %ebx,0xc0010904
c000331c:	0f 20 d9             	mov    %cr3,%ecx
c000331f:	39 c8                	cmp    %ecx,%eax
c0003321:	74 d9                	je     c00032fc <.done>
c0003323:	0f 22 d8             	mov    %eax,%cr3

c0003326 <.done2>:
c0003326:	5d                   	pop    %ebp
c0003327:	5f                   	pop    %edi
c0003328:	5e                   	pop    %esi
c0003329:	5b                   	pop    %ebx
c000332a:	c3                   	ret    
c000332b:	90                   	nop

c000332c <enable_paging>:
c000332c:	55                   	push   %ebp
c000332d:	89 e5                	mov    %esp,%ebp
c000332f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003332:	0f 22 d8             	mov    %eax,%cr3
c0003335:	0f 20 c0             	mov    %cr0,%eax
c0003338:	0d 01 00 00 80       	or     $0x80000001,%eax
c000333d:	0f 22 c0             	mov    %eax,%cr0
c0003340:	89 ec                	mov    %ebp,%esp
c0003342:	5d                   	pop    %ebp
c0003343:	c3                   	ret    

c0003344 <set_page_dir>:
c0003344:	8b 44 24 04          	mov    0x4(%esp),%eax
c0003348:	0f 22 d8             	mov    %eax,%cr3
c000334b:	c3                   	ret    

c000334c <get_page_dir>:
c000334c:	0f 20 d8             	mov    %cr3,%eax
c000334f:	c3                   	ret    

c0003350 <refresh_tlb>:
c0003350:	0f 20 d8             	mov    %cr3,%eax
c0003353:	0f 22 d8             	mov    %eax,%cr3
c0003356:	c3                   	ret    
c0003357:	90                   	nop

c0003358 <refresh_page>:
c0003358:	8b 44 24 04          	mov    0x4(%esp),%eax
c000335c:	0f 01 38             	invlpg (%eax)
c000335f:	c3                   	ret    
