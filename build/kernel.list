
build/kernel:     file format elf32-i386


Disassembly of section .text.boot:

00100000 <_start-0xc>:
  100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fb                   	sti    
  100009:	4f                   	dec    %edi
  10000a:	52                   	push   %edx
  10000b:	e4                   	.byte 0xe4

0010000c <_start>:
  10000c:	fa                   	cli    
  10000d:	3d 02 b0 ad 2b       	cmp    $0x2badb002,%eax
  100012:	0f 85 c1 00 00 00    	jne    1000d9 <kpanic>
  100018:	8d 25 00 f0 10 00    	lea    0x10f000,%esp
  10001e:	53                   	push   %ebx
  10001f:	8d 3d 00 f0 10 00    	lea    0x10f000,%edi
  100025:	b8 83 00 00 00       	mov    $0x83,%eax
  10002a:	89 07                	mov    %eax,(%edi)
  10002c:	0f 20 e0             	mov    %cr4,%eax
  10002f:	83 c8 10             	or     $0x10,%eax
  100032:	0f 22 e0             	mov    %eax,%cr4
  100035:	8d 35 00 00 11 00    	lea    0x110000,%esi
  10003b:	83 ce 03             	or     $0x3,%esi
  10003e:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  100044:	c1 e8 16             	shr    $0x16,%eax
  100047:	bb 04 00 00 00       	mov    $0x4,%ebx
  10004c:	f7 e3                	mul    %ebx
  10004e:	8d 3d 00 f0 10 00    	lea    0x10f000,%edi
  100054:	01 c7                	add    %eax,%edi
  100056:	89 37                	mov    %esi,(%edi)
  100058:	8d 1d 00 00 00 c0    	lea    0xc0000000,%ebx
  10005e:	c1 eb 0c             	shr    $0xc,%ebx
  100061:	8d 0d 68 09 01 c0    	lea    0xc0010968,%ecx
  100067:	81 c1 ff 0f 00 00    	add    $0xfff,%ecx
  10006d:	c1 e9 0c             	shr    $0xc,%ecx
  100070:	29 d9                	sub    %ebx,%ecx
  100072:	8d 05 00 00 00 c0    	lea    0xc0000000,%eax
  100078:	25 00 f0 3f 00       	and    $0x3ff000,%eax
  10007d:	c1 e8 0c             	shr    $0xc,%eax
  100080:	bb 04 00 00 00       	mov    $0x4,%ebx
  100085:	f7 e3                	mul    %ebx
  100087:	8d 3d 00 00 11 00    	lea    0x110000,%edi
  10008d:	01 c7                	add    %eax,%edi
  10008f:	8d 05 00 10 10 00    	lea    0x101000,%eax
  100095:	83 c8 03             	or     $0x3,%eax
  100098:	fc                   	cld    

00100099 <.nextpte>:
  100099:	ab                   	stos   %eax,%es:(%edi)
  10009a:	05 00 10 00 00       	add    $0x1000,%eax
  10009f:	e2 f8                	loop   100099 <.nextpte>
  1000a1:	8d 35 00 f0 10 00    	lea    0x10f000,%esi
  1000a7:	89 f7                	mov    %esi,%edi
  1000a9:	81 c7 fc 0f 00 00    	add    $0xffc,%edi
  1000af:	83 ce 03             	or     $0x3,%esi
  1000b2:	89 37                	mov    %esi,(%edi)
  1000b4:	5b                   	pop    %ebx

001000b5 <_enable_paging>:
  1000b5:	8d 05 00 f0 10 00    	lea    0x10f000,%eax
  1000bb:	0f 22 d8             	mov    %eax,%cr3
  1000be:	0f 20 c0             	mov    %cr0,%eax
  1000c1:	0d 00 00 01 80       	or     $0x80010000,%eax
  1000c6:	0f 22 c0             	mov    %eax,%cr0
  1000c9:	8d 25 00 e0 00 c0    	lea    0xc000e000,%esp
  1000cf:	50                   	push   %eax
  1000d0:	50                   	push   %eax
  1000d1:	50                   	push   %eax
  1000d2:	53                   	push   %ebx
  1000d3:	e8 85 2a f0 bf       	call   c0002b5d <kernel_main>
  1000d8:	fa                   	cli    

001000d9 <kpanic>:
  1000d9:	f4                   	hlt    
  1000da:	eb fd                	jmp    1000d9 <kpanic>

Disassembly of section .text:

c0000000 <syscall>:
#include "terminal.h"
#include "kprintf.h"

void syscall()
{
c0000000:	55                   	push   %ebp
c0000001:	89 e5                	mov    %esp,%ebp
}
c0000003:	90                   	nop
c0000004:	5d                   	pop    %ebp
c0000005:	c3                   	ret    

c0000006 <vga_entry_color>:
	VGA_COLOR_LIGHT_BROWN = 14,
	VGA_COLOR_WHITE = 15,
};
 
static inline uint8_t vga_entry_color(enum vga_color fg, enum vga_color bg) 
{
c0000006:	55                   	push   %ebp
c0000007:	89 e5                	mov    %esp,%ebp
	return fg | bg << 4;
c0000009:	8b 45 0c             	mov    0xc(%ebp),%eax
c000000c:	c1 e0 04             	shl    $0x4,%eax
c000000f:	89 c2                	mov    %eax,%edx
c0000011:	8b 45 08             	mov    0x8(%ebp),%eax
c0000014:	09 d0                	or     %edx,%eax
}
c0000016:	5d                   	pop    %ebp
c0000017:	c3                   	ret    

c0000018 <vga_entry>:
 
static inline uint16_t vga_entry(unsigned char uc, uint8_t color) 
{
c0000018:	55                   	push   %ebp
c0000019:	89 e5                	mov    %esp,%ebp
c000001b:	83 ec 08             	sub    $0x8,%esp
c000001e:	8b 55 08             	mov    0x8(%ebp),%edx
c0000021:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000024:	88 55 fc             	mov    %dl,-0x4(%ebp)
c0000027:	88 45 f8             	mov    %al,-0x8(%ebp)
	return (uint16_t) uc | (uint16_t) color << 8;
c000002a:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c000002e:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0000032:	c1 e0 08             	shl    $0x8,%eax
c0000035:	09 d0                	or     %edx,%eax
}
c0000037:	c9                   	leave  
c0000038:	c3                   	ret    

c0000039 <outb>:
  return _v;
}

static inline void
outb (unsigned char __value, unsigned short int __port)
{
c0000039:	55                   	push   %ebp
c000003a:	89 e5                	mov    %esp,%ebp
c000003c:	83 ec 08             	sub    $0x8,%esp
c000003f:	8b 55 08             	mov    0x8(%ebp),%edx
c0000042:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000045:	88 55 fc             	mov    %dl,-0x4(%ebp)
c0000048:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
c000004c:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0000050:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
c0000054:	ee                   	out    %al,(%dx)
}
c0000055:	90                   	nop
c0000056:	c9                   	leave  
c0000057:	c3                   	ret    

c0000058 <terminal_init>:
#include "io.h"

struct terminal stdout;

void terminal_init(struct terminal* term) 
{
c0000058:	55                   	push   %ebp
c0000059:	89 e5                	mov    %esp,%ebp
c000005b:	53                   	push   %ebx
c000005c:	83 ec 10             	sub    $0x10,%esp
	term->row = 0;
c000005f:	8b 45 08             	mov    0x8(%ebp),%eax
c0000062:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	term->column = 0;
c0000068:	8b 45 08             	mov    0x8(%ebp),%eax
c000006b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	term->color = vga_entry_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
c0000072:	6a 00                	push   $0x0
c0000074:	6a 07                	push   $0x7
c0000076:	e8 8b ff ff ff       	call   c0000006 <vga_entry_color>
c000007b:	83 c4 08             	add    $0x8,%esp
c000007e:	8b 55 08             	mov    0x8(%ebp),%edx
c0000081:	88 42 08             	mov    %al,0x8(%edx)
	term->buffer = (uint16_t*) VGA_BUFFER;
c0000084:	8b 45 08             	mov    0x8(%ebp),%eax
c0000087:	c7 40 0c 00 80 0b 00 	movl   $0xb8000,0xc(%eax)
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
c000008e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0000095:	eb 54                	jmp    c00000eb <terminal_init+0x93>
		for (size_t x = 0; x < VGA_WIDTH; x++) {
c0000097:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000009e:	eb 41                	jmp    c00000e1 <terminal_init+0x89>
			const size_t index = y * VGA_WIDTH + x;
c00000a0:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00000a3:	89 d0                	mov    %edx,%eax
c00000a5:	c1 e0 02             	shl    $0x2,%eax
c00000a8:	01 d0                	add    %edx,%eax
c00000aa:	c1 e0 04             	shl    $0x4,%eax
c00000ad:	89 c2                	mov    %eax,%edx
c00000af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00000b2:	01 d0                	add    %edx,%eax
c00000b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
			term->buffer[index] = vga_entry(' ', term->color);
c00000b7:	8b 45 08             	mov    0x8(%ebp),%eax
c00000ba:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c00000be:	0f b6 c0             	movzbl %al,%eax
c00000c1:	8b 55 08             	mov    0x8(%ebp),%edx
c00000c4:	8b 4a 0c             	mov    0xc(%edx),%ecx
c00000c7:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00000ca:	01 d2                	add    %edx,%edx
c00000cc:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
c00000cf:	50                   	push   %eax
c00000d0:	6a 20                	push   $0x20
c00000d2:	e8 41 ff ff ff       	call   c0000018 <vga_entry>
c00000d7:	83 c4 08             	add    $0x8,%esp
c00000da:	66 89 03             	mov    %ax,(%ebx)
		for (size_t x = 0; x < VGA_WIDTH; x++) {
c00000dd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00000e1:	83 7d f4 4f          	cmpl   $0x4f,-0xc(%ebp)
c00000e5:	76 b9                	jbe    c00000a0 <terminal_init+0x48>
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
c00000e7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c00000eb:	83 7d f8 18          	cmpl   $0x18,-0x8(%ebp)
c00000ef:	76 a6                	jbe    c0000097 <terminal_init+0x3f>
		}
	}

	//disable cursor
	outb(0x0A, 0x3D4);
c00000f1:	68 d4 03 00 00       	push   $0x3d4
c00000f6:	6a 0a                	push   $0xa
c00000f8:	e8 3c ff ff ff       	call   c0000039 <outb>
c00000fd:	83 c4 08             	add    $0x8,%esp
	outb(0x20, 0x3D5);
c0000100:	68 d5 03 00 00       	push   $0x3d5
c0000105:	6a 20                	push   $0x20
c0000107:	e8 2d ff ff ff       	call   c0000039 <outb>
c000010c:	83 c4 08             	add    $0x8,%esp
	// outb(0x0A, 0x3D4);
	// outb((inb(0x3D5) & 0xC0) | cursor_start, 0x3D5);
 
	// outb(0x0B, 0x3D4);
	// outb((inb(0x3D5) & 0xE0) | cursor_end, 0x3D5);
}
c000010f:	90                   	nop
c0000110:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0000113:	c9                   	leave  
c0000114:	c3                   	ret    

c0000115 <terminal_setcolor>:
 
void terminal_setcolor(struct terminal* term, uint8_t color) 
{
c0000115:	55                   	push   %ebp
c0000116:	89 e5                	mov    %esp,%ebp
c0000118:	83 ec 04             	sub    $0x4,%esp
c000011b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000011e:	88 45 fc             	mov    %al,-0x4(%ebp)
	term->color = color;
c0000121:	8b 45 08             	mov    0x8(%ebp),%eax
c0000124:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c0000128:	88 50 08             	mov    %dl,0x8(%eax)
}
c000012b:	90                   	nop
c000012c:	c9                   	leave  
c000012d:	c3                   	ret    

c000012e <terminal_putentryat>:
 
void terminal_putentryat(struct terminal* term, char c, uint8_t color, size_t x, size_t y) 
{
c000012e:	55                   	push   %ebp
c000012f:	89 e5                	mov    %esp,%ebp
c0000131:	53                   	push   %ebx
c0000132:	83 ec 18             	sub    $0x18,%esp
c0000135:	8b 55 0c             	mov    0xc(%ebp),%edx
c0000138:	8b 45 10             	mov    0x10(%ebp),%eax
c000013b:	88 55 e8             	mov    %dl,-0x18(%ebp)
c000013e:	88 45 e4             	mov    %al,-0x1c(%ebp)
	const size_t index = y * VGA_WIDTH + x;
c0000141:	8b 55 18             	mov    0x18(%ebp),%edx
c0000144:	89 d0                	mov    %edx,%eax
c0000146:	c1 e0 02             	shl    $0x2,%eax
c0000149:	01 d0                	add    %edx,%eax
c000014b:	c1 e0 04             	shl    $0x4,%eax
c000014e:	89 c2                	mov    %eax,%edx
c0000150:	8b 45 14             	mov    0x14(%ebp),%eax
c0000153:	01 d0                	add    %edx,%eax
c0000155:	89 45 f8             	mov    %eax,-0x8(%ebp)
	term->buffer[index] = vga_entry(c, color);
c0000158:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c000015c:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0000160:	0f b6 c0             	movzbl %al,%eax
c0000163:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0000166:	8b 59 0c             	mov    0xc(%ecx),%ebx
c0000169:	8b 4d f8             	mov    -0x8(%ebp),%ecx
c000016c:	01 c9                	add    %ecx,%ecx
c000016e:	01 cb                	add    %ecx,%ebx
c0000170:	52                   	push   %edx
c0000171:	50                   	push   %eax
c0000172:	e8 a1 fe ff ff       	call   c0000018 <vga_entry>
c0000177:	83 c4 08             	add    $0x8,%esp
c000017a:	66 89 03             	mov    %ax,(%ebx)
	// terminal_movecursor(term, x, y);
}
c000017d:	90                   	nop
c000017e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0000181:	c9                   	leave  
c0000182:	c3                   	ret    

c0000183 <terminal_movecursor>:

void terminal_movecursor(struct terminal* term, size_t x, size_t y)
{
c0000183:	55                   	push   %ebp
c0000184:	89 e5                	mov    %esp,%ebp
c0000186:	83 ec 10             	sub    $0x10,%esp
	(void) term; //we are directly manipulating curser, so were arean't using the term struct

	uint16_t pos = y * VGA_WIDTH + x;
c0000189:	8b 45 10             	mov    0x10(%ebp),%eax
c000018c:	89 c2                	mov    %eax,%edx
c000018e:	89 d0                	mov    %edx,%eax
c0000190:	c1 e0 02             	shl    $0x2,%eax
c0000193:	01 d0                	add    %edx,%eax
c0000195:	c1 e0 04             	shl    $0x4,%eax
c0000198:	89 c2                	mov    %eax,%edx
c000019a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000019d:	01 d0                	add    %edx,%eax
c000019f:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

	outb(0x0F, 0x3D4);
c00001a3:	68 d4 03 00 00       	push   $0x3d4
c00001a8:	6a 0f                	push   $0xf
c00001aa:	e8 8a fe ff ff       	call   c0000039 <outb>
c00001af:	83 c4 08             	add    $0x8,%esp
	outb((uint8_t) (pos & 0xFF), 0x3D5);
c00001b2:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c00001b6:	0f b6 c0             	movzbl %al,%eax
c00001b9:	68 d5 03 00 00       	push   $0x3d5
c00001be:	50                   	push   %eax
c00001bf:	e8 75 fe ff ff       	call   c0000039 <outb>
c00001c4:	83 c4 08             	add    $0x8,%esp
	outb(0x0E, 0x3D4);
c00001c7:	68 d4 03 00 00       	push   $0x3d4
c00001cc:	6a 0e                	push   $0xe
c00001ce:	e8 66 fe ff ff       	call   c0000039 <outb>
c00001d3:	83 c4 08             	add    $0x8,%esp
	outb((uint8_t) ((pos >> 8) & 0xFF), 0x3D5);
c00001d6:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c00001da:	66 c1 e8 08          	shr    $0x8,%ax
c00001de:	0f b6 c0             	movzbl %al,%eax
c00001e1:	68 d5 03 00 00       	push   $0x3d5
c00001e6:	50                   	push   %eax
c00001e7:	e8 4d fe ff ff       	call   c0000039 <outb>
c00001ec:	83 c4 08             	add    $0x8,%esp
}
c00001ef:	90                   	nop
c00001f0:	c9                   	leave  
c00001f1:	c3                   	ret    

c00001f2 <terminal_putchar>:

 
void terminal_putchar(struct terminal* term, char c) 
{
c00001f2:	55                   	push   %ebp
c00001f3:	89 e5                	mov    %esp,%ebp
c00001f5:	53                   	push   %ebx
c00001f6:	83 ec 14             	sub    $0x14,%esp
c00001f9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00001fc:	88 45 f4             	mov    %al,-0xc(%ebp)
	if(c == '\n')
c00001ff:	80 7d f4 0a          	cmpb   $0xa,-0xc(%ebp)
c0000203:	75 10                	jne    c0000215 <terminal_putchar+0x23>
	{
		terminal_newline(term);
c0000205:	83 ec 0c             	sub    $0xc,%esp
c0000208:	ff 75 08             	pushl  0x8(%ebp)
c000020b:	e8 95 00 00 00       	call   c00002a5 <terminal_newline>
c0000210:	83 c4 10             	add    $0x10,%esp
		return;
c0000213:	eb 53                	jmp    c0000268 <terminal_putchar+0x76>
	}

	terminal_putentryat(term, c, term->color, term->column, term->row);
c0000215:	8b 45 08             	mov    0x8(%ebp),%eax
c0000218:	8b 18                	mov    (%eax),%ebx
c000021a:	8b 45 08             	mov    0x8(%ebp),%eax
c000021d:	8b 48 04             	mov    0x4(%eax),%ecx
c0000220:	8b 45 08             	mov    0x8(%ebp),%eax
c0000223:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c0000227:	0f b6 d0             	movzbl %al,%edx
c000022a:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c000022e:	83 ec 0c             	sub    $0xc,%esp
c0000231:	53                   	push   %ebx
c0000232:	51                   	push   %ecx
c0000233:	52                   	push   %edx
c0000234:	50                   	push   %eax
c0000235:	ff 75 08             	pushl  0x8(%ebp)
c0000238:	e8 f1 fe ff ff       	call   c000012e <terminal_putentryat>
c000023d:	83 c4 20             	add    $0x20,%esp
	if (++term->column == VGA_WIDTH)
c0000240:	8b 45 08             	mov    0x8(%ebp),%eax
c0000243:	8b 40 04             	mov    0x4(%eax),%eax
c0000246:	8d 50 01             	lea    0x1(%eax),%edx
c0000249:	8b 45 08             	mov    0x8(%ebp),%eax
c000024c:	89 50 04             	mov    %edx,0x4(%eax)
c000024f:	8b 45 08             	mov    0x8(%ebp),%eax
c0000252:	8b 40 04             	mov    0x4(%eax),%eax
c0000255:	83 f8 50             	cmp    $0x50,%eax
c0000258:	75 0e                	jne    c0000268 <terminal_putchar+0x76>
		terminal_newline(term);
c000025a:	83 ec 0c             	sub    $0xc,%esp
c000025d:	ff 75 08             	pushl  0x8(%ebp)
c0000260:	e8 40 00 00 00       	call   c00002a5 <terminal_newline>
c0000265:	83 c4 10             	add    $0x10,%esp
}
c0000268:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000026b:	c9                   	leave  
c000026c:	c3                   	ret    

c000026d <terminal_putcharn>:

void terminal_putcharn(struct terminal* term, char c, size_t repeat) 
{
c000026d:	55                   	push   %ebp
c000026e:	89 e5                	mov    %esp,%ebp
c0000270:	83 ec 28             	sub    $0x28,%esp
c0000273:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000276:	88 45 e4             	mov    %al,-0x1c(%ebp)
	for (size_t i = 0; i < repeat; i++)
c0000279:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0000280:	eb 17                	jmp    c0000299 <terminal_putcharn+0x2c>
		terminal_putchar(term, c);
c0000282:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
c0000286:	83 ec 08             	sub    $0x8,%esp
c0000289:	50                   	push   %eax
c000028a:	ff 75 08             	pushl  0x8(%ebp)
c000028d:	e8 60 ff ff ff       	call   c00001f2 <terminal_putchar>
c0000292:	83 c4 10             	add    $0x10,%esp
	for (size_t i = 0; i < repeat; i++)
c0000295:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0000299:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000029c:	3b 45 10             	cmp    0x10(%ebp),%eax
c000029f:	72 e1                	jb     c0000282 <terminal_putcharn+0x15>
}
c00002a1:	90                   	nop
c00002a2:	90                   	nop
c00002a3:	c9                   	leave  
c00002a4:	c3                   	ret    

c00002a5 <terminal_newline>:

void terminal_newline(struct terminal* term)
{
c00002a5:	55                   	push   %ebp
c00002a6:	89 e5                	mov    %esp,%ebp
c00002a8:	83 ec 08             	sub    $0x8,%esp
    term->column = 0;
c00002ab:	8b 45 08             	mov    0x8(%ebp),%eax
c00002ae:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if (++term->row == VGA_HEIGHT)
c00002b5:	8b 45 08             	mov    0x8(%ebp),%eax
c00002b8:	8b 00                	mov    (%eax),%eax
c00002ba:	8d 50 01             	lea    0x1(%eax),%edx
c00002bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00002c0:	89 10                	mov    %edx,(%eax)
c00002c2:	8b 45 08             	mov    0x8(%ebp),%eax
c00002c5:	8b 00                	mov    (%eax),%eax
c00002c7:	83 f8 19             	cmp    $0x19,%eax
c00002ca:	75 0e                	jne    c00002da <terminal_newline+0x35>
        terminal_scrollline(term);
c00002cc:	83 ec 0c             	sub    $0xc,%esp
c00002cf:	ff 75 08             	pushl  0x8(%ebp)
c00002d2:	e8 06 00 00 00       	call   c00002dd <terminal_scrollline>
c00002d7:	83 c4 10             	add    $0x10,%esp
}
c00002da:	90                   	nop
c00002db:	c9                   	leave  
c00002dc:	c3                   	ret    

c00002dd <terminal_scrollline>:

void terminal_scrollline(struct terminal* term)
{
c00002dd:	55                   	push   %ebp
c00002de:	89 e5                	mov    %esp,%ebp
c00002e0:	83 ec 08             	sub    $0x8,%esp
	// copy rows 2 though N to rows 1 through N-1
	memcpy(term->buffer, &term->buffer[VGA_WIDTH], VGA_WIDTH*(VGA_HEIGHT-1)*sizeof(term->buffer[0]));
c00002e3:	8b 45 08             	mov    0x8(%ebp),%eax
c00002e6:	8b 40 0c             	mov    0xc(%eax),%eax
c00002e9:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c00002ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00002f2:	8b 40 0c             	mov    0xc(%eax),%eax
c00002f5:	83 ec 04             	sub    $0x4,%esp
c00002f8:	68 00 0f 00 00       	push   $0xf00
c00002fd:	52                   	push   %edx
c00002fe:	50                   	push   %eax
c00002ff:	e8 bf 0f 00 00       	call   c00012c3 <memcpy>
c0000304:	83 c4 10             	add    $0x10,%esp
	// clear last row
	term->row = VGA_HEIGHT-1;
c0000307:	8b 45 08             	mov    0x8(%ebp),%eax
c000030a:	c7 00 18 00 00 00    	movl   $0x18,(%eax)
	terminal_clearline(term);
c0000310:	83 ec 0c             	sub    $0xc,%esp
c0000313:	ff 75 08             	pushl  0x8(%ebp)
c0000316:	e8 06 00 00 00       	call   c0000321 <terminal_clearline>
c000031b:	83 c4 10             	add    $0x10,%esp
}
c000031e:	90                   	nop
c000031f:	c9                   	leave  
c0000320:	c3                   	ret    

c0000321 <terminal_clearline>:

void terminal_clearline(struct terminal* term)
{
c0000321:	55                   	push   %ebp
c0000322:	89 e5                	mov    %esp,%ebp
c0000324:	53                   	push   %ebx
c0000325:	83 ec 10             	sub    $0x10,%esp
	size_t row_start = term->row * VGA_WIDTH;
c0000328:	8b 45 08             	mov    0x8(%ebp),%eax
c000032b:	8b 10                	mov    (%eax),%edx
c000032d:	89 d0                	mov    %edx,%eax
c000032f:	c1 e0 02             	shl    $0x2,%eax
c0000332:	01 d0                	add    %edx,%eax
c0000334:	c1 e0 04             	shl    $0x4,%eax
c0000337:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c000033a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0000341:	eb 2f                	jmp    c0000372 <terminal_clearline+0x51>
		term->buffer[row_start+nn] = vga_entry(' ', term->color);
c0000343:	8b 45 08             	mov    0x8(%ebp),%eax
c0000346:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c000034a:	0f b6 c0             	movzbl %al,%eax
c000034d:	8b 55 08             	mov    0x8(%ebp),%edx
c0000350:	8b 4a 0c             	mov    0xc(%edx),%ecx
c0000353:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c0000356:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0000359:	01 da                	add    %ebx,%edx
c000035b:	01 d2                	add    %edx,%edx
c000035d:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
c0000360:	50                   	push   %eax
c0000361:	6a 20                	push   $0x20
c0000363:	e8 b0 fc ff ff       	call   c0000018 <vga_entry>
c0000368:	83 c4 08             	add    $0x8,%esp
c000036b:	66 89 03             	mov    %ax,(%ebx)
	for(size_t nn=0;nn<VGA_WIDTH;nn++)
c000036e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0000372:	83 7d f8 4f          	cmpl   $0x4f,-0x8(%ebp)
c0000376:	76 cb                	jbe    c0000343 <terminal_clearline+0x22>

}
c0000378:	90                   	nop
c0000379:	90                   	nop
c000037a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000037d:	c9                   	leave  
c000037e:	c3                   	ret    

c000037f <terminal_write>:


void terminal_write(struct terminal* term, const char* data, size_t size) 
{
c000037f:	55                   	push   %ebp
c0000380:	89 e5                	mov    %esp,%ebp
c0000382:	83 ec 18             	sub    $0x18,%esp
	for (size_t i = 0; i < size; i++)
c0000385:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000038c:	eb 21                	jmp    c00003af <terminal_write+0x30>
		terminal_putchar(term, data[i]);
c000038e:	8b 55 0c             	mov    0xc(%ebp),%edx
c0000391:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000394:	01 d0                	add    %edx,%eax
c0000396:	0f b6 00             	movzbl (%eax),%eax
c0000399:	0f be c0             	movsbl %al,%eax
c000039c:	83 ec 08             	sub    $0x8,%esp
c000039f:	50                   	push   %eax
c00003a0:	ff 75 08             	pushl  0x8(%ebp)
c00003a3:	e8 4a fe ff ff       	call   c00001f2 <terminal_putchar>
c00003a8:	83 c4 10             	add    $0x10,%esp
	for (size_t i = 0; i < size; i++)
c00003ab:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00003af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00003b2:	3b 45 10             	cmp    0x10(%ebp),%eax
c00003b5:	72 d7                	jb     c000038e <terminal_write+0xf>
}
c00003b7:	90                   	nop
c00003b8:	90                   	nop
c00003b9:	c9                   	leave  
c00003ba:	c3                   	ret    

c00003bb <terminal_writestring>:
 
void terminal_writestring(struct terminal* term, const char* data) 
{
c00003bb:	55                   	push   %ebp
c00003bc:	89 e5                	mov    %esp,%ebp
c00003be:	83 ec 08             	sub    $0x8,%esp
	terminal_write(term, data, strlen(data));
c00003c1:	83 ec 0c             	sub    $0xc,%esp
c00003c4:	ff 75 0c             	pushl  0xc(%ebp)
c00003c7:	e8 d0 0e 00 00       	call   c000129c <strlen>
c00003cc:	83 c4 10             	add    $0x10,%esp
c00003cf:	83 ec 04             	sub    $0x4,%esp
c00003d2:	50                   	push   %eax
c00003d3:	ff 75 0c             	pushl  0xc(%ebp)
c00003d6:	ff 75 08             	pushl  0x8(%ebp)
c00003d9:	e8 a1 ff ff ff       	call   c000037f <terminal_write>
c00003de:	83 c4 10             	add    $0x10,%esp
}
c00003e1:	90                   	nop
c00003e2:	c9                   	leave  
c00003e3:	c3                   	ret    

c00003e4 <kprint>:
unsigned int numdigits_uint(unsigned int value, unsigned int base);

int format_uint(unsigned int value, char* str, unsigned int base, int precision, int cap);

int kprint(const char* str)
{
c00003e4:	55                   	push   %ebp
c00003e5:	89 e5                	mov    %esp,%ebp
c00003e7:	83 ec 08             	sub    $0x8,%esp
    terminal_writestring(&stdout, str);
c00003ea:	83 ec 08             	sub    $0x8,%esp
c00003ed:	ff 75 08             	pushl  0x8(%ebp)
c00003f0:	68 00 00 01 c0       	push   $0xc0010000
c00003f5:	e8 c1 ff ff ff       	call   c00003bb <terminal_writestring>
c00003fa:	83 c4 10             	add    $0x10,%esp
    return strlen(str);
c00003fd:	83 ec 0c             	sub    $0xc,%esp
c0000400:	ff 75 08             	pushl  0x8(%ebp)
c0000403:	e8 94 0e 00 00       	call   c000129c <strlen>
c0000408:	83 c4 10             	add    $0x10,%esp
}
c000040b:	c9                   	leave  
c000040c:	c3                   	ret    

c000040d <kprintn>:

int kprintn(const char* str, size_t len)
{
c000040d:	55                   	push   %ebp
c000040e:	89 e5                	mov    %esp,%ebp
c0000410:	83 ec 08             	sub    $0x8,%esp
    terminal_write(&stdout, str, len);
c0000413:	83 ec 04             	sub    $0x4,%esp
c0000416:	ff 75 0c             	pushl  0xc(%ebp)
c0000419:	ff 75 08             	pushl  0x8(%ebp)
c000041c:	68 00 00 01 c0       	push   $0xc0010000
c0000421:	e8 59 ff ff ff       	call   c000037f <terminal_write>
c0000426:	83 c4 10             	add    $0x10,%esp
    return len;
c0000429:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c000042c:	c9                   	leave  
c000042d:	c3                   	ret    

c000042e <kprint_char>:

int kprint_char(char c)
{
c000042e:	55                   	push   %ebp
c000042f:	89 e5                	mov    %esp,%ebp
c0000431:	83 ec 18             	sub    $0x18,%esp
c0000434:	8b 45 08             	mov    0x8(%ebp),%eax
c0000437:	88 45 f4             	mov    %al,-0xc(%ebp)
    terminal_putchar(&stdout, c); 
c000043a:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c000043e:	83 ec 08             	sub    $0x8,%esp
c0000441:	50                   	push   %eax
c0000442:	68 00 00 01 c0       	push   $0xc0010000
c0000447:	e8 a6 fd ff ff       	call   c00001f2 <terminal_putchar>
c000044c:	83 c4 10             	add    $0x10,%esp
    return 1;
c000044f:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0000454:	c9                   	leave  
c0000455:	c3                   	ret    

c0000456 <kprintn_char>:

int kprintn_char(char c, size_t rpt)
{
c0000456:	55                   	push   %ebp
c0000457:	89 e5                	mov    %esp,%ebp
c0000459:	83 ec 18             	sub    $0x18,%esp
c000045c:	8b 45 08             	mov    0x8(%ebp),%eax
c000045f:	88 45 f4             	mov    %al,-0xc(%ebp)
    terminal_putcharn(&stdout, c, rpt); 
c0000462:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c0000466:	83 ec 04             	sub    $0x4,%esp
c0000469:	ff 75 0c             	pushl  0xc(%ebp)
c000046c:	50                   	push   %eax
c000046d:	68 00 00 01 c0       	push   $0xc0010000
c0000472:	e8 f6 fd ff ff       	call   c000026d <terminal_putcharn>
c0000477:	83 c4 10             	add    $0x10,%esp
    return rpt;
c000047a:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c000047d:	c9                   	leave  
c000047e:	c3                   	ret    

c000047f <kprintf>:


int kprintf(const char* format, ...)
{
c000047f:	55                   	push   %ebp
c0000480:	89 e5                	mov    %esp,%ebp
c0000482:	81 ec a8 02 00 00    	sub    $0x2a8,%esp
    /* initialize valist for num number of arguments */
    va_list valist;
    va_start(valist, format);
c0000488:	8d 45 0c             	lea    0xc(%ebp),%eax
c000048b:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)

    // parse format into str
    const char* f = format;
c0000491:	8b 45 08             	mov    0x8(%ebp),%eax
c0000494:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int nchar = 0;
c0000497:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    while(f[0] != 0)
c000049e:	e9 9e 0a 00 00       	jmp    c0000f41 <kprintf+0xac2>
    {
        if(f[0] == '\\' && f[1] == '%')
c00004a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00004a6:	0f b6 00             	movzbl (%eax),%eax
c00004a9:	3c 5c                	cmp    $0x5c,%al
c00004ab:	75 22                	jne    c00004cf <kprintf+0x50>
c00004ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00004b0:	83 c0 01             	add    $0x1,%eax
c00004b3:	0f b6 00             	movzbl (%eax),%eax
c00004b6:	3c 25                	cmp    $0x25,%al
c00004b8:	75 15                	jne    c00004cf <kprintf+0x50>
        {
            //write escaped "%%" as '%'
            kprint_char('%');
c00004ba:	83 ec 0c             	sub    $0xc,%esp
c00004bd:	6a 25                	push   $0x25
c00004bf:	e8 6a ff ff ff       	call   c000042e <kprint_char>
c00004c4:	83 c4 10             	add    $0x10,%esp
            nchar++;
c00004c7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
            f += 2;
c00004cb:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
        }

        if(f[0] == '%')
c00004cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00004d2:	0f b6 00             	movzbl (%eax),%eax
c00004d5:	3c 25                	cmp    $0x25,%al
c00004d7:	0f 85 45 0a 00 00    	jne    c0000f22 <kprintf+0xaa3>
        {
            // found new field

            // parse flags
            struct format_flags flags = {0};
c00004dd:	c7 85 77 ff ff ff 00 	movl   $0x0,-0x89(%ebp)
c00004e4:	00 00 00 
c00004e7:	c6 85 7b ff ff ff 00 	movb   $0x0,-0x85(%ebp)
            int check_flags = 1;
c00004ee:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
            while(check_flags)
c00004f5:	e9 ee 00 00 00       	jmp    c00005e8 <kprintf+0x169>
            {
                switch(*(++f))
c00004fa:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00004fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000501:	0f b6 00             	movzbl (%eax),%eax
c0000504:	0f be c0             	movsbl %al,%eax
c0000507:	85 c0                	test   %eax,%eax
c0000509:	0f 84 c8 00 00 00    	je     c00005d7 <kprintf+0x158>
c000050f:	85 c0                	test   %eax,%eax
c0000511:	0f 88 ca 00 00 00    	js     c00005e1 <kprintf+0x162>
c0000517:	83 f8 30             	cmp    $0x30,%eax
c000051a:	0f 8f c1 00 00 00    	jg     c00005e1 <kprintf+0x162>
c0000520:	83 f8 20             	cmp    $0x20,%eax
c0000523:	0f 8c b8 00 00 00    	jl     c00005e1 <kprintf+0x162>
c0000529:	83 e8 20             	sub    $0x20,%eax
c000052c:	83 f8 10             	cmp    $0x10,%eax
c000052f:	0f 87 ac 00 00 00    	ja     c00005e1 <kprintf+0x162>
c0000535:	8b 04 85 00 40 00 c0 	mov    -0x3fffc000(,%eax,4),%eax
c000053c:	ff e0                	jmp    *%eax
                {
                    case '#':
                        if(flags.alt) return 0;
c000053e:	0f b6 85 77 ff ff ff 	movzbl -0x89(%ebp),%eax
c0000545:	84 c0                	test   %al,%al
c0000547:	74 0a                	je     c0000553 <kprintf+0xd4>
c0000549:	b8 00 00 00 00       	mov    $0x0,%eax
c000054e:	e9 ff 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        flags.alt = 1;
c0000553:	c6 85 77 ff ff ff 01 	movb   $0x1,-0x89(%ebp)
                        break;
c000055a:	e9 89 00 00 00       	jmp    c00005e8 <kprintf+0x169>
                    case '0':
                        if(flags.zero) return 0;
c000055f:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000566:	84 c0                	test   %al,%al
c0000568:	74 0a                	je     c0000574 <kprintf+0xf5>
c000056a:	b8 00 00 00 00       	mov    $0x0,%eax
c000056f:	e9 de 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        flags.zero = 1;
c0000574:	c6 85 78 ff ff ff 01 	movb   $0x1,-0x88(%ebp)
                        break;
c000057b:	eb 6b                	jmp    c00005e8 <kprintf+0x169>
                    case '-':
                        if(flags.left) return 0;
c000057d:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000584:	84 c0                	test   %al,%al
c0000586:	74 0a                	je     c0000592 <kprintf+0x113>
c0000588:	b8 00 00 00 00       	mov    $0x0,%eax
c000058d:	e9 c0 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        flags.left = 1;
c0000592:	c6 85 79 ff ff ff 01 	movb   $0x1,-0x87(%ebp)
                        break;
c0000599:	eb 4d                	jmp    c00005e8 <kprintf+0x169>
                    case ' ':
                        if(flags.space) return 0;
c000059b:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c00005a2:	84 c0                	test   %al,%al
c00005a4:	74 0a                	je     c00005b0 <kprintf+0x131>
c00005a6:	b8 00 00 00 00       	mov    $0x0,%eax
c00005ab:	e9 a2 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        flags.space = 1;
c00005b0:	c6 85 7a ff ff ff 01 	movb   $0x1,-0x86(%ebp)
                        break;
c00005b7:	eb 2f                	jmp    c00005e8 <kprintf+0x169>
                    case '+':
                        if(flags.sign) return 0;
c00005b9:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c00005c0:	84 c0                	test   %al,%al
c00005c2:	74 0a                	je     c00005ce <kprintf+0x14f>
c00005c4:	b8 00 00 00 00       	mov    $0x0,%eax
c00005c9:	e9 84 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        flags.sign = 1;
c00005ce:	c6 85 7b ff ff ff 01 	movb   $0x1,-0x85(%ebp)
                        break;
c00005d5:	eb 11                	jmp    c00005e8 <kprintf+0x169>
                    case '\0':
                        //unexpected string termination
                        return -1;
c00005d7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00005dc:	e9 71 09 00 00       	jmp    c0000f52 <kprintf+0xad3>
                        break;
                    default:
                        //no more flags
                        check_flags = 0;
c00005e1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
            while(check_flags)
c00005e8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c00005ec:	0f 85 08 ff ff ff    	jne    c00004fa <kprintf+0x7b>
                }
            }

            if(flags.left) flags.zero = 0; //If the 0 and - flags both appear, the 0 flag is ignored
c00005f2:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c00005f9:	84 c0                	test   %al,%al
c00005fb:	74 07                	je     c0000604 <kprintf+0x185>
c00005fd:	c6 85 78 ff ff ff 00 	movb   $0x0,-0x88(%ebp)

            // parse field width
            int field_width=0;
c0000604:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
            int nn=0;
c000060b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
            while(f[nn] >= '0' && f[nn] <= '9')
c0000612:	eb 04                	jmp    c0000618 <kprintf+0x199>
                nn++;            
c0000614:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
            while(f[nn] >= '0' && f[nn] <= '9')
c0000618:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c000061b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000061e:	01 d0                	add    %edx,%eax
c0000620:	0f b6 00             	movzbl (%eax),%eax
c0000623:	3c 2f                	cmp    $0x2f,%al
c0000625:	7e 0f                	jle    c0000636 <kprintf+0x1b7>
c0000627:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c000062a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000062d:	01 d0                	add    %edx,%eax
c000062f:	0f b6 00             	movzbl (%eax),%eax
c0000632:	3c 39                	cmp    $0x39,%al
c0000634:	7e de                	jle    c0000614 <kprintf+0x195>
            if(nn>0)
c0000636:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c000063a:	7e 17                	jle    c0000653 <kprintf+0x1d4>
            {
                field_width = atoi(f);
c000063c:	83 ec 0c             	sub    $0xc,%esp
c000063f:	ff 75 f4             	pushl  -0xc(%ebp)
c0000642:	e8 21 0d 00 00       	call   c0001368 <atoi>
c0000647:	83 c4 10             	add    $0x10,%esp
c000064a:	89 45 e8             	mov    %eax,-0x18(%ebp)
                f += nn;
c000064d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0000650:	01 45 f4             	add    %eax,-0xc(%ebp)
            }

            // parse field precision
            int field_prec=-1; //default is -1
c0000653:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
            if(f[0] == '.')
c000065a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000065d:	0f b6 00             	movzbl (%eax),%eax
c0000660:	3c 2e                	cmp    $0x2e,%al
c0000662:	75 59                	jne    c00006bd <kprintf+0x23e>
            {
                f++;
c0000664:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                nn=0;
c0000668:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
                while(f[nn] >= '0' && f[nn] <= '9')
c000066f:	eb 04                	jmp    c0000675 <kprintf+0x1f6>
                    nn++;            
c0000671:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                while(f[nn] >= '0' && f[nn] <= '9')
c0000675:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000678:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000067b:	01 d0                	add    %edx,%eax
c000067d:	0f b6 00             	movzbl (%eax),%eax
c0000680:	3c 2f                	cmp    $0x2f,%al
c0000682:	7e 0f                	jle    c0000693 <kprintf+0x214>
c0000684:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0000687:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000068a:	01 d0                	add    %edx,%eax
c000068c:	0f b6 00             	movzbl (%eax),%eax
c000068f:	3c 39                	cmp    $0x39,%al
c0000691:	7e de                	jle    c0000671 <kprintf+0x1f2>
                if(nn>0)
c0000693:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0000697:	7e 24                	jle    c00006bd <kprintf+0x23e>
                {
                    field_prec = atoi(f);
c0000699:	83 ec 0c             	sub    $0xc,%esp
c000069c:	ff 75 f4             	pushl  -0xc(%ebp)
c000069f:	e8 c4 0c 00 00       	call   c0001368 <atoi>
c00006a4:	83 c4 10             	add    $0x10,%esp
c00006a7:	89 45 e0             	mov    %eax,-0x20(%ebp)
                    if(field_prec<0) field_prec = 0;
c00006aa:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c00006ae:	79 07                	jns    c00006b7 <kprintf+0x238>
c00006b0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
                    f += nn;
c00006b7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00006ba:	01 45 f4             	add    %eax,-0xc(%ebp)

            //parse type
            enum length_mod_t {DEFAULT, CHARINT, SHORTINT, LONGINT, LONGLONGINT,
                            LONGDOUBLE, INTMAX, SIZE, PTRDIFF} length_mod;

            switch(*(f++))
c00006bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00006c0:	8d 50 01             	lea    0x1(%eax),%edx
c00006c3:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00006c6:	0f b6 00             	movzbl (%eax),%eax
c00006c9:	0f be c0             	movsbl %al,%eax
c00006cc:	83 e8 4c             	sub    $0x4c,%eax
c00006cf:	83 f8 2e             	cmp    $0x2e,%eax
c00006d2:	77 6d                	ja     c0000741 <kprintf+0x2c2>
c00006d4:	8b 04 85 44 40 00 c0 	mov    -0x3fffbfbc(,%eax,4),%eax
c00006db:	ff e0                	jmp    *%eax
            {
                case 'h':
                    if(*f == 'h')
c00006dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00006e0:	0f b6 00             	movzbl (%eax),%eax
c00006e3:	3c 68                	cmp    $0x68,%al
c00006e5:	75 0d                	jne    c00006f4 <kprintf+0x275>
                    {
                        f++;
c00006e7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                        length_mod = CHARINT;
c00006eb:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
                    }
                    else
                        length_mod = SHORTINT;
                    break;
c00006f2:	eb 58                	jmp    c000074c <kprintf+0x2cd>
                        length_mod = SHORTINT;
c00006f4:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
                    break;
c00006fb:	eb 4f                	jmp    c000074c <kprintf+0x2cd>
                case 'l':
                    if(*f == 'l')
c00006fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000700:	0f b6 00             	movzbl (%eax),%eax
c0000703:	3c 6c                	cmp    $0x6c,%al
c0000705:	75 0d                	jne    c0000714 <kprintf+0x295>
                    {
                        f++;
c0000707:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                        length_mod = LONGLONGINT;
c000070b:	c7 45 dc 04 00 00 00 	movl   $0x4,-0x24(%ebp)
                    }
                    else
                        length_mod = LONGINT;
                    break;
c0000712:	eb 38                	jmp    c000074c <kprintf+0x2cd>
                        length_mod = LONGINT;
c0000714:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
                    break;
c000071b:	eb 2f                	jmp    c000074c <kprintf+0x2cd>
                case 'q':
                case 'L':
                    length_mod = LONGDOUBLE;
c000071d:	c7 45 dc 05 00 00 00 	movl   $0x5,-0x24(%ebp)
                    break;
c0000724:	eb 26                	jmp    c000074c <kprintf+0x2cd>
                case 'j':
                    length_mod = INTMAX;
c0000726:	c7 45 dc 06 00 00 00 	movl   $0x6,-0x24(%ebp)
                    break;
c000072d:	eb 1d                	jmp    c000074c <kprintf+0x2cd>
                case 'Z':
                case 'z':
                    length_mod = SIZE;
c000072f:	c7 45 dc 07 00 00 00 	movl   $0x7,-0x24(%ebp)
                    break;
c0000736:	eb 14                	jmp    c000074c <kprintf+0x2cd>
                case 't':
                    length_mod = PTRDIFF;
c0000738:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
                    break;
c000073f:	eb 0b                	jmp    c000074c <kprintf+0x2cd>
                default:
                    f--; //no length mod, back up a char...
c0000741:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
                    length_mod = DEFAULT;
c0000745:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
            }

            //parse field
            char val_buf[512]; //assuming here that numberical values cannot exceed 512 chars 
            if(field_width>511)
c000074c:	81 7d e8 ff 01 00 00 	cmpl   $0x1ff,-0x18(%ebp)
c0000753:	7e 0a                	jle    c000075f <kprintf+0x2e0>
                return -1;
c0000755:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000075a:	e9 f3 07 00 00       	jmp    c0000f52 <kprintf+0xad3>

            switch(*f)
c000075f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000762:	0f b6 00             	movzbl (%eax),%eax
c0000765:	0f be c0             	movsbl %al,%eax
c0000768:	83 e8 45             	sub    $0x45,%eax
c000076b:	83 f8 33             	cmp    $0x33,%eax
c000076e:	0f 87 97 07 00 00    	ja     c0000f0b <kprintf+0xa8c>
c0000774:	8b 04 85 00 41 00 c0 	mov    -0x3fffbf00(,%eax,4),%eax
c000077b:	ff e0                	jmp    *%eax
c000077d:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000781:	0f 87 67 01 00 00    	ja     c00008ee <kprintf+0x46f>
                        case(LONGINT):
                        case(LONGLONGINT):
                        case(DEFAULT):
                            {
                                int i_value;
                                if(length_mod == LONGLONGINT)
c0000787:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c000078b:	75 19                	jne    c00007a6 <kprintf+0x327>
                                    i_value = (int) va_arg(valist, long long int); //TODO: implement actual longlong handling
c000078d:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000793:	8d 50 08             	lea    0x8(%eax),%edx
c0000796:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c000079c:	8b 50 04             	mov    0x4(%eax),%edx
c000079f:	8b 00                	mov    (%eax),%eax
c00007a1:	89 45 d8             	mov    %eax,-0x28(%ebp)
c00007a4:	eb 14                	jmp    c00007ba <kprintf+0x33b>
                                else
                                    i_value = va_arg(valist, int);
c00007a6:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c00007ac:	8d 50 04             	lea    0x4(%eax),%edx
c00007af:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c00007b5:	8b 00                	mov    (%eax),%eax
c00007b7:	89 45 d8             	mov    %eax,-0x28(%ebp)

                                char sign_char = 0; //sign character or 0 if none
c00007ba:	c6 45 d7 00          	movb   $0x0,-0x29(%ebp)
                                unsigned int ui_value; //unsigned value (abs value)
                                if(i_value<0)
c00007be:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c00007c2:	79 0e                	jns    c00007d2 <kprintf+0x353>
                                {
                                    ui_value = -i_value;
c00007c4:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00007c7:	f7 d8                	neg    %eax
c00007c9:	89 45 d0             	mov    %eax,-0x30(%ebp)
                                    sign_char = '-';
c00007cc:	c6 45 d7 2d          	movb   $0x2d,-0x29(%ebp)
c00007d0:	eb 26                	jmp    c00007f8 <kprintf+0x379>
                                }
                                else
                                {
                                    ui_value = i_value;
c00007d2:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00007d5:	89 45 d0             	mov    %eax,-0x30(%ebp)
                                    if(flags.sign)
c00007d8:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c00007df:	84 c0                	test   %al,%al
c00007e1:	74 06                	je     c00007e9 <kprintf+0x36a>
                                        sign_char = '+';
c00007e3:	c6 45 d7 2b          	movb   $0x2b,-0x29(%ebp)
c00007e7:	eb 0f                	jmp    c00007f8 <kprintf+0x379>
                                    else if(flags.space)
c00007e9:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c00007f0:	84 c0                	test   %al,%al
c00007f2:	74 04                	je     c00007f8 <kprintf+0x379>
                                        sign_char = ' ';
c00007f4:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
                                    
                                    //else positive number has no sign character
                                }

                                //convert value into string
                                int len = format_uint(ui_value, val_buf, 10, field_prec, 0);
c00007f8:	83 ec 0c             	sub    $0xc,%esp
c00007fb:	6a 00                	push   $0x0
c00007fd:	ff 75 e0             	pushl  -0x20(%ebp)
c0000800:	6a 0a                	push   $0xa
c0000802:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000808:	50                   	push   %eax
c0000809:	ff 75 d0             	pushl  -0x30(%ebp)
c000080c:	e8 43 07 00 00       	call   c0000f54 <format_uint>
c0000811:	83 c4 20             	add    $0x20,%esp
c0000814:	89 45 9c             	mov    %eax,-0x64(%ebp)
                                //amount of padding required to meet requested width
                                int lenpad = field_width - len; 
c0000817:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000081a:	2b 45 9c             	sub    -0x64(%ebp),%eax
c000081d:	89 45 cc             	mov    %eax,-0x34(%ebp)

                                if(sign_char)
c0000820:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
c0000824:	74 22                	je     c0000848 <kprintf+0x3c9>
                                {
                                    lenpad--; //remove one char of padding to account for sign
c0000826:	83 6d cc 01          	subl   $0x1,-0x34(%ebp)
                                    if(flags.zero)
c000082a:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000831:	84 c0                	test   %al,%al
c0000833:	74 13                	je     c0000848 <kprintf+0x3c9>
                                        nchar += kprint_char(sign_char); //if zero padding, sign is at beginning
c0000835:	0f be 45 d7          	movsbl -0x29(%ebp),%eax
c0000839:	83 ec 0c             	sub    $0xc,%esp
c000083c:	50                   	push   %eax
c000083d:	e8 ec fb ff ff       	call   c000042e <kprint_char>
c0000842:	83 c4 10             	add    $0x10,%esp
c0000845:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                if(!flags.left && lenpad>0)
c0000848:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c000084f:	84 c0                	test   %al,%al
c0000851:	75 3b                	jne    c000088e <kprintf+0x40f>
c0000853:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
c0000857:	7e 35                	jle    c000088e <kprintf+0x40f>
                                {
                                    if(flags.zero)
c0000859:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000860:	84 c0                	test   %al,%al
c0000862:	74 16                	je     c000087a <kprintf+0x3fb>
                                        nchar += kprintn_char('0', lenpad);
c0000864:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0000867:	83 ec 08             	sub    $0x8,%esp
c000086a:	50                   	push   %eax
c000086b:	6a 30                	push   $0x30
c000086d:	e8 e4 fb ff ff       	call   c0000456 <kprintn_char>
c0000872:	83 c4 10             	add    $0x10,%esp
c0000875:	01 45 f0             	add    %eax,-0x10(%ebp)
c0000878:	eb 14                	jmp    c000088e <kprintf+0x40f>
                                    else
                                        nchar += kprintn_char(' ', lenpad);
c000087a:	8b 45 cc             	mov    -0x34(%ebp),%eax
c000087d:	83 ec 08             	sub    $0x8,%esp
c0000880:	50                   	push   %eax
c0000881:	6a 20                	push   $0x20
c0000883:	e8 ce fb ff ff       	call   c0000456 <kprintn_char>
c0000888:	83 c4 10             	add    $0x10,%esp
c000088b:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                if(!flags.zero && sign_char)
c000088e:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000895:	84 c0                	test   %al,%al
c0000897:	75 19                	jne    c00008b2 <kprintf+0x433>
c0000899:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
c000089d:	74 13                	je     c00008b2 <kprintf+0x433>
                                    nchar += kprint_char(sign_char); //if not zero padding, write sign here
c000089f:	0f be 45 d7          	movsbl -0x29(%ebp),%eax
c00008a3:	83 ec 0c             	sub    $0xc,%esp
c00008a6:	50                   	push   %eax
c00008a7:	e8 82 fb ff ff       	call   c000042e <kprint_char>
c00008ac:	83 c4 10             	add    $0x10,%esp
c00008af:	01 45 f0             	add    %eax,-0x10(%ebp)

                                nchar += kprint(val_buf);
c00008b2:	83 ec 0c             	sub    $0xc,%esp
c00008b5:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c00008bb:	50                   	push   %eax
c00008bc:	e8 23 fb ff ff       	call   c00003e4 <kprint>
c00008c1:	83 c4 10             	add    $0x10,%esp
c00008c4:	01 45 f0             	add    %eax,-0x10(%ebp)

                                if(flags.left && lenpad>0)
c00008c7:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c00008ce:	84 c0                	test   %al,%al
c00008d0:	74 26                	je     c00008f8 <kprintf+0x479>
c00008d2:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
c00008d6:	7e 20                	jle    c00008f8 <kprintf+0x479>
                                    nchar += kprintn_char(' ', lenpad);
c00008d8:	8b 45 cc             	mov    -0x34(%ebp),%eax
c00008db:	83 ec 08             	sub    $0x8,%esp
c00008de:	50                   	push   %eax
c00008df:	6a 20                	push   $0x20
c00008e1:	e8 70 fb ff ff       	call   c0000456 <kprintn_char>
c00008e6:	83 c4 10             	add    $0x10,%esp
c00008e9:	01 45 f0             	add    %eax,-0x10(%ebp)


                            }
                            break;
c00008ec:	eb 0a                	jmp    c00008f8 <kprintf+0x479>
                        default:
                            return -1; //invalid length mod
c00008ee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00008f3:	e9 5a 06 00 00       	jmp    c0000f52 <kprintf+0xad3>
                            break;
c00008f8:	90                   	nop
                    }
                    break;
c00008f9:	e9 1e 06 00 00       	jmp    c0000f1c <kprintf+0xa9d>
c00008fe:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000902:	0f 87 03 02 00 00    	ja     c0000b0b <kprintf+0x68c>
                        case(SHORTINT):
                        case(LONGINT):
                        case(LONGLONGINT):
                        case(DEFAULT):
                            {
                                unsigned int base = 10;
c0000908:	c7 45 c8 0a 00 00 00 	movl   $0xa,-0x38(%ebp)
                                unsigned int ui_value;
                                if(length_mod == LONGLONGINT)
c000090f:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
c0000913:	75 19                	jne    c000092e <kprintf+0x4af>
                                    ui_value = (unsigned int) va_arg(valist, long long unsigned int); //TODO: implement actual longlong handling
c0000915:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c000091b:	8d 50 08             	lea    0x8(%eax),%edx
c000091e:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000924:	8b 50 04             	mov    0x4(%eax),%edx
c0000927:	8b 00                	mov    (%eax),%eax
c0000929:	89 45 c4             	mov    %eax,-0x3c(%ebp)
c000092c:	eb 14                	jmp    c0000942 <kprintf+0x4c3>
                                else
                                    ui_value = va_arg(valist, unsigned int);
c000092e:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000934:	8d 50 04             	lea    0x4(%eax),%edx
c0000937:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c000093d:	8b 00                	mov    (%eax),%eax
c000093f:	89 45 c4             	mov    %eax,-0x3c(%ebp)

                                if(*f == 'o')
c0000942:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000945:	0f b6 00             	movzbl (%eax),%eax
c0000948:	3c 6f                	cmp    $0x6f,%al
c000094a:	75 09                	jne    c0000955 <kprintf+0x4d6>
                                    base = 8;
c000094c:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
c0000953:	eb 3e                	jmp    c0000993 <kprintf+0x514>
                                else if(*f == 'x' || *f == 'X')
c0000955:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000958:	0f b6 00             	movzbl (%eax),%eax
c000095b:	3c 78                	cmp    $0x78,%al
c000095d:	74 0a                	je     c0000969 <kprintf+0x4ea>
c000095f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000962:	0f b6 00             	movzbl (%eax),%eax
c0000965:	3c 58                	cmp    $0x58,%al
c0000967:	75 09                	jne    c0000972 <kprintf+0x4f3>
                                    base = 16;
c0000969:	c7 45 c8 10 00 00 00 	movl   $0x10,-0x38(%ebp)
c0000970:	eb 21                	jmp    c0000993 <kprintf+0x514>
                                else if(*f == 'p')
c0000972:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000975:	0f b6 00             	movzbl (%eax),%eax
c0000978:	3c 70                	cmp    $0x70,%al
c000097a:	75 10                	jne    c000098c <kprintf+0x50d>
                                {
                                    //print as hex with 0x prefix
                                    base = 16;
c000097c:	c7 45 c8 10 00 00 00 	movl   $0x10,-0x38(%ebp)
                                    flags.alt = 1; 
c0000983:	c6 85 77 ff ff ff 01 	movb   $0x1,-0x89(%ebp)
c000098a:	eb 07                	jmp    c0000993 <kprintf+0x514>
                                }
                                else
                                    flags.alt = 0;
c000098c:	c6 85 77 ff ff ff 00 	movb   $0x0,-0x89(%ebp)
                                
                                int cap = (*f == 'X') ? 1 : 0;
c0000993:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000996:	0f b6 00             	movzbl (%eax),%eax
c0000999:	3c 58                	cmp    $0x58,%al
c000099b:	0f 94 c0             	sete   %al
c000099e:	0f b6 c0             	movzbl %al,%eax
c00009a1:	89 45 94             	mov    %eax,-0x6c(%ebp)

                                //convert value into string
                                int len = format_uint(ui_value, val_buf, base, field_prec, cap);
c00009a4:	83 ec 0c             	sub    $0xc,%esp
c00009a7:	ff 75 94             	pushl  -0x6c(%ebp)
c00009aa:	ff 75 e0             	pushl  -0x20(%ebp)
c00009ad:	ff 75 c8             	pushl  -0x38(%ebp)
c00009b0:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c00009b6:	50                   	push   %eax
c00009b7:	ff 75 c4             	pushl  -0x3c(%ebp)
c00009ba:	e8 95 05 00 00       	call   c0000f54 <format_uint>
c00009bf:	83 c4 20             	add    $0x20,%esp
c00009c2:	89 45 90             	mov    %eax,-0x70(%ebp)
                                //amount of padding required to meet requested width
                                int lenpad = field_width - len; 
c00009c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00009c8:	2b 45 90             	sub    -0x70(%ebp),%eax
c00009cb:	89 45 c0             	mov    %eax,-0x40(%ebp)


                                //format radix prefix for oct and hex with alt flag
                                char radix[3]="";
c00009ce:	66 c7 85 74 ff ff ff 	movw   $0x0,-0x8c(%ebp)
c00009d5:	00 00 
c00009d7:	c6 85 76 ff ff ff 00 	movb   $0x0,-0x8a(%ebp)
                                if(flags.alt)
c00009de:	0f b6 85 77 ff ff ff 	movzbl -0x89(%ebp),%eax
c00009e5:	84 c0                	test   %al,%al
c00009e7:	74 75                	je     c0000a5e <kprintf+0x5df>
                                {
                                    if(base==16)
c00009e9:	83 7d c8 10          	cmpl   $0x10,-0x38(%ebp)
c00009ed:	75 2c                	jne    c0000a1b <kprintf+0x59c>
                                    {
                                        lenpad -= 2;
c00009ef:	83 6d c0 02          	subl   $0x2,-0x40(%ebp)
                                        radix[0] = '0';
c00009f3:	c6 85 74 ff ff ff 30 	movb   $0x30,-0x8c(%ebp)
                                        radix[1] = cap ? 'X' : 'x';
c00009fa:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
c00009fe:	74 07                	je     c0000a07 <kprintf+0x588>
c0000a00:	b8 58 00 00 00       	mov    $0x58,%eax
c0000a05:	eb 05                	jmp    c0000a0c <kprintf+0x58d>
c0000a07:	b8 78 00 00 00       	mov    $0x78,%eax
c0000a0c:	88 85 75 ff ff ff    	mov    %al,-0x8b(%ebp)
                                        radix[2] = 0;
c0000a12:	c6 85 76 ff ff ff 00 	movb   $0x0,-0x8a(%ebp)
c0000a19:	eb 23                	jmp    c0000a3e <kprintf+0x5bf>
                                    }
                                    else if(base==8 && val_buf[0] != '0')
c0000a1b:	83 7d c8 08          	cmpl   $0x8,-0x38(%ebp)
c0000a1f:	75 1d                	jne    c0000a3e <kprintf+0x5bf>
c0000a21:	0f b6 85 74 fd ff ff 	movzbl -0x28c(%ebp),%eax
c0000a28:	3c 30                	cmp    $0x30,%al
c0000a2a:	74 12                	je     c0000a3e <kprintf+0x5bf>
                                    {
                                        lenpad -= 1;
c0000a2c:	83 6d c0 01          	subl   $0x1,-0x40(%ebp)
                                        radix[0] = '0';
c0000a30:	c6 85 74 ff ff ff 30 	movb   $0x30,-0x8c(%ebp)
                                        radix[1] = 0;
c0000a37:	c6 85 75 ff ff ff 00 	movb   $0x0,-0x8b(%ebp)
                                    }

                                    //if zero padding, radix is printed first
                                    if(flags.zero)
c0000a3e:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000a45:	84 c0                	test   %al,%al
c0000a47:	74 15                	je     c0000a5e <kprintf+0x5df>
                                        nchar += kprint(radix);
c0000a49:	83 ec 0c             	sub    $0xc,%esp
c0000a4c:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
c0000a52:	50                   	push   %eax
c0000a53:	e8 8c f9 ff ff       	call   c00003e4 <kprint>
c0000a58:	83 c4 10             	add    $0x10,%esp
c0000a5b:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }


                                //print leading padding, if any
                                if(!flags.left && lenpad>0)
c0000a5e:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000a65:	84 c0                	test   %al,%al
c0000a67:	75 3b                	jne    c0000aa4 <kprintf+0x625>
c0000a69:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
c0000a6d:	7e 35                	jle    c0000aa4 <kprintf+0x625>
                                {
                                    if(flags.zero)
c0000a6f:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000a76:	84 c0                	test   %al,%al
c0000a78:	74 16                	je     c0000a90 <kprintf+0x611>
                                        nchar += kprintn_char('0', lenpad);
c0000a7a:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000a7d:	83 ec 08             	sub    $0x8,%esp
c0000a80:	50                   	push   %eax
c0000a81:	6a 30                	push   $0x30
c0000a83:	e8 ce f9 ff ff       	call   c0000456 <kprintn_char>
c0000a88:	83 c4 10             	add    $0x10,%esp
c0000a8b:	01 45 f0             	add    %eax,-0x10(%ebp)
c0000a8e:	eb 14                	jmp    c0000aa4 <kprintf+0x625>
                                    else
                                        nchar += kprintn_char(' ', lenpad);
c0000a90:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000a93:	83 ec 08             	sub    $0x8,%esp
c0000a96:	50                   	push   %eax
c0000a97:	6a 20                	push   $0x20
c0000a99:	e8 b8 f9 ff ff       	call   c0000456 <kprintn_char>
c0000a9e:	83 c4 10             	add    $0x10,%esp
c0000aa1:	01 45 f0             	add    %eax,-0x10(%ebp)
                                }

                                //print radix prefix if valid and not leading zeros
                                if(!flags.zero && radix[0])
c0000aa4:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000aab:	84 c0                	test   %al,%al
c0000aad:	75 20                	jne    c0000acf <kprintf+0x650>
c0000aaf:	0f b6 85 74 ff ff ff 	movzbl -0x8c(%ebp),%eax
c0000ab6:	84 c0                	test   %al,%al
c0000ab8:	74 15                	je     c0000acf <kprintf+0x650>
                                    nchar += kprint(radix);
c0000aba:	83 ec 0c             	sub    $0xc,%esp
c0000abd:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
c0000ac3:	50                   	push   %eax
c0000ac4:	e8 1b f9 ff ff       	call   c00003e4 <kprint>
c0000ac9:	83 c4 10             	add    $0x10,%esp
c0000acc:	01 45 f0             	add    %eax,-0x10(%ebp)

                                //print number itself
                                nchar += kprint(val_buf);
c0000acf:	83 ec 0c             	sub    $0xc,%esp
c0000ad2:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000ad8:	50                   	push   %eax
c0000ad9:	e8 06 f9 ff ff       	call   c00003e4 <kprint>
c0000ade:	83 c4 10             	add    $0x10,%esp
c0000ae1:	01 45 f0             	add    %eax,-0x10(%ebp)

                                //print trailing padding if left justified
                                if(flags.left && lenpad>0)
c0000ae4:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000aeb:	84 c0                	test   %al,%al
c0000aed:	74 26                	je     c0000b15 <kprintf+0x696>
c0000aef:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
c0000af3:	7e 20                	jle    c0000b15 <kprintf+0x696>
                                    nchar += kprintn_char(' ', lenpad);
c0000af5:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0000af8:	83 ec 08             	sub    $0x8,%esp
c0000afb:	50                   	push   %eax
c0000afc:	6a 20                	push   $0x20
c0000afe:	e8 53 f9 ff ff       	call   c0000456 <kprintn_char>
c0000b03:	83 c4 10             	add    $0x10,%esp
c0000b06:	01 45 f0             	add    %eax,-0x10(%ebp)

                            }
                            break;
c0000b09:	eb 0a                	jmp    c0000b15 <kprintf+0x696>
                        default:
                            return -1; //invalid length mod
c0000b0b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000b10:	e9 3d 04 00 00       	jmp    c0000f52 <kprintf+0xad3>
                            break;
c0000b15:	90                   	nop
                    }

                    break;
c0000b16:	e9 01 04 00 00       	jmp    c0000f1c <kprintf+0xa9d>

                case 'f':
                case 'F':
                    {
                        float f_value = (float) va_arg(valist, double);
c0000b1b:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000b21:	8d 50 08             	lea    0x8(%eax),%edx
c0000b24:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000b2a:	dd 00                	fldl   (%eax)
c0000b2c:	d9 5d 8c             	fstps  -0x74(%ebp)

                        //When 0 is printed with an explicit precision 0, the output is empty.
                        if(f_value==0 && field_prec==0)
c0000b2f:	d9 45 8c             	flds   -0x74(%ebp)
c0000b32:	d9 ee                	fldz   
c0000b34:	df e9                	fucomip %st(1),%st
c0000b36:	dd d8                	fstp   %st(0)
c0000b38:	7a 15                	jp     c0000b4f <kprintf+0x6d0>
c0000b3a:	d9 45 8c             	flds   -0x74(%ebp)
c0000b3d:	d9 ee                	fldz   
c0000b3f:	df e9                	fucomip %st(1),%st
c0000b41:	dd d8                	fstp   %st(0)
c0000b43:	75 0a                	jne    c0000b4f <kprintf+0x6d0>
c0000b45:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000b49:	0f 84 c3 03 00 00    	je     c0000f12 <kprintf+0xa93>
                            break;
                        if(field_prec<0) field_prec = 6;  //default is prec = 6
c0000b4f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000b53:	79 07                	jns    c0000b5c <kprintf+0x6dd>
c0000b55:	c7 45 e0 06 00 00 00 	movl   $0x6,-0x20(%ebp)

                        unsigned int ui_part;
                        char sign_char = 0;
c0000b5c:	c6 45 bb 00          	movb   $0x0,-0x45(%ebp)
                        if(f_value<0)
c0000b60:	d9 45 8c             	flds   -0x74(%ebp)
c0000b63:	d9 ee                	fldz   
c0000b65:	df f1                	fcomip %st(1),%st
c0000b67:	dd d8                	fstp   %st(0)
c0000b69:	76 3d                	jbe    c0000ba8 <kprintf+0x729>
                        {
                            ui_part = (unsigned int) -f_value;
c0000b6b:	d9 45 8c             	flds   -0x74(%ebp)
c0000b6e:	d9 e0                	fchs   
c0000b70:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c0000b76:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c0000b7d:	80 cc 0c             	or     $0xc,%ah
c0000b80:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c0000b87:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c0000b8d:	df bd 58 fd ff ff    	fistpll -0x2a8(%ebp)
c0000b93:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
c0000b99:	8b 85 58 fd ff ff    	mov    -0x2a8(%ebp),%eax
c0000b9f:	89 45 bc             	mov    %eax,-0x44(%ebp)
                            sign_char = '-';
c0000ba2:	c6 45 bb 2d          	movb   $0x2d,-0x45(%ebp)
c0000ba6:	eb 55                	jmp    c0000bfd <kprintf+0x77e>
                        }
                        else
                        {
                            ui_part = (unsigned int) f_value;
c0000ba8:	d9 45 8c             	flds   -0x74(%ebp)
c0000bab:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c0000bb1:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c0000bb8:	80 cc 0c             	or     $0xc,%ah
c0000bbb:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c0000bc2:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c0000bc8:	df bd 58 fd ff ff    	fistpll -0x2a8(%ebp)
c0000bce:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
c0000bd4:	8b 85 58 fd ff ff    	mov    -0x2a8(%ebp),%eax
c0000bda:	89 45 bc             	mov    %eax,-0x44(%ebp)
                            if(flags.sign)
c0000bdd:	0f b6 85 7b ff ff ff 	movzbl -0x85(%ebp),%eax
c0000be4:	84 c0                	test   %al,%al
c0000be6:	74 06                	je     c0000bee <kprintf+0x76f>
                                sign_char = '+';
c0000be8:	c6 45 bb 2b          	movb   $0x2b,-0x45(%ebp)
c0000bec:	eb 0f                	jmp    c0000bfd <kprintf+0x77e>
                            else if(flags.space)
c0000bee:	0f b6 85 7a ff ff ff 	movzbl -0x86(%ebp),%eax
c0000bf5:	84 c0                	test   %al,%al
c0000bf7:	74 04                	je     c0000bfd <kprintf+0x77e>
                                sign_char = ' ';
c0000bf9:	c6 45 bb 20          	movb   $0x20,-0x45(%ebp)
                            
                            //else positive number has no sign character
                        }

                        int int_len = format_uint(ui_part,val_buf,10,-1,0);
c0000bfd:	83 ec 0c             	sub    $0xc,%esp
c0000c00:	6a 00                	push   $0x0
c0000c02:	6a ff                	push   $0xffffffff
c0000c04:	6a 0a                	push   $0xa
c0000c06:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000c0c:	50                   	push   %eax
c0000c0d:	ff 75 bc             	pushl  -0x44(%ebp)
c0000c10:	e8 3f 03 00 00       	call   c0000f54 <format_uint>
c0000c15:	83 c4 20             	add    $0x20,%esp
c0000c18:	89 45 88             	mov    %eax,-0x78(%ebp)

                        int f_len = int_len + 1 + field_prec;
c0000c1b:	8b 45 88             	mov    -0x78(%ebp),%eax
c0000c1e:	8d 50 01             	lea    0x1(%eax),%edx
c0000c21:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0000c24:	01 d0                	add    %edx,%eax
c0000c26:	89 45 84             	mov    %eax,-0x7c(%ebp)

                        //amount of padding required to meet requested width
                        int lenpad = field_width - f_len; 
c0000c29:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000c2c:	2b 45 84             	sub    -0x7c(%ebp),%eax
c0000c2f:	89 45 b4             	mov    %eax,-0x4c(%ebp)

                        if(sign_char)
c0000c32:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
c0000c36:	74 22                	je     c0000c5a <kprintf+0x7db>
                        {
                            lenpad--; //remove one char of padding to account for sign
c0000c38:	83 6d b4 01          	subl   $0x1,-0x4c(%ebp)
                            if(flags.zero)
c0000c3c:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000c43:	84 c0                	test   %al,%al
c0000c45:	74 13                	je     c0000c5a <kprintf+0x7db>
                                nchar += kprint_char(sign_char); //if zero padding, sign is at beginning
c0000c47:	0f be 45 bb          	movsbl -0x45(%ebp),%eax
c0000c4b:	83 ec 0c             	sub    $0xc,%esp
c0000c4e:	50                   	push   %eax
c0000c4f:	e8 da f7 ff ff       	call   c000042e <kprint_char>
c0000c54:	83 c4 10             	add    $0x10,%esp
c0000c57:	01 45 f0             	add    %eax,-0x10(%ebp)
                        }

                        if(!flags.left && lenpad>0)
c0000c5a:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000c61:	84 c0                	test   %al,%al
c0000c63:	75 3b                	jne    c0000ca0 <kprintf+0x821>
c0000c65:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
c0000c69:	7e 35                	jle    c0000ca0 <kprintf+0x821>
                        {
                            if(flags.zero)
c0000c6b:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000c72:	84 c0                	test   %al,%al
c0000c74:	74 16                	je     c0000c8c <kprintf+0x80d>
                                nchar += kprintn_char('0', lenpad);
c0000c76:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c0000c79:	83 ec 08             	sub    $0x8,%esp
c0000c7c:	50                   	push   %eax
c0000c7d:	6a 30                	push   $0x30
c0000c7f:	e8 d2 f7 ff ff       	call   c0000456 <kprintn_char>
c0000c84:	83 c4 10             	add    $0x10,%esp
c0000c87:	01 45 f0             	add    %eax,-0x10(%ebp)
c0000c8a:	eb 14                	jmp    c0000ca0 <kprintf+0x821>
                            else
                                nchar += kprintn_char(' ', lenpad);
c0000c8c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c0000c8f:	83 ec 08             	sub    $0x8,%esp
c0000c92:	50                   	push   %eax
c0000c93:	6a 20                	push   $0x20
c0000c95:	e8 bc f7 ff ff       	call   c0000456 <kprintn_char>
c0000c9a:	83 c4 10             	add    $0x10,%esp
c0000c9d:	01 45 f0             	add    %eax,-0x10(%ebp)
                        }

                        if(!flags.zero && sign_char)
c0000ca0:	0f b6 85 78 ff ff ff 	movzbl -0x88(%ebp),%eax
c0000ca7:	84 c0                	test   %al,%al
c0000ca9:	75 19                	jne    c0000cc4 <kprintf+0x845>
c0000cab:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
c0000caf:	74 13                	je     c0000cc4 <kprintf+0x845>
                            nchar += kprint_char(sign_char); //if not zero padding, write sign here
c0000cb1:	0f be 45 bb          	movsbl -0x45(%ebp),%eax
c0000cb5:	83 ec 0c             	sub    $0xc,%esp
c0000cb8:	50                   	push   %eax
c0000cb9:	e8 70 f7 ff ff       	call   c000042e <kprint_char>
c0000cbe:	83 c4 10             	add    $0x10,%esp
c0000cc1:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprint(val_buf);
c0000cc4:	83 ec 0c             	sub    $0xc,%esp
c0000cc7:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
c0000ccd:	50                   	push   %eax
c0000cce:	e8 11 f7 ff ff       	call   c00003e4 <kprint>
c0000cd3:	83 c4 10             	add    $0x10,%esp
c0000cd6:	01 45 f0             	add    %eax,-0x10(%ebp)
                        nchar += kprint_char('.');
c0000cd9:	83 ec 0c             	sub    $0xc,%esp
c0000cdc:	6a 2e                	push   $0x2e
c0000cde:	e8 4b f7 ff ff       	call   c000042e <kprint_char>
c0000ce3:	83 c4 10             	add    $0x10,%esp
c0000ce6:	01 45 f0             	add    %eax,-0x10(%ebp)

                        //compute fractional digits.
                        float frac = f_value<0 ? -f_value - ui_part : f_value - ui_part;
c0000ce9:	d9 45 8c             	flds   -0x74(%ebp)
c0000cec:	d9 ee                	fldz   
c0000cee:	df f1                	fcomip %st(1),%st
c0000cf0:	dd d8                	fstp   %st(0)
c0000cf2:	76 23                	jbe    c0000d17 <kprintf+0x898>
c0000cf4:	d9 45 8c             	flds   -0x74(%ebp)
c0000cf7:	d9 e0                	fchs   
c0000cf9:	8b 45 bc             	mov    -0x44(%ebp),%eax
c0000cfc:	ba 00 00 00 00       	mov    $0x0,%edx
c0000d01:	89 85 58 fd ff ff    	mov    %eax,-0x2a8(%ebp)
c0000d07:	89 95 5c fd ff ff    	mov    %edx,-0x2a4(%ebp)
c0000d0d:	df ad 58 fd ff ff    	fildll -0x2a8(%ebp)
c0000d13:	de e9                	fsubrp %st,%st(1)
c0000d15:	eb 1f                	jmp    c0000d36 <kprintf+0x8b7>
c0000d17:	8b 45 bc             	mov    -0x44(%ebp),%eax
c0000d1a:	ba 00 00 00 00       	mov    $0x0,%edx
c0000d1f:	89 85 58 fd ff ff    	mov    %eax,-0x2a8(%ebp)
c0000d25:	89 95 5c fd ff ff    	mov    %edx,-0x2a4(%ebp)
c0000d2b:	df ad 58 fd ff ff    	fildll -0x2a8(%ebp)
c0000d31:	d9 45 8c             	flds   -0x74(%ebp)
c0000d34:	de e1                	fsubp  %st,%st(1)
c0000d36:	d9 5d b0             	fstps  -0x50(%ebp)
                        int d;
                        for(int nn=0;nn<field_prec; nn++)
c0000d39:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
c0000d40:	eb 5e                	jmp    c0000da0 <kprintf+0x921>
                        {
                            frac *= 10.;
c0000d42:	d9 45 b0             	flds   -0x50(%ebp)
c0000d45:	d9 05 1c 44 00 c0    	flds   0xc000441c
c0000d4b:	de c9                	fmulp  %st,%st(1)
c0000d4d:	d9 5d b0             	fstps  -0x50(%ebp)
                            d = (int) frac;
c0000d50:	d9 45 b0             	flds   -0x50(%ebp)
c0000d53:	d9 bd 66 fd ff ff    	fnstcw -0x29a(%ebp)
c0000d59:	0f b7 85 66 fd ff ff 	movzwl -0x29a(%ebp),%eax
c0000d60:	80 cc 0c             	or     $0xc,%ah
c0000d63:	66 89 85 64 fd ff ff 	mov    %ax,-0x29c(%ebp)
c0000d6a:	d9 ad 64 fd ff ff    	fldcw  -0x29c(%ebp)
c0000d70:	db 5d 80             	fistpl -0x80(%ebp)
c0000d73:	d9 ad 66 fd ff ff    	fldcw  -0x29a(%ebp)
                            frac -= d;
c0000d79:	db 45 80             	fildl  -0x80(%ebp)
c0000d7c:	d9 45 b0             	flds   -0x50(%ebp)
c0000d7f:	de e1                	fsubp  %st,%st(1)
c0000d81:	d9 5d b0             	fstps  -0x50(%ebp)
                            nchar += kprint_char('0' + d);
c0000d84:	8b 45 80             	mov    -0x80(%ebp),%eax
c0000d87:	83 c0 30             	add    $0x30,%eax
c0000d8a:	0f be c0             	movsbl %al,%eax
c0000d8d:	83 ec 0c             	sub    $0xc,%esp
c0000d90:	50                   	push   %eax
c0000d91:	e8 98 f6 ff ff       	call   c000042e <kprint_char>
c0000d96:	83 c4 10             	add    $0x10,%esp
c0000d99:	01 45 f0             	add    %eax,-0x10(%ebp)
                        for(int nn=0;nn<field_prec; nn++)
c0000d9c:	83 45 ac 01          	addl   $0x1,-0x54(%ebp)
c0000da0:	8b 45 ac             	mov    -0x54(%ebp),%eax
c0000da3:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c0000da6:	7c 9a                	jl     c0000d42 <kprintf+0x8c3>
                        }

                        if(flags.left && lenpad>0)
c0000da8:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000daf:	84 c0                	test   %al,%al
c0000db1:	0f 84 5e 01 00 00    	je     c0000f15 <kprintf+0xa96>
c0000db7:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
c0000dbb:	0f 8e 54 01 00 00    	jle    c0000f15 <kprintf+0xa96>
                            nchar += kprintn_char(' ', lenpad);
c0000dc1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c0000dc4:	83 ec 08             	sub    $0x8,%esp
c0000dc7:	50                   	push   %eax
c0000dc8:	6a 20                	push   $0x20
c0000dca:	e8 87 f6 ff ff       	call   c0000456 <kprintn_char>
c0000dcf:	83 c4 10             	add    $0x10,%esp
c0000dd2:	01 45 f0             	add    %eax,-0x10(%ebp)

                    }
                    break;
c0000dd5:	e9 3b 01 00 00       	jmp    c0000f15 <kprintf+0xa96>
                case 'e':
                case 'E':
                case 'g':
                case 'G':
                    return -1; // not yet implemented
c0000dda:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000ddf:	e9 6e 01 00 00       	jmp    c0000f52 <kprintf+0xad3>
                case 'c':
                    {
                        char c = (char) va_arg(valist, int);
c0000de4:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000dea:	8d 50 04             	lea    0x4(%eax),%edx
c0000ded:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000df3:	8b 00                	mov    (%eax),%eax
c0000df5:	88 45 9b             	mov    %al,-0x65(%ebp)

                        if(field_width>1 && !flags.left)    
c0000df8:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
c0000dfc:	7e 22                	jle    c0000e20 <kprintf+0x9a1>
c0000dfe:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000e05:	84 c0                	test   %al,%al
c0000e07:	75 17                	jne    c0000e20 <kprintf+0x9a1>
                            nchar += kprintn_char(' ', field_width-1);
c0000e09:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000e0c:	83 e8 01             	sub    $0x1,%eax
c0000e0f:	83 ec 08             	sub    $0x8,%esp
c0000e12:	50                   	push   %eax
c0000e13:	6a 20                	push   $0x20
c0000e15:	e8 3c f6 ff ff       	call   c0000456 <kprintn_char>
c0000e1a:	83 c4 10             	add    $0x10,%esp
c0000e1d:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprint_char(c);
c0000e20:	0f be 45 9b          	movsbl -0x65(%ebp),%eax
c0000e24:	83 ec 0c             	sub    $0xc,%esp
c0000e27:	50                   	push   %eax
c0000e28:	e8 01 f6 ff ff       	call   c000042e <kprint_char>
c0000e2d:	83 c4 10             	add    $0x10,%esp
c0000e30:	01 45 f0             	add    %eax,-0x10(%ebp)

                        if(field_width>1 && flags.left)    
c0000e33:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
c0000e37:	0f 8e db 00 00 00    	jle    c0000f18 <kprintf+0xa99>
c0000e3d:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000e44:	84 c0                	test   %al,%al
c0000e46:	0f 84 cc 00 00 00    	je     c0000f18 <kprintf+0xa99>
                            nchar += kprintn_char(' ', field_width-1);
c0000e4c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000e4f:	83 e8 01             	sub    $0x1,%eax
c0000e52:	83 ec 08             	sub    $0x8,%esp
c0000e55:	50                   	push   %eax
c0000e56:	6a 20                	push   $0x20
c0000e58:	e8 f9 f5 ff ff       	call   c0000456 <kprintn_char>
c0000e5d:	83 c4 10             	add    $0x10,%esp
c0000e60:	01 45 f0             	add    %eax,-0x10(%ebp)
                    }                    
                    break;
c0000e63:	e9 b0 00 00 00       	jmp    c0000f18 <kprintf+0xa99>

                case 's':
                    {
                        char* str = va_arg(valist, char*);
c0000e68:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0000e6e:	8d 50 04             	lea    0x4(%eax),%edx
c0000e71:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0000e77:	8b 00                	mov    (%eax),%eax
c0000e79:	89 45 a4             	mov    %eax,-0x5c(%ebp)
                        int len = strlen(str);
c0000e7c:	83 ec 0c             	sub    $0xc,%esp
c0000e7f:	ff 75 a4             	pushl  -0x5c(%ebp)
c0000e82:	e8 15 04 00 00       	call   c000129c <strlen>
c0000e87:	83 c4 10             	add    $0x10,%esp
c0000e8a:	89 45 a8             	mov    %eax,-0x58(%ebp)
                        if(field_prec > 0 && field_prec < len)
c0000e8d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0000e91:	7e 0e                	jle    c0000ea1 <kprintf+0xa22>
c0000e93:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0000e96:	3b 45 a8             	cmp    -0x58(%ebp),%eax
c0000e99:	7d 06                	jge    c0000ea1 <kprintf+0xa22>
                            len = field_prec;
c0000e9b:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0000e9e:	89 45 a8             	mov    %eax,-0x58(%ebp)

                        int lenpad = field_width - len; 
c0000ea1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000ea4:	2b 45 a8             	sub    -0x58(%ebp),%eax
c0000ea7:	89 45 a0             	mov    %eax,-0x60(%ebp)

                        if(lenpad>0 && !flags.left)    
c0000eaa:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
c0000eae:	7e 1f                	jle    c0000ecf <kprintf+0xa50>
c0000eb0:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000eb7:	84 c0                	test   %al,%al
c0000eb9:	75 14                	jne    c0000ecf <kprintf+0xa50>
                            nchar += kprintn_char(' ', lenpad);
c0000ebb:	8b 45 a0             	mov    -0x60(%ebp),%eax
c0000ebe:	83 ec 08             	sub    $0x8,%esp
c0000ec1:	50                   	push   %eax
c0000ec2:	6a 20                	push   $0x20
c0000ec4:	e8 8d f5 ff ff       	call   c0000456 <kprintn_char>
c0000ec9:	83 c4 10             	add    $0x10,%esp
c0000ecc:	01 45 f0             	add    %eax,-0x10(%ebp)

                        nchar += kprintn(str,len);
c0000ecf:	8b 45 a8             	mov    -0x58(%ebp),%eax
c0000ed2:	83 ec 08             	sub    $0x8,%esp
c0000ed5:	50                   	push   %eax
c0000ed6:	ff 75 a4             	pushl  -0x5c(%ebp)
c0000ed9:	e8 2f f5 ff ff       	call   c000040d <kprintn>
c0000ede:	83 c4 10             	add    $0x10,%esp
c0000ee1:	01 45 f0             	add    %eax,-0x10(%ebp)

                        if(lenpad>0 && flags.left)
c0000ee4:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
c0000ee8:	7e 31                	jle    c0000f1b <kprintf+0xa9c>
c0000eea:	0f b6 85 79 ff ff ff 	movzbl -0x87(%ebp),%eax
c0000ef1:	84 c0                	test   %al,%al
c0000ef3:	74 26                	je     c0000f1b <kprintf+0xa9c>
                            nchar += kprintn_char(' ', lenpad);
c0000ef5:	8b 45 a0             	mov    -0x60(%ebp),%eax
c0000ef8:	83 ec 08             	sub    $0x8,%esp
c0000efb:	50                   	push   %eax
c0000efc:	6a 20                	push   $0x20
c0000efe:	e8 53 f5 ff ff       	call   c0000456 <kprintn_char>
c0000f03:	83 c4 10             	add    $0x10,%esp
c0000f06:	01 45 f0             	add    %eax,-0x10(%ebp)
                        
                    }
                    break;
c0000f09:	eb 10                	jmp    c0000f1b <kprintf+0xa9c>
                default:
                    //unsupported type
                    return -1;
c0000f0b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000f10:	eb 40                	jmp    c0000f52 <kprintf+0xad3>
                            break;
c0000f12:	90                   	nop
c0000f13:	eb 07                	jmp    c0000f1c <kprintf+0xa9d>
                    break;
c0000f15:	90                   	nop
c0000f16:	eb 04                	jmp    c0000f1c <kprintf+0xa9d>
                    break;
c0000f18:	90                   	nop
c0000f19:	eb 01                	jmp    c0000f1c <kprintf+0xa9d>
                    break;
c0000f1b:	90                   	nop
                
            }
            f++;
c0000f1c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0000f20:	eb 1f                	jmp    c0000f41 <kprintf+0xac2>
        }
        else
        {
            //this isnt part of a format code, just copy char to string and increment pointers
            kprint_char(*(f++));
c0000f22:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000f25:	8d 50 01             	lea    0x1(%eax),%edx
c0000f28:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0000f2b:	0f b6 00             	movzbl (%eax),%eax
c0000f2e:	0f be c0             	movsbl %al,%eax
c0000f31:	83 ec 0c             	sub    $0xc,%esp
c0000f34:	50                   	push   %eax
c0000f35:	e8 f4 f4 ff ff       	call   c000042e <kprint_char>
c0000f3a:	83 c4 10             	add    $0x10,%esp
            nchar++;
c0000f3d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    while(f[0] != 0)
c0000f41:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000f44:	0f b6 00             	movzbl (%eax),%eax
c0000f47:	84 c0                	test   %al,%al
c0000f49:	0f 85 54 f5 ff ff    	jne    c00004a3 <kprintf+0x24>
    }

   /* clean memory reserved for valist */
   va_end(valist);

   return nchar; //number of characters copied to str
c0000f4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0000f52:	c9                   	leave  
c0000f53:	c3                   	ret    

c0000f54 <format_uint>:
// base may be 2-32
// precision is per printf format, precision<0 represents default (unspecified) 
// cap = 0, alpha-numbers are capitalized [base>10 only]
// returns length of string (not counting null termination)
int format_uint(unsigned int value, char* str, unsigned int base, int precision, int cap)
{
c0000f54:	55                   	push   %ebp
c0000f55:	89 e5                	mov    %esp,%ebp
c0000f57:	83 ec 18             	sub    $0x18,%esp
    if(base < 2 || base > 32)
c0000f5a:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c0000f5e:	76 06                	jbe    c0000f66 <format_uint+0x12>
c0000f60:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
c0000f64:	76 0a                	jbe    c0000f70 <format_uint+0x1c>
        return -1;
c0000f66:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0000f6b:	e9 d1 00 00 00       	jmp    c0001041 <format_uint+0xed>

    //When 0 is printed with an explicit precision 0, the output is empty.
    if(value==0 && precision==0)
c0000f70:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0000f74:	75 16                	jne    c0000f8c <format_uint+0x38>
c0000f76:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c0000f7a:	75 10                	jne    c0000f8c <format_uint+0x38>
    {
        str[0] = 0;
c0000f7c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000f7f:	c6 00 00             	movb   $0x0,(%eax)
        return 0;
c0000f82:	b8 00 00 00 00       	mov    $0x0,%eax
c0000f87:	e9 b5 00 00 00       	jmp    c0001041 <format_uint+0xed>
    }

    // find number of digits
    int num_digits = numdigits_uint(value, base);
c0000f8c:	83 ec 08             	sub    $0x8,%esp
c0000f8f:	ff 75 10             	pushl  0x10(%ebp)
c0000f92:	ff 75 08             	pushl  0x8(%ebp)
c0000f95:	e8 a9 00 00 00       	call   c0001043 <numdigits_uint>
c0000f9a:	83 c4 10             	add    $0x10,%esp
c0000f9d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    num_digits = num_digits>precision ? num_digits : precision;
c0000fa0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0000fa3:	39 45 14             	cmp    %eax,0x14(%ebp)
c0000fa6:	0f 4d 45 14          	cmovge 0x14(%ebp),%eax
c0000faa:	89 45 ec             	mov    %eax,-0x14(%ebp)

    //write formatted number out in reverse order
    char* s = str + num_digits;
c0000fad:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0000fb0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0000fb3:	01 d0                	add    %edx,%eax
c0000fb5:	89 45 f4             	mov    %eax,-0xc(%ebp)

    *(s--) = '\0'; //null termination
c0000fb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000fbb:	8d 50 ff             	lea    -0x1(%eax),%edx
c0000fbe:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0000fc1:	c6 00 00             	movb   $0x0,(%eax)

    //compute each digit from lowest to highest.
    unsigned int d;
    for(int nn=0;nn<num_digits; nn++)
c0000fc4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0000fcb:	eb 69                	jmp    c0001036 <format_uint+0xe2>
    {
        d = value % base;
c0000fcd:	8b 45 08             	mov    0x8(%ebp),%eax
c0000fd0:	ba 00 00 00 00       	mov    $0x0,%edx
c0000fd5:	f7 75 10             	divl   0x10(%ebp)
c0000fd8:	89 55 e8             	mov    %edx,-0x18(%ebp)
        value /= base;
c0000fdb:	8b 45 08             	mov    0x8(%ebp),%eax
c0000fde:	ba 00 00 00 00       	mov    $0x0,%edx
c0000fe3:	f7 75 10             	divl   0x10(%ebp)
c0000fe6:	89 45 08             	mov    %eax,0x8(%ebp)

        //write digit into string and decrement pointer
        if(d < 10)
c0000fe9:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
c0000fed:	77 15                	ja     c0001004 <format_uint+0xb0>
            *(s--) = d + '0';
c0000fef:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0000ff2:	8d 48 30             	lea    0x30(%eax),%ecx
c0000ff5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0000ff8:	8d 50 ff             	lea    -0x1(%eax),%edx
c0000ffb:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0000ffe:	89 ca                	mov    %ecx,%edx
c0001000:	88 10                	mov    %dl,(%eax)
c0001002:	eb 2e                	jmp    c0001032 <format_uint+0xde>
        else if(cap == 0)
c0001004:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
c0001008:	75 15                	jne    c000101f <format_uint+0xcb>
            *(s--) = d - 10 + 'a';
c000100a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000100d:	8d 48 57             	lea    0x57(%eax),%ecx
c0001010:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001013:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001016:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0001019:	89 ca                	mov    %ecx,%edx
c000101b:	88 10                	mov    %dl,(%eax)
c000101d:	eb 13                	jmp    c0001032 <format_uint+0xde>
        else
            *(s--) = d - 10 + 'A';
c000101f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001022:	8d 48 37             	lea    0x37(%eax),%ecx
c0001025:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001028:	8d 50 ff             	lea    -0x1(%eax),%edx
c000102b:	89 55 f4             	mov    %edx,-0xc(%ebp)
c000102e:	89 ca                	mov    %ecx,%edx
c0001030:	88 10                	mov    %dl,(%eax)
    for(int nn=0;nn<num_digits; nn++)
c0001032:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0001036:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001039:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c000103c:	7c 8f                	jl     c0000fcd <format_uint+0x79>
    }

    return num_digits;
c000103e:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c0001041:	c9                   	leave  
c0001042:	c3                   	ret    

c0001043 <numdigits_uint>:


//returns number of digits of unsigned int represented in given base
//num_digits is always >= 1
unsigned int numdigits_uint(unsigned int value, unsigned int base)
{
c0001043:	55                   	push   %ebp
c0001044:	89 e5                	mov    %esp,%ebp
c0001046:	83 ec 10             	sub    $0x10,%esp
    unsigned int num_digits = 1;
c0001049:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
    while(value >= base)
c0001050:	eb 12                	jmp    c0001064 <numdigits_uint+0x21>
    {
        num_digits++;
c0001052:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        value /= base;
c0001056:	8b 45 08             	mov    0x8(%ebp),%eax
c0001059:	ba 00 00 00 00       	mov    $0x0,%edx
c000105e:	f7 75 0c             	divl   0xc(%ebp)
c0001061:	89 45 08             	mov    %eax,0x8(%ebp)
    while(value >= base)
c0001064:	8b 45 08             	mov    0x8(%ebp),%eax
c0001067:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000106a:	73 e6                	jae    c0001052 <numdigits_uint+0xf>
    }
    return num_digits;
c000106c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c000106f:	c9                   	leave  
c0001070:	c3                   	ret    

c0001071 <kprintf_test>:



void kprintf_test()
{
c0001071:	55                   	push   %ebp
c0001072:	89 e5                	mov    %esp,%ebp
c0001074:	83 ec 18             	sub    $0x18,%esp
    int num = 12345678;    
c0001077:	c7 45 f4 4e 61 bc 00 	movl   $0xbc614e,-0xc(%ebp)
    kprintf("\nkprintf() tests...\n", num);
c000107e:	83 ec 08             	sub    $0x8,%esp
c0001081:	ff 75 f4             	pushl  -0xc(%ebp)
c0001084:	68 d0 41 00 c0       	push   $0xc00041d0
c0001089:	e8 f1 f3 ff ff       	call   c000047f <kprintf>
c000108e:	83 c4 10             	add    $0x10,%esp
    kprintf("Fixed width, right justify:\n");
c0001091:	83 ec 0c             	sub    $0xc,%esp
c0001094:	68 e5 41 00 c0       	push   $0xc00041e5
c0001099:	e8 e1 f3 ff ff       	call   c000047f <kprintf>
c000109e:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%15d]\n", num);
c00010a1:	83 ec 08             	sub    $0x8,%esp
c00010a4:	ff 75 f4             	pushl  -0xc(%ebp)
c00010a7:	68 02 42 00 c0       	push   $0xc0004202
c00010ac:	e8 ce f3 ff ff       	call   c000047f <kprintf>
c00010b1:	83 c4 10             	add    $0x10,%esp
    kprintf("Hex:     [%#15x]\n", num);
c00010b4:	83 ec 08             	sub    $0x8,%esp
c00010b7:	ff 75 f4             	pushl  -0xc(%ebp)
c00010ba:	68 13 42 00 c0       	push   $0xc0004213
c00010bf:	e8 bb f3 ff ff       	call   c000047f <kprintf>
c00010c4:	83 c4 10             	add    $0x10,%esp
    kprintf("Oct:     [%#15o]\n", num);
c00010c7:	83 ec 08             	sub    $0x8,%esp
c00010ca:	ff 75 f4             	pushl  -0xc(%ebp)
c00010cd:	68 25 42 00 c0       	push   $0xc0004225
c00010d2:	e8 a8 f3 ff ff       	call   c000047f <kprintf>
c00010d7:	83 c4 10             	add    $0x10,%esp
    kprintf("String:  [%15s]\n", "Hello World!");
c00010da:	83 ec 08             	sub    $0x8,%esp
c00010dd:	68 37 42 00 c0       	push   $0xc0004237
c00010e2:	68 44 42 00 c0       	push   $0xc0004244
c00010e7:	e8 93 f3 ff ff       	call   c000047f <kprintf>
c00010ec:	83 c4 10             	add    $0x10,%esp
    kprintf("Char:    [%15c]\n", '!');
c00010ef:	83 ec 08             	sub    $0x8,%esp
c00010f2:	6a 21                	push   $0x21
c00010f4:	68 55 42 00 c0       	push   $0xc0004255
c00010f9:	e8 81 f3 ff ff       	call   c000047f <kprintf>
c00010fe:	83 c4 10             	add    $0x10,%esp

    kprintf("\nFixed width, left justify:\n");
c0001101:	83 ec 0c             	sub    $0xc,%esp
c0001104:	68 66 42 00 c0       	push   $0xc0004266
c0001109:	e8 71 f3 ff ff       	call   c000047f <kprintf>
c000110e:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%-15d]\n", num);
c0001111:	83 ec 08             	sub    $0x8,%esp
c0001114:	ff 75 f4             	pushl  -0xc(%ebp)
c0001117:	68 83 42 00 c0       	push   $0xc0004283
c000111c:	e8 5e f3 ff ff       	call   c000047f <kprintf>
c0001121:	83 c4 10             	add    $0x10,%esp
    kprintf("Hex:     [%-#15x]\n", num);
c0001124:	83 ec 08             	sub    $0x8,%esp
c0001127:	ff 75 f4             	pushl  -0xc(%ebp)
c000112a:	68 95 42 00 c0       	push   $0xc0004295
c000112f:	e8 4b f3 ff ff       	call   c000047f <kprintf>
c0001134:	83 c4 10             	add    $0x10,%esp
    kprintf("String:  [%-15s]\n", "Hello World!");
c0001137:	83 ec 08             	sub    $0x8,%esp
c000113a:	68 37 42 00 c0       	push   $0xc0004237
c000113f:	68 a8 42 00 c0       	push   $0xc00042a8
c0001144:	e8 36 f3 ff ff       	call   c000047f <kprintf>
c0001149:	83 c4 10             	add    $0x10,%esp

    kprintf("\nFixed Precision:\n");
c000114c:	83 ec 0c             	sub    $0xc,%esp
c000114f:	68 ba 42 00 c0       	push   $0xc00042ba
c0001154:	e8 26 f3 ff ff       	call   c000047f <kprintf>
c0001159:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%15.10d]\nHex:     [%#15.10x]\nOct:     [%#15.10o]\nString:  [%15.10s]\n", 
c000115c:	83 ec 0c             	sub    $0xc,%esp
c000115f:	68 37 42 00 c0       	push   $0xc0004237
c0001164:	ff 75 f4             	pushl  -0xc(%ebp)
c0001167:	ff 75 f4             	pushl  -0xc(%ebp)
c000116a:	ff 75 f4             	pushl  -0xc(%ebp)
c000116d:	68 d0 42 00 c0       	push   $0xc00042d0
c0001172:	e8 08 f3 ff ff       	call   c000047f <kprintf>
c0001177:	83 c4 20             	add    $0x20,%esp
        num, num, num, "Hello World!");

    kprintf("\nLeading Zeros:\n");
c000117a:	83 ec 0c             	sub    $0xc,%esp
c000117d:	68 1f 43 00 c0       	push   $0xc000431f
c0001182:	e8 f8 f2 ff ff       	call   c000047f <kprintf>
c0001187:	83 c4 10             	add    $0x10,%esp
    kprintf("Decimal: [%015.10d]\nHex:     [%#015.10x]\nOct:     [%#015.10o]\n",num, num, num);
c000118a:	ff 75 f4             	pushl  -0xc(%ebp)
c000118d:	ff 75 f4             	pushl  -0xc(%ebp)
c0001190:	ff 75 f4             	pushl  -0xc(%ebp)
c0001193:	68 30 43 00 c0       	push   $0xc0004330
c0001198:	e8 e2 f2 ff ff       	call   c000047f <kprintf>
c000119d:	83 c4 10             	add    $0x10,%esp

    kprintf("Signed (none):  [%d], [%d]\n",num, -num);
c00011a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00011a3:	f7 d8                	neg    %eax
c00011a5:	83 ec 04             	sub    $0x4,%esp
c00011a8:	50                   	push   %eax
c00011a9:	ff 75 f4             	pushl  -0xc(%ebp)
c00011ac:	68 6f 43 00 c0       	push   $0xc000436f
c00011b1:	e8 c9 f2 ff ff       	call   c000047f <kprintf>
c00011b6:	83 c4 10             	add    $0x10,%esp
    kprintf("Signed (space): [% d], [% d]\n",num, -num);
c00011b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00011bc:	f7 d8                	neg    %eax
c00011be:	83 ec 04             	sub    $0x4,%esp
c00011c1:	50                   	push   %eax
c00011c2:	ff 75 f4             	pushl  -0xc(%ebp)
c00011c5:	68 8b 43 00 c0       	push   $0xc000438b
c00011ca:	e8 b0 f2 ff ff       	call   c000047f <kprintf>
c00011cf:	83 c4 10             	add    $0x10,%esp
    kprintf("Signed (+):     [%+d], [%+d]\n",num, -num);
c00011d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00011d5:	f7 d8                	neg    %eax
c00011d7:	83 ec 04             	sub    $0x4,%esp
c00011da:	50                   	push   %eax
c00011db:	ff 75 f4             	pushl  -0xc(%ebp)
c00011de:	68 a9 43 00 c0       	push   $0xc00043a9
c00011e3:	e8 97 f2 ff ff       	call   c000047f <kprintf>
c00011e8:	83 c4 10             	add    $0x10,%esp

    float f = 1.23456789;
c00011eb:	d9 05 20 44 00 c0    	flds   0xc0004420
c00011f1:	d9 5d f0             	fstps  -0x10(%ebp)
    kprintf("\nfloat:     [%15.f]\n",f);
c00011f4:	d9 45 f0             	flds   -0x10(%ebp)
c00011f7:	83 ec 04             	sub    $0x4,%esp
c00011fa:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c00011fe:	dd 1c 24             	fstpl  (%esp)
c0001201:	68 c7 43 00 c0       	push   $0xc00043c7
c0001206:	e8 74 f2 ff ff       	call   c000047f <kprintf>
c000120b:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.3f]\n",f);
c000120e:	d9 45 f0             	flds   -0x10(%ebp)
c0001211:	83 ec 04             	sub    $0x4,%esp
c0001214:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001218:	dd 1c 24             	fstpl  (%esp)
c000121b:	68 dc 43 00 c0       	push   $0xc00043dc
c0001220:	e8 5a f2 ff ff       	call   c000047f <kprintf>
c0001225:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.10f]\n",f);
c0001228:	d9 45 f0             	flds   -0x10(%ebp)
c000122b:	83 ec 04             	sub    $0x4,%esp
c000122e:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001232:	dd 1c 24             	fstpl  (%esp)
c0001235:	68 f1 43 00 c0       	push   $0xc00043f1
c000123a:	e8 40 f2 ff ff       	call   c000047f <kprintf>
c000123f:	83 c4 10             	add    $0x10,%esp

    f = -12345.6789;
c0001242:	d9 05 24 44 00 c0    	flds   0xc0004424
c0001248:	d9 5d f0             	fstps  -0x10(%ebp)
    kprintf("float:     [%15f]\n",f);
c000124b:	d9 45 f0             	flds   -0x10(%ebp)
c000124e:	83 ec 04             	sub    $0x4,%esp
c0001251:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001255:	dd 1c 24             	fstpl  (%esp)
c0001258:	68 07 44 00 c0       	push   $0xc0004407
c000125d:	e8 1d f2 ff ff       	call   c000047f <kprintf>
c0001262:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.3f]\n",f);
c0001265:	d9 45 f0             	flds   -0x10(%ebp)
c0001268:	83 ec 04             	sub    $0x4,%esp
c000126b:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c000126f:	dd 1c 24             	fstpl  (%esp)
c0001272:	68 dc 43 00 c0       	push   $0xc00043dc
c0001277:	e8 03 f2 ff ff       	call   c000047f <kprintf>
c000127c:	83 c4 10             	add    $0x10,%esp
    kprintf("float:     [%15.10f]\n",f);
c000127f:	d9 45 f0             	flds   -0x10(%ebp)
c0001282:	83 ec 04             	sub    $0x4,%esp
c0001285:	8d 64 24 f8          	lea    -0x8(%esp),%esp
c0001289:	dd 1c 24             	fstpl  (%esp)
c000128c:	68 f1 43 00 c0       	push   $0xc00043f1
c0001291:	e8 e9 f1 ff ff       	call   c000047f <kprintf>
c0001296:	83 c4 10             	add    $0x10,%esp
}
c0001299:	90                   	nop
c000129a:	c9                   	leave  
c000129b:	c3                   	ret    

c000129c <strlen>:
#include "common.h"

size_t strlen(const char* str) 
{
c000129c:	55                   	push   %ebp
c000129d:	89 e5                	mov    %esp,%ebp
c000129f:	83 ec 10             	sub    $0x10,%esp
	size_t len = 0;
c00012a2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while (str[len])
c00012a9:	eb 04                	jmp    c00012af <strlen+0x13>
		len++;
c00012ab:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
	while (str[len])
c00012af:	8b 55 08             	mov    0x8(%ebp),%edx
c00012b2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00012b5:	01 d0                	add    %edx,%eax
c00012b7:	0f b6 00             	movzbl (%eax),%eax
c00012ba:	84 c0                	test   %al,%al
c00012bc:	75 ed                	jne    c00012ab <strlen+0xf>
	return len;
c00012be:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00012c1:	c9                   	leave  
c00012c2:	c3                   	ret    

c00012c3 <memcpy>:

// copy n bytes from src to dest
void *memcpy(void *dest, const void *src, size_t n)
{
c00012c3:	55                   	push   %ebp
c00012c4:	89 e5                	mov    %esp,%ebp
c00012c6:	83 ec 20             	sub    $0x20,%esp
    //system wordsize is equal to length of size_t
    size_t n_words = n/sizeof(size_t);
c00012c9:	8b 45 10             	mov    0x10(%ebp),%eax
c00012cc:	c1 e8 02             	shr    $0x2,%eax
c00012cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t* dest_word = (size_t *) dest;
c00012d2:	8b 45 08             	mov    0x8(%ebp),%eax
c00012d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    size_t* src_word = (size_t *) src;
c00012d8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00012db:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for(size_t nn=0; nn<n_words; nn++)
c00012de:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00012e5:	eb 26                	jmp    c000130d <memcpy+0x4a>
        dest_word[nn]=src_word[nn];
c00012e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00012ea:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c00012f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00012f4:	01 d0                	add    %edx,%eax
c00012f6:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00012f9:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
c0001300:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001303:	01 ca                	add    %ecx,%edx
c0001305:	8b 00                	mov    (%eax),%eax
c0001307:	89 02                	mov    %eax,(%edx)
    for(size_t nn=0; nn<n_words; nn++)
c0001309:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c000130d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001310:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0001313:	72 d2                	jb     c00012e7 <memcpy+0x24>
    
    //copy remaining bytes
    size_t n_bytes = n - n_words*sizeof(size_t);
c0001315:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001318:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000131f:	8b 45 10             	mov    0x10(%ebp),%eax
c0001322:	29 d0                	sub    %edx,%eax
c0001324:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(n_bytes > 0)
c0001327:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c000132b:	74 36                	je     c0001363 <memcpy+0xa0>
    {
        char* dest_byte = (char *) dest;
c000132d:	8b 45 08             	mov    0x8(%ebp),%eax
c0001330:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        char* src_byte = (char *) src;
c0001333:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001336:	89 45 e0             	mov    %eax,-0x20(%ebp)
        for(size_t nn=0; nn<n_bytes; nn++)
c0001339:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0001340:	eb 19                	jmp    c000135b <memcpy+0x98>
            dest_byte[nn]=src_byte[nn];
c0001342:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0001345:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0001348:	01 d0                	add    %edx,%eax
c000134a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c000134d:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0001350:	01 ca                	add    %ecx,%edx
c0001352:	0f b6 00             	movzbl (%eax),%eax
c0001355:	88 02                	mov    %al,(%edx)
        for(size_t nn=0; nn<n_bytes; nn++)
c0001357:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c000135b:	8b 45 f8             	mov    -0x8(%ebp),%eax
c000135e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0001361:	72 df                	jb     c0001342 <memcpy+0x7f>
    }

    return dest;
c0001363:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0001366:	c9                   	leave  
c0001367:	c3                   	ret    

c0001368 <atoi>:

int atoi(const char* str)
{
c0001368:	55                   	push   %ebp
c0001369:	89 e5                	mov    %esp,%ebp
c000136b:	83 ec 20             	sub    $0x20,%esp
    int p = 0;
c000136e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    int neg = 0;
c0001375:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    //find start of number string, ignore whitespace
    while(str[p] == '-' || str[p] == ' ' || (str[p] >= 9 && str[p] <= 13))
c000137c:	eb 41                	jmp    c00013bf <atoi+0x57>
    {
        if(str[p++] == '-')
c000137e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001381:	8d 50 01             	lea    0x1(%eax),%edx
c0001384:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001387:	89 c2                	mov    %eax,%edx
c0001389:	8b 45 08             	mov    0x8(%ebp),%eax
c000138c:	01 d0                	add    %edx,%eax
c000138e:	0f b6 00             	movzbl (%eax),%eax
c0001391:	3c 2d                	cmp    $0x2d,%al
c0001393:	75 09                	jne    c000139e <atoi+0x36>
        {
            neg=1;
c0001395:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
            break;
c000139c:	eb 5d                	jmp    c00013fb <atoi+0x93>
        }
        if(str[p++] == '\0')
c000139e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00013a1:	8d 50 01             	lea    0x1(%eax),%edx
c00013a4:	89 55 fc             	mov    %edx,-0x4(%ebp)
c00013a7:	89 c2                	mov    %eax,%edx
c00013a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00013ac:	01 d0                	add    %edx,%eax
c00013ae:	0f b6 00             	movzbl (%eax),%eax
c00013b1:	84 c0                	test   %al,%al
c00013b3:	75 0a                	jne    c00013bf <atoi+0x57>
            return 0; //invalid string (only whitespace found)
c00013b5:	b8 00 00 00 00       	mov    $0x0,%eax
c00013ba:	e9 ee 00 00 00       	jmp    c00014ad <atoi+0x145>
    while(str[p] == '-' || str[p] == ' ' || (str[p] >= 9 && str[p] <= 13))
c00013bf:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00013c2:	8b 45 08             	mov    0x8(%ebp),%eax
c00013c5:	01 d0                	add    %edx,%eax
c00013c7:	0f b6 00             	movzbl (%eax),%eax
c00013ca:	3c 2d                	cmp    $0x2d,%al
c00013cc:	74 b0                	je     c000137e <atoi+0x16>
c00013ce:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00013d1:	8b 45 08             	mov    0x8(%ebp),%eax
c00013d4:	01 d0                	add    %edx,%eax
c00013d6:	0f b6 00             	movzbl (%eax),%eax
c00013d9:	3c 20                	cmp    $0x20,%al
c00013db:	74 a1                	je     c000137e <atoi+0x16>
c00013dd:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00013e0:	8b 45 08             	mov    0x8(%ebp),%eax
c00013e3:	01 d0                	add    %edx,%eax
c00013e5:	0f b6 00             	movzbl (%eax),%eax
c00013e8:	3c 08                	cmp    $0x8,%al
c00013ea:	7e 0f                	jle    c00013fb <atoi+0x93>
c00013ec:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00013ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00013f2:	01 d0                	add    %edx,%eax
c00013f4:	0f b6 00             	movzbl (%eax),%eax
c00013f7:	3c 0d                	cmp    $0xd,%al
c00013f9:	7e 83                	jle    c000137e <atoi+0x16>
    }

    int num_start = p;
c00013fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00013fe:	89 45 e8             	mov    %eax,-0x18(%ebp)

    //find end of integer string (ints only, no decimal point)
    while(str[p] >= '0' && str[p] <= '9')
c0001401:	eb 21                	jmp    c0001424 <atoi+0xbc>
    {
        if(str[p++] == '\0')
c0001403:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001406:	8d 50 01             	lea    0x1(%eax),%edx
c0001409:	89 55 fc             	mov    %edx,-0x4(%ebp)
c000140c:	89 c2                	mov    %eax,%edx
c000140e:	8b 45 08             	mov    0x8(%ebp),%eax
c0001411:	01 d0                	add    %edx,%eax
c0001413:	0f b6 00             	movzbl (%eax),%eax
c0001416:	84 c0                	test   %al,%al
c0001418:	75 0a                	jne    c0001424 <atoi+0xbc>
            return 0; //invalid string (only whitespace found)
c000141a:	b8 00 00 00 00       	mov    $0x0,%eax
c000141f:	e9 89 00 00 00       	jmp    c00014ad <atoi+0x145>
    while(str[p] >= '0' && str[p] <= '9')
c0001424:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0001427:	8b 45 08             	mov    0x8(%ebp),%eax
c000142a:	01 d0                	add    %edx,%eax
c000142c:	0f b6 00             	movzbl (%eax),%eax
c000142f:	3c 2f                	cmp    $0x2f,%al
c0001431:	7e 0f                	jle    c0001442 <atoi+0xda>
c0001433:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0001436:	8b 45 08             	mov    0x8(%ebp),%eax
c0001439:	01 d0                	add    %edx,%eax
c000143b:	0f b6 00             	movzbl (%eax),%eax
c000143e:	3c 39                	cmp    $0x39,%al
c0001440:	7e c1                	jle    c0001403 <atoi+0x9b>
    }

    if(num_start == p) return 0; //length 0 string
c0001442:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001445:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c0001448:	75 07                	jne    c0001451 <atoi+0xe9>
c000144a:	b8 00 00 00 00       	mov    $0x0,%eax
c000144f:	eb 5c                	jmp    c00014ad <atoi+0x145>

    int number = 0;
c0001451:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    int place = 1;
c0001458:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    //iterate backwards through number to add each digit
    for(int digit = p-1; digit >= num_start; digit--)
c000145f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001462:	83 e8 01             	sub    $0x1,%eax
c0001465:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0001468:	eb 2b                	jmp    c0001495 <atoi+0x12d>
    {
        number += (int) (str[digit] - '0') * place;
c000146a:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000146d:	8b 45 08             	mov    0x8(%ebp),%eax
c0001470:	01 d0                	add    %edx,%eax
c0001472:	0f b6 00             	movzbl (%eax),%eax
c0001475:	0f be c0             	movsbl %al,%eax
c0001478:	83 e8 30             	sub    $0x30,%eax
c000147b:	0f af 45 f0          	imul   -0x10(%ebp),%eax
c000147f:	01 45 f4             	add    %eax,-0xc(%ebp)
        place *= 10;
c0001482:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001485:	89 d0                	mov    %edx,%eax
c0001487:	c1 e0 02             	shl    $0x2,%eax
c000148a:	01 d0                	add    %edx,%eax
c000148c:	01 c0                	add    %eax,%eax
c000148e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for(int digit = p-1; digit >= num_start; digit--)
c0001491:	83 6d ec 01          	subl   $0x1,-0x14(%ebp)
c0001495:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001498:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c000149b:	7d cd                	jge    c000146a <atoi+0x102>
    }

    if(neg)
c000149d:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c00014a1:	74 07                	je     c00014aa <atoi+0x142>
        return -1*number;
c00014a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00014a6:	f7 d8                	neg    %eax
c00014a8:	eb 03                	jmp    c00014ad <atoi+0x145>
    else
        return number;
c00014aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00014ad:	c9                   	leave  
c00014ae:	c3                   	ret    

c00014af <itoa>:

char* itoa( int value, char* str, int base)
{
c00014af:	55                   	push   %ebp
c00014b0:	89 e5                	mov    %esp,%ebp
c00014b2:	83 ec 20             	sub    $0x20,%esp
    if(base < 2 || base > 32)
c00014b5:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c00014b9:	7e 06                	jle    c00014c1 <itoa+0x12>
c00014bb:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
c00014bf:	7e 0a                	jle    c00014cb <itoa+0x1c>
        return NULL;
c00014c1:	b8 00 00 00 00       	mov    $0x0,%eax
c00014c6:	e9 df 00 00 00       	jmp    c00015aa <itoa+0xfb>

    //handle zero as special case 
    if(value == 0)
c00014cb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00014cf:	75 17                	jne    c00014e8 <itoa+0x39>
    {
        str[0] = '0';
c00014d1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00014d4:	c6 00 30             	movb   $0x30,(%eax)
        str[1] = '\0';
c00014d7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00014da:	83 c0 01             	add    $0x1,%eax
c00014dd:	c6 00 00             	movb   $0x0,(%eax)
        return str;
c00014e0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00014e3:	e9 c2 00 00 00       	jmp    c00015aa <itoa+0xfb>
    }

    char* s = str;
c00014e8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00014eb:	89 45 fc             	mov    %eax,-0x4(%ebp)
    unsigned int residual; //holds the unsigned value still to be parsed
    if(base == 10 && value < 0)
c00014ee:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
c00014f2:	75 1c                	jne    c0001510 <itoa+0x61>
c00014f4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00014f8:	79 16                	jns    c0001510 <itoa+0x61>
    {
        residual = -value;
c00014fa:	8b 45 08             	mov    0x8(%ebp),%eax
c00014fd:	f7 d8                	neg    %eax
c00014ff:	89 45 f8             	mov    %eax,-0x8(%ebp)
        *(s++) = '-';
c0001502:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001505:	8d 50 01             	lea    0x1(%eax),%edx
c0001508:	89 55 fc             	mov    %edx,-0x4(%ebp)
c000150b:	c6 00 2d             	movb   $0x2d,(%eax)
c000150e:	eb 06                	jmp    c0001516 <itoa+0x67>
    }
    else
    {
        //all non-decimal numbers are treated as unsigned
        residual = (unsigned int) value;
c0001510:	8b 45 08             	mov    0x8(%ebp),%eax
c0001513:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    
    // find number of digits so that we can parse number
    // directly into string from lowest to highest digit    
    unsigned int num_digits = 0;
c0001516:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    unsigned int temp = residual;
c000151d:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0001520:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(temp>0)
c0001523:	eb 14                	jmp    c0001539 <itoa+0x8a>
    {
        num_digits++;
c0001525:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
        temp /= base;
c0001529:	8b 4d 10             	mov    0x10(%ebp),%ecx
c000152c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000152f:	ba 00 00 00 00       	mov    $0x0,%edx
c0001534:	f7 f1                	div    %ecx
c0001536:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(temp>0)
c0001539:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000153d:	75 e6                	jne    c0001525 <itoa+0x76>
    }

    //point at end of string
    s += num_digits;
c000153f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001542:	01 45 fc             	add    %eax,-0x4(%ebp)
    *(s--) = '\0'; //null termination
c0001545:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001548:	8d 50 ff             	lea    -0x1(%eax),%edx
c000154b:	89 55 fc             	mov    %edx,-0x4(%ebp)
c000154e:	c6 00 00             	movb   $0x0,(%eax)

    //compute each digit from lowest to highest.
    unsigned int digit;
    while(residual>0)
c0001551:	eb 4e                	jmp    c00015a1 <itoa+0xf2>
    {
        digit = residual % base;
c0001553:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0001556:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0001559:	ba 00 00 00 00       	mov    $0x0,%edx
c000155e:	f7 f1                	div    %ecx
c0001560:	89 55 ec             	mov    %edx,-0x14(%ebp)
        residual /= base;
c0001563:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0001566:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0001569:	ba 00 00 00 00       	mov    $0x0,%edx
c000156e:	f7 f1                	div    %ecx
c0001570:	89 45 f8             	mov    %eax,-0x8(%ebp)

        //write digit into string and decrement pointer
        if(digit < 10)
c0001573:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
c0001577:	77 15                	ja     c000158e <itoa+0xdf>
            *(s--) = digit + '0';
c0001579:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000157c:	8d 48 30             	lea    0x30(%eax),%ecx
c000157f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001582:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001585:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0001588:	89 ca                	mov    %ecx,%edx
c000158a:	88 10                	mov    %dl,(%eax)
c000158c:	eb 13                	jmp    c00015a1 <itoa+0xf2>
        else
            *(s--) = digit - 10 + 'A';        
c000158e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001591:	8d 48 37             	lea    0x37(%eax),%ecx
c0001594:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001597:	8d 50 ff             	lea    -0x1(%eax),%edx
c000159a:	89 55 fc             	mov    %edx,-0x4(%ebp)
c000159d:	89 ca                	mov    %ecx,%edx
c000159f:	88 10                	mov    %dl,(%eax)
    while(residual>0)
c00015a1:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c00015a5:	75 ac                	jne    c0001553 <itoa+0xa4>
    }

    return str;
c00015a7:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c00015aa:	c9                   	leave  
c00015ab:	c3                   	ret    

c00015ac <printregs>:
#include "regs.h"
#include "kprintf.h"

void printregs(const reg_t* regs)
{
c00015ac:	55                   	push   %ebp
c00015ad:	89 e5                	mov    %esp,%ebp
c00015af:	57                   	push   %edi
c00015b0:	56                   	push   %esi
c00015b1:	53                   	push   %ebx
c00015b2:	83 ec 0c             	sub    $0xc,%esp
    kprintf("Registers:\n");
c00015b5:	83 ec 0c             	sub    $0xc,%esp
c00015b8:	68 28 44 00 c0       	push   $0xc0004428
c00015bd:	e8 bd ee ff ff       	call   c000047f <kprintf>
c00015c2:	83 c4 10             	add    $0x10,%esp
    kprintf("eax: 0x%x\n", regs->eax);
c00015c5:	8b 45 08             	mov    0x8(%ebp),%eax
c00015c8:	8b 00                	mov    (%eax),%eax
c00015ca:	83 ec 08             	sub    $0x8,%esp
c00015cd:	50                   	push   %eax
c00015ce:	68 34 44 00 c0       	push   $0xc0004434
c00015d3:	e8 a7 ee ff ff       	call   c000047f <kprintf>
c00015d8:	83 c4 10             	add    $0x10,%esp
    kprintf("ebx: 0x%x\n", regs->ebx);
c00015db:	8b 45 08             	mov    0x8(%ebp),%eax
c00015de:	8b 40 04             	mov    0x4(%eax),%eax
c00015e1:	83 ec 08             	sub    $0x8,%esp
c00015e4:	50                   	push   %eax
c00015e5:	68 3f 44 00 c0       	push   $0xc000443f
c00015ea:	e8 90 ee ff ff       	call   c000047f <kprintf>
c00015ef:	83 c4 10             	add    $0x10,%esp
    kprintf("ecx: 0x%x\n", regs->ecx);
c00015f2:	8b 45 08             	mov    0x8(%ebp),%eax
c00015f5:	8b 40 08             	mov    0x8(%eax),%eax
c00015f8:	83 ec 08             	sub    $0x8,%esp
c00015fb:	50                   	push   %eax
c00015fc:	68 4a 44 00 c0       	push   $0xc000444a
c0001601:	e8 79 ee ff ff       	call   c000047f <kprintf>
c0001606:	83 c4 10             	add    $0x10,%esp
    kprintf("edx: 0x%x\n", regs->edx);
c0001609:	8b 45 08             	mov    0x8(%ebp),%eax
c000160c:	8b 40 0c             	mov    0xc(%eax),%eax
c000160f:	83 ec 08             	sub    $0x8,%esp
c0001612:	50                   	push   %eax
c0001613:	68 55 44 00 c0       	push   $0xc0004455
c0001618:	e8 62 ee ff ff       	call   c000047f <kprintf>
c000161d:	83 c4 10             	add    $0x10,%esp
    kprintf("esi: 0x%x\n", regs->esi);
c0001620:	8b 45 08             	mov    0x8(%ebp),%eax
c0001623:	8b 40 10             	mov    0x10(%eax),%eax
c0001626:	83 ec 08             	sub    $0x8,%esp
c0001629:	50                   	push   %eax
c000162a:	68 60 44 00 c0       	push   $0xc0004460
c000162f:	e8 4b ee ff ff       	call   c000047f <kprintf>
c0001634:	83 c4 10             	add    $0x10,%esp
    kprintf("edi: 0x%x\n", regs->edi);
c0001637:	8b 45 08             	mov    0x8(%ebp),%eax
c000163a:	8b 40 14             	mov    0x14(%eax),%eax
c000163d:	83 ec 08             	sub    $0x8,%esp
c0001640:	50                   	push   %eax
c0001641:	68 6b 44 00 c0       	push   $0xc000446b
c0001646:	e8 34 ee ff ff       	call   c000047f <kprintf>
c000164b:	83 c4 10             	add    $0x10,%esp
    kprintf("ebp: 0x%x\n", regs->ebp);
c000164e:	8b 45 08             	mov    0x8(%ebp),%eax
c0001651:	8b 40 1c             	mov    0x1c(%eax),%eax
c0001654:	83 ec 08             	sub    $0x8,%esp
c0001657:	50                   	push   %eax
c0001658:	68 76 44 00 c0       	push   $0xc0004476
c000165d:	e8 1d ee ff ff       	call   c000047f <kprintf>
c0001662:	83 c4 10             	add    $0x10,%esp
    kprintf("esp: 0x%x\n", regs->esp);
c0001665:	8b 45 08             	mov    0x8(%ebp),%eax
c0001668:	8b 40 18             	mov    0x18(%eax),%eax
c000166b:	83 ec 08             	sub    $0x8,%esp
c000166e:	50                   	push   %eax
c000166f:	68 81 44 00 c0       	push   $0xc0004481
c0001674:	e8 06 ee ff ff       	call   c000047f <kprintf>
c0001679:	83 c4 10             	add    $0x10,%esp
    kprintf("eip: 0x%x\n", regs->eip);
c000167c:	8b 45 08             	mov    0x8(%ebp),%eax
c000167f:	8b 40 20             	mov    0x20(%eax),%eax
c0001682:	83 ec 08             	sub    $0x8,%esp
c0001685:	50                   	push   %eax
c0001686:	68 8c 44 00 c0       	push   $0xc000448c
c000168b:	e8 ef ed ff ff       	call   c000047f <kprintf>
c0001690:	83 c4 10             	add    $0x10,%esp
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
                                                            (regs->eflags&EFLAGS_PF) == EFLAGS_PF,
                                                            (regs->eflags&EFLAGS_AF) == EFLAGS_AF,
                                                            (regs->eflags&EFLAGS_ZF) == EFLAGS_ZF,
                                                            (regs->eflags&EFLAGS_SF) == EFLAGS_SF,
                                                            (regs->eflags&EFLAGS_TF) == EFLAGS_TF);
c0001693:	8b 45 08             	mov    0x8(%ebp),%eax
c0001696:	8b 40 24             	mov    0x24(%eax),%eax
c0001699:	25 00 01 00 00       	and    $0x100,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c000169e:	85 c0                	test   %eax,%eax
c00016a0:	0f 95 c0             	setne  %al
c00016a3:	0f b6 f8             	movzbl %al,%edi
                                                            (regs->eflags&EFLAGS_SF) == EFLAGS_SF,
c00016a6:	8b 45 08             	mov    0x8(%ebp),%eax
c00016a9:	8b 40 24             	mov    0x24(%eax),%eax
c00016ac:	25 80 00 00 00       	and    $0x80,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c00016b1:	85 c0                	test   %eax,%eax
c00016b3:	0f 95 c0             	setne  %al
c00016b6:	0f b6 f0             	movzbl %al,%esi
                                                            (regs->eflags&EFLAGS_ZF) == EFLAGS_ZF,
c00016b9:	8b 45 08             	mov    0x8(%ebp),%eax
c00016bc:	8b 40 24             	mov    0x24(%eax),%eax
c00016bf:	83 e0 40             	and    $0x40,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c00016c2:	85 c0                	test   %eax,%eax
c00016c4:	0f 95 c0             	setne  %al
c00016c7:	0f b6 d8             	movzbl %al,%ebx
                                                            (regs->eflags&EFLAGS_AF) == EFLAGS_AF,
c00016ca:	8b 45 08             	mov    0x8(%ebp),%eax
c00016cd:	8b 40 24             	mov    0x24(%eax),%eax
c00016d0:	83 e0 10             	and    $0x10,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c00016d3:	85 c0                	test   %eax,%eax
c00016d5:	0f 95 c0             	setne  %al
c00016d8:	0f b6 c8             	movzbl %al,%ecx
                                                            (regs->eflags&EFLAGS_PF) == EFLAGS_PF,
c00016db:	8b 45 08             	mov    0x8(%ebp),%eax
c00016de:	8b 40 24             	mov    0x24(%eax),%eax
c00016e1:	83 e0 04             	and    $0x4,%eax
    kprintf("eflags: CF=%d PF=%d AF=%d ZF=%d SF=%d TF=%d\n", (regs->eflags&EFLAGS_CF) == EFLAGS_CF,
c00016e4:	85 c0                	test   %eax,%eax
c00016e6:	0f 95 c0             	setne  %al
c00016e9:	0f b6 d0             	movzbl %al,%edx
c00016ec:	8b 45 08             	mov    0x8(%ebp),%eax
c00016ef:	8b 40 24             	mov    0x24(%eax),%eax
c00016f2:	83 e0 01             	and    $0x1,%eax
c00016f5:	85 c0                	test   %eax,%eax
c00016f7:	0f 95 c0             	setne  %al
c00016fa:	0f b6 c0             	movzbl %al,%eax
c00016fd:	83 ec 04             	sub    $0x4,%esp
c0001700:	57                   	push   %edi
c0001701:	56                   	push   %esi
c0001702:	53                   	push   %ebx
c0001703:	51                   	push   %ecx
c0001704:	52                   	push   %edx
c0001705:	50                   	push   %eax
c0001706:	68 98 44 00 c0       	push   $0xc0004498
c000170b:	e8 6f ed ff ff       	call   c000047f <kprintf>
c0001710:	83 c4 20             	add    $0x20,%esp
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
                                                            (regs->eflags&EFLAGS_DF) == EFLAGS_DF,
                                                            (regs->eflags&EFLAGS_OF) == EFLAGS_OF,
                                                            (regs->eflags&EFLAGS_IOPL) >> 12,
                                                            (regs->eflags&EFLAGS_NT) == EFLAGS_NT,
                                                            (regs->eflags&EFLAGS_RF) == EFLAGS_RF);
c0001713:	8b 45 08             	mov    0x8(%ebp),%eax
c0001716:	8b 40 24             	mov    0x24(%eax),%eax
c0001719:	25 00 00 01 00       	and    $0x10000,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c000171e:	85 c0                	test   %eax,%eax
c0001720:	0f 95 c0             	setne  %al
c0001723:	0f b6 f0             	movzbl %al,%esi
                                                            (regs->eflags&EFLAGS_NT) == EFLAGS_NT,
c0001726:	8b 45 08             	mov    0x8(%ebp),%eax
c0001729:	8b 40 24             	mov    0x24(%eax),%eax
c000172c:	25 00 40 00 00       	and    $0x4000,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001731:	85 c0                	test   %eax,%eax
c0001733:	0f 95 c0             	setne  %al
c0001736:	0f b6 d8             	movzbl %al,%ebx
                                                            (regs->eflags&EFLAGS_IOPL) >> 12,
c0001739:	8b 45 08             	mov    0x8(%ebp),%eax
c000173c:	8b 40 24             	mov    0x24(%eax),%eax
c000173f:	c1 e8 0c             	shr    $0xc,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001742:	83 e0 03             	and    $0x3,%eax
c0001745:	89 c7                	mov    %eax,%edi
                                                            (regs->eflags&EFLAGS_OF) == EFLAGS_OF,
c0001747:	8b 45 08             	mov    0x8(%ebp),%eax
c000174a:	8b 40 24             	mov    0x24(%eax),%eax
c000174d:	25 00 08 00 00       	and    $0x800,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001752:	85 c0                	test   %eax,%eax
c0001754:	0f 95 c0             	setne  %al
c0001757:	0f b6 c8             	movzbl %al,%ecx
                                                            (regs->eflags&EFLAGS_DF) == EFLAGS_DF,
c000175a:	8b 45 08             	mov    0x8(%ebp),%eax
c000175d:	8b 40 24             	mov    0x24(%eax),%eax
c0001760:	25 00 04 00 00       	and    $0x400,%eax
    kprintf("        IF=%d DF=%d OF=%d IOPL=%d NT=%d RF=%d\n", (regs->eflags&EFLAGS_IF) == EFLAGS_IF,
c0001765:	85 c0                	test   %eax,%eax
c0001767:	0f 95 c0             	setne  %al
c000176a:	0f b6 d0             	movzbl %al,%edx
c000176d:	8b 45 08             	mov    0x8(%ebp),%eax
c0001770:	8b 40 24             	mov    0x24(%eax),%eax
c0001773:	25 00 02 00 00       	and    $0x200,%eax
c0001778:	85 c0                	test   %eax,%eax
c000177a:	0f 95 c0             	setne  %al
c000177d:	0f b6 c0             	movzbl %al,%eax
c0001780:	83 ec 04             	sub    $0x4,%esp
c0001783:	56                   	push   %esi
c0001784:	53                   	push   %ebx
c0001785:	57                   	push   %edi
c0001786:	51                   	push   %ecx
c0001787:	52                   	push   %edx
c0001788:	50                   	push   %eax
c0001789:	68 c8 44 00 c0       	push   $0xc00044c8
c000178e:	e8 ec ec ff ff       	call   c000047f <kprintf>
c0001793:	83 c4 20             	add    $0x20,%esp
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
                                                            (regs->eflags&EFLAGS_AC) == EFLAGS_AC,
                                                            (regs->eflags&EFLAGS_VIF) == EFLAGS_VIF,
                                                            (regs->eflags&EFLAGS_VIP) == EFLAGS_VIP,
                                                            (regs->eflags&EFLAGS_ID) == EFLAGS_ID);
c0001796:	8b 45 08             	mov    0x8(%ebp),%eax
c0001799:	8b 40 24             	mov    0x24(%eax),%eax
c000179c:	25 00 00 20 00       	and    $0x200000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c00017a1:	85 c0                	test   %eax,%eax
c00017a3:	0f 95 c0             	setne  %al
c00017a6:	0f b6 f0             	movzbl %al,%esi
                                                            (regs->eflags&EFLAGS_VIP) == EFLAGS_VIP,
c00017a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00017ac:	8b 40 24             	mov    0x24(%eax),%eax
c00017af:	25 00 00 10 00       	and    $0x100000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c00017b4:	85 c0                	test   %eax,%eax
c00017b6:	0f 95 c0             	setne  %al
c00017b9:	0f b6 d8             	movzbl %al,%ebx
                                                            (regs->eflags&EFLAGS_VIF) == EFLAGS_VIF,
c00017bc:	8b 45 08             	mov    0x8(%ebp),%eax
c00017bf:	8b 40 24             	mov    0x24(%eax),%eax
c00017c2:	25 00 00 08 00       	and    $0x80000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c00017c7:	85 c0                	test   %eax,%eax
c00017c9:	0f 95 c0             	setne  %al
c00017cc:	0f b6 c8             	movzbl %al,%ecx
                                                            (regs->eflags&EFLAGS_AC) == EFLAGS_AC,
c00017cf:	8b 45 08             	mov    0x8(%ebp),%eax
c00017d2:	8b 40 24             	mov    0x24(%eax),%eax
c00017d5:	25 00 00 04 00       	and    $0x40000,%eax
    kprintf("        VM=%d AC=%d VIF=%d VIP=%d ID=%d\n", (regs->eflags&EFLAGS_VM) == EFLAGS_VM,
c00017da:	85 c0                	test   %eax,%eax
c00017dc:	0f 95 c0             	setne  %al
c00017df:	0f b6 d0             	movzbl %al,%edx
c00017e2:	8b 45 08             	mov    0x8(%ebp),%eax
c00017e5:	8b 40 24             	mov    0x24(%eax),%eax
c00017e8:	25 00 00 02 00       	and    $0x20000,%eax
c00017ed:	85 c0                	test   %eax,%eax
c00017ef:	0f 95 c0             	setne  %al
c00017f2:	0f b6 c0             	movzbl %al,%eax
c00017f5:	83 ec 08             	sub    $0x8,%esp
c00017f8:	56                   	push   %esi
c00017f9:	53                   	push   %ebx
c00017fa:	51                   	push   %ecx
c00017fb:	52                   	push   %edx
c00017fc:	50                   	push   %eax
c00017fd:	68 f8 44 00 c0       	push   $0xc00044f8
c0001802:	e8 78 ec ff ff       	call   c000047f <kprintf>
c0001807:	83 c4 20             	add    $0x20,%esp
    kprintf("cr0: 0x%x\n", regs->cr0);
c000180a:	8b 45 08             	mov    0x8(%ebp),%eax
c000180d:	8b 40 28             	mov    0x28(%eax),%eax
c0001810:	83 ec 08             	sub    $0x8,%esp
c0001813:	50                   	push   %eax
c0001814:	68 21 45 00 c0       	push   $0xc0004521
c0001819:	e8 61 ec ff ff       	call   c000047f <kprintf>
c000181e:	83 c4 10             	add    $0x10,%esp
    kprintf("cr2: 0x%x\n", regs->cr2);
c0001821:	8b 45 08             	mov    0x8(%ebp),%eax
c0001824:	8b 40 2c             	mov    0x2c(%eax),%eax
c0001827:	83 ec 08             	sub    $0x8,%esp
c000182a:	50                   	push   %eax
c000182b:	68 2c 45 00 c0       	push   $0xc000452c
c0001830:	e8 4a ec ff ff       	call   c000047f <kprintf>
c0001835:	83 c4 10             	add    $0x10,%esp
    kprintf("cr3: 0x%x\n", regs->cr3);
c0001838:	8b 45 08             	mov    0x8(%ebp),%eax
c000183b:	8b 40 30             	mov    0x30(%eax),%eax
c000183e:	83 ec 08             	sub    $0x8,%esp
c0001841:	50                   	push   %eax
c0001842:	68 37 45 00 c0       	push   $0xc0004537
c0001847:	e8 33 ec ff ff       	call   c000047f <kprintf>
c000184c:	83 c4 10             	add    $0x10,%esp
    kprintf("cr4: 0x%x\n", regs->cr4);
c000184f:	8b 45 08             	mov    0x8(%ebp),%eax
c0001852:	8b 40 34             	mov    0x34(%eax),%eax
c0001855:	83 ec 08             	sub    $0x8,%esp
c0001858:	50                   	push   %eax
c0001859:	68 42 45 00 c0       	push   $0xc0004542
c000185e:	e8 1c ec ff ff       	call   c000047f <kprintf>
c0001863:	83 c4 10             	add    $0x10,%esp
}
c0001866:	90                   	nop
c0001867:	8d 65 f4             	lea    -0xc(%ebp),%esp
c000186a:	5b                   	pop    %ebx
c000186b:	5e                   	pop    %esi
c000186c:	5f                   	pop    %edi
c000186d:	5d                   	pop    %ebp
c000186e:	c3                   	ret    

c000186f <memory_table>:
#include "multiboot.h"
#include "kprintf.h"

size_t memory_table(multiboot_info_t* mbd)
{
c000186f:	55                   	push   %ebp
c0001870:	89 e5                	mov    %esp,%ebp
c0001872:	56                   	push   %esi
c0001873:	53                   	push   %ebx
c0001874:	83 ec 10             	sub    $0x10,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c0001877:	8b 45 08             	mov    0x8(%ebp),%eax
c000187a:	8b 40 30             	mov    0x30(%eax),%eax
c000187d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    size_t available_mem = 0;
c0001880:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001887:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c000188e:	e9 83 00 00 00       	jmp    c0001916 <memory_table+0xa7>
	{
		if(mmap_table[nn].len>0 && mmap_table[nn].size>0)
c0001893:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0001896:	89 d0                	mov    %edx,%eax
c0001898:	01 c0                	add    %eax,%eax
c000189a:	01 d0                	add    %edx,%eax
c000189c:	c1 e0 03             	shl    $0x3,%eax
c000189f:	89 c2                	mov    %eax,%edx
c00018a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00018a4:	01 d0                	add    %edx,%eax
c00018a6:	8b 50 10             	mov    0x10(%eax),%edx
c00018a9:	8b 40 0c             	mov    0xc(%eax),%eax
c00018ac:	89 c6                	mov    %eax,%esi
c00018ae:	83 f6 00             	xor    $0x0,%esi
c00018b1:	89 f1                	mov    %esi,%ecx
c00018b3:	89 d0                	mov    %edx,%eax
c00018b5:	80 f4 00             	xor    $0x0,%ah
c00018b8:	89 c3                	mov    %eax,%ebx
c00018ba:	89 d8                	mov    %ebx,%eax
c00018bc:	09 c8                	or     %ecx,%eax
c00018be:	85 c0                	test   %eax,%eax
c00018c0:	74 50                	je     c0001912 <memory_table+0xa3>
c00018c2:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00018c5:	89 d0                	mov    %edx,%eax
c00018c7:	01 c0                	add    %eax,%eax
c00018c9:	01 d0                	add    %edx,%eax
c00018cb:	c1 e0 03             	shl    $0x3,%eax
c00018ce:	89 c2                	mov    %eax,%edx
c00018d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00018d3:	01 d0                	add    %edx,%eax
c00018d5:	8b 00                	mov    (%eax),%eax
c00018d7:	85 c0                	test   %eax,%eax
c00018d9:	74 37                	je     c0001912 <memory_table+0xa3>
        {
            if(mmap_table[nn].type == 1)
c00018db:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00018de:	89 d0                	mov    %edx,%eax
c00018e0:	01 c0                	add    %eax,%eax
c00018e2:	01 d0                	add    %edx,%eax
c00018e4:	c1 e0 03             	shl    $0x3,%eax
c00018e7:	89 c2                	mov    %eax,%edx
c00018e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00018ec:	01 d0                	add    %edx,%eax
c00018ee:	8b 40 14             	mov    0x14(%eax),%eax
c00018f1:	83 f8 01             	cmp    $0x1,%eax
c00018f4:	75 1c                	jne    c0001912 <memory_table+0xa3>
            available_mem += mmap_table[nn].len;
c00018f6:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00018f9:	89 d0                	mov    %edx,%eax
c00018fb:	01 c0                	add    %eax,%eax
c00018fd:	01 d0                	add    %edx,%eax
c00018ff:	c1 e0 03             	shl    $0x3,%eax
c0001902:	89 c2                	mov    %eax,%edx
c0001904:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001907:	01 d0                	add    %edx,%eax
c0001909:	8b 50 10             	mov    0x10(%eax),%edx
c000190c:	8b 40 0c             	mov    0xc(%eax),%eax
c000190f:	01 45 f4             	add    %eax,-0xc(%ebp)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001912:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0001916:	8b 45 08             	mov    0x8(%ebp),%eax
c0001919:	8b 40 2c             	mov    0x2c(%eax),%eax
c000191c:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c000191f:	0f 82 6e ff ff ff    	jb     c0001893 <memory_table+0x24>
        }
		
	}

    return available_mem;
c0001925:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0001928:	83 c4 10             	add    $0x10,%esp
c000192b:	5b                   	pop    %ebx
c000192c:	5e                   	pop    %esi
c000192d:	5d                   	pop    %ebp
c000192e:	c3                   	ret    

c000192f <print_memory_table>:

int print_memory_table(multiboot_info_t* mbd)
{
c000192f:	55                   	push   %ebp
c0001930:	89 e5                	mov    %esp,%ebp
c0001932:	57                   	push   %edi
c0001933:	56                   	push   %esi
c0001934:	53                   	push   %ebx
c0001935:	83 ec 2c             	sub    $0x2c,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c0001938:	8b 45 08             	mov    0x8(%ebp),%eax
c000193b:	8b 40 30             	mov    0x30(%eax),%eax
c000193e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	kprintf("Memory Table:\n");
c0001941:	83 ec 0c             	sub    $0xc,%esp
c0001944:	68 50 45 00 c0       	push   $0xc0004550
c0001949:	e8 31 eb ff ff       	call   c000047f <kprintf>
c000194e:	83 c4 10             	add    $0x10,%esp
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001951:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c0001958:	e9 a6 01 00 00       	jmp    c0001b03 <print_memory_table+0x1d4>
	{
        if(mmap_table[nn].size == 0)
c000195d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001960:	89 d0                	mov    %edx,%eax
c0001962:	01 c0                	add    %eax,%eax
c0001964:	01 d0                	add    %edx,%eax
c0001966:	c1 e0 03             	shl    $0x3,%eax
c0001969:	89 c2                	mov    %eax,%edx
c000196b:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000196e:	01 d0                	add    %edx,%eax
c0001970:	8b 00                	mov    (%eax),%eax
c0001972:	85 c0                	test   %eax,%eax
c0001974:	0f 84 9a 01 00 00    	je     c0001b14 <print_memory_table+0x1e5>
            break;

		if(mmap_table[nn].len>0)
c000197a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c000197d:	89 d0                	mov    %edx,%eax
c000197f:	01 c0                	add    %eax,%eax
c0001981:	01 d0                	add    %edx,%eax
c0001983:	c1 e0 03             	shl    $0x3,%eax
c0001986:	89 c2                	mov    %eax,%edx
c0001988:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000198b:	01 d0                	add    %edx,%eax
c000198d:	8b 50 10             	mov    0x10(%eax),%edx
c0001990:	8b 40 0c             	mov    0xc(%eax),%eax
c0001993:	89 c7                	mov    %eax,%edi
c0001995:	83 f7 00             	xor    $0x0,%edi
c0001998:	89 7d d0             	mov    %edi,-0x30(%ebp)
c000199b:	89 d0                	mov    %edx,%eax
c000199d:	80 f4 00             	xor    $0x0,%ah
c00019a0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
c00019a3:	8b 5d d0             	mov    -0x30(%ebp),%ebx
c00019a6:	8b 75 d4             	mov    -0x2c(%ebp),%esi
c00019a9:	89 f0                	mov    %esi,%eax
c00019ab:	09 d8                	or     %ebx,%eax
c00019ad:	85 c0                	test   %eax,%eax
c00019af:	0f 84 4a 01 00 00    	je     c0001aff <print_memory_table+0x1d0>
		{
			if(mmap_table[nn].type == MULTIBOOT_MEMORY_AVAILABLE)
c00019b5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00019b8:	89 d0                	mov    %edx,%eax
c00019ba:	01 c0                	add    %eax,%eax
c00019bc:	01 d0                	add    %edx,%eax
c00019be:	c1 e0 03             	shl    $0x3,%eax
c00019c1:	89 c2                	mov    %eax,%edx
c00019c3:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00019c6:	01 d0                	add    %edx,%eax
c00019c8:	8b 40 14             	mov    0x14(%eax),%eax
c00019cb:	83 f8 01             	cmp    $0x1,%eax
c00019ce:	0f 85 98 00 00 00    	jne    c0001a6c <print_memory_table+0x13d>
				kprintf("%.8llp - %.8llp [AVAILABLE] (%6llu kiB)\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c00019d4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00019d7:	89 d0                	mov    %edx,%eax
c00019d9:	01 c0                	add    %eax,%eax
c00019db:	01 d0                	add    %edx,%eax
c00019dd:	c1 e0 03             	shl    $0x3,%eax
c00019e0:	89 c2                	mov    %eax,%edx
c00019e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00019e5:	01 d0                	add    %edx,%eax
c00019e7:	8b 50 10             	mov    0x10(%eax),%edx
c00019ea:	8b 40 0c             	mov    0xc(%eax),%eax
c00019ed:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c00019f1:	c1 ea 0a             	shr    $0xa,%edx
c00019f4:	89 c6                	mov    %eax,%esi
c00019f6:	89 d7                	mov    %edx,%edi
c00019f8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00019fb:	89 d0                	mov    %edx,%eax
c00019fd:	01 c0                	add    %eax,%eax
c00019ff:	01 d0                	add    %edx,%eax
c0001a01:	c1 e0 03             	shl    $0x3,%eax
c0001a04:	89 c2                	mov    %eax,%edx
c0001a06:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001a09:	01 d0                	add    %edx,%eax
c0001a0b:	8b 48 04             	mov    0x4(%eax),%ecx
c0001a0e:	8b 58 08             	mov    0x8(%eax),%ebx
c0001a11:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001a14:	89 d0                	mov    %edx,%eax
c0001a16:	01 c0                	add    %eax,%eax
c0001a18:	01 d0                	add    %edx,%eax
c0001a1a:	c1 e0 03             	shl    $0x3,%eax
c0001a1d:	89 c2                	mov    %eax,%edx
c0001a1f:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001a22:	01 d0                	add    %edx,%eax
c0001a24:	8b 50 10             	mov    0x10(%eax),%edx
c0001a27:	8b 40 0c             	mov    0xc(%eax),%eax
c0001a2a:	01 c8                	add    %ecx,%eax
c0001a2c:	11 da                	adc    %ebx,%edx
c0001a2e:	83 c0 ff             	add    $0xffffffff,%eax
c0001a31:	83 d2 ff             	adc    $0xffffffff,%edx
c0001a34:	89 c1                	mov    %eax,%ecx
c0001a36:	89 d3                	mov    %edx,%ebx
c0001a38:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001a3b:	89 d0                	mov    %edx,%eax
c0001a3d:	01 c0                	add    %eax,%eax
c0001a3f:	01 d0                	add    %edx,%eax
c0001a41:	c1 e0 03             	shl    $0x3,%eax
c0001a44:	89 c2                	mov    %eax,%edx
c0001a46:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001a49:	01 d0                	add    %edx,%eax
c0001a4b:	8b 50 08             	mov    0x8(%eax),%edx
c0001a4e:	8b 40 04             	mov    0x4(%eax),%eax
c0001a51:	83 ec 04             	sub    $0x4,%esp
c0001a54:	57                   	push   %edi
c0001a55:	56                   	push   %esi
c0001a56:	53                   	push   %ebx
c0001a57:	51                   	push   %ecx
c0001a58:	52                   	push   %edx
c0001a59:	50                   	push   %eax
c0001a5a:	68 60 45 00 c0       	push   $0xc0004560
c0001a5f:	e8 1b ea ff ff       	call   c000047f <kprintf>
c0001a64:	83 c4 20             	add    $0x20,%esp
c0001a67:	e9 93 00 00 00       	jmp    c0001aff <print_memory_table+0x1d0>
			else
				kprintf("%.8llp - %.8llp [RESERVED]\n", mmap_table[nn].addr, mmap_table[nn].addr+mmap_table[nn].len - 1, mmap_table[nn].len/1024);
c0001a6c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001a6f:	89 d0                	mov    %edx,%eax
c0001a71:	01 c0                	add    %eax,%eax
c0001a73:	01 d0                	add    %edx,%eax
c0001a75:	c1 e0 03             	shl    $0x3,%eax
c0001a78:	89 c2                	mov    %eax,%edx
c0001a7a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001a7d:	01 d0                	add    %edx,%eax
c0001a7f:	8b 50 10             	mov    0x10(%eax),%edx
c0001a82:	8b 40 0c             	mov    0xc(%eax),%eax
c0001a85:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c0001a89:	c1 ea 0a             	shr    $0xa,%edx
c0001a8c:	89 c6                	mov    %eax,%esi
c0001a8e:	89 d7                	mov    %edx,%edi
c0001a90:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001a93:	89 d0                	mov    %edx,%eax
c0001a95:	01 c0                	add    %eax,%eax
c0001a97:	01 d0                	add    %edx,%eax
c0001a99:	c1 e0 03             	shl    $0x3,%eax
c0001a9c:	89 c2                	mov    %eax,%edx
c0001a9e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001aa1:	01 d0                	add    %edx,%eax
c0001aa3:	8b 48 04             	mov    0x4(%eax),%ecx
c0001aa6:	8b 58 08             	mov    0x8(%eax),%ebx
c0001aa9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001aac:	89 d0                	mov    %edx,%eax
c0001aae:	01 c0                	add    %eax,%eax
c0001ab0:	01 d0                	add    %edx,%eax
c0001ab2:	c1 e0 03             	shl    $0x3,%eax
c0001ab5:	89 c2                	mov    %eax,%edx
c0001ab7:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001aba:	01 d0                	add    %edx,%eax
c0001abc:	8b 50 10             	mov    0x10(%eax),%edx
c0001abf:	8b 40 0c             	mov    0xc(%eax),%eax
c0001ac2:	01 c8                	add    %ecx,%eax
c0001ac4:	11 da                	adc    %ebx,%edx
c0001ac6:	83 c0 ff             	add    $0xffffffff,%eax
c0001ac9:	83 d2 ff             	adc    $0xffffffff,%edx
c0001acc:	89 c1                	mov    %eax,%ecx
c0001ace:	89 d3                	mov    %edx,%ebx
c0001ad0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0001ad3:	89 d0                	mov    %edx,%eax
c0001ad5:	01 c0                	add    %eax,%eax
c0001ad7:	01 d0                	add    %edx,%eax
c0001ad9:	c1 e0 03             	shl    $0x3,%eax
c0001adc:	89 c2                	mov    %eax,%edx
c0001ade:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0001ae1:	01 d0                	add    %edx,%eax
c0001ae3:	8b 50 08             	mov    0x8(%eax),%edx
c0001ae6:	8b 40 04             	mov    0x4(%eax),%eax
c0001ae9:	83 ec 04             	sub    $0x4,%esp
c0001aec:	57                   	push   %edi
c0001aed:	56                   	push   %esi
c0001aee:	53                   	push   %ebx
c0001aef:	51                   	push   %ecx
c0001af0:	52                   	push   %edx
c0001af1:	50                   	push   %eax
c0001af2:	68 89 45 00 c0       	push   $0xc0004589
c0001af7:	e8 83 e9 ff ff       	call   c000047f <kprintf>
c0001afc:	83 c4 20             	add    $0x20,%esp
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c0001aff:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c0001b03:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b06:	8b 40 2c             	mov    0x2c(%eax),%eax
c0001b09:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c0001b0c:	0f 82 4b fe ff ff    	jb     c000195d <print_memory_table+0x2e>
c0001b12:	eb 01                	jmp    c0001b15 <print_memory_table+0x1e6>
            break;
c0001b14:	90                   	nop
    //         kprintf("[%3u] %p (%#x)\n", nn, addr, flags);		
	// }

    // print_crs();

    return 0;
c0001b15:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0001b1a:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0001b1d:	5b                   	pop    %ebx
c0001b1e:	5e                   	pop    %esi
c0001b1f:	5f                   	pop    %edi
c0001b20:	5d                   	pop    %ebp
c0001b21:	c3                   	ret    

c0001b22 <inb>:
{
c0001b22:	55                   	push   %ebp
c0001b23:	89 e5                	mov    %esp,%ebp
c0001b25:	83 ec 14             	sub    $0x14,%esp
c0001b28:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b2b:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  __asm__ __volatile__ ("inb %w1,%0":"=a" (_v):"Nd" (__port));
c0001b2f:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0001b33:	89 c2                	mov    %eax,%edx
c0001b35:	ec                   	in     (%dx),%al
c0001b36:	88 45 ff             	mov    %al,-0x1(%ebp)
  return _v;
c0001b39:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0001b3d:	c9                   	leave  
c0001b3e:	c3                   	ret    

c0001b3f <outb>:
{
c0001b3f:	55                   	push   %ebp
c0001b40:	89 e5                	mov    %esp,%ebp
c0001b42:	83 ec 08             	sub    $0x8,%esp
c0001b45:	8b 55 08             	mov    0x8(%ebp),%edx
c0001b48:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001b4b:	88 55 fc             	mov    %dl,-0x4(%ebp)
c0001b4e:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
c0001b52:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0001b56:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
c0001b5a:	ee                   	out    %al,(%dx)
}
c0001b5b:	90                   	nop
c0001b5c:	c9                   	leave  
c0001b5d:	c3                   	ret    

c0001b5e <init_interrupts>:

idt_entry_t __aligned idt[NUM_INTERRUPT_HANDLERS] = {0};
idt_descriptor_t __aligned idtd;

void init_interrupts()
{
c0001b5e:	55                   	push   %ebp
c0001b5f:	89 e5                	mov    %esp,%ebp
c0001b61:	83 ec 08             	sub    $0x8,%esp
    /* init the PIC */
	outb(PIC_INIT, PIC1_CMD);  // init PIC 1
c0001b64:	6a 20                	push   $0x20
c0001b66:	6a 11                	push   $0x11
c0001b68:	e8 d2 ff ff ff       	call   c0001b3f <outb>
c0001b6d:	83 c4 08             	add    $0x8,%esp
    outb(PIC_INIT, PIC2_CMD);  // init PIC 2
c0001b70:	68 a0 00 00 00       	push   $0xa0
c0001b75:	6a 11                	push   $0x11
c0001b77:	e8 c3 ff ff ff       	call   c0001b3f <outb>
c0001b7c:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_OFFSET, PIC1_DATA); // map irq 0x0-0x7 to int 0x20-0x27
c0001b7f:	6a 21                	push   $0x21
c0001b81:	6a 20                	push   $0x20
c0001b83:	e8 b7 ff ff ff       	call   c0001b3f <outb>
c0001b88:	83 c4 08             	add    $0x8,%esp
    outb(PIC2_OFFSET, PIC2_DATA); // map irq 0x8-0xf to int 0x28-0x2f
c0001b8b:	68 a1 00 00 00       	push   $0xa1
c0001b90:	6a 28                	push   $0x28
c0001b92:	e8 a8 ff ff ff       	call   c0001b3f <outb>
c0001b97:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_MS, PIC1_DATA);     // pic1 is master, with slave at irq 2
c0001b9a:	6a 21                	push   $0x21
c0001b9c:	6a 04                	push   $0x4
c0001b9e:	e8 9c ff ff ff       	call   c0001b3f <outb>
c0001ba3:	83 c4 08             	add    $0x8,%esp
    outb(PIC2_MS, PIC2_DATA);     // pic2 is slave with id 2
c0001ba6:	68 a1 00 00 00       	push   $0xa1
c0001bab:	6a 02                	push   $0x2
c0001bad:	e8 8d ff ff ff       	call   c0001b3f <outb>
c0001bb2:	83 c4 08             	add    $0x8,%esp
    outb(PIC_8086MODE, PIC1_DATA); //enable 8086 mode
c0001bb5:	6a 21                	push   $0x21
c0001bb7:	6a 01                	push   $0x1
c0001bb9:	e8 81 ff ff ff       	call   c0001b3f <outb>
c0001bbe:	83 c4 08             	add    $0x8,%esp
    outb(PIC_8086MODE, PIC2_DATA); //enable 8086 mode
c0001bc1:	68 a1 00 00 00       	push   $0xa1
c0001bc6:	6a 01                	push   $0x1
c0001bc8:	e8 72 ff ff ff       	call   c0001b3f <outb>
c0001bcd:	83 c4 08             	add    $0x8,%esp
    // interrupt mask
    outb( ~(1<<1) , PIC1_DATA); //enable irq1 (keyboard)
c0001bd0:	6a 21                	push   $0x21
c0001bd2:	68 fd 00 00 00       	push   $0xfd
c0001bd7:	e8 63 ff ff ff       	call   c0001b3f <outb>
c0001bdc:	83 c4 08             	add    $0x8,%esp
    outb(0xff, PIC2_DATA); //disable interrupts from slave
c0001bdf:	68 a1 00 00 00       	push   $0xa1
c0001be4:	68 ff 00 00 00       	push   $0xff
c0001be9:	e8 51 ff ff ff       	call   c0001b3f <outb>
c0001bee:	83 c4 08             	add    $0x8,%esp


    // individual handler routines defined in interrupt.S
    // these call back to exception_handler() and irq_handler()
    set_interrupt_handler(0,except_0);
c0001bf1:	83 ec 08             	sub    $0x8,%esp
c0001bf4:	68 f8 2d 00 c0       	push   $0xc0002df8
c0001bf9:	6a 00                	push   $0x0
c0001bfb:	e8 94 02 00 00       	call   c0001e94 <set_interrupt_handler>
c0001c00:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(1,except_1);
c0001c03:	83 ec 08             	sub    $0x8,%esp
c0001c06:	68 18 2e 00 c0       	push   $0xc0002e18
c0001c0b:	6a 01                	push   $0x1
c0001c0d:	e8 82 02 00 00       	call   c0001e94 <set_interrupt_handler>
c0001c12:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(2,except_2);
c0001c15:	83 ec 08             	sub    $0x8,%esp
c0001c18:	68 38 2e 00 c0       	push   $0xc0002e38
c0001c1d:	6a 02                	push   $0x2
c0001c1f:	e8 70 02 00 00       	call   c0001e94 <set_interrupt_handler>
c0001c24:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(3,except_3);
c0001c27:	83 ec 08             	sub    $0x8,%esp
c0001c2a:	68 58 2e 00 c0       	push   $0xc0002e58
c0001c2f:	6a 03                	push   $0x3
c0001c31:	e8 5e 02 00 00       	call   c0001e94 <set_interrupt_handler>
c0001c36:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(4,except_4);
c0001c39:	83 ec 08             	sub    $0x8,%esp
c0001c3c:	68 78 2e 00 c0       	push   $0xc0002e78
c0001c41:	6a 04                	push   $0x4
c0001c43:	e8 4c 02 00 00       	call   c0001e94 <set_interrupt_handler>
c0001c48:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(5,except_5);
c0001c4b:	83 ec 08             	sub    $0x8,%esp
c0001c4e:	68 98 2e 00 c0       	push   $0xc0002e98
c0001c53:	6a 05                	push   $0x5
c0001c55:	e8 3a 02 00 00       	call   c0001e94 <set_interrupt_handler>
c0001c5a:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(6,except_6);
c0001c5d:	83 ec 08             	sub    $0x8,%esp
c0001c60:	68 b8 2e 00 c0       	push   $0xc0002eb8
c0001c65:	6a 06                	push   $0x6
c0001c67:	e8 28 02 00 00       	call   c0001e94 <set_interrupt_handler>
c0001c6c:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(7,except_7);
c0001c6f:	83 ec 08             	sub    $0x8,%esp
c0001c72:	68 d8 2e 00 c0       	push   $0xc0002ed8
c0001c77:	6a 07                	push   $0x7
c0001c79:	e8 16 02 00 00       	call   c0001e94 <set_interrupt_handler>
c0001c7e:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(8,except_8);
c0001c81:	83 ec 08             	sub    $0x8,%esp
c0001c84:	68 f8 2e 00 c0       	push   $0xc0002ef8
c0001c89:	6a 08                	push   $0x8
c0001c8b:	e8 04 02 00 00       	call   c0001e94 <set_interrupt_handler>
c0001c90:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(10,except_10);
c0001c93:	83 ec 08             	sub    $0x8,%esp
c0001c96:	68 18 2f 00 c0       	push   $0xc0002f18
c0001c9b:	6a 0a                	push   $0xa
c0001c9d:	e8 f2 01 00 00       	call   c0001e94 <set_interrupt_handler>
c0001ca2:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(11,except_11);
c0001ca5:	83 ec 08             	sub    $0x8,%esp
c0001ca8:	68 38 2f 00 c0       	push   $0xc0002f38
c0001cad:	6a 0b                	push   $0xb
c0001caf:	e8 e0 01 00 00       	call   c0001e94 <set_interrupt_handler>
c0001cb4:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(12,except_12);
c0001cb7:	83 ec 08             	sub    $0x8,%esp
c0001cba:	68 58 2f 00 c0       	push   $0xc0002f58
c0001cbf:	6a 0c                	push   $0xc
c0001cc1:	e8 ce 01 00 00       	call   c0001e94 <set_interrupt_handler>
c0001cc6:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(13,except_13);
c0001cc9:	83 ec 08             	sub    $0x8,%esp
c0001ccc:	68 78 2f 00 c0       	push   $0xc0002f78
c0001cd1:	6a 0d                	push   $0xd
c0001cd3:	e8 bc 01 00 00       	call   c0001e94 <set_interrupt_handler>
c0001cd8:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(14,except_14);
c0001cdb:	83 ec 08             	sub    $0x8,%esp
c0001cde:	68 98 2f 00 c0       	push   $0xc0002f98
c0001ce3:	6a 0e                	push   $0xe
c0001ce5:	e8 aa 01 00 00       	call   c0001e94 <set_interrupt_handler>
c0001cea:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(16,except_16);
c0001ced:	83 ec 08             	sub    $0x8,%esp
c0001cf0:	68 b8 2f 00 c0       	push   $0xc0002fb8
c0001cf5:	6a 10                	push   $0x10
c0001cf7:	e8 98 01 00 00       	call   c0001e94 <set_interrupt_handler>
c0001cfc:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(17,except_17);
c0001cff:	83 ec 08             	sub    $0x8,%esp
c0001d02:	68 d8 2f 00 c0       	push   $0xc0002fd8
c0001d07:	6a 11                	push   $0x11
c0001d09:	e8 86 01 00 00       	call   c0001e94 <set_interrupt_handler>
c0001d0e:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(18,except_18);
c0001d11:	83 ec 08             	sub    $0x8,%esp
c0001d14:	68 f8 2f 00 c0       	push   $0xc0002ff8
c0001d19:	6a 12                	push   $0x12
c0001d1b:	e8 74 01 00 00       	call   c0001e94 <set_interrupt_handler>
c0001d20:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(19,except_19);
c0001d23:	83 ec 08             	sub    $0x8,%esp
c0001d26:	68 18 30 00 c0       	push   $0xc0003018
c0001d2b:	6a 13                	push   $0x13
c0001d2d:	e8 62 01 00 00       	call   c0001e94 <set_interrupt_handler>
c0001d32:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(20,except_20);
c0001d35:	83 ec 08             	sub    $0x8,%esp
c0001d38:	68 38 30 00 c0       	push   $0xc0003038
c0001d3d:	6a 14                	push   $0x14
c0001d3f:	e8 50 01 00 00       	call   c0001e94 <set_interrupt_handler>
c0001d44:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(30,except_30);
c0001d47:	83 ec 08             	sub    $0x8,%esp
c0001d4a:	68 58 30 00 c0       	push   $0xc0003058
c0001d4f:	6a 1e                	push   $0x1e
c0001d51:	e8 3e 01 00 00       	call   c0001e94 <set_interrupt_handler>
c0001d56:	83 c4 10             	add    $0x10,%esp

    set_interrupt_handler(32,irq_0);
c0001d59:	83 ec 08             	sub    $0x8,%esp
c0001d5c:	68 78 30 00 c0       	push   $0xc0003078
c0001d61:	6a 20                	push   $0x20
c0001d63:	e8 2c 01 00 00       	call   c0001e94 <set_interrupt_handler>
c0001d68:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(33,irq_1);
c0001d6b:	83 ec 08             	sub    $0x8,%esp
c0001d6e:	68 8c 30 00 c0       	push   $0xc000308c
c0001d73:	6a 21                	push   $0x21
c0001d75:	e8 1a 01 00 00       	call   c0001e94 <set_interrupt_handler>
c0001d7a:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(34,irq_2);
c0001d7d:	83 ec 08             	sub    $0x8,%esp
c0001d80:	68 a0 30 00 c0       	push   $0xc00030a0
c0001d85:	6a 22                	push   $0x22
c0001d87:	e8 08 01 00 00       	call   c0001e94 <set_interrupt_handler>
c0001d8c:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(35,irq_3);
c0001d8f:	83 ec 08             	sub    $0x8,%esp
c0001d92:	68 b4 30 00 c0       	push   $0xc00030b4
c0001d97:	6a 23                	push   $0x23
c0001d99:	e8 f6 00 00 00       	call   c0001e94 <set_interrupt_handler>
c0001d9e:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(36,irq_4);
c0001da1:	83 ec 08             	sub    $0x8,%esp
c0001da4:	68 c8 30 00 c0       	push   $0xc00030c8
c0001da9:	6a 24                	push   $0x24
c0001dab:	e8 e4 00 00 00       	call   c0001e94 <set_interrupt_handler>
c0001db0:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(37,irq_5);
c0001db3:	83 ec 08             	sub    $0x8,%esp
c0001db6:	68 dc 30 00 c0       	push   $0xc00030dc
c0001dbb:	6a 25                	push   $0x25
c0001dbd:	e8 d2 00 00 00       	call   c0001e94 <set_interrupt_handler>
c0001dc2:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(38,irq_6);
c0001dc5:	83 ec 08             	sub    $0x8,%esp
c0001dc8:	68 f0 30 00 c0       	push   $0xc00030f0
c0001dcd:	6a 26                	push   $0x26
c0001dcf:	e8 c0 00 00 00       	call   c0001e94 <set_interrupt_handler>
c0001dd4:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(39,irq_7);
c0001dd7:	83 ec 08             	sub    $0x8,%esp
c0001dda:	68 04 31 00 c0       	push   $0xc0003104
c0001ddf:	6a 27                	push   $0x27
c0001de1:	e8 ae 00 00 00       	call   c0001e94 <set_interrupt_handler>
c0001de6:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(40,irq_8);
c0001de9:	83 ec 08             	sub    $0x8,%esp
c0001dec:	68 18 31 00 c0       	push   $0xc0003118
c0001df1:	6a 28                	push   $0x28
c0001df3:	e8 9c 00 00 00       	call   c0001e94 <set_interrupt_handler>
c0001df8:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(41,irq_9);
c0001dfb:	83 ec 08             	sub    $0x8,%esp
c0001dfe:	68 2c 31 00 c0       	push   $0xc000312c
c0001e03:	6a 29                	push   $0x29
c0001e05:	e8 8a 00 00 00       	call   c0001e94 <set_interrupt_handler>
c0001e0a:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(42,irq_10);
c0001e0d:	83 ec 08             	sub    $0x8,%esp
c0001e10:	68 40 31 00 c0       	push   $0xc0003140
c0001e15:	6a 2a                	push   $0x2a
c0001e17:	e8 78 00 00 00       	call   c0001e94 <set_interrupt_handler>
c0001e1c:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(43,irq_11);
c0001e1f:	83 ec 08             	sub    $0x8,%esp
c0001e22:	68 54 31 00 c0       	push   $0xc0003154
c0001e27:	6a 2b                	push   $0x2b
c0001e29:	e8 66 00 00 00       	call   c0001e94 <set_interrupt_handler>
c0001e2e:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(44,irq_12);
c0001e31:	83 ec 08             	sub    $0x8,%esp
c0001e34:	68 68 31 00 c0       	push   $0xc0003168
c0001e39:	6a 2c                	push   $0x2c
c0001e3b:	e8 54 00 00 00       	call   c0001e94 <set_interrupt_handler>
c0001e40:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(45,irq_13);
c0001e43:	83 ec 08             	sub    $0x8,%esp
c0001e46:	68 7c 31 00 c0       	push   $0xc000317c
c0001e4b:	6a 2d                	push   $0x2d
c0001e4d:	e8 42 00 00 00       	call   c0001e94 <set_interrupt_handler>
c0001e52:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(46,irq_14);
c0001e55:	83 ec 08             	sub    $0x8,%esp
c0001e58:	68 90 31 00 c0       	push   $0xc0003190
c0001e5d:	6a 2e                	push   $0x2e
c0001e5f:	e8 30 00 00 00       	call   c0001e94 <set_interrupt_handler>
c0001e64:	83 c4 10             	add    $0x10,%esp
    set_interrupt_handler(47,irq_15);
c0001e67:	83 ec 08             	sub    $0x8,%esp
c0001e6a:	68 a4 31 00 c0       	push   $0xc00031a4
c0001e6f:	6a 2f                	push   $0x2f
c0001e71:	e8 1e 00 00 00       	call   c0001e94 <set_interrupt_handler>
c0001e76:	83 c4 10             	add    $0x10,%esp



    idtd.base = (uint32_t) idt;
c0001e79:	b8 20 00 01 c0       	mov    $0xc0010020,%eax
c0001e7e:	a3 22 08 01 c0       	mov    %eax,0xc0010822
    idtd.limit = sizeof(idt_entry_t) * NUM_INTERRUPT_HANDLERS - 1;
c0001e83:	66 c7 05 20 08 01 c0 	movw   $0x7ff,0xc0010820
c0001e8a:	ff 07 
    load_idt();
c0001e8c:	e8 57 0f 00 00       	call   c0002de8 <load_idt>
}
c0001e91:	90                   	nop
c0001e92:	c9                   	leave  
c0001e93:	c3                   	ret    

c0001e94 <set_interrupt_handler>:

void set_interrupt_handler(int int_num, void* handler)
{
c0001e94:	55                   	push   %ebp
c0001e95:	89 e5                	mov    %esp,%ebp
	idt[int_num].offset_low = ((uint32_t) handler) & 0xffff;
c0001e97:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001e9a:	89 c2                	mov    %eax,%edx
c0001e9c:	8b 45 08             	mov    0x8(%ebp),%eax
c0001e9f:	66 89 14 c5 20 00 01 	mov    %dx,-0x3ffeffe0(,%eax,8)
c0001ea6:	c0 
	idt[int_num].segment = KERNEL_CODE_SEGMENT;
c0001ea7:	8b 45 08             	mov    0x8(%ebp),%eax
c0001eaa:	66 c7 04 c5 22 00 01 	movw   $0x8,-0x3ffeffde(,%eax,8)
c0001eb1:	c0 08 00 
	idt[int_num].zero = 0;
c0001eb4:	8b 45 08             	mov    0x8(%ebp),%eax
c0001eb7:	c6 04 c5 24 00 01 c0 	movb   $0x0,-0x3ffeffdc(,%eax,8)
c0001ebe:	00 
	idt[int_num].type = 0x8e; /* INTERRUPT_GATE */
c0001ebf:	8b 45 08             	mov    0x8(%ebp),%eax
c0001ec2:	c6 04 c5 25 00 01 c0 	movb   $0x8e,-0x3ffeffdb(,%eax,8)
c0001ec9:	8e 
	idt[int_num].offset_high = (((uint32_t) handler) & 0xffff0000) >> 16;    
c0001eca:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001ecd:	c1 e8 10             	shr    $0x10,%eax
c0001ed0:	89 c2                	mov    %eax,%edx
c0001ed2:	8b 45 08             	mov    0x8(%ebp),%eax
c0001ed5:	66 89 14 c5 26 00 01 	mov    %dx,-0x3ffeffda(,%eax,8)
c0001edc:	c0 
}
c0001edd:	90                   	nop
c0001ede:	5d                   	pop    %ebp
c0001edf:	c3                   	ret    

c0001ee0 <page_fault_handler>:

void page_fault_handler(uint32_t code, void* fault_ip)
{
c0001ee0:	55                   	push   %ebp
c0001ee1:	89 e5                	mov    %esp,%ebp
c0001ee3:	83 ec 08             	sub    $0x8,%esp

    if(code & PF_CODE_WRITE)
c0001ee6:	8b 45 08             	mov    0x8(%ebp),%eax
c0001ee9:	83 e0 02             	and    $0x2,%eax
c0001eec:	85 c0                	test   %eax,%eax
c0001eee:	74 1b                	je     c0001f0b <page_fault_handler+0x2b>
        kprintf("\n\nPage Fault writing to 0x%x (instruction 0x%x)\n", pf_addr(), fault_ip);
c0001ef0:	e8 ff 0e 00 00       	call   c0002df4 <pf_addr>
c0001ef5:	83 ec 04             	sub    $0x4,%esp
c0001ef8:	ff 75 0c             	pushl  0xc(%ebp)
c0001efb:	50                   	push   %eax
c0001efc:	68 a8 45 00 c0       	push   $0xc00045a8
c0001f01:	e8 79 e5 ff ff       	call   c000047f <kprintf>
c0001f06:	83 c4 10             	add    $0x10,%esp
c0001f09:	eb 19                	jmp    c0001f24 <page_fault_handler+0x44>
    else        
        kprintf("\n\nPage Fault reading from 0x%x (instruction 0x%x)\n", pf_addr(), fault_ip);
c0001f0b:	e8 e4 0e 00 00       	call   c0002df4 <pf_addr>
c0001f10:	83 ec 04             	sub    $0x4,%esp
c0001f13:	ff 75 0c             	pushl  0xc(%ebp)
c0001f16:	50                   	push   %eax
c0001f17:	68 dc 45 00 c0       	push   $0xc00045dc
c0001f1c:	e8 5e e5 ff ff       	call   c000047f <kprintf>
c0001f21:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_PGPROT)
c0001f24:	8b 45 08             	mov    0x8(%ebp),%eax
c0001f27:	83 e0 01             	and    $0x1,%eax
c0001f2a:	85 c0                	test   %eax,%eax
c0001f2c:	74 12                	je     c0001f40 <page_fault_handler+0x60>
        kprintf("Page protection violation\n");
c0001f2e:	83 ec 0c             	sub    $0xc,%esp
c0001f31:	68 0f 46 00 c0       	push   $0xc000460f
c0001f36:	e8 44 e5 ff ff       	call   c000047f <kprintf>
c0001f3b:	83 c4 10             	add    $0x10,%esp
c0001f3e:	eb 10                	jmp    c0001f50 <page_fault_handler+0x70>
    else
        kprintf("Page not present\n");
c0001f40:	83 ec 0c             	sub    $0xc,%esp
c0001f43:	68 2a 46 00 c0       	push   $0xc000462a
c0001f48:	e8 32 e5 ff ff       	call   c000047f <kprintf>
c0001f4d:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_USER)
c0001f50:	8b 45 08             	mov    0x8(%ebp),%eax
c0001f53:	83 e0 04             	and    $0x4,%eax
c0001f56:	85 c0                	test   %eax,%eax
c0001f58:	74 10                	je     c0001f6a <page_fault_handler+0x8a>
        kprintf("\n\nFault caused by user code\n");
c0001f5a:	83 ec 0c             	sub    $0xc,%esp
c0001f5d:	68 3c 46 00 c0       	push   $0xc000463c
c0001f62:	e8 18 e5 ff ff       	call   c000047f <kprintf>
c0001f67:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_RES)
c0001f6a:	8b 45 08             	mov    0x8(%ebp),%eax
c0001f6d:	83 e0 08             	and    $0x8,%eax
c0001f70:	85 c0                	test   %eax,%eax
c0001f72:	74 10                	je     c0001f84 <page_fault_handler+0xa4>
        kprintf("Page reserved bit set\n");
c0001f74:	83 ec 0c             	sub    $0xc,%esp
c0001f77:	68 59 46 00 c0       	push   $0xc0004659
c0001f7c:	e8 fe e4 ff ff       	call   c000047f <kprintf>
c0001f81:	83 c4 10             	add    $0x10,%esp
    if(code & PF_CODE_IF)
c0001f84:	8b 45 08             	mov    0x8(%ebp),%eax
c0001f87:	83 e0 10             	and    $0x10,%eax
c0001f8a:	85 c0                	test   %eax,%eax
c0001f8c:	74 10                	je     c0001f9e <page_fault_handler+0xbe>
        kprintf("Fault caused by instruction fetch\n");
c0001f8e:	83 ec 0c             	sub    $0xc,%esp
c0001f91:	68 70 46 00 c0       	push   $0xc0004670
c0001f96:	e8 e4 e4 ff ff       	call   c000047f <kprintf>
c0001f9b:	83 c4 10             	add    $0x10,%esp

    while(1);
c0001f9e:	eb fe                	jmp    c0001f9e <page_fault_handler+0xbe>

c0001fa0 <exception_handler>:
}


void exception_handler(uint32_t exception_num, uint32_t code, void* fault_ip)
{
c0001fa0:	55                   	push   %ebp
c0001fa1:	89 e5                	mov    %esp,%ebp
c0001fa3:	83 ec 08             	sub    $0x8,%esp
    if(exception_num==14)
c0001fa6:	83 7d 08 0e          	cmpl   $0xe,0x8(%ebp)
c0001faa:	75 13                	jne    c0001fbf <exception_handler+0x1f>
        page_fault_handler(code, fault_ip);
c0001fac:	83 ec 08             	sub    $0x8,%esp
c0001faf:	ff 75 10             	pushl  0x10(%ebp)
c0001fb2:	ff 75 0c             	pushl  0xc(%ebp)
c0001fb5:	e8 26 ff ff ff       	call   c0001ee0 <page_fault_handler>
c0001fba:	83 c4 10             	add    $0x10,%esp
c0001fbd:	eb 16                	jmp    c0001fd5 <exception_handler+0x35>
    else
        kprintf("\n\nException %u with code 0x%x at instruction 0x%x\n", exception_num, code, fault_ip);
c0001fbf:	ff 75 10             	pushl  0x10(%ebp)
c0001fc2:	ff 75 0c             	pushl  0xc(%ebp)
c0001fc5:	ff 75 08             	pushl  0x8(%ebp)
c0001fc8:	68 94 46 00 c0       	push   $0xc0004694
c0001fcd:	e8 ad e4 ff ff       	call   c000047f <kprintf>
c0001fd2:	83 c4 10             	add    $0x10,%esp
    while(1);
c0001fd5:	eb fe                	jmp    c0001fd5 <exception_handler+0x35>

c0001fd7 <irq_handler>:
}

void irq_handler(uint32_t irq_num)
{
c0001fd7:	55                   	push   %ebp
c0001fd8:	89 e5                	mov    %esp,%ebp
c0001fda:	83 ec 18             	sub    $0x18,%esp
    if(irq_num == 1)
c0001fdd:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0001fe1:	75 36                	jne    c0002019 <irq_handler+0x42>
    {
        unsigned char scan_code = inb(0x60);
c0001fe3:	6a 60                	push   $0x60
c0001fe5:	e8 38 fb ff ff       	call   c0001b22 <inb>
c0001fea:	83 c4 04             	add    $0x4,%esp
c0001fed:	88 45 f7             	mov    %al,-0x9(%ebp)
        char key_ascii = scancode_to_ascii(scan_code);
c0001ff0:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0001ff4:	83 ec 0c             	sub    $0xc,%esp
c0001ff7:	50                   	push   %eax
c0001ff8:	e8 89 0a 00 00       	call   c0002a86 <scancode_to_ascii>
c0001ffd:	83 c4 10             	add    $0x10,%esp
c0002000:	88 45 f6             	mov    %al,-0xa(%ebp)
        // kprintf("code: 0x%x, ascii:%c\n", scan_code, key_ascii);
        if(key_ascii>0)
c0002003:	80 7d f6 00          	cmpb   $0x0,-0xa(%ebp)
c0002007:	7e 10                	jle    c0002019 <irq_handler+0x42>
            kprint_char(key_ascii);
c0002009:	0f be 45 f6          	movsbl -0xa(%ebp),%eax
c000200d:	83 ec 0c             	sub    $0xc,%esp
c0002010:	50                   	push   %eax
c0002011:	e8 18 e4 ff ff       	call   c000042e <kprint_char>
c0002016:	83 c4 10             	add    $0x10,%esp
    
    }

    // notify PIC that interrupt handling is complete
    if(irq_num >= 8)
c0002019:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
c000201d:	76 12                	jbe    c0002031 <irq_handler+0x5a>
        outb(PIC_EOI, PIC2_CMD);
c000201f:	83 ec 08             	sub    $0x8,%esp
c0002022:	68 a0 00 00 00       	push   $0xa0
c0002027:	6a 20                	push   $0x20
c0002029:	e8 11 fb ff ff       	call   c0001b3f <outb>
c000202e:	83 c4 10             	add    $0x10,%esp

    outb(PIC_EOI, PIC1_CMD);
c0002031:	83 ec 08             	sub    $0x8,%esp
c0002034:	6a 20                	push   $0x20
c0002036:	6a 20                	push   $0x20
c0002038:	e8 02 fb ff ff       	call   c0001b3f <outb>
c000203d:	83 c4 10             	add    $0x10,%esp

    return;
c0002040:	90                   	nop
}
c0002041:	c9                   	leave  
c0002042:	c3                   	ret    

c0002043 <initialize_multitasking>:
task_control_block_t kernel_main_task;

uint32_t pid_counter;

void initialize_multitasking()
{    
c0002043:	55                   	push   %ebp
c0002044:	89 e5                	mov    %esp,%ebp
c0002046:	83 ec 08             	sub    $0x8,%esp
    // initialize current task as initial task
    kernel_main_task.pid = pid_counter = 0;
c0002049:	c7 05 80 08 01 c0 00 	movl   $0x0,0xc0010880
c0002050:	00 00 00 
c0002053:	a1 80 08 01 c0       	mov    0xc0010880,%eax
c0002058:	a3 60 08 01 c0       	mov    %eax,0xc0010860
    kernel_main_task.state = RUNNING;
c000205d:	c7 05 64 08 01 c0 00 	movl   $0x0,0xc0010864
c0002064:	00 00 00 
    kernel_main_task.esp = NULL; //this is initialized only on task switch
c0002067:	c7 05 68 08 01 c0 00 	movl   $0x0,0xc0010868
c000206e:	00 00 00 
    kernel_main_task.pd = get_page_dir();
c0002071:	e8 c2 11 00 00       	call   c0003238 <get_page_dir>
c0002076:	a3 70 08 01 c0       	mov    %eax,0xc0010870

    // this is the only task so far
    //as we add tasks this becomes circular linked list
    kernel_main_task.next_task = &kernel_main_task;
c000207b:	c7 05 74 08 01 c0 60 	movl   $0xc0010860,0xc0010874
c0002082:	08 01 c0 
    current_task = &kernel_main_task;
c0002085:	c7 05 40 08 01 c0 60 	movl   $0xc0010860,0xc0010840
c000208c:	08 01 c0 
}
c000208f:	90                   	nop
c0002090:	c9                   	leave  
c0002091:	c3                   	ret    

c0002092 <new_kernel_task>:

task_control_block_t* new_kernel_task(int32_t (*task_entry) (void))
{
c0002092:	55                   	push   %ebp
c0002093:	89 e5                	mov    %esp,%ebp
c0002095:	83 ec 18             	sub    $0x18,%esp
    task_control_block_t* new_task = kmalloc(sizeof(task_control_block_t));
c0002098:	83 ec 0c             	sub    $0xc,%esp
c000209b:	6a 20                	push   $0x20
c000209d:	e8 2f 09 00 00       	call   c00029d1 <kmalloc>
c00020a2:	83 c4 10             	add    $0x10,%esp
c00020a5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void* new_stack = kmalloc(KERNEL_STACK_SIZE);
c00020a8:	83 ec 0c             	sub    $0xc,%esp
c00020ab:	68 00 80 00 00       	push   $0x8000
c00020b0:	e8 1c 09 00 00       	call   c00029d1 <kmalloc>
c00020b5:	83 c4 10             	add    $0x10,%esp
c00020b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint32_t* esp0 = (uint32_t*) (new_stack + KERNEL_STACK_SIZE);
c00020bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00020be:	05 00 80 00 00       	add    $0x8000,%eax
c00020c3:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // init new stack with valid context to launch new task
    *(--esp0) = (uint32_t) new_task; //argument to launch_task
c00020c6:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c00020ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00020cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00020d0:	89 10                	mov    %edx,(%eax)
    *(--esp0) = (uint32_t) terminate_task; // launch_task() returns to here, to close out task
c00020d2:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c00020d6:	ba ed 31 00 c0       	mov    $0xc00031ed,%edx
c00020db:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00020de:	89 10                	mov    %edx,(%eax)
    *(--esp0) = (uint32_t) launch_task; //common entry function for new tasks
c00020e0:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c00020e4:	ba 4f 22 00 c0       	mov    $0xc000224f,%edx
c00020e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00020ec:	89 10                	mov    %edx,(%eax)
    *(--esp0) = 0; //push ebx
c00020ee:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c00020f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00020f5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp0) = 0; //push esi
c00020fb:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c00020ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002102:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp0) = 0; //push edi
c0002108:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c000210c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000210f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *(--esp0) = 0; //push ebp
c0002115:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
c0002119:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000211c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    update_kstack(esp0); //update tss with esp0
c0002122:	83 ec 0c             	sub    $0xc,%esp
c0002125:	ff 75 ec             	pushl  -0x14(%ebp)
c0002128:	e8 24 0c 00 00       	call   c0002d51 <update_kstack>
c000212d:	83 c4 10             	add    $0x10,%esp

    //create copy of kernel page_dir
    void* new_pd = kmalloc_aligned(PAGE_SIZE, PAGE_SIZE);
c0002130:	83 ec 08             	sub    $0x8,%esp
c0002133:	68 00 10 00 00       	push   $0x1000
c0002138:	68 00 10 00 00       	push   $0x1000
c000213d:	e8 c6 07 00 00       	call   c0002908 <kmalloc_aligned>
c0002142:	83 c4 10             	add    $0x10,%esp
c0002145:	89 45 e8             	mov    %eax,-0x18(%ebp)
    memcpy(new_pd, (void*) &pd->dir,PAGE_SIZE);
c0002148:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c000214d:	05 00 f0 3f 00       	add    $0x3ff000,%eax
c0002152:	83 ec 04             	sub    $0x4,%esp
c0002155:	68 00 10 00 00       	push   $0x1000
c000215a:	50                   	push   %eax
c000215b:	ff 75 e8             	pushl  -0x18(%ebp)
c000215e:	e8 60 f1 ff ff       	call   c00012c3 <memcpy>
c0002163:	83 c4 10             	add    $0x10,%esp
    new_task->pd = get_physaddr(new_pd); //page dir is physical address.
c0002166:	83 ec 0c             	sub    $0xc,%esp
c0002169:	ff 75 e8             	pushl  -0x18(%ebp)
c000216c:	e8 0a 02 00 00       	call   c000237b <get_physaddr>
c0002171:	83 c4 10             	add    $0x10,%esp
c0002174:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002177:	89 42 10             	mov    %eax,0x10(%edx)


    new_task->pid = ++pid_counter;
c000217a:	a1 80 08 01 c0       	mov    0xc0010880,%eax
c000217f:	83 c0 01             	add    $0x1,%eax
c0002182:	a3 80 08 01 c0       	mov    %eax,0xc0010880
c0002187:	8b 15 80 08 01 c0    	mov    0xc0010880,%edx
c000218d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002190:	89 10                	mov    %edx,(%eax)
    new_task->state = WAITING;
c0002192:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002195:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
    new_task->esp = esp0;
c000219c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000219f:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00021a2:	89 50 08             	mov    %edx,0x8(%eax)
    new_task->task_entry = task_entry;
c00021a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00021a8:	8b 55 08             	mov    0x8(%ebp),%edx
c00021ab:	89 50 18             	mov    %edx,0x18(%eax)
    new_task->return_val = -1;
c00021ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00021b1:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%eax)

    //insert task into the ll
    new_task->next_task = current_task->next_task;
c00021b8:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c00021bd:	8b 50 14             	mov    0x14(%eax),%edx
c00021c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00021c3:	89 50 14             	mov    %edx,0x14(%eax)
    current_task->next_task = new_task;
c00021c6:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c00021cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00021ce:	89 50 14             	mov    %edx,0x14(%eax)

    return new_task;
c00021d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00021d4:	c9                   	leave  
c00021d5:	c3                   	ret    

c00021d6 <yield>:

void yield(void)
{
c00021d6:	55                   	push   %ebp
c00021d7:	89 e5                	mov    %esp,%ebp
c00021d9:	83 ec 08             	sub    $0x8,%esp
    current_task->state = WAITING;
c00021dc:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c00021e1:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
    current_task->next_task->state = RUNNING;    
c00021e8:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c00021ed:	8b 40 14             	mov    0x14(%eax),%eax
c00021f0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    switch_to_task(current_task->next_task);
c00021f7:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c00021fc:	8b 40 14             	mov    0x14(%eax),%eax
c00021ff:	83 ec 0c             	sub    $0xc,%esp
c0002202:	50                   	push   %eax
c0002203:	e8 b0 0f 00 00       	call   c00031b8 <switch_to_task>
c0002208:	83 c4 10             	add    $0x10,%esp
}
c000220b:	90                   	nop
c000220c:	c9                   	leave  
c000220d:	c3                   	ret    

c000220e <join>:

int32_t join(task_control_block_t* task)
{
c000220e:	55                   	push   %ebp
c000220f:	89 e5                	mov    %esp,%ebp
c0002211:	83 ec 08             	sub    $0x8,%esp
    // make sure we are not trying to join the current task or the main kernel task
    if(task == current_task || task == &kernel_main_task)
c0002214:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c0002219:	39 45 08             	cmp    %eax,0x8(%ebp)
c000221c:	74 09                	je     c0002227 <join+0x19>
c000221e:	81 7d 08 60 08 01 c0 	cmpl   $0xc0010860,0x8(%ebp)
c0002225:	75 0c                	jne    c0002233 <join+0x25>
        return -1; 
c0002227:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000222c:	eb 1f                	jmp    c000224d <join+0x3f>

    while(task->state == WAITING || task->state == RUNNING)
        yield();
c000222e:	e8 a3 ff ff ff       	call   c00021d6 <yield>
    while(task->state == WAITING || task->state == RUNNING)
c0002233:	8b 45 08             	mov    0x8(%ebp),%eax
c0002236:	8b 40 04             	mov    0x4(%eax),%eax
c0002239:	83 f8 02             	cmp    $0x2,%eax
c000223c:	74 f0                	je     c000222e <join+0x20>
c000223e:	8b 45 08             	mov    0x8(%ebp),%eax
c0002241:	8b 40 04             	mov    0x4(%eax),%eax
c0002244:	85 c0                	test   %eax,%eax
c0002246:	74 e6                	je     c000222e <join+0x20>

    // free task memory: stack, heap and paging structures
    // free tcb? << what should lifetime be?  Want to interrogate after process completes, but dont want it to live forever...
    // before I can do any of this, I need to actually implement free() :)

    return 0;
c0002248:	b8 00 00 00 00       	mov    $0x0,%eax
}
c000224d:	c9                   	leave  
c000224e:	c3                   	ret    

c000224f <launch_task>:


void launch_task(task_control_block_t* task)
{
c000224f:	55                   	push   %ebp
c0002250:	89 e5                	mov    %esp,%ebp
c0002252:	83 ec 18             	sub    $0x18,%esp
    task->state = RUNNING;
c0002255:	8b 45 08             	mov    0x8(%ebp),%eax
c0002258:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

   // call task main function
    task->return_val = (*task->task_entry)();
c000225f:	8b 45 08             	mov    0x8(%ebp),%eax
c0002262:	8b 40 18             	mov    0x18(%eax),%eax
c0002265:	ff d0                	call   *%eax
c0002267:	8b 55 08             	mov    0x8(%ebp),%edx
c000226a:	89 42 1c             	mov    %eax,0x1c(%edx)

    //remove this task from active task list
    task_control_block_t* t = task->next_task;
c000226d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002270:	8b 40 14             	mov    0x14(%eax),%eax
c0002273:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while( t->next_task != task)
c0002276:	eb 09                	jmp    c0002281 <launch_task+0x32>
        t = t->next_task;
c0002278:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000227b:	8b 40 14             	mov    0x14(%eax),%eax
c000227e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while( t->next_task != task)
c0002281:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002284:	8b 40 14             	mov    0x14(%eax),%eax
c0002287:	39 45 08             	cmp    %eax,0x8(%ebp)
c000228a:	75 ec                	jne    c0002278 <launch_task+0x29>
    t->next_task = t->next_task->next_task;
c000228c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000228f:	8b 40 14             	mov    0x14(%eax),%eax
c0002292:	8b 50 14             	mov    0x14(%eax),%edx
c0002295:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002298:	89 50 14             	mov    %edx,0x14(%eax)

    task->state = COMPLETE;
c000229b:	8b 45 08             	mov    0x8(%ebp),%eax
c000229e:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)

    // this will "return" to terminite_task 
}
c00022a5:	90                   	nop
c00022a6:	c9                   	leave  
c00022a7:	c3                   	ret    

c00022a8 <num_tasks>:

int num_tasks()
{
c00022a8:	55                   	push   %ebp
c00022a9:	89 e5                	mov    %esp,%ebp
c00022ab:	83 ec 10             	sub    $0x10,%esp
    task_control_block_t* t = current_task;
c00022ae:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c00022b3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int nn = 1;
c00022b6:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    while( t->next_task != current_task)
c00022bd:	eb 0d                	jmp    c00022cc <num_tasks+0x24>
    {
        t = t->next_task;
c00022bf:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00022c2:	8b 40 14             	mov    0x14(%eax),%eax
c00022c5:	89 45 fc             	mov    %eax,-0x4(%ebp)
        nn++;
c00022c8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while( t->next_task != current_task)
c00022cc:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00022cf:	8b 50 14             	mov    0x14(%eax),%edx
c00022d2:	a1 40 08 01 c0       	mov    0xc0010840,%eax
c00022d7:	39 c2                	cmp    %eax,%edx
c00022d9:	75 e4                	jne    c00022bf <num_tasks+0x17>
    }
    return nn;
c00022db:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c00022de:	c9                   	leave  
c00022df:	c3                   	ret    

c00022e0 <user_test>:
int user_test()
{
c00022e0:	55                   	push   %ebp
c00022e1:	89 e5                	mov    %esp,%ebp
c00022e3:	83 ec 10             	sub    $0x10,%esp
    int a = 1;
c00022e6:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
    int b = 2;
c00022ed:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
    int c = b/a;
c00022f4:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00022f7:	99                   	cltd   
c00022f8:	f7 7d fc             	idivl  -0x4(%ebp)
c00022fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return c;
c00022fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002301:	c9                   	leave  
c0002302:	c3                   	ret    

c0002303 <get_ptindex>:
//global pointer to page directory
extern page_directory_virt_t* pd;   //initialized in paging_asm.S

// return page table index for virtual address
static inline uint32_t get_ptindex(void* addr)
{
c0002303:	55                   	push   %ebp
c0002304:	89 e5                	mov    %esp,%ebp
    return (((uint32_t) addr) & PAGE_PTE_MASK ) >> 12;
c0002306:	8b 45 08             	mov    0x8(%ebp),%eax
c0002309:	c1 e8 0c             	shr    $0xc,%eax
c000230c:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c0002311:	5d                   	pop    %ebp
c0002312:	c3                   	ret    

c0002313 <get_pdindex>:

// return page directory index for virtual address
static inline uint32_t get_pdindex(void* addr)
{
c0002313:	55                   	push   %ebp
c0002314:	89 e5                	mov    %esp,%ebp
    return ((uint32_t) addr) >> 22;
c0002316:	8b 45 08             	mov    0x8(%ebp),%eax
c0002319:	c1 e8 16             	shr    $0x16,%eax
}
c000231c:	5d                   	pop    %ebp
c000231d:	c3                   	ret    

c000231e <get_page_offset>:

// return offset into page
static inline uint32_t get_page_offset(void* addr)
{
c000231e:	55                   	push   %ebp
c000231f:	89 e5                	mov    %esp,%ebp
    return ((uint32_t) addr) & ~PAGE_ADDRMASK;
c0002321:	8b 45 08             	mov    0x8(%ebp),%eax
c0002324:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c0002329:	5d                   	pop    %ebp
c000232a:	c3                   	ret    

c000232b <get_table>:

page_directory_virt_t* pd = (page_directory_virt_t*) PD_ADDR;

// return page directory index for virtual address
page_table_t* get_table(void* addr)
{
c000232b:	55                   	push   %ebp
c000232c:	89 e5                	mov    %esp,%ebp
c000232e:	53                   	push   %ebx
c000232f:	83 ec 10             	sub    $0x10,%esp
    uint32_t idx = get_pdindex(addr);
c0002332:	ff 75 08             	pushl  0x8(%ebp)
c0002335:	e8 d9 ff ff ff       	call   c0002313 <get_pdindex>
c000233a:	83 c4 04             	add    $0x4,%esp
c000233d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(pd->dir.pde[idx] & PAGE_FLAG_PRESENT)
c0002340:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c0002345:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0002348:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c000234e:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0002351:	83 e0 01             	and    $0x1,%eax
c0002354:	85 c0                	test   %eax,%eax
c0002356:	74 19                	je     c0002371 <get_table+0x46>
        return pd->tables + get_pdindex(addr);
c0002358:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c000235d:	89 c3                	mov    %eax,%ebx
c000235f:	ff 75 08             	pushl  0x8(%ebp)
c0002362:	e8 ac ff ff ff       	call   c0002313 <get_pdindex>
c0002367:	83 c4 04             	add    $0x4,%esp
c000236a:	c1 e0 0c             	shl    $0xc,%eax
c000236d:	01 d8                	add    %ebx,%eax
c000236f:	eb 05                	jmp    c0002376 <get_table+0x4b>
    else 
        return NULL;
c0002371:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002376:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0002379:	c9                   	leave  
c000237a:	c3                   	ret    

c000237b <get_physaddr>:

// return physical addr from virt addr
void* get_physaddr(void* addr)
{
c000237b:	55                   	push   %ebp
c000237c:	89 e5                	mov    %esp,%ebp
c000237e:	53                   	push   %ebx
c000237f:	83 ec 10             	sub    $0x10,%esp
    //check pd entry is present
    uint32_t pdi = get_pdindex(addr);
c0002382:	ff 75 08             	pushl  0x8(%ebp)
c0002385:	e8 89 ff ff ff       	call   c0002313 <get_pdindex>
c000238a:	83 c4 04             	add    $0x4,%esp
c000238d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(! pd->dir.pde[pdi] & PAGE_FLAG_PRESENT)
c0002390:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c0002395:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0002398:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c000239e:	8b 04 90             	mov    (%eax,%edx,4),%eax
c00023a1:	85 c0                	test   %eax,%eax
c00023a3:	75 07                	jne    c00023ac <get_physaddr+0x31>
        return NULL;
c00023a5:	b8 00 00 00 00       	mov    $0x0,%eax
c00023aa:	eb 45                	jmp    c00023f1 <get_physaddr+0x76>

    //check pt entry is present
    uint32_t pte = pd->tables[pdi].pte[get_ptindex(addr)];
c00023ac:	8b 1d 00 50 00 c0    	mov    0xc0005000,%ebx
c00023b2:	ff 75 08             	pushl  0x8(%ebp)
c00023b5:	e8 49 ff ff ff       	call   c0002303 <get_ptindex>
c00023ba:	83 c4 04             	add    $0x4,%esp
c00023bd:	89 c2                	mov    %eax,%edx
c00023bf:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00023c2:	c1 e0 0a             	shl    $0xa,%eax
c00023c5:	01 d0                	add    %edx,%eax
c00023c7:	8b 04 83             	mov    (%ebx,%eax,4),%eax
c00023ca:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(! pte & PAGE_FLAG_PRESENT)
c00023cd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00023d1:	75 07                	jne    c00023da <get_physaddr+0x5f>
        return NULL;
c00023d3:	b8 00 00 00 00       	mov    $0x0,%eax
c00023d8:	eb 17                	jmp    c00023f1 <get_physaddr+0x76>

    return (void*) ((pte & PAGE_ADDRMASK) +  get_page_offset(addr) );
c00023da:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00023dd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00023e2:	89 c3                	mov    %eax,%ebx
c00023e4:	ff 75 08             	pushl  0x8(%ebp)
c00023e7:	e8 32 ff ff ff       	call   c000231e <get_page_offset>
c00023ec:	83 c4 04             	add    $0x4,%esp
c00023ef:	01 d8                	add    %ebx,%eax
}
c00023f1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00023f4:	c9                   	leave  
c00023f5:	c3                   	ret    

c00023f6 <get_ptindex>:
{
c00023f6:	55                   	push   %ebp
c00023f7:	89 e5                	mov    %esp,%ebp
    return (((uint32_t) addr) & PAGE_PTE_MASK ) >> 12;
c00023f9:	8b 45 08             	mov    0x8(%ebp),%eax
c00023fc:	c1 e8 0c             	shr    $0xc,%eax
c00023ff:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c0002404:	5d                   	pop    %ebp
c0002405:	c3                   	ret    

c0002406 <get_pdindex>:
{
c0002406:	55                   	push   %ebp
c0002407:	89 e5                	mov    %esp,%ebp
    return ((uint32_t) addr) >> 22;
c0002409:	8b 45 08             	mov    0x8(%ebp),%eax
c000240c:	c1 e8 16             	shr    $0x16,%eax
}
c000240f:	5d                   	pop    %ebp
c0002410:	c3                   	ret    

c0002411 <align_addr>:
page_t* get_next_heap_page_virt();
page_t* get_next_heap_page_phys();

void* kmalloc(size_t sz);
void* kmalloc_aligned(size_t sz, size_t alignment);
void* memset(void* addr, int val, size_t cnt);
c0002411:	55                   	push   %ebp
c0002412:	89 e5                	mov    %esp,%ebp
c0002414:	83 ec 10             	sub    $0x10,%esp

c0002417:	8b 45 0c             	mov    0xc(%ebp),%eax
c000241a:	83 e8 01             	sub    $0x1,%eax
c000241d:	89 45 fc             	mov    %eax,-0x4(%ebp)
static inline void* align_addr(void* addr, uint32_t alignment)
c0002420:	8b 55 08             	mov    0x8(%ebp),%edx
c0002423:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002426:	01 c2                	add    %eax,%edx
c0002428:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000242b:	f7 d0                	not    %eax
c000242d:	21 d0                	and    %edx,%eax
{
c000242f:	c9                   	leave  
c0002430:	c3                   	ret    

c0002431 <is_pow_of_two>:
    uint32_t am = alignment - 1;
    return (char*) (((uint32_t)addr + am) & ~am);
}
c0002431:	55                   	push   %ebp
c0002432:	89 e5                	mov    %esp,%ebp

c0002434:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002438:	74 14                	je     c000244e <is_pow_of_two+0x1d>
c000243a:	8b 45 08             	mov    0x8(%ebp),%eax
c000243d:	83 e8 01             	sub    $0x1,%eax
c0002440:	23 45 08             	and    0x8(%ebp),%eax
c0002443:	85 c0                	test   %eax,%eax
c0002445:	75 07                	jne    c000244e <is_pow_of_two+0x1d>
c0002447:	b8 01 00 00 00       	mov    $0x1,%eax
c000244c:	eb 05                	jmp    c0002453 <is_pow_of_two+0x22>
c000244e:	b8 00 00 00 00       	mov    $0x0,%eax
static inline int is_pow_of_two(uint32_t x)
c0002453:	5d                   	pop    %ebp
c0002454:	c3                   	ret    

c0002455 <memory_init>:
char* heap;
char* heap_end;
char* heap_end_phys;

int memory_init(multiboot_info_t* mbd)
{
c0002455:	55                   	push   %ebp
c0002456:	89 e5                	mov    %esp,%ebp
c0002458:	83 ec 08             	sub    $0x8,%esp
	if(! heap_init(mbd) )
c000245b:	83 ec 0c             	sub    $0xc,%esp
c000245e:	ff 75 08             	pushl  0x8(%ebp)
c0002461:	e8 3b 01 00 00       	call   c00025a1 <heap_init>
c0002466:	83 c4 10             	add    $0x10,%esp
c0002469:	85 c0                	test   %eax,%eax
c000246b:	75 07                	jne    c0002474 <memory_init+0x1f>
        return -1;
c000246d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002472:	eb 25                	jmp    c0002499 <memory_init+0x44>

	if( unmap_lowmem() )
c0002474:	e8 22 00 00 00       	call   c000249b <unmap_lowmem>
c0002479:	85 c0                	test   %eax,%eax
c000247b:	74 07                	je     c0002484 <memory_init+0x2f>
        return -1;
c000247d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002482:	eb 15                	jmp    c0002499 <memory_init+0x44>

	// if(! map_multiboot() )
    //     return -1;

	if(! map_vga() )
c0002484:	e8 33 00 00 00       	call   c00024bc <map_vga>
c0002489:	85 c0                	test   %eax,%eax
c000248b:	75 07                	jne    c0002494 <memory_init+0x3f>
        return -1;
c000248d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002492:	eb 05                	jmp    c0002499 <memory_init+0x44>

    return 0;
c0002494:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0002499:	c9                   	leave  
c000249a:	c3                   	ret    

c000249b <unmap_lowmem>:

int unmap_lowmem()
{
c000249b:	55                   	push   %ebp
c000249c:	89 e5                	mov    %esp,%ebp
c000249e:	83 ec 08             	sub    $0x8,%esp
    pd->dir.pde[0] = PAGE_FLAG_EMPTY;
c00024a1:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c00024a6:	c7 80 00 f0 3f 00 00 	movl   $0x0,0x3ff000(%eax)
c00024ad:	00 00 00 
    refresh_tlb();
c00024b0:	e8 87 0d 00 00       	call   c000323c <refresh_tlb>
    return 0;
c00024b5:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00024ba:	c9                   	leave  
c00024bb:	c3                   	ret    

c00024bc <map_vga>:
// {

// }

char* map_vga()
{
c00024bc:	55                   	push   %ebp
c00024bd:	89 e5                	mov    %esp,%ebp
c00024bf:	83 ec 18             	sub    $0x18,%esp
    page_t* vga_buf = (page_t*) VGA_BUFFER;
c00024c2:	c7 45 f4 00 80 0b 00 	movl   $0xb8000,-0xc(%ebp)

    //map 6 pages of vga memory    
    map_page_at(vga_buf,vga_buf, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c00024c9:	83 ec 04             	sub    $0x4,%esp
c00024cc:	6a 06                	push   $0x6
c00024ce:	ff 75 f4             	pushl  -0xc(%ebp)
c00024d1:	ff 75 f4             	pushl  -0xc(%ebp)
c00024d4:	e8 fa 02 00 00       	call   c00027d3 <map_page_at>
c00024d9:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+1,vga_buf+1, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c00024dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00024df:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c00024e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00024e8:	05 00 10 00 00       	add    $0x1000,%eax
c00024ed:	83 ec 04             	sub    $0x4,%esp
c00024f0:	6a 06                	push   $0x6
c00024f2:	52                   	push   %edx
c00024f3:	50                   	push   %eax
c00024f4:	e8 da 02 00 00       	call   c00027d3 <map_page_at>
c00024f9:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+2,vga_buf+2, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c00024fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00024ff:	8d 90 00 20 00 00    	lea    0x2000(%eax),%edx
c0002505:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002508:	05 00 20 00 00       	add    $0x2000,%eax
c000250d:	83 ec 04             	sub    $0x4,%esp
c0002510:	6a 06                	push   $0x6
c0002512:	52                   	push   %edx
c0002513:	50                   	push   %eax
c0002514:	e8 ba 02 00 00       	call   c00027d3 <map_page_at>
c0002519:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+3,vga_buf+3, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c000251c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000251f:	8d 90 00 30 00 00    	lea    0x3000(%eax),%edx
c0002525:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002528:	05 00 30 00 00       	add    $0x3000,%eax
c000252d:	83 ec 04             	sub    $0x4,%esp
c0002530:	6a 06                	push   $0x6
c0002532:	52                   	push   %edx
c0002533:	50                   	push   %eax
c0002534:	e8 9a 02 00 00       	call   c00027d3 <map_page_at>
c0002539:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+4,vga_buf+4, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c000253c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000253f:	8d 90 00 40 00 00    	lea    0x4000(%eax),%edx
c0002545:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002548:	05 00 40 00 00       	add    $0x4000,%eax
c000254d:	83 ec 04             	sub    $0x4,%esp
c0002550:	6a 06                	push   $0x6
c0002552:	52                   	push   %edx
c0002553:	50                   	push   %eax
c0002554:	e8 7a 02 00 00       	call   c00027d3 <map_page_at>
c0002559:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+5,vga_buf+5, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c000255c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000255f:	8d 90 00 50 00 00    	lea    0x5000(%eax),%edx
c0002565:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002568:	05 00 50 00 00       	add    $0x5000,%eax
c000256d:	83 ec 04             	sub    $0x4,%esp
c0002570:	6a 06                	push   $0x6
c0002572:	52                   	push   %edx
c0002573:	50                   	push   %eax
c0002574:	e8 5a 02 00 00       	call   c00027d3 <map_page_at>
c0002579:	83 c4 10             	add    $0x10,%esp
    map_page_at(vga_buf+6,vga_buf+6, PAGE_FLAG_USER | PAGE_FLAG_WRITE);
c000257c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000257f:	8d 90 00 60 00 00    	lea    0x6000(%eax),%edx
c0002585:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002588:	05 00 60 00 00       	add    $0x6000,%eax
c000258d:	83 ec 04             	sub    $0x4,%esp
c0002590:	6a 06                	push   $0x6
c0002592:	52                   	push   %edx
c0002593:	50                   	push   %eax
c0002594:	e8 3a 02 00 00       	call   c00027d3 <map_page_at>
c0002599:	83 c4 10             	add    $0x10,%esp

    return (char*) vga_buf;
c000259c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c000259f:	c9                   	leave  
c00025a0:	c3                   	ret    

c00025a1 <heap_init>:

char* heap_init(multiboot_info_t* mbd)
{
c00025a1:	55                   	push   %ebp
c00025a2:	89 e5                	mov    %esp,%ebp
c00025a4:	83 ec 18             	sub    $0x18,%esp
    char* heap_phys;
	size_t free_mem_size = get_big_block(mbd, (void**) &heap_phys);
c00025a7:	83 ec 08             	sub    $0x8,%esp
c00025aa:	8d 45 f0             	lea    -0x10(%ebp),%eax
c00025ad:	50                   	push   %eax
c00025ae:	ff 75 08             	pushl  0x8(%ebp)
c00025b1:	e8 00 01 00 00       	call   c00026b6 <get_big_block>
c00025b6:	83 c4 10             	add    $0x10,%esp
c00025b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	heap_end_phys = heap_phys+free_mem_size;
c00025bc:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00025bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00025c2:	01 d0                	add    %edx,%eax
c00025c4:	a3 94 08 01 c0       	mov    %eax,0xc0010894

	// this memory is not actually completely free, but includes the kernel
	if(&_kernel_end_phys >= heap_phys && &_kernel_end_phys < heap_end_phys)
c00025c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00025cc:	3d 68 19 11 00       	cmp    $0x111968,%eax
c00025d1:	77 13                	ja     c00025e6 <heap_init+0x45>
c00025d3:	a1 94 08 01 c0       	mov    0xc0010894,%eax
c00025d8:	3d 68 19 11 00       	cmp    $0x111968,%eax
c00025dd:	76 07                	jbe    c00025e6 <heap_init+0x45>
		heap_phys = &_kernel_end_phys;
c00025df:	c7 45 f0 68 19 11 00 	movl   $0x111968,-0x10(%ebp)

    //start new allocations here in physical memory
    heap_page_phys = (page_t*) align_addr((void*) heap_phys, PAGE_SIZE);
c00025e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00025e9:	83 ec 08             	sub    $0x8,%esp
c00025ec:	68 00 10 00 00       	push   $0x1000
c00025f1:	50                   	push   %eax
c00025f2:	e8 1a fe ff ff       	call   c0002411 <align_addr>
c00025f7:	83 c4 10             	add    $0x10,%esp
c00025fa:	a3 88 08 01 c0       	mov    %eax,0xc0010888
    heap_phys = (char*) heap_page_phys;
c00025ff:	a1 88 08 01 c0       	mov    0xc0010888,%eax
c0002604:	89 45 f0             	mov    %eax,-0x10(%ebp)

    //start new allocations here in virtual memory
    heap_page = (page_t*) align_addr((void*) KERNEL_HEAP, PAGE_SIZE);
c0002607:	83 ec 08             	sub    $0x8,%esp
c000260a:	68 00 10 00 00       	push   $0x1000
c000260f:	68 00 00 00 c5       	push   $0xc5000000
c0002614:	e8 f8 fd ff ff       	call   c0002411 <align_addr>
c0002619:	83 c4 10             	add    $0x10,%esp
c000261c:	a3 84 08 01 c0       	mov    %eax,0xc0010884
    heap = (char*) heap_page;
c0002621:	a1 84 08 01 c0       	mov    0xc0010884,%eax
c0002626:	a3 8c 08 01 c0       	mov    %eax,0xc001088c
    heap_end = (char*) KERNEL_HEAP_END;
c000262b:	c7 05 90 08 01 c0 00 	movl   $0xf0000000,0xc0010890
c0002632:	00 00 f0 

	kprintf("\nPhysical heap: 0x%.8x - 0x%.8x (%u MiB)\n", heap_phys, heap_end_phys,  (uint32_t) (heap_end_phys-heap_phys) >> 20);
c0002635:	a1 94 08 01 c0       	mov    0xc0010894,%eax
c000263a:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000263d:	29 d0                	sub    %edx,%eax
c000263f:	c1 e8 14             	shr    $0x14,%eax
c0002642:	89 c1                	mov    %eax,%ecx
c0002644:	8b 15 94 08 01 c0    	mov    0xc0010894,%edx
c000264a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000264d:	51                   	push   %ecx
c000264e:	52                   	push   %edx
c000264f:	50                   	push   %eax
c0002650:	68 c8 46 00 c0       	push   $0xc00046c8
c0002655:	e8 25 de ff ff       	call   c000047f <kprintf>
c000265a:	83 c4 10             	add    $0x10,%esp
	kprintf("Virtual heap: 0x%.8x - 0x%.8x (%u MiB)\n\n", heap, heap_end,  (uint32_t) (heap_end-heap) >> 20);
c000265d:	a1 90 08 01 c0       	mov    0xc0010890,%eax
c0002662:	8b 15 8c 08 01 c0    	mov    0xc001088c,%edx
c0002668:	29 d0                	sub    %edx,%eax
c000266a:	c1 e8 14             	shr    $0x14,%eax
c000266d:	89 c1                	mov    %eax,%ecx
c000266f:	8b 15 90 08 01 c0    	mov    0xc0010890,%edx
c0002675:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
c000267a:	51                   	push   %ecx
c000267b:	52                   	push   %edx
c000267c:	50                   	push   %eax
c000267d:	68 f4 46 00 c0       	push   $0xc00046f4
c0002682:	e8 f8 dd ff ff       	call   c000047f <kprintf>
c0002687:	83 c4 10             	add    $0x10,%esp

    //map the first page on the heap
    if(!map_page_at(heap_page, heap_page_phys, PAGE_FLAG_WRITE))
c000268a:	8b 15 88 08 01 c0    	mov    0xc0010888,%edx
c0002690:	a1 84 08 01 c0       	mov    0xc0010884,%eax
c0002695:	83 ec 04             	sub    $0x4,%esp
c0002698:	6a 02                	push   $0x2
c000269a:	52                   	push   %edx
c000269b:	50                   	push   %eax
c000269c:	e8 32 01 00 00       	call   c00027d3 <map_page_at>
c00026a1:	83 c4 10             	add    $0x10,%esp
c00026a4:	85 c0                	test   %eax,%eax
c00026a6:	75 07                	jne    c00026af <heap_init+0x10e>
        return NULL;
c00026a8:	b8 00 00 00 00       	mov    $0x0,%eax
c00026ad:	eb 05                	jmp    c00026b4 <heap_init+0x113>

    return heap;
c00026af:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
}
c00026b4:	c9                   	leave  
c00026b5:	c3                   	ret    

c00026b6 <get_big_block>:


size_t get_big_block(multiboot_info_t* mbd, void** block)
{
c00026b6:	55                   	push   %ebp
c00026b7:	89 e5                	mov    %esp,%ebp
c00026b9:	57                   	push   %edi
c00026ba:	56                   	push   %esi
c00026bb:	53                   	push   %ebx
c00026bc:	83 ec 14             	sub    $0x14,%esp
	multiboot_memory_map_t* mmap_table = (multiboot_memory_map_t*) mbd->mmap_addr;
c00026bf:	8b 45 08             	mov    0x8(%ebp),%eax
c00026c2:	8b 40 30             	mov    0x30(%eax),%eax
c00026c5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    size_t block_size = 0;
c00026c8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c00026cf:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c00026d6:	e9 d8 00 00 00       	jmp    c00027b3 <get_big_block+0xfd>
	{
        if(mmap_table[nn].size == 0)
c00026db:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00026de:	89 d0                	mov    %edx,%eax
c00026e0:	01 c0                	add    %eax,%eax
c00026e2:	01 d0                	add    %edx,%eax
c00026e4:	c1 e0 03             	shl    $0x3,%eax
c00026e7:	89 c2                	mov    %eax,%edx
c00026e9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00026ec:	01 d0                	add    %edx,%eax
c00026ee:	8b 00                	mov    (%eax),%eax
c00026f0:	85 c0                	test   %eax,%eax
c00026f2:	0f 84 cc 00 00 00    	je     c00027c4 <get_big_block+0x10e>
            break;

		if(mmap_table[nn].len>block_size && mmap_table[nn].type == MULTIBOOT_MEMORY_AVAILABLE)
c00026f8:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00026fb:	89 d0                	mov    %edx,%eax
c00026fd:	01 c0                	add    %eax,%eax
c00026ff:	01 d0                	add    %edx,%eax
c0002701:	c1 e0 03             	shl    $0x3,%eax
c0002704:	89 c2                	mov    %eax,%edx
c0002706:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0002709:	01 d0                	add    %edx,%eax
c000270b:	8b 50 10             	mov    0x10(%eax),%edx
c000270e:	8b 40 0c             	mov    0xc(%eax),%eax
c0002711:	8b 75 ec             	mov    -0x14(%ebp),%esi
c0002714:	bf 00 00 00 00       	mov    $0x0,%edi
c0002719:	39 c6                	cmp    %eax,%esi
c000271b:	89 fe                	mov    %edi,%esi
c000271d:	19 d6                	sbb    %edx,%esi
c000271f:	0f 83 8a 00 00 00    	jae    c00027af <get_big_block+0xf9>
c0002725:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0002728:	89 d0                	mov    %edx,%eax
c000272a:	01 c0                	add    %eax,%eax
c000272c:	01 d0                	add    %edx,%eax
c000272e:	c1 e0 03             	shl    $0x3,%eax
c0002731:	89 c2                	mov    %eax,%edx
c0002733:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0002736:	01 d0                	add    %edx,%eax
c0002738:	8b 40 14             	mov    0x14(%eax),%eax
c000273b:	83 f8 01             	cmp    $0x1,%eax
c000273e:	75 6f                	jne    c00027af <get_big_block+0xf9>
        {
            block_size = mmap_table[nn].len;
c0002740:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0002743:	89 d0                	mov    %edx,%eax
c0002745:	01 c0                	add    %eax,%eax
c0002747:	01 d0                	add    %edx,%eax
c0002749:	c1 e0 03             	shl    $0x3,%eax
c000274c:	89 c2                	mov    %eax,%edx
c000274e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0002751:	01 d0                	add    %edx,%eax
c0002753:	8b 50 10             	mov    0x10(%eax),%edx
c0002756:	8b 40 0c             	mov    0xc(%eax),%eax
c0002759:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if(mmap_table[nn].addr >> 32)
c000275c:	8b 55 e8             	mov    -0x18(%ebp),%edx
c000275f:	89 d0                	mov    %edx,%eax
c0002761:	01 c0                	add    %eax,%eax
c0002763:	01 d0                	add    %edx,%eax
c0002765:	c1 e0 03             	shl    $0x3,%eax
c0002768:	89 c2                	mov    %eax,%edx
c000276a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000276d:	01 d0                	add    %edx,%eax
c000276f:	8b 50 08             	mov    0x8(%eax),%edx
c0002772:	8b 40 04             	mov    0x4(%eax),%eax
c0002775:	89 d0                	mov    %edx,%eax
c0002777:	31 d2                	xor    %edx,%edx
c0002779:	89 c7                	mov    %eax,%edi
c000277b:	83 f7 00             	xor    $0x0,%edi
c000277e:	89 f9                	mov    %edi,%ecx
c0002780:	89 d0                	mov    %edx,%eax
c0002782:	80 f4 00             	xor    $0x0,%ah
c0002785:	89 c3                	mov    %eax,%ebx
c0002787:	89 d8                	mov    %ebx,%eax
c0002789:	09 c8                	or     %ecx,%eax
c000278b:	85 c0                	test   %eax,%eax
c000278d:	75 38                	jne    c00027c7 <get_big_block+0x111>
            {
                // ignore anything above 32bits
                break;
            }
            *block = (void*) (uint32_t) mmap_table[nn].addr;
c000278f:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0002792:	89 d0                	mov    %edx,%eax
c0002794:	01 c0                	add    %eax,%eax
c0002796:	01 d0                	add    %edx,%eax
c0002798:	c1 e0 03             	shl    $0x3,%eax
c000279b:	89 c2                	mov    %eax,%edx
c000279d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00027a0:	01 d0                	add    %edx,%eax
c00027a2:	8b 50 08             	mov    0x8(%eax),%edx
c00027a5:	8b 40 04             	mov    0x4(%eax),%eax
c00027a8:	89 c2                	mov    %eax,%edx
c00027aa:	8b 45 0c             	mov    0xc(%ebp),%eax
c00027ad:	89 10                	mov    %edx,(%eax)
	for(unsigned int nn=0; nn<mbd->mmap_length; nn++)
c00027af:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c00027b3:	8b 45 08             	mov    0x8(%ebp),%eax
c00027b6:	8b 40 2c             	mov    0x2c(%eax),%eax
c00027b9:	39 45 e8             	cmp    %eax,-0x18(%ebp)
c00027bc:	0f 82 19 ff ff ff    	jb     c00026db <get_big_block+0x25>
c00027c2:	eb 04                	jmp    c00027c8 <get_big_block+0x112>
            break;
c00027c4:	90                   	nop
c00027c5:	eb 01                	jmp    c00027c8 <get_big_block+0x112>
                break;
c00027c7:	90                   	nop
        }
	}
    return block_size;
c00027c8:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c00027cb:	83 c4 14             	add    $0x14,%esp
c00027ce:	5b                   	pop    %ebx
c00027cf:	5e                   	pop    %esi
c00027d0:	5f                   	pop    %edi
c00027d1:	5d                   	pop    %ebp
c00027d2:	c3                   	ret    

c00027d3 <map_page_at>:


page_t* map_page_at(page_t* page_virt, page_t* page_phys, uint32_t flags)
{
c00027d3:	55                   	push   %ebp
c00027d4:	89 e5                	mov    %esp,%ebp
c00027d6:	53                   	push   %ebx
c00027d7:	83 ec 14             	sub    $0x14,%esp
    page_table_t* pt = get_table(page_virt);
c00027da:	83 ec 0c             	sub    $0xc,%esp
c00027dd:	ff 75 08             	pushl  0x8(%ebp)
c00027e0:	e8 46 fb ff ff       	call   c000232b <get_table>
c00027e5:	83 c4 10             	add    $0x10,%esp
c00027e8:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(!pt)
c00027eb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00027ef:	75 14                	jne    c0002805 <map_page_at+0x32>
        pt = new_page_table(page_virt, flags); // page table is not present, allocate a new one
c00027f1:	83 ec 08             	sub    $0x8,%esp
c00027f4:	ff 75 10             	pushl  0x10(%ebp)
c00027f7:	ff 75 08             	pushl  0x8(%ebp)
c00027fa:	e8 64 00 00 00       	call   c0002863 <new_page_table>
c00027ff:	83 c4 10             	add    $0x10,%esp
c0002802:	89 45 f4             	mov    %eax,-0xc(%ebp)
    
    if(pt->pte[get_ptindex(page_virt)] & PAGE_FLAG_PRESENT)
c0002805:	83 ec 0c             	sub    $0xc,%esp
c0002808:	ff 75 08             	pushl  0x8(%ebp)
c000280b:	e8 e6 fb ff ff       	call   c00023f6 <get_ptindex>
c0002810:	83 c4 10             	add    $0x10,%esp
c0002813:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002816:	8b 04 82             	mov    (%edx,%eax,4),%eax
c0002819:	83 e0 01             	and    $0x1,%eax
c000281c:	85 c0                	test   %eax,%eax
c000281e:	74 07                	je     c0002827 <map_page_at+0x54>
        return NULL; //page already mapped
c0002820:	b8 00 00 00 00       	mov    $0x0,%eax
c0002825:	eb 37                	jmp    c000285e <map_page_at+0x8b>

    // map page
    pt->pte[get_ptindex(page_virt)] = (((uint32_t) page_phys) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c0002827:	8b 45 0c             	mov    0xc(%ebp),%eax
c000282a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c000282f:	0b 45 10             	or     0x10(%ebp),%eax
c0002832:	89 c3                	mov    %eax,%ebx
c0002834:	83 ec 0c             	sub    $0xc,%esp
c0002837:	ff 75 08             	pushl  0x8(%ebp)
c000283a:	e8 b7 fb ff ff       	call   c00023f6 <get_ptindex>
c000283f:	83 c4 10             	add    $0x10,%esp
c0002842:	89 d9                	mov    %ebx,%ecx
c0002844:	83 c9 01             	or     $0x1,%ecx
c0002847:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000284a:	89 0c 82             	mov    %ecx,(%edx,%eax,4)

    refresh_page(page_virt);
c000284d:	83 ec 0c             	sub    $0xc,%esp
c0002850:	ff 75 08             	pushl  0x8(%ebp)
c0002853:	e8 ec 09 00 00       	call   c0003244 <refresh_page>
c0002858:	83 c4 10             	add    $0x10,%esp
    return page_virt;
c000285b:	8b 45 08             	mov    0x8(%ebp),%eax
}
c000285e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0002861:	c9                   	leave  
c0002862:	c3                   	ret    

c0002863 <new_page_table>:

page_table_t* new_page_table(void* addr, uint32_t flags)
{
c0002863:	55                   	push   %ebp
c0002864:	89 e5                	mov    %esp,%ebp
c0002866:	83 ec 18             	sub    $0x18,%esp
    uint32_t pdindex = get_pdindex(addr);      // index into page dir (which table does this address point to)
c0002869:	ff 75 08             	pushl  0x8(%ebp)
c000286c:	e8 95 fb ff ff       	call   c0002406 <get_pdindex>
c0002871:	83 c4 04             	add    $0x4,%esp
c0002874:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // is this table already mapped?
    if(pd->dir.pde[pdindex] & PAGE_FLAG_PRESENT)
c0002877:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c000287c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000287f:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c0002885:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0002888:	83 e0 01             	and    $0x1,%eax
c000288b:	85 c0                	test   %eax,%eax
c000288d:	74 07                	je     c0002896 <new_page_table+0x33>
        return NULL;
c000288f:	b8 00 00 00 00       	mov    $0x0,%eax
c0002894:	eb 70                	jmp    c0002906 <new_page_table+0xa3>

    page_t* pp = get_next_heap_page_phys();         // find a free page in physical mem for page table
c0002896:	e8 81 01 00 00       	call   c0002a1c <get_next_heap_page_phys>
c000289b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!pp) return NULL; // OOM
c000289e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00028a2:	75 07                	jne    c00028ab <new_page_table+0x48>
c00028a4:	b8 00 00 00 00       	mov    $0x0,%eax
c00028a9:	eb 5b                	jmp    c0002906 <new_page_table+0xa3>

    // we don't need to allocate virtual memory space, since table lives in our paging structure
    page_table_t* pv = pd->tables + pdindex;        // pointer to table (virtual)
c00028ab:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c00028b0:	89 c2                	mov    %eax,%edx
c00028b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00028b5:	c1 e0 0c             	shl    $0xc,%eax
c00028b8:	01 d0                	add    %edx,%eax
c00028ba:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // map table: point the pd entry at the physical page we just reserved, and set flags
    pd->dir.pde[pdindex] = (((uint32_t) pp) & PAGE_ADDRMASK) | PAGE_FLAG_PRESENT | flags;
c00028bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00028c0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00028c5:	0b 45 0c             	or     0xc(%ebp),%eax
c00028c8:	89 c2                	mov    %eax,%edx
c00028ca:	a1 00 50 00 c0       	mov    0xc0005000,%eax
c00028cf:	89 d1                	mov    %edx,%ecx
c00028d1:	83 c9 01             	or     $0x1,%ecx
c00028d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00028d7:	81 c2 00 fc 0f 00    	add    $0xffc00,%edx
c00028dd:	89 0c 90             	mov    %ecx,(%eax,%edx,4)

    // flush the tlb
    refresh_page(pv);
c00028e0:	83 ec 0c             	sub    $0xc,%esp
c00028e3:	ff 75 ec             	pushl  -0x14(%ebp)
c00028e6:	e8 59 09 00 00       	call   c0003244 <refresh_page>
c00028eb:	83 c4 10             	add    $0x10,%esp

    //clear table
    memset((char*) pv, 0, PAGE_SIZE);     
c00028ee:	83 ec 04             	sub    $0x4,%esp
c00028f1:	68 00 10 00 00       	push   $0x1000
c00028f6:	6a 00                	push   $0x0
c00028f8:	ff 75 ec             	pushl  -0x14(%ebp)
c00028fb:	e8 e9 00 00 00       	call   c00029e9 <memset>
c0002900:	83 c4 10             	add    $0x10,%esp

    // return pointer to table (virtual)
    return pv;
c0002903:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c0002906:	c9                   	leave  
c0002907:	c3                   	ret    

c0002908 <kmalloc_aligned>:

void* kmalloc_aligned(size_t sz, size_t alignment)
{
c0002908:	55                   	push   %ebp
c0002909:	89 e5                	mov    %esp,%ebp
c000290b:	83 ec 28             	sub    $0x28,%esp
    if( sz == 0 || !is_pow_of_two(alignment) ) return NULL;
c000290e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002912:	74 0f                	je     c0002923 <kmalloc_aligned+0x1b>
c0002914:	ff 75 0c             	pushl  0xc(%ebp)
c0002917:	e8 15 fb ff ff       	call   c0002431 <is_pow_of_two>
c000291c:	83 c4 04             	add    $0x4,%esp
c000291f:	85 c0                	test   %eax,%eax
c0002921:	75 0a                	jne    c000292d <kmalloc_aligned+0x25>
c0002923:	b8 00 00 00 00       	mov    $0x0,%eax
c0002928:	e9 a2 00 00 00       	jmp    c00029cf <kmalloc_aligned+0xc7>

    char* mem = align_addr(heap, alignment); //start of allocated region
c000292d:	a1 8c 08 01 c0       	mov    0xc001088c,%eax
c0002932:	ff 75 0c             	pushl  0xc(%ebp)
c0002935:	50                   	push   %eax
c0002936:	e8 d6 fa ff ff       	call   c0002411 <align_addr>
c000293b:	83 c4 08             	add    $0x8,%esp
c000293e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char* mem_end = align_addr(mem+sz, alignment); //first byte past end of allocated region
c0002941:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002944:	8b 45 08             	mov    0x8(%ebp),%eax
c0002947:	01 d0                	add    %edx,%eax
c0002949:	ff 75 0c             	pushl  0xc(%ebp)
c000294c:	50                   	push   %eax
c000294d:	e8 bf fa ff ff       	call   c0002411 <align_addr>
c0002952:	83 c4 08             	add    $0x8,%esp
c0002955:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if(mem_end > heap_end)
c0002958:	a1 90 08 01 c0       	mov    0xc0010890,%eax
c000295d:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0002960:	76 07                	jbe    c0002969 <kmalloc_aligned+0x61>
    {
        // out of memory!
        return NULL;
c0002962:	b8 00 00 00 00       	mov    $0x0,%eax
c0002967:	eb 66                	jmp    c00029cf <kmalloc_aligned+0xc7>
    }

    //map new pages
    page_t* page_end = (page_t*) (((uint32_t) mem_end - 1) & PAGE_ADDRMASK);
c0002969:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000296c:	83 e8 01             	sub    $0x1,%eax
c000296f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002974:	89 45 ec             	mov    %eax,-0x14(%ebp)
    while(page_end > heap_page)
c0002977:	eb 41                	jmp    c00029ba <kmalloc_aligned+0xb2>
    {
        page_t* pp = get_next_heap_page_phys();    // find a free page in physical mem
c0002979:	e8 9e 00 00 00       	call   c0002a1c <get_next_heap_page_phys>
c000297e:	89 45 e8             	mov    %eax,-0x18(%ebp)
        page_t* pv = get_next_heap_page_virt();         // find a free page in virtual mem
c0002981:	e8 cb 00 00 00       	call   c0002a51 <get_next_heap_page_virt>
c0002986:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        if(!pp || !pv)
c0002989:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c000298d:	74 06                	je     c0002995 <kmalloc_aligned+0x8d>
c000298f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0002993:	75 07                	jne    c000299c <kmalloc_aligned+0x94>
            return NULL; //OOM
c0002995:	b8 00 00 00 00       	mov    $0x0,%eax
c000299a:	eb 33                	jmp    c00029cf <kmalloc_aligned+0xc7>

        if(!map_page_at(pv, pp, PAGE_FLAG_WRITE))
c000299c:	83 ec 04             	sub    $0x4,%esp
c000299f:	6a 02                	push   $0x2
c00029a1:	ff 75 e8             	pushl  -0x18(%ebp)
c00029a4:	ff 75 e4             	pushl  -0x1c(%ebp)
c00029a7:	e8 27 fe ff ff       	call   c00027d3 <map_page_at>
c00029ac:	83 c4 10             	add    $0x10,%esp
c00029af:	85 c0                	test   %eax,%eax
c00029b1:	75 07                	jne    c00029ba <kmalloc_aligned+0xb2>
            return NULL;
c00029b3:	b8 00 00 00 00       	mov    $0x0,%eax
c00029b8:	eb 15                	jmp    c00029cf <kmalloc_aligned+0xc7>
    while(page_end > heap_page)
c00029ba:	a1 84 08 01 c0       	mov    0xc0010884,%eax
c00029bf:	39 45 ec             	cmp    %eax,-0x14(%ebp)
c00029c2:	77 b5                	ja     c0002979 <kmalloc_aligned+0x71>
    }

    heap = mem_end;     //update pointer to end of used heap
c00029c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00029c7:	a3 8c 08 01 c0       	mov    %eax,0xc001088c
    return (void*) mem;
c00029cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00029cf:	c9                   	leave  
c00029d0:	c3                   	ret    

c00029d1 <kmalloc>:


void* kmalloc(size_t sz)
{
c00029d1:	55                   	push   %ebp
c00029d2:	89 e5                	mov    %esp,%ebp
c00029d4:	83 ec 08             	sub    $0x8,%esp
    return kmalloc_aligned(sz, 4);
c00029d7:	83 ec 08             	sub    $0x8,%esp
c00029da:	6a 04                	push   $0x4
c00029dc:	ff 75 08             	pushl  0x8(%ebp)
c00029df:	e8 24 ff ff ff       	call   c0002908 <kmalloc_aligned>
c00029e4:	83 c4 10             	add    $0x10,%esp
}
c00029e7:	c9                   	leave  
c00029e8:	c3                   	ret    

c00029e9 <memset>:

void* memset(void* addr, int val, size_t cnt)
{
c00029e9:	55                   	push   %ebp
c00029ea:	89 e5                	mov    %esp,%ebp
c00029ec:	83 ec 10             	sub    $0x10,%esp
    char* m = (char*) addr;
c00029ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00029f2:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for(size_t nn=0;nn<cnt; nn++)
c00029f5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00029fc:	eb 11                	jmp    c0002a0f <memset+0x26>
        m[nn] = val;
c00029fe:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0002a01:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002a04:	01 d0                	add    %edx,%eax
c0002a06:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002a09:	88 10                	mov    %dl,(%eax)
    for(size_t nn=0;nn<cnt; nn++)
c0002a0b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0002a0f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002a12:	3b 45 10             	cmp    0x10(%ebp),%eax
c0002a15:	72 e7                	jb     c00029fe <memset+0x15>

    return addr;
c0002a17:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0002a1a:	c9                   	leave  
c0002a1b:	c3                   	ret    

c0002a1c <get_next_heap_page_phys>:

// return next available physical page from the heap and updates the heap_page_phys pointer
// returns NULL on OOM
page_t* get_next_heap_page_phys()
{
c0002a1c:	55                   	push   %ebp
c0002a1d:	89 e5                	mov    %esp,%ebp
    if( (uint32_t) (heap_page_phys+1) > (uint32_t) heap_end_phys)
c0002a1f:	a1 88 08 01 c0       	mov    0xc0010888,%eax
c0002a24:	05 00 10 00 00       	add    $0x1000,%eax
c0002a29:	89 c2                	mov    %eax,%edx
c0002a2b:	a1 94 08 01 c0       	mov    0xc0010894,%eax
c0002a30:	39 c2                	cmp    %eax,%edx
c0002a32:	76 07                	jbe    c0002a3b <get_next_heap_page_phys+0x1f>
    {
        //out of memory
        return NULL;
c0002a34:	b8 00 00 00 00       	mov    $0x0,%eax
c0002a39:	eb 14                	jmp    c0002a4f <get_next_heap_page_phys+0x33>
    }
    return ++heap_page_phys;
c0002a3b:	a1 88 08 01 c0       	mov    0xc0010888,%eax
c0002a40:	05 00 10 00 00       	add    $0x1000,%eax
c0002a45:	a3 88 08 01 c0       	mov    %eax,0xc0010888
c0002a4a:	a1 88 08 01 c0       	mov    0xc0010888,%eax
}
c0002a4f:	5d                   	pop    %ebp
c0002a50:	c3                   	ret    

c0002a51 <get_next_heap_page_virt>:

// returns next available virtual page from the heap and updates the heap_page_phys pointer
// this does *not* update the heap pointer
// returns NULL on OOM
page_t* get_next_heap_page_virt()
{
c0002a51:	55                   	push   %ebp
c0002a52:	89 e5                	mov    %esp,%ebp
    if( (uint32_t) (heap_page+1) > (uint32_t) heap_end)
c0002a54:	a1 84 08 01 c0       	mov    0xc0010884,%eax
c0002a59:	05 00 10 00 00       	add    $0x1000,%eax
c0002a5e:	89 c2                	mov    %eax,%edx
c0002a60:	a1 90 08 01 c0       	mov    0xc0010890,%eax
c0002a65:	39 c2                	cmp    %eax,%edx
c0002a67:	76 07                	jbe    c0002a70 <get_next_heap_page_virt+0x1f>
    {
        //out of memory
        return NULL;
c0002a69:	b8 00 00 00 00       	mov    $0x0,%eax
c0002a6e:	eb 14                	jmp    c0002a84 <get_next_heap_page_virt+0x33>
    }
    return ++heap_page;
c0002a70:	a1 84 08 01 c0       	mov    0xc0010884,%eax
c0002a75:	05 00 10 00 00       	add    $0x1000,%eax
c0002a7a:	a3 84 08 01 c0       	mov    %eax,0xc0010884
c0002a7f:	a1 84 08 01 c0       	mov    0xc0010884,%eax
}
c0002a84:	5d                   	pop    %ebp
c0002a85:	c3                   	ret    

c0002a86 <scancode_to_ascii>:
    0,  /* F12 Key */
    0,  /* All other keys are undefined */
};

char scancode_to_ascii(uint8_t scancode)
{
c0002a86:	55                   	push   %ebp
c0002a87:	89 e5                	mov    %esp,%ebp
c0002a89:	83 ec 04             	sub    $0x4,%esp
c0002a8c:	8b 45 08             	mov    0x8(%ebp),%eax
c0002a8f:	88 45 fc             	mov    %al,-0x4(%ebp)
    return kbd_US[scancode];
c0002a92:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0002a96:	0f b6 80 20 50 00 c0 	movzbl -0x3fffafe0(%eax),%eax
}
c0002a9d:	c9                   	leave  
c0002a9e:	c3                   	ret    

c0002a9f <test_multitasking2>:
#if defined(__linux__)  || !defined(__i386__)
#error "This kernel requires ix86-elf cross compiler"
#endif

int32_t test_multitasking2()
{
c0002a9f:	55                   	push   %ebp
c0002aa0:	89 e5                	mov    %esp,%ebp
c0002aa2:	83 ec 18             	sub    $0x18,%esp
	int nn;
	for(nn=0;nn<5;nn++)
c0002aa5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0002aac:	eb 22                	jmp    c0002ad0 <test_multitasking2+0x31>
	{
		kprintf("task 2, count %d, [%d active tasks]\n", nn, num_tasks());
c0002aae:	e8 f5 f7 ff ff       	call   c00022a8 <num_tasks>
c0002ab3:	83 ec 04             	sub    $0x4,%esp
c0002ab6:	50                   	push   %eax
c0002ab7:	ff 75 f4             	pushl  -0xc(%ebp)
c0002aba:	68 20 47 00 c0       	push   $0xc0004720
c0002abf:	e8 bb d9 ff ff       	call   c000047f <kprintf>
c0002ac4:	83 c4 10             	add    $0x10,%esp
		yield();
c0002ac7:	e8 0a f7 ff ff       	call   c00021d6 <yield>
	for(nn=0;nn<5;nn++)
c0002acc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0002ad0:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
c0002ad4:	7e d8                	jle    c0002aae <test_multitasking2+0xf>
	}
	return nn;
c0002ad6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0002ad9:	c9                   	leave  
c0002ada:	c3                   	ret    

c0002adb <test_multitasking1>:

void test_multitasking1()
{
c0002adb:	55                   	push   %ebp
c0002adc:	89 e5                	mov    %esp,%ebp
c0002ade:	83 ec 18             	sub    $0x18,%esp
	task_control_block_t* task2 = new_kernel_task( &test_multitasking2 );
c0002ae1:	83 ec 0c             	sub    $0xc,%esp
c0002ae4:	68 9f 2a 00 c0       	push   $0xc0002a9f
c0002ae9:	e8 a4 f5 ff ff       	call   c0002092 <new_kernel_task>
c0002aee:	83 c4 10             	add    $0x10,%esp
c0002af1:	89 45 f0             	mov    %eax,-0x10(%ebp)

	int nn;
	for(nn=0;nn<10;nn++)
c0002af4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0002afb:	eb 22                	jmp    c0002b1f <test_multitasking1+0x44>
	{
		kprintf("task 1, count %d  [%d active tasks]\n", nn, num_tasks());
c0002afd:	e8 a6 f7 ff ff       	call   c00022a8 <num_tasks>
c0002b02:	83 ec 04             	sub    $0x4,%esp
c0002b05:	50                   	push   %eax
c0002b06:	ff 75 f4             	pushl  -0xc(%ebp)
c0002b09:	68 48 47 00 c0       	push   $0xc0004748
c0002b0e:	e8 6c d9 ff ff       	call   c000047f <kprintf>
c0002b13:	83 c4 10             	add    $0x10,%esp
		yield();
c0002b16:	e8 bb f6 ff ff       	call   c00021d6 <yield>
	for(nn=0;nn<10;nn++)
c0002b1b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0002b1f:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c0002b23:	7e d8                	jle    c0002afd <test_multitasking1+0x22>
	}	

	kprintf("Waiting for task 2...\n");	
c0002b25:	83 ec 0c             	sub    $0xc,%esp
c0002b28:	68 6d 47 00 c0       	push   $0xc000476d
c0002b2d:	e8 4d d9 ff ff       	call   c000047f <kprintf>
c0002b32:	83 c4 10             	add    $0x10,%esp
	join(task2);
c0002b35:	83 ec 0c             	sub    $0xc,%esp
c0002b38:	ff 75 f0             	pushl  -0x10(%ebp)
c0002b3b:	e8 ce f6 ff ff       	call   c000220e <join>
c0002b40:	83 c4 10             	add    $0x10,%esp
	kprintf("Task 2 complete, ran %dx\n", task2->return_val);
c0002b43:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002b46:	8b 40 1c             	mov    0x1c(%eax),%eax
c0002b49:	83 ec 08             	sub    $0x8,%esp
c0002b4c:	50                   	push   %eax
c0002b4d:	68 84 47 00 c0       	push   $0xc0004784
c0002b52:	e8 28 d9 ff ff       	call   c000047f <kprintf>
c0002b57:	83 c4 10             	add    $0x10,%esp
}
c0002b5a:	90                   	nop
c0002b5b:	c9                   	leave  
c0002b5c:	c3                   	ret    

c0002b5d <kernel_main>:

void kernel_main(multiboot_info_t* mbd)
{
c0002b5d:	55                   	push   %ebp
c0002b5e:	89 e5                	mov    %esp,%ebp
c0002b60:	83 ec 08             	sub    $0x8,%esp
	init_gdt();
c0002b63:	e8 2e 01 00 00       	call   c0002c96 <init_gdt>
	init_interrupts();
c0002b68:	e8 f1 ef ff ff       	call   c0001b5e <init_interrupts>

	terminal_init(&stdout);
c0002b6d:	83 ec 0c             	sub    $0xc,%esp
c0002b70:	68 00 00 01 c0       	push   $0xc0010000
c0002b75:	e8 de d4 ff ff       	call   c0000058 <terminal_init>
c0002b7a:	83 c4 10             	add    $0x10,%esp

    // terminal_setcolor(&stdout, VGA_COLOR_WHITE);
	kprintf("Let's learn about Operating Systems!\n");
c0002b7d:	83 ec 0c             	sub    $0xc,%esp
c0002b80:	68 a0 47 00 c0       	push   $0xc00047a0
c0002b85:	e8 f5 d8 ff ff       	call   c000047f <kprintf>
c0002b8a:	83 c4 10             	add    $0x10,%esp
	kprintf("Jon Doane, 2020\n\n");
c0002b8d:	83 ec 0c             	sub    $0xc,%esp
c0002b90:	68 c6 47 00 c0       	push   $0xc00047c6
c0002b95:	e8 e5 d8 ff ff       	call   c000047f <kprintf>
c0002b9a:	83 c4 10             	add    $0x10,%esp

	print_memory_table(mbd);
c0002b9d:	83 ec 0c             	sub    $0xc,%esp
c0002ba0:	ff 75 08             	pushl  0x8(%ebp)
c0002ba3:	e8 87 ed ff ff       	call   c000192f <print_memory_table>
c0002ba8:	83 c4 10             	add    $0x10,%esp
	memory_init(mbd);	//after this the multiboot structure is unmapped
c0002bab:	83 ec 0c             	sub    $0xc,%esp
c0002bae:	ff 75 08             	pushl  0x8(%ebp)
c0002bb1:	e8 9f f8 ff ff       	call   c0002455 <memory_init>
c0002bb6:	83 c4 10             	add    $0x10,%esp
	initialize_multitasking();
c0002bb9:	e8 85 f4 ff ff       	call   c0002043 <initialize_multitasking>
    // reg_t regs;
    // getregs(&regs);
	// printregs(&regs);


	test_multitasking1();
c0002bbe:	e8 18 ff ff ff       	call   c0002adb <test_multitasking1>

	while(1);
c0002bc3:	eb fe                	jmp    c0002bc3 <kernel_main+0x66>

c0002bc5 <populate_gdt_entry>:
   uint16_t iomap_base;
} tss_entry_t;


static inline void populate_gdt_entry(gdt_entry_t* sd, uint32_t base, uint32_t limit, uint8_t access, uint8_t flags)
{
c0002bc5:	55                   	push   %ebp
c0002bc6:	89 e5                	mov    %esp,%ebp
c0002bc8:	53                   	push   %ebx
c0002bc9:	83 ec 08             	sub    $0x8,%esp
c0002bcc:	8b 55 14             	mov    0x14(%ebp),%edx
c0002bcf:	8b 45 18             	mov    0x18(%ebp),%eax
c0002bd2:	88 55 f8             	mov    %dl,-0x8(%ebp)
c0002bd5:	88 45 f4             	mov    %al,-0xc(%ebp)
    sd->limit_low = limit & SEGMENT_LIMIT_LOW_MASK;
c0002bd8:	8b 45 10             	mov    0x10(%ebp),%eax
c0002bdb:	89 c2                	mov    %eax,%edx
c0002bdd:	8b 45 08             	mov    0x8(%ebp),%eax
c0002be0:	0f b7 ca             	movzwl %dx,%ecx
c0002be3:	0f b6 d9             	movzbl %cl,%ebx
c0002be6:	0f b6 08             	movzbl (%eax),%ecx
c0002be9:	83 e1 00             	and    $0x0,%ecx
c0002bec:	09 d9                	or     %ebx,%ecx
c0002bee:	88 08                	mov    %cl,(%eax)
c0002bf0:	66 c1 ea 08          	shr    $0x8,%dx
c0002bf4:	0f b7 ca             	movzwl %dx,%ecx
c0002bf7:	0f b6 50 01          	movzbl 0x1(%eax),%edx
c0002bfb:	83 e2 00             	and    $0x0,%edx
c0002bfe:	09 ca                	or     %ecx,%edx
c0002c00:	88 50 01             	mov    %dl,0x1(%eax)
    sd->limit_high = (limit & SEGMENT_LIMIT_HIGH_MASK) >> 16;
c0002c03:	8b 45 10             	mov    0x10(%ebp),%eax
c0002c06:	c1 e8 10             	shr    $0x10,%eax
c0002c09:	83 e0 0f             	and    $0xf,%eax
c0002c0c:	8b 55 08             	mov    0x8(%ebp),%edx
c0002c0f:	83 e0 0f             	and    $0xf,%eax
c0002c12:	89 c1                	mov    %eax,%ecx
c0002c14:	0f b6 42 06          	movzbl 0x6(%edx),%eax
c0002c18:	83 e0 f0             	and    $0xfffffff0,%eax
c0002c1b:	09 c8                	or     %ecx,%eax
c0002c1d:	88 42 06             	mov    %al,0x6(%edx)
    sd->base_low = base & SEGMENT_BASE_LOW_MASK;
c0002c20:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002c23:	89 c2                	mov    %eax,%edx
c0002c25:	8b 45 08             	mov    0x8(%ebp),%eax
c0002c28:	0f b7 ca             	movzwl %dx,%ecx
c0002c2b:	0f b6 d9             	movzbl %cl,%ebx
c0002c2e:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
c0002c32:	83 e1 00             	and    $0x0,%ecx
c0002c35:	09 d9                	or     %ebx,%ecx
c0002c37:	88 48 02             	mov    %cl,0x2(%eax)
c0002c3a:	66 c1 ea 08          	shr    $0x8,%dx
c0002c3e:	0f b7 ca             	movzwl %dx,%ecx
c0002c41:	0f b6 50 03          	movzbl 0x3(%eax),%edx
c0002c45:	83 e2 00             	and    $0x0,%edx
c0002c48:	09 ca                	or     %ecx,%edx
c0002c4a:	88 50 03             	mov    %dl,0x3(%eax)
    sd->base_mid = (base & SEGMENT_BASE_MID_MASK) >> 16;
c0002c4d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002c50:	c1 e8 10             	shr    $0x10,%eax
c0002c53:	89 c2                	mov    %eax,%edx
c0002c55:	8b 45 08             	mov    0x8(%ebp),%eax
c0002c58:	88 50 04             	mov    %dl,0x4(%eax)
    sd->base_high = (base & SEGMENT_BASE_HIGH_MASK) >> 24;
c0002c5b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002c5e:	c1 e8 18             	shr    $0x18,%eax
c0002c61:	89 c2                	mov    %eax,%edx
c0002c63:	8b 45 08             	mov    0x8(%ebp),%eax
c0002c66:	88 50 07             	mov    %dl,0x7(%eax)
    sd->access = access;
c0002c69:	8b 45 08             	mov    0x8(%ebp),%eax
c0002c6c:	0f b6 55 f8          	movzbl -0x8(%ebp),%edx
c0002c70:	88 50 05             	mov    %dl,0x5(%eax)
    sd->flags = flags;
c0002c73:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0002c77:	83 e0 0f             	and    $0xf,%eax
c0002c7a:	89 c2                	mov    %eax,%edx
c0002c7c:	8b 45 08             	mov    0x8(%ebp),%eax
c0002c7f:	89 d1                	mov    %edx,%ecx
c0002c81:	c1 e1 04             	shl    $0x4,%ecx
c0002c84:	0f b6 50 06          	movzbl 0x6(%eax),%edx
c0002c88:	83 e2 0f             	and    $0xf,%edx
c0002c8b:	09 ca                	or     %ecx,%edx
c0002c8d:	88 50 06             	mov    %dl,0x6(%eax)
}
c0002c90:	90                   	nop
c0002c91:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0002c94:	c9                   	leave  
c0002c95:	c3                   	ret    

c0002c96 <init_gdt>:
gdt_description_t __aligned  gdtd;

tss_entry_t tss = {0};

void init_gdt()
{
c0002c96:	55                   	push   %ebp
c0002c97:	89 e5                	mov    %esp,%ebp
c0002c99:	83 ec 08             	sub    $0x8,%esp
    // gdt[0] unused
    populate_gdt_entry(&gdt[1], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(0) | SEG_DESCTYPE(1) | SEG_CODE_EXRD, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // priv code, seg 0x008
c0002c9c:	6a 0c                	push   $0xc
c0002c9e:	68 9a 00 00 00       	push   $0x9a
c0002ca3:	6a ff                	push   $0xffffffff
c0002ca5:	6a 00                	push   $0x0
c0002ca7:	68 a8 08 01 c0       	push   $0xc00108a8
c0002cac:	e8 14 ff ff ff       	call   c0002bc5 <populate_gdt_entry>
c0002cb1:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[2], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(0) | SEG_DESCTYPE(1) | SEG_DATA_RDWR, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // priv data, seg 0x010
c0002cb4:	6a 0c                	push   $0xc
c0002cb6:	68 92 00 00 00       	push   $0x92
c0002cbb:	6a ff                	push   $0xffffffff
c0002cbd:	6a 00                	push   $0x0
c0002cbf:	68 b0 08 01 c0       	push   $0xc00108b0
c0002cc4:	e8 fc fe ff ff       	call   c0002bc5 <populate_gdt_entry>
c0002cc9:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[3], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(3) | SEG_DESCTYPE(1) | SEG_CODE_EXRD, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // user code, seg 0x018
c0002ccc:	6a 0c                	push   $0xc
c0002cce:	68 fa 00 00 00       	push   $0xfa
c0002cd3:	6a ff                	push   $0xffffffff
c0002cd5:	6a 00                	push   $0x0
c0002cd7:	68 b8 08 01 c0       	push   $0xc00108b8
c0002cdc:	e8 e4 fe ff ff       	call   c0002bc5 <populate_gdt_entry>
c0002ce1:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[4], 0, 0xffffffff, SEG_PRES(1) | SEG_PRIV(3) | SEG_DESCTYPE(1) | SEG_DATA_RDWR, SEG_FLAG_GRAN(1) | SEG_FLAG_SIZE(1)); // user data  seg 0x020
c0002ce4:	6a 0c                	push   $0xc
c0002ce6:	68 f2 00 00 00       	push   $0xf2
c0002ceb:	6a ff                	push   $0xffffffff
c0002ced:	6a 00                	push   $0x0
c0002cef:	68 c0 08 01 c0       	push   $0xc00108c0
c0002cf4:	e8 cc fe ff ff       	call   c0002bc5 <populate_gdt_entry>
c0002cf9:	83 c4 14             	add    $0x14,%esp
    populate_gdt_entry(&gdt[5], (uint32_t) &tss, sizeof(tss_entry_t), SEG_TSS, SEG_FLAG_TSS); // tss, seg 0x028
c0002cfc:	b8 00 09 01 c0       	mov    $0xc0010900,%eax
c0002d01:	6a 04                	push   $0x4
c0002d03:	68 89 00 00 00       	push   $0x89
c0002d08:	6a 68                	push   $0x68
c0002d0a:	50                   	push   %eax
c0002d0b:	68 c8 08 01 c0       	push   $0xc00108c8
c0002d10:	e8 b0 fe ff ff       	call   c0002bc5 <populate_gdt_entry>
c0002d15:	83 c4 14             	add    $0x14,%esp

    //tss.esp0 = XXXXX
    tss.ss0 = KERNEL_DATA_SEGMENT; //kernel data segment    
c0002d18:	c7 05 08 09 01 c0 10 	movl   $0x10,0xc0010908
c0002d1f:	00 00 00 
    tss.iomap_base = sizeof(tss_entry_t);
c0002d22:	66 c7 05 66 09 01 c0 	movw   $0x68,0xc0010966
c0002d29:	68 00 
    // before we can actually switch tasks, we must first set the kernel stack pointer, with update_tss()

    gdtd.addr = (uint32_t) gdt;
c0002d2b:	b8 a0 08 01 c0       	mov    $0xc00108a0,%eax
c0002d30:	a3 e2 08 01 c0       	mov    %eax,0xc00108e2
    gdtd.size = sizeof(gdt);    
c0002d35:	66 c7 05 e0 08 01 c0 	movw   $0x30,0xc00108e0
c0002d3c:	30 00 
    load_gdt(&gdtd);
c0002d3e:	83 ec 0c             	sub    $0xc,%esp
c0002d41:	68 e0 08 01 c0       	push   $0xc00108e0
c0002d46:	e8 1d 00 00 00       	call   c0002d68 <load_gdt>
c0002d4b:	83 c4 10             	add    $0x10,%esp
}
c0002d4e:	90                   	nop
c0002d4f:	c9                   	leave  
c0002d50:	c3                   	ret    

c0002d51 <update_kstack>:

void update_kstack(void* kernel_stack_ptr)
{
c0002d51:	55                   	push   %ebp
c0002d52:	89 e5                	mov    %esp,%ebp
c0002d54:	83 ec 08             	sub    $0x8,%esp
    tss.esp0 = (uint32_t) kernel_stack_ptr; //kernel stack ptr
c0002d57:	8b 45 08             	mov    0x8(%ebp),%eax
c0002d5a:	a3 04 09 01 c0       	mov    %eax,0xc0010904
    load_tss();
c0002d5f:	e8 24 00 00 00       	call   c0002d88 <load_tss>
}
c0002d64:	90                   	nop
c0002d65:	c9                   	leave  
c0002d66:	c3                   	ret    
c0002d67:	90                   	nop

c0002d68 <load_gdt>:
c0002d68:	0f 01 15 e0 08 01 c0 	lgdtl  0xc00108e0
c0002d6f:	ea 76 2d 00 c0 08 00 	ljmp   $0x8,$0xc0002d76

c0002d76 <complete_flush>:
c0002d76:	66 b8 10 00          	mov    $0x10,%ax
c0002d7a:	8e d8                	mov    %eax,%ds
c0002d7c:	8e c0                	mov    %eax,%es
c0002d7e:	8e e0                	mov    %eax,%fs
c0002d80:	8e e8                	mov    %eax,%gs
c0002d82:	8e d0                	mov    %eax,%ss
c0002d84:	c3                   	ret    
c0002d85:	8d 76 00             	lea    0x0(%esi),%esi

c0002d88 <load_tss>:
c0002d88:	66 b8 28 00          	mov    $0x28,%ax
c0002d8c:	66 83 c8 03          	or     $0x3,%ax
c0002d90:	0f 00 d8             	ltr    %ax
c0002d93:	c3                   	ret    

c0002d94 <getregs>:
c0002d94:	55                   	push   %ebp
c0002d95:	89 e5                	mov    %esp,%ebp
c0002d97:	53                   	push   %ebx
c0002d98:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0002d9b:	89 03                	mov    %eax,(%ebx)
c0002d9d:	8b 04 24             	mov    (%esp),%eax
c0002da0:	89 43 04             	mov    %eax,0x4(%ebx)
c0002da3:	89 4b 08             	mov    %ecx,0x8(%ebx)
c0002da6:	89 53 0c             	mov    %edx,0xc(%ebx)
c0002da9:	89 73 10             	mov    %esi,0x10(%ebx)
c0002dac:	89 7b 14             	mov    %edi,0x14(%ebx)
c0002daf:	89 e8                	mov    %ebp,%eax
c0002db1:	83 c0 0c             	add    $0xc,%eax
c0002db4:	89 43 18             	mov    %eax,0x18(%ebx)
c0002db7:	8b 45 00             	mov    0x0(%ebp),%eax
c0002dba:	89 43 1c             	mov    %eax,0x1c(%ebx)
c0002dbd:	8b 45 04             	mov    0x4(%ebp),%eax
c0002dc0:	89 43 20             	mov    %eax,0x20(%ebx)
c0002dc3:	b8 00 00 00 00       	mov    $0x0,%eax
c0002dc8:	9f                   	lahf   
c0002dc9:	89 43 24             	mov    %eax,0x24(%ebx)
c0002dcc:	0f 20 c0             	mov    %cr0,%eax
c0002dcf:	89 43 28             	mov    %eax,0x28(%ebx)
c0002dd2:	0f 20 d0             	mov    %cr2,%eax
c0002dd5:	89 43 2c             	mov    %eax,0x2c(%ebx)
c0002dd8:	0f 20 d8             	mov    %cr3,%eax
c0002ddb:	89 43 30             	mov    %eax,0x30(%ebx)
c0002dde:	0f 20 e0             	mov    %cr4,%eax
c0002de1:	89 43 34             	mov    %eax,0x34(%ebx)
c0002de4:	5b                   	pop    %ebx
c0002de5:	5d                   	pop    %ebp
c0002de6:	c3                   	ret    
c0002de7:	90                   	nop

c0002de8 <load_idt>:
c0002de8:	0f 01 1d 20 08 01 c0 	lidtl  0xc0010820
c0002def:	fb                   	sti    
c0002df0:	c3                   	ret    
c0002df1:	8d 76 00             	lea    0x0(%esi),%esi

c0002df4 <pf_addr>:
c0002df4:	0f 20 d0             	mov    %cr2,%eax
c0002df7:	c3                   	ret    

c0002df8 <except_0>:
c0002df8:	55                   	push   %ebp
c0002df9:	89 e5                	mov    %esp,%ebp
c0002dfb:	60                   	pusha  
c0002dfc:	8b 45 04             	mov    0x4(%ebp),%eax
c0002dff:	50                   	push   %eax
c0002e00:	b8 00 00 00 00       	mov    $0x0,%eax
c0002e05:	50                   	push   %eax
c0002e06:	b8 00 00 00 00       	mov    $0x0,%eax
c0002e0b:	50                   	push   %eax
c0002e0c:	e8 8f f1 ff ff       	call   c0001fa0 <exception_handler>
c0002e11:	83 c4 0c             	add    $0xc,%esp
c0002e14:	61                   	popa   
c0002e15:	5d                   	pop    %ebp
c0002e16:	cf                   	iret   
c0002e17:	90                   	nop

c0002e18 <except_1>:
c0002e18:	55                   	push   %ebp
c0002e19:	89 e5                	mov    %esp,%ebp
c0002e1b:	60                   	pusha  
c0002e1c:	8b 45 04             	mov    0x4(%ebp),%eax
c0002e1f:	50                   	push   %eax
c0002e20:	b8 00 00 00 00       	mov    $0x0,%eax
c0002e25:	50                   	push   %eax
c0002e26:	b8 01 00 00 00       	mov    $0x1,%eax
c0002e2b:	50                   	push   %eax
c0002e2c:	e8 6f f1 ff ff       	call   c0001fa0 <exception_handler>
c0002e31:	83 c4 0c             	add    $0xc,%esp
c0002e34:	61                   	popa   
c0002e35:	5d                   	pop    %ebp
c0002e36:	cf                   	iret   
c0002e37:	90                   	nop

c0002e38 <except_2>:
c0002e38:	55                   	push   %ebp
c0002e39:	89 e5                	mov    %esp,%ebp
c0002e3b:	60                   	pusha  
c0002e3c:	8b 45 04             	mov    0x4(%ebp),%eax
c0002e3f:	50                   	push   %eax
c0002e40:	b8 00 00 00 00       	mov    $0x0,%eax
c0002e45:	50                   	push   %eax
c0002e46:	b8 02 00 00 00       	mov    $0x2,%eax
c0002e4b:	50                   	push   %eax
c0002e4c:	e8 4f f1 ff ff       	call   c0001fa0 <exception_handler>
c0002e51:	83 c4 0c             	add    $0xc,%esp
c0002e54:	61                   	popa   
c0002e55:	5d                   	pop    %ebp
c0002e56:	cf                   	iret   
c0002e57:	90                   	nop

c0002e58 <except_3>:
c0002e58:	55                   	push   %ebp
c0002e59:	89 e5                	mov    %esp,%ebp
c0002e5b:	60                   	pusha  
c0002e5c:	8b 45 04             	mov    0x4(%ebp),%eax
c0002e5f:	50                   	push   %eax
c0002e60:	b8 00 00 00 00       	mov    $0x0,%eax
c0002e65:	50                   	push   %eax
c0002e66:	b8 03 00 00 00       	mov    $0x3,%eax
c0002e6b:	50                   	push   %eax
c0002e6c:	e8 2f f1 ff ff       	call   c0001fa0 <exception_handler>
c0002e71:	83 c4 0c             	add    $0xc,%esp
c0002e74:	61                   	popa   
c0002e75:	5d                   	pop    %ebp
c0002e76:	cf                   	iret   
c0002e77:	90                   	nop

c0002e78 <except_4>:
c0002e78:	55                   	push   %ebp
c0002e79:	89 e5                	mov    %esp,%ebp
c0002e7b:	60                   	pusha  
c0002e7c:	8b 45 04             	mov    0x4(%ebp),%eax
c0002e7f:	50                   	push   %eax
c0002e80:	b8 00 00 00 00       	mov    $0x0,%eax
c0002e85:	50                   	push   %eax
c0002e86:	b8 04 00 00 00       	mov    $0x4,%eax
c0002e8b:	50                   	push   %eax
c0002e8c:	e8 0f f1 ff ff       	call   c0001fa0 <exception_handler>
c0002e91:	83 c4 0c             	add    $0xc,%esp
c0002e94:	61                   	popa   
c0002e95:	5d                   	pop    %ebp
c0002e96:	cf                   	iret   
c0002e97:	90                   	nop

c0002e98 <except_5>:
c0002e98:	55                   	push   %ebp
c0002e99:	89 e5                	mov    %esp,%ebp
c0002e9b:	60                   	pusha  
c0002e9c:	8b 45 04             	mov    0x4(%ebp),%eax
c0002e9f:	50                   	push   %eax
c0002ea0:	b8 00 00 00 00       	mov    $0x0,%eax
c0002ea5:	50                   	push   %eax
c0002ea6:	b8 05 00 00 00       	mov    $0x5,%eax
c0002eab:	50                   	push   %eax
c0002eac:	e8 ef f0 ff ff       	call   c0001fa0 <exception_handler>
c0002eb1:	83 c4 0c             	add    $0xc,%esp
c0002eb4:	61                   	popa   
c0002eb5:	5d                   	pop    %ebp
c0002eb6:	cf                   	iret   
c0002eb7:	90                   	nop

c0002eb8 <except_6>:
c0002eb8:	55                   	push   %ebp
c0002eb9:	89 e5                	mov    %esp,%ebp
c0002ebb:	60                   	pusha  
c0002ebc:	8b 45 04             	mov    0x4(%ebp),%eax
c0002ebf:	50                   	push   %eax
c0002ec0:	b8 00 00 00 00       	mov    $0x0,%eax
c0002ec5:	50                   	push   %eax
c0002ec6:	b8 06 00 00 00       	mov    $0x6,%eax
c0002ecb:	50                   	push   %eax
c0002ecc:	e8 cf f0 ff ff       	call   c0001fa0 <exception_handler>
c0002ed1:	83 c4 0c             	add    $0xc,%esp
c0002ed4:	61                   	popa   
c0002ed5:	5d                   	pop    %ebp
c0002ed6:	cf                   	iret   
c0002ed7:	90                   	nop

c0002ed8 <except_7>:
c0002ed8:	55                   	push   %ebp
c0002ed9:	89 e5                	mov    %esp,%ebp
c0002edb:	60                   	pusha  
c0002edc:	8b 45 04             	mov    0x4(%ebp),%eax
c0002edf:	50                   	push   %eax
c0002ee0:	b8 00 00 00 00       	mov    $0x0,%eax
c0002ee5:	50                   	push   %eax
c0002ee6:	b8 07 00 00 00       	mov    $0x7,%eax
c0002eeb:	50                   	push   %eax
c0002eec:	e8 af f0 ff ff       	call   c0001fa0 <exception_handler>
c0002ef1:	83 c4 0c             	add    $0xc,%esp
c0002ef4:	61                   	popa   
c0002ef5:	5d                   	pop    %ebp
c0002ef6:	cf                   	iret   
c0002ef7:	90                   	nop

c0002ef8 <except_8>:
c0002ef8:	55                   	push   %ebp
c0002ef9:	89 e5                	mov    %esp,%ebp
c0002efb:	60                   	pusha  
c0002efc:	8b 45 08             	mov    0x8(%ebp),%eax
c0002eff:	50                   	push   %eax
c0002f00:	8b 45 04             	mov    0x4(%ebp),%eax
c0002f03:	50                   	push   %eax
c0002f04:	b8 08 00 00 00       	mov    $0x8,%eax
c0002f09:	50                   	push   %eax
c0002f0a:	e8 91 f0 ff ff       	call   c0001fa0 <exception_handler>
c0002f0f:	83 c4 0c             	add    $0xc,%esp
c0002f12:	61                   	popa   
c0002f13:	5d                   	pop    %ebp
c0002f14:	83 c4 04             	add    $0x4,%esp
c0002f17:	cf                   	iret   

c0002f18 <except_10>:
c0002f18:	55                   	push   %ebp
c0002f19:	89 e5                	mov    %esp,%ebp
c0002f1b:	60                   	pusha  
c0002f1c:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f1f:	50                   	push   %eax
c0002f20:	8b 45 04             	mov    0x4(%ebp),%eax
c0002f23:	50                   	push   %eax
c0002f24:	b8 0a 00 00 00       	mov    $0xa,%eax
c0002f29:	50                   	push   %eax
c0002f2a:	e8 71 f0 ff ff       	call   c0001fa0 <exception_handler>
c0002f2f:	83 c4 0c             	add    $0xc,%esp
c0002f32:	61                   	popa   
c0002f33:	5d                   	pop    %ebp
c0002f34:	83 c4 04             	add    $0x4,%esp
c0002f37:	cf                   	iret   

c0002f38 <except_11>:
c0002f38:	55                   	push   %ebp
c0002f39:	89 e5                	mov    %esp,%ebp
c0002f3b:	60                   	pusha  
c0002f3c:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f3f:	50                   	push   %eax
c0002f40:	8b 45 04             	mov    0x4(%ebp),%eax
c0002f43:	50                   	push   %eax
c0002f44:	b8 0b 00 00 00       	mov    $0xb,%eax
c0002f49:	50                   	push   %eax
c0002f4a:	e8 51 f0 ff ff       	call   c0001fa0 <exception_handler>
c0002f4f:	83 c4 0c             	add    $0xc,%esp
c0002f52:	61                   	popa   
c0002f53:	5d                   	pop    %ebp
c0002f54:	83 c4 04             	add    $0x4,%esp
c0002f57:	cf                   	iret   

c0002f58 <except_12>:
c0002f58:	55                   	push   %ebp
c0002f59:	89 e5                	mov    %esp,%ebp
c0002f5b:	60                   	pusha  
c0002f5c:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f5f:	50                   	push   %eax
c0002f60:	8b 45 04             	mov    0x4(%ebp),%eax
c0002f63:	50                   	push   %eax
c0002f64:	b8 0c 00 00 00       	mov    $0xc,%eax
c0002f69:	50                   	push   %eax
c0002f6a:	e8 31 f0 ff ff       	call   c0001fa0 <exception_handler>
c0002f6f:	83 c4 0c             	add    $0xc,%esp
c0002f72:	61                   	popa   
c0002f73:	5d                   	pop    %ebp
c0002f74:	83 c4 04             	add    $0x4,%esp
c0002f77:	cf                   	iret   

c0002f78 <except_13>:
c0002f78:	55                   	push   %ebp
c0002f79:	89 e5                	mov    %esp,%ebp
c0002f7b:	60                   	pusha  
c0002f7c:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f7f:	50                   	push   %eax
c0002f80:	8b 45 04             	mov    0x4(%ebp),%eax
c0002f83:	50                   	push   %eax
c0002f84:	b8 0d 00 00 00       	mov    $0xd,%eax
c0002f89:	50                   	push   %eax
c0002f8a:	e8 11 f0 ff ff       	call   c0001fa0 <exception_handler>
c0002f8f:	83 c4 0c             	add    $0xc,%esp
c0002f92:	61                   	popa   
c0002f93:	5d                   	pop    %ebp
c0002f94:	83 c4 04             	add    $0x4,%esp
c0002f97:	cf                   	iret   

c0002f98 <except_14>:
c0002f98:	55                   	push   %ebp
c0002f99:	89 e5                	mov    %esp,%ebp
c0002f9b:	60                   	pusha  
c0002f9c:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f9f:	50                   	push   %eax
c0002fa0:	8b 45 04             	mov    0x4(%ebp),%eax
c0002fa3:	50                   	push   %eax
c0002fa4:	b8 0e 00 00 00       	mov    $0xe,%eax
c0002fa9:	50                   	push   %eax
c0002faa:	e8 f1 ef ff ff       	call   c0001fa0 <exception_handler>
c0002faf:	83 c4 0c             	add    $0xc,%esp
c0002fb2:	61                   	popa   
c0002fb3:	5d                   	pop    %ebp
c0002fb4:	83 c4 04             	add    $0x4,%esp
c0002fb7:	cf                   	iret   

c0002fb8 <except_16>:
c0002fb8:	55                   	push   %ebp
c0002fb9:	89 e5                	mov    %esp,%ebp
c0002fbb:	60                   	pusha  
c0002fbc:	8b 45 08             	mov    0x8(%ebp),%eax
c0002fbf:	50                   	push   %eax
c0002fc0:	8b 45 04             	mov    0x4(%ebp),%eax
c0002fc3:	50                   	push   %eax
c0002fc4:	b8 10 00 00 00       	mov    $0x10,%eax
c0002fc9:	50                   	push   %eax
c0002fca:	e8 d1 ef ff ff       	call   c0001fa0 <exception_handler>
c0002fcf:	83 c4 0c             	add    $0xc,%esp
c0002fd2:	61                   	popa   
c0002fd3:	5d                   	pop    %ebp
c0002fd4:	83 c4 04             	add    $0x4,%esp
c0002fd7:	cf                   	iret   

c0002fd8 <except_17>:
c0002fd8:	55                   	push   %ebp
c0002fd9:	89 e5                	mov    %esp,%ebp
c0002fdb:	60                   	pusha  
c0002fdc:	8b 45 08             	mov    0x8(%ebp),%eax
c0002fdf:	50                   	push   %eax
c0002fe0:	8b 45 04             	mov    0x4(%ebp),%eax
c0002fe3:	50                   	push   %eax
c0002fe4:	b8 11 00 00 00       	mov    $0x11,%eax
c0002fe9:	50                   	push   %eax
c0002fea:	e8 b1 ef ff ff       	call   c0001fa0 <exception_handler>
c0002fef:	83 c4 0c             	add    $0xc,%esp
c0002ff2:	61                   	popa   
c0002ff3:	5d                   	pop    %ebp
c0002ff4:	83 c4 04             	add    $0x4,%esp
c0002ff7:	cf                   	iret   

c0002ff8 <except_18>:
c0002ff8:	55                   	push   %ebp
c0002ff9:	89 e5                	mov    %esp,%ebp
c0002ffb:	60                   	pusha  
c0002ffc:	8b 45 08             	mov    0x8(%ebp),%eax
c0002fff:	50                   	push   %eax
c0003000:	8b 45 04             	mov    0x4(%ebp),%eax
c0003003:	50                   	push   %eax
c0003004:	b8 12 00 00 00       	mov    $0x12,%eax
c0003009:	50                   	push   %eax
c000300a:	e8 91 ef ff ff       	call   c0001fa0 <exception_handler>
c000300f:	83 c4 0c             	add    $0xc,%esp
c0003012:	61                   	popa   
c0003013:	5d                   	pop    %ebp
c0003014:	83 c4 04             	add    $0x4,%esp
c0003017:	cf                   	iret   

c0003018 <except_19>:
c0003018:	55                   	push   %ebp
c0003019:	89 e5                	mov    %esp,%ebp
c000301b:	60                   	pusha  
c000301c:	8b 45 08             	mov    0x8(%ebp),%eax
c000301f:	50                   	push   %eax
c0003020:	8b 45 04             	mov    0x4(%ebp),%eax
c0003023:	50                   	push   %eax
c0003024:	b8 13 00 00 00       	mov    $0x13,%eax
c0003029:	50                   	push   %eax
c000302a:	e8 71 ef ff ff       	call   c0001fa0 <exception_handler>
c000302f:	83 c4 0c             	add    $0xc,%esp
c0003032:	61                   	popa   
c0003033:	5d                   	pop    %ebp
c0003034:	83 c4 04             	add    $0x4,%esp
c0003037:	cf                   	iret   

c0003038 <except_20>:
c0003038:	55                   	push   %ebp
c0003039:	89 e5                	mov    %esp,%ebp
c000303b:	60                   	pusha  
c000303c:	8b 45 08             	mov    0x8(%ebp),%eax
c000303f:	50                   	push   %eax
c0003040:	8b 45 04             	mov    0x4(%ebp),%eax
c0003043:	50                   	push   %eax
c0003044:	b8 14 00 00 00       	mov    $0x14,%eax
c0003049:	50                   	push   %eax
c000304a:	e8 51 ef ff ff       	call   c0001fa0 <exception_handler>
c000304f:	83 c4 0c             	add    $0xc,%esp
c0003052:	61                   	popa   
c0003053:	5d                   	pop    %ebp
c0003054:	83 c4 04             	add    $0x4,%esp
c0003057:	cf                   	iret   

c0003058 <except_30>:
c0003058:	55                   	push   %ebp
c0003059:	89 e5                	mov    %esp,%ebp
c000305b:	60                   	pusha  
c000305c:	8b 45 08             	mov    0x8(%ebp),%eax
c000305f:	50                   	push   %eax
c0003060:	8b 45 04             	mov    0x4(%ebp),%eax
c0003063:	50                   	push   %eax
c0003064:	b8 1e 00 00 00       	mov    $0x1e,%eax
c0003069:	50                   	push   %eax
c000306a:	e8 31 ef ff ff       	call   c0001fa0 <exception_handler>
c000306f:	83 c4 0c             	add    $0xc,%esp
c0003072:	61                   	popa   
c0003073:	5d                   	pop    %ebp
c0003074:	83 c4 04             	add    $0x4,%esp
c0003077:	cf                   	iret   

c0003078 <irq_0>:
c0003078:	60                   	pusha  
c0003079:	b8 00 00 00 00       	mov    $0x0,%eax
c000307e:	50                   	push   %eax
c000307f:	e8 53 ef ff ff       	call   c0001fd7 <irq_handler>
c0003084:	83 c4 04             	add    $0x4,%esp
c0003087:	61                   	popa   
c0003088:	cf                   	iret   
c0003089:	8d 76 00             	lea    0x0(%esi),%esi

c000308c <irq_1>:
c000308c:	60                   	pusha  
c000308d:	b8 01 00 00 00       	mov    $0x1,%eax
c0003092:	50                   	push   %eax
c0003093:	e8 3f ef ff ff       	call   c0001fd7 <irq_handler>
c0003098:	83 c4 04             	add    $0x4,%esp
c000309b:	61                   	popa   
c000309c:	cf                   	iret   
c000309d:	8d 76 00             	lea    0x0(%esi),%esi

c00030a0 <irq_2>:
c00030a0:	60                   	pusha  
c00030a1:	b8 02 00 00 00       	mov    $0x2,%eax
c00030a6:	50                   	push   %eax
c00030a7:	e8 2b ef ff ff       	call   c0001fd7 <irq_handler>
c00030ac:	83 c4 04             	add    $0x4,%esp
c00030af:	61                   	popa   
c00030b0:	cf                   	iret   
c00030b1:	8d 76 00             	lea    0x0(%esi),%esi

c00030b4 <irq_3>:
c00030b4:	60                   	pusha  
c00030b5:	b8 03 00 00 00       	mov    $0x3,%eax
c00030ba:	50                   	push   %eax
c00030bb:	e8 17 ef ff ff       	call   c0001fd7 <irq_handler>
c00030c0:	83 c4 04             	add    $0x4,%esp
c00030c3:	61                   	popa   
c00030c4:	cf                   	iret   
c00030c5:	8d 76 00             	lea    0x0(%esi),%esi

c00030c8 <irq_4>:
c00030c8:	60                   	pusha  
c00030c9:	b8 04 00 00 00       	mov    $0x4,%eax
c00030ce:	50                   	push   %eax
c00030cf:	e8 03 ef ff ff       	call   c0001fd7 <irq_handler>
c00030d4:	83 c4 04             	add    $0x4,%esp
c00030d7:	61                   	popa   
c00030d8:	cf                   	iret   
c00030d9:	8d 76 00             	lea    0x0(%esi),%esi

c00030dc <irq_5>:
c00030dc:	60                   	pusha  
c00030dd:	b8 05 00 00 00       	mov    $0x5,%eax
c00030e2:	50                   	push   %eax
c00030e3:	e8 ef ee ff ff       	call   c0001fd7 <irq_handler>
c00030e8:	83 c4 04             	add    $0x4,%esp
c00030eb:	61                   	popa   
c00030ec:	cf                   	iret   
c00030ed:	8d 76 00             	lea    0x0(%esi),%esi

c00030f0 <irq_6>:
c00030f0:	60                   	pusha  
c00030f1:	b8 06 00 00 00       	mov    $0x6,%eax
c00030f6:	50                   	push   %eax
c00030f7:	e8 db ee ff ff       	call   c0001fd7 <irq_handler>
c00030fc:	83 c4 04             	add    $0x4,%esp
c00030ff:	61                   	popa   
c0003100:	cf                   	iret   
c0003101:	8d 76 00             	lea    0x0(%esi),%esi

c0003104 <irq_7>:
c0003104:	60                   	pusha  
c0003105:	b8 07 00 00 00       	mov    $0x7,%eax
c000310a:	50                   	push   %eax
c000310b:	e8 c7 ee ff ff       	call   c0001fd7 <irq_handler>
c0003110:	83 c4 04             	add    $0x4,%esp
c0003113:	61                   	popa   
c0003114:	cf                   	iret   
c0003115:	8d 76 00             	lea    0x0(%esi),%esi

c0003118 <irq_8>:
c0003118:	60                   	pusha  
c0003119:	b8 08 00 00 00       	mov    $0x8,%eax
c000311e:	50                   	push   %eax
c000311f:	e8 b3 ee ff ff       	call   c0001fd7 <irq_handler>
c0003124:	83 c4 04             	add    $0x4,%esp
c0003127:	61                   	popa   
c0003128:	cf                   	iret   
c0003129:	8d 76 00             	lea    0x0(%esi),%esi

c000312c <irq_9>:
c000312c:	60                   	pusha  
c000312d:	b8 09 00 00 00       	mov    $0x9,%eax
c0003132:	50                   	push   %eax
c0003133:	e8 9f ee ff ff       	call   c0001fd7 <irq_handler>
c0003138:	83 c4 04             	add    $0x4,%esp
c000313b:	61                   	popa   
c000313c:	cf                   	iret   
c000313d:	8d 76 00             	lea    0x0(%esi),%esi

c0003140 <irq_10>:
c0003140:	60                   	pusha  
c0003141:	b8 0a 00 00 00       	mov    $0xa,%eax
c0003146:	50                   	push   %eax
c0003147:	e8 8b ee ff ff       	call   c0001fd7 <irq_handler>
c000314c:	83 c4 04             	add    $0x4,%esp
c000314f:	61                   	popa   
c0003150:	cf                   	iret   
c0003151:	8d 76 00             	lea    0x0(%esi),%esi

c0003154 <irq_11>:
c0003154:	60                   	pusha  
c0003155:	b8 0b 00 00 00       	mov    $0xb,%eax
c000315a:	50                   	push   %eax
c000315b:	e8 77 ee ff ff       	call   c0001fd7 <irq_handler>
c0003160:	83 c4 04             	add    $0x4,%esp
c0003163:	61                   	popa   
c0003164:	cf                   	iret   
c0003165:	8d 76 00             	lea    0x0(%esi),%esi

c0003168 <irq_12>:
c0003168:	60                   	pusha  
c0003169:	b8 0c 00 00 00       	mov    $0xc,%eax
c000316e:	50                   	push   %eax
c000316f:	e8 63 ee ff ff       	call   c0001fd7 <irq_handler>
c0003174:	83 c4 04             	add    $0x4,%esp
c0003177:	61                   	popa   
c0003178:	cf                   	iret   
c0003179:	8d 76 00             	lea    0x0(%esi),%esi

c000317c <irq_13>:
c000317c:	60                   	pusha  
c000317d:	b8 0d 00 00 00       	mov    $0xd,%eax
c0003182:	50                   	push   %eax
c0003183:	e8 4f ee ff ff       	call   c0001fd7 <irq_handler>
c0003188:	83 c4 04             	add    $0x4,%esp
c000318b:	61                   	popa   
c000318c:	cf                   	iret   
c000318d:	8d 76 00             	lea    0x0(%esi),%esi

c0003190 <irq_14>:
c0003190:	60                   	pusha  
c0003191:	b8 0e 00 00 00       	mov    $0xe,%eax
c0003196:	50                   	push   %eax
c0003197:	e8 3b ee ff ff       	call   c0001fd7 <irq_handler>
c000319c:	83 c4 04             	add    $0x4,%esp
c000319f:	61                   	popa   
c00031a0:	cf                   	iret   
c00031a1:	8d 76 00             	lea    0x0(%esi),%esi

c00031a4 <irq_15>:
c00031a4:	60                   	pusha  
c00031a5:	b8 0f 00 00 00       	mov    $0xf,%eax
c00031aa:	50                   	push   %eax
c00031ab:	e8 27 ee ff ff       	call   c0001fd7 <irq_handler>
c00031b0:	83 c4 04             	add    $0x4,%esp
c00031b3:	61                   	popa   
c00031b4:	cf                   	iret   
c00031b5:	66 90                	xchg   %ax,%ax
c00031b7:	90                   	nop

c00031b8 <switch_to_task>:
c00031b8:	53                   	push   %ebx
c00031b9:	56                   	push   %esi
c00031ba:	57                   	push   %edi
c00031bb:	55                   	push   %ebp
c00031bc:	8b 3d 40 08 01 c0    	mov    0xc0010840,%edi
c00031c2:	89 67 08             	mov    %esp,0x8(%edi)
c00031c5:	8b 74 24 14          	mov    0x14(%esp),%esi
c00031c9:	89 35 40 08 01 c0    	mov    %esi,0xc0010840
c00031cf:	8b 66 08             	mov    0x8(%esi),%esp
c00031d2:	8b 5e 0c             	mov    0xc(%esi),%ebx
c00031d5:	8b 46 10             	mov    0x10(%esi),%eax
c00031d8:	89 1d 04 09 01 c0    	mov    %ebx,0xc0010904
c00031de:	0f 20 d9             	mov    %cr3,%ecx
c00031e1:	39 c8                	cmp    %ecx,%eax
c00031e3:	74 03                	je     c00031e8 <.done>
c00031e5:	0f 22 d8             	mov    %eax,%cr3

c00031e8 <.done>:
c00031e8:	5d                   	pop    %ebp
c00031e9:	5f                   	pop    %edi
c00031ea:	5e                   	pop    %esi
c00031eb:	5b                   	pop    %ebx
c00031ec:	c3                   	ret    

c00031ed <terminate_task>:
c00031ed:	8d 35 60 08 01 c0    	lea    0xc0010860,%esi
c00031f3:	89 35 40 08 01 c0    	mov    %esi,0xc0010840
c00031f9:	8b 66 08             	mov    0x8(%esi),%esp
c00031fc:	8b 5e 0c             	mov    0xc(%esi),%ebx
c00031ff:	8b 46 10             	mov    0x10(%esi),%eax
c0003202:	89 1d 04 09 01 c0    	mov    %ebx,0xc0010904
c0003208:	0f 20 d9             	mov    %cr3,%ecx
c000320b:	39 c8                	cmp    %ecx,%eax
c000320d:	74 d9                	je     c00031e8 <.done>
c000320f:	0f 22 d8             	mov    %eax,%cr3

c0003212 <.done2>:
c0003212:	5d                   	pop    %ebp
c0003213:	5f                   	pop    %edi
c0003214:	5e                   	pop    %esi
c0003215:	5b                   	pop    %ebx
c0003216:	c3                   	ret    
c0003217:	90                   	nop

c0003218 <enable_paging>:
c0003218:	55                   	push   %ebp
c0003219:	89 e5                	mov    %esp,%ebp
c000321b:	8b 45 08             	mov    0x8(%ebp),%eax
c000321e:	0f 22 d8             	mov    %eax,%cr3
c0003221:	0f 20 c0             	mov    %cr0,%eax
c0003224:	0d 01 00 00 80       	or     $0x80000001,%eax
c0003229:	0f 22 c0             	mov    %eax,%cr0
c000322c:	89 ec                	mov    %ebp,%esp
c000322e:	5d                   	pop    %ebp
c000322f:	c3                   	ret    

c0003230 <set_page_dir>:
c0003230:	8b 44 24 04          	mov    0x4(%esp),%eax
c0003234:	0f 22 d8             	mov    %eax,%cr3
c0003237:	c3                   	ret    

c0003238 <get_page_dir>:
c0003238:	0f 20 d8             	mov    %cr3,%eax
c000323b:	c3                   	ret    

c000323c <refresh_tlb>:
c000323c:	0f 20 d8             	mov    %cr3,%eax
c000323f:	0f 22 d8             	mov    %eax,%cr3
c0003242:	c3                   	ret    
c0003243:	90                   	nop

c0003244 <refresh_page>:
c0003244:	8b 44 24 04          	mov    0x4(%esp),%eax
c0003248:	0f 01 38             	invlpg (%eax)
c000324b:	c3                   	ret    
